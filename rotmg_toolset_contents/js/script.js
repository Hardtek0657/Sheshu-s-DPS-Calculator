/*! For license information please see script.js.LICENSE.txt */
(() => {
  var t,
    e = {
      6570: (t) => {
        "use strict";
        function e(t, e, n) {
          n = n || 2;
          var r,
            o,
            a,
            l,
            c,
            d,
            f,
            m = e && e.length,
            g = m ? e[0] * n : t.length,
            v = i(t, 0, g, n, !0),
            y = [];
          if (!v || v.next === v.prev) return y;
          if (
            (m &&
              (v = (function (t, e, n, s) {
                var r,
                  o,
                  a,
                  l = [];
                for (r = 0, o = e.length; r < o; r++)
                  (a = i(
                    t,
                    e[r] * s,
                    r < o - 1 ? e[r + 1] * s : t.length,
                    s,
                    !1
                  )) === a.next && (a.steiner = !0),
                    l.push(p(a));
                for (l.sort(u), r = 0; r < l.length; r++) n = h(l[r], n);
                return n;
              })(t, e, v, n)),
            t.length > 80 * n)
          ) {
            (r = a = t[0]), (o = l = t[1]);
            for (var x = n; x < g; x += n)
              (c = t[x]) < r && (r = c),
                (d = t[x + 1]) < o && (o = d),
                c > a && (a = c),
                d > l && (l = d);
            f = 0 !== (f = Math.max(a - r, l - o)) ? 32767 / f : 0;
          }
          return s(v, y, n, r, o, f, 0), y;
        }
        function i(t, e, i, n, s) {
          var r, o;
          if (s === P(t, e, i, n) > 0)
            for (r = e; r < i; r += n) o = _(r, t[r], t[r + 1], o);
          else for (r = i - n; r >= e; r -= n) o = _(r, t[r], t[r + 1], o);
          return o && v(o, o.next) && (T(o), (o = o.next)), o;
        }
        function n(t, e) {
          if (!t) return t;
          e || (e = t);
          var i,
            n = t;
          do {
            if (
              ((i = !1),
              n.steiner || (!v(n, n.next) && 0 !== g(n.prev, n, n.next)))
            )
              n = n.next;
            else {
              if ((T(n), (n = e = n.prev) === n.next)) break;
              i = !0;
            }
          } while (i || n !== e);
          return e;
        }
        function s(t, e, i, u, h, c, p) {
          if (t) {
            !p &&
              c &&
              (function (t, e, i, n) {
                var s = t;
                do {
                  0 === s.z && (s.z = d(s.x, s.y, e, i, n)),
                    (s.prevZ = s.prev),
                    (s.nextZ = s.next),
                    (s = s.next);
                } while (s !== t);
                (s.prevZ.nextZ = null),
                  (s.prevZ = null),
                  (function (t) {
                    var e,
                      i,
                      n,
                      s,
                      r,
                      o,
                      a,
                      l,
                      u = 1;
                    do {
                      for (i = t, t = null, r = null, o = 0; i; ) {
                        for (
                          o++, n = i, a = 0, e = 0;
                          e < u && (a++, (n = n.nextZ));
                          e++
                        );
                        for (l = u; a > 0 || (l > 0 && n); )
                          0 !== a && (0 === l || !n || i.z <= n.z)
                            ? ((s = i), (i = i.nextZ), a--)
                            : ((s = n), (n = n.nextZ), l--),
                            r ? (r.nextZ = s) : (t = s),
                            (s.prevZ = r),
                            (r = s);
                        i = n;
                      }
                      (r.nextZ = null), (u *= 2);
                    } while (o > 1);
                  })(s);
              })(t, u, h, c);
            for (var f, m, g = t; t.prev !== t.next; )
              if (((f = t.prev), (m = t.next), c ? o(t, u, h, c) : r(t)))
                e.push((f.i / i) | 0),
                  e.push((t.i / i) | 0),
                  e.push((m.i / i) | 0),
                  T(t),
                  (t = m.next),
                  (g = m.next);
              else if ((t = m) === g) {
                p
                  ? 1 === p
                    ? s((t = a(n(t), e, i)), e, i, u, h, c, 2)
                    : 2 === p && l(t, e, i, u, h, c)
                  : s(n(t), e, i, u, h, c, 1);
                break;
              }
          }
        }
        function r(t) {
          var e = t.prev,
            i = t,
            n = t.next;
          if (g(e, i, n) >= 0) return !1;
          for (
            var s = e.x,
              r = i.x,
              o = n.x,
              a = e.y,
              l = i.y,
              u = n.y,
              h = s < r ? (s < o ? s : o) : r < o ? r : o,
              c = a < l ? (a < u ? a : u) : l < u ? l : u,
              d = s > r ? (s > o ? s : o) : r > o ? r : o,
              p = a > l ? (a > u ? a : u) : l > u ? l : u,
              m = n.next;
            m !== e;

          ) {
            if (
              m.x >= h &&
              m.x <= d &&
              m.y >= c &&
              m.y <= p &&
              f(s, a, r, l, o, u, m.x, m.y) &&
              g(m.prev, m, m.next) >= 0
            )
              return !1;
            m = m.next;
          }
          return !0;
        }
        function o(t, e, i, n) {
          var s = t.prev,
            r = t,
            o = t.next;
          if (g(s, r, o) >= 0) return !1;
          for (
            var a = s.x,
              l = r.x,
              u = o.x,
              h = s.y,
              c = r.y,
              p = o.y,
              m = a < l ? (a < u ? a : u) : l < u ? l : u,
              v = h < c ? (h < p ? h : p) : c < p ? c : p,
              y = a > l ? (a > u ? a : u) : l > u ? l : u,
              x = h > c ? (h > p ? h : p) : c > p ? c : p,
              b = d(m, v, e, i, n),
              S = d(y, x, e, i, n),
              C = t.prevZ,
              _ = t.nextZ;
            C && C.z >= b && _ && _.z <= S;

          ) {
            if (
              C.x >= m &&
              C.x <= y &&
              C.y >= v &&
              C.y <= x &&
              C !== s &&
              C !== o &&
              f(a, h, l, c, u, p, C.x, C.y) &&
              g(C.prev, C, C.next) >= 0
            )
              return !1;
            if (
              ((C = C.prevZ),
              _.x >= m &&
                _.x <= y &&
                _.y >= v &&
                _.y <= x &&
                _ !== s &&
                _ !== o &&
                f(a, h, l, c, u, p, _.x, _.y) &&
                g(_.prev, _, _.next) >= 0)
            )
              return !1;
            _ = _.nextZ;
          }
          for (; C && C.z >= b; ) {
            if (
              C.x >= m &&
              C.x <= y &&
              C.y >= v &&
              C.y <= x &&
              C !== s &&
              C !== o &&
              f(a, h, l, c, u, p, C.x, C.y) &&
              g(C.prev, C, C.next) >= 0
            )
              return !1;
            C = C.prevZ;
          }
          for (; _ && _.z <= S; ) {
            if (
              _.x >= m &&
              _.x <= y &&
              _.y >= v &&
              _.y <= x &&
              _ !== s &&
              _ !== o &&
              f(a, h, l, c, u, p, _.x, _.y) &&
              g(_.prev, _, _.next) >= 0
            )
              return !1;
            _ = _.nextZ;
          }
          return !0;
        }
        function a(t, e, i) {
          var s = t;
          do {
            var r = s.prev,
              o = s.next.next;
            !v(r, o) &&
              y(r, s, s.next, o) &&
              S(r, o) &&
              S(o, r) &&
              (e.push((r.i / i) | 0),
              e.push((s.i / i) | 0),
              e.push((o.i / i) | 0),
              T(s),
              T(s.next),
              (s = t = o)),
              (s = s.next);
          } while (s !== t);
          return n(s);
        }
        function l(t, e, i, r, o, a) {
          var l = t;
          do {
            for (var u = l.next.next; u !== l.prev; ) {
              if (l.i !== u.i && m(l, u)) {
                var h = C(l, u);
                return (
                  (l = n(l, l.next)),
                  (h = n(h, h.next)),
                  s(l, e, i, r, o, a, 0),
                  void s(h, e, i, r, o, a, 0)
                );
              }
              u = u.next;
            }
            l = l.next;
          } while (l !== t);
        }
        function u(t, e) {
          return t.x - e.x;
        }
        function h(t, e) {
          var i = (function (t, e) {
            var i,
              n = e,
              s = t.x,
              r = t.y,
              o = -1 / 0;
            do {
              if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                var a = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
                if (
                  a <= s &&
                  a > o &&
                  ((o = a), (i = n.x < n.next.x ? n : n.next), a === s)
                )
                  return i;
              }
              n = n.next;
            } while (n !== e);
            if (!i) return null;
            var l,
              u = i,
              h = i.x,
              d = i.y,
              p = 1 / 0;
            n = i;
            do {
              s >= n.x &&
                n.x >= h &&
                s !== n.x &&
                f(r < d ? s : o, r, h, d, r < d ? o : s, r, n.x, n.y) &&
                ((l = Math.abs(r - n.y) / (s - n.x)),
                S(n, t) &&
                  (l < p ||
                    (l === p && (n.x > i.x || (n.x === i.x && c(i, n))))) &&
                  ((i = n), (p = l))),
                (n = n.next);
            } while (n !== u);
            return i;
          })(t, e);
          if (!i) return e;
          var s = C(i, t);
          return n(s, s.next), n(i, i.next);
        }
        function c(t, e) {
          return g(t.prev, t, e.prev) < 0 && g(e.next, t, t.next) < 0;
        }
        function d(t, e, i, n, s) {
          return (
            (t =
              1431655765 &
              ((t =
                858993459 &
                ((t =
                  252645135 &
                  ((t = 16711935 & ((t = ((t - i) * s) | 0) | (t << 8))) |
                    (t << 4))) |
                  (t << 2))) |
                (t << 1))) |
            ((e =
              1431655765 &
              ((e =
                858993459 &
                ((e =
                  252645135 &
                  ((e = 16711935 & ((e = ((e - n) * s) | 0) | (e << 8))) |
                    (e << 4))) |
                  (e << 2))) |
                (e << 1))) <<
              1)
          );
        }
        function p(t) {
          var e = t,
            i = t;
          do {
            (e.x < i.x || (e.x === i.x && e.y < i.y)) && (i = e), (e = e.next);
          } while (e !== t);
          return i;
        }
        function f(t, e, i, n, s, r, o, a) {
          return (
            (s - o) * (e - a) >= (t - o) * (r - a) &&
            (t - o) * (n - a) >= (i - o) * (e - a) &&
            (i - o) * (r - a) >= (s - o) * (n - a)
          );
        }
        function m(t, e) {
          return (
            t.next.i !== e.i &&
            t.prev.i !== e.i &&
            !(function (t, e) {
              var i = t;
              do {
                if (
                  i.i !== t.i &&
                  i.next.i !== t.i &&
                  i.i !== e.i &&
                  i.next.i !== e.i &&
                  y(i, i.next, t, e)
                )
                  return !0;
                i = i.next;
              } while (i !== t);
              return !1;
            })(t, e) &&
            ((S(t, e) &&
              S(e, t) &&
              (function (t, e) {
                var i = t,
                  n = !1,
                  s = (t.x + e.x) / 2,
                  r = (t.y + e.y) / 2;
                do {
                  i.y > r != i.next.y > r &&
                    i.next.y !== i.y &&
                    s <
                      ((i.next.x - i.x) * (r - i.y)) / (i.next.y - i.y) + i.x &&
                    (n = !n),
                    (i = i.next);
                } while (i !== t);
                return n;
              })(t, e) &&
              (g(t.prev, t, e.prev) || g(t, e.prev, e))) ||
              (v(t, e) && g(t.prev, t, t.next) > 0 && g(e.prev, e, e.next) > 0))
          );
        }
        function g(t, e, i) {
          return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
        }
        function v(t, e) {
          return t.x === e.x && t.y === e.y;
        }
        function y(t, e, i, n) {
          var s = b(g(t, e, i)),
            r = b(g(t, e, n)),
            o = b(g(i, n, t)),
            a = b(g(i, n, e));
          return (
            (s !== r && o !== a) ||
            !(0 !== s || !x(t, i, e)) ||
            !(0 !== r || !x(t, n, e)) ||
            !(0 !== o || !x(i, t, n)) ||
            !(0 !== a || !x(i, e, n))
          );
        }
        function x(t, e, i) {
          return (
            e.x <= Math.max(t.x, i.x) &&
            e.x >= Math.min(t.x, i.x) &&
            e.y <= Math.max(t.y, i.y) &&
            e.y >= Math.min(t.y, i.y)
          );
        }
        function b(t) {
          return t > 0 ? 1 : t < 0 ? -1 : 0;
        }
        function S(t, e) {
          return g(t.prev, t, t.next) < 0
            ? g(t, e, t.next) >= 0 && g(t, t.prev, e) >= 0
            : g(t, e, t.prev) < 0 || g(t, t.next, e) < 0;
        }
        function C(t, e) {
          var i = new w(t.i, t.x, t.y),
            n = new w(e.i, e.x, e.y),
            s = t.next,
            r = e.prev;
          return (
            (t.next = e),
            (e.prev = t),
            (i.next = s),
            (s.prev = i),
            (n.next = i),
            (i.prev = n),
            (r.next = n),
            (n.prev = r),
            n
          );
        }
        function _(t, e, i, n) {
          var s = new w(t, e, i);
          return (
            n
              ? ((s.next = n.next),
                (s.prev = n),
                (n.next.prev = s),
                (n.next = s))
              : ((s.prev = s), (s.next = s)),
            s
          );
        }
        function T(t) {
          (t.next.prev = t.prev),
            (t.prev.next = t.next),
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ);
        }
        function w(t, e, i) {
          (this.i = t),
            (this.x = e),
            (this.y = i),
            (this.prev = null),
            (this.next = null),
            (this.z = 0),
            (this.prevZ = null),
            (this.nextZ = null),
            (this.steiner = !1);
        }
        function P(t, e, i, n) {
          for (var s = 0, r = e, o = i - n; r < i; r += n)
            (s += (t[o] - t[r]) * (t[r + 1] + t[o + 1])), (o = r);
          return s;
        }
        (t.exports = e),
          (t.exports.default = e),
          (e.deviation = function (t, e, i, n) {
            var s = e && e.length,
              r = s ? e[0] * i : t.length,
              o = Math.abs(P(t, 0, r, i));
            if (s)
              for (var a = 0, l = e.length; a < l; a++) {
                var u = e[a] * i,
                  h = a < l - 1 ? e[a + 1] * i : t.length;
                o -= Math.abs(P(t, u, h, i));
              }
            var c = 0;
            for (a = 0; a < n.length; a += 3) {
              var d = n[a] * i,
                p = n[a + 1] * i,
                f = n[a + 2] * i;
              c += Math.abs(
                (t[d] - t[f]) * (t[p + 1] - t[d + 1]) -
                  (t[d] - t[p]) * (t[f + 1] - t[d + 1])
              );
            }
            return 0 === o && 0 === c ? 0 : Math.abs((c - o) / o);
          }),
          (e.flatten = function (t) {
            for (
              var e = t[0][0].length,
                i = { vertices: [], holes: [], dimensions: e },
                n = 0,
                s = 0;
              s < t.length;
              s++
            ) {
              for (var r = 0; r < t[s].length; r++)
                for (var o = 0; o < e; o++) i.vertices.push(t[s][r][o]);
              s > 0 && ((n += t[s - 1].length), i.holes.push(n));
            }
            return i;
          });
      },
      228: (t) => {
        "use strict";
        var e = Object.prototype.hasOwnProperty,
          i = "~";
        function n() {}
        function s(t, e, i) {
          (this.fn = t), (this.context = e), (this.once = i || !1);
        }
        function r(t, e, n, r, o) {
          if ("function" != typeof n)
            throw new TypeError("The listener must be a function");
          var a = new s(n, r || t, o),
            l = i ? i + e : e;
          return (
            t._events[l]
              ? t._events[l].fn
                ? (t._events[l] = [t._events[l], a])
                : t._events[l].push(a)
              : ((t._events[l] = a), t._eventsCount++),
            t
          );
        }
        function o(t, e) {
          0 == --t._eventsCount ? (t._events = new n()) : delete t._events[e];
        }
        function a() {
          (this._events = new n()), (this._eventsCount = 0);
        }
        Object.create &&
          ((n.prototype = Object.create(null)), new n().__proto__ || (i = !1)),
          (a.prototype.eventNames = function () {
            var t,
              n,
              s = [];
            if (0 === this._eventsCount) return s;
            for (n in (t = this._events))
              e.call(t, n) && s.push(i ? n.slice(1) : n);
            return Object.getOwnPropertySymbols
              ? s.concat(Object.getOwnPropertySymbols(t))
              : s;
          }),
          (a.prototype.listeners = function (t) {
            var e = i ? i + t : t,
              n = this._events[e];
            if (!n) return [];
            if (n.fn) return [n.fn];
            for (var s = 0, r = n.length, o = new Array(r); s < r; s++)
              o[s] = n[s].fn;
            return o;
          }),
          (a.prototype.listenerCount = function (t) {
            var e = i ? i + t : t,
              n = this._events[e];
            return n ? (n.fn ? 1 : n.length) : 0;
          }),
          (a.prototype.emit = function (t, e, n, s, r, o) {
            var a = i ? i + t : t;
            if (!this._events[a]) return !1;
            var l,
              u,
              h = this._events[a],
              c = arguments.length;
            if (h.fn) {
              switch ((h.once && this.removeListener(t, h.fn, void 0, !0), c)) {
                case 1:
                  return h.fn.call(h.context), !0;
                case 2:
                  return h.fn.call(h.context, e), !0;
                case 3:
                  return h.fn.call(h.context, e, n), !0;
                case 4:
                  return h.fn.call(h.context, e, n, s), !0;
                case 5:
                  return h.fn.call(h.context, e, n, s, r), !0;
                case 6:
                  return h.fn.call(h.context, e, n, s, r, o), !0;
              }
              for (u = 1, l = new Array(c - 1); u < c; u++)
                l[u - 1] = arguments[u];
              h.fn.apply(h.context, l);
            } else {
              var d,
                p = h.length;
              for (u = 0; u < p; u++)
                switch (
                  (h[u].once && this.removeListener(t, h[u].fn, void 0, !0), c)
                ) {
                  case 1:
                    h[u].fn.call(h[u].context);
                    break;
                  case 2:
                    h[u].fn.call(h[u].context, e);
                    break;
                  case 3:
                    h[u].fn.call(h[u].context, e, n);
                    break;
                  case 4:
                    h[u].fn.call(h[u].context, e, n, s);
                    break;
                  default:
                    if (!l)
                      for (d = 1, l = new Array(c - 1); d < c; d++)
                        l[d - 1] = arguments[d];
                    h[u].fn.apply(h[u].context, l);
                }
            }
            return !0;
          }),
          (a.prototype.on = function (t, e, i) {
            return r(this, t, e, i, !1);
          }),
          (a.prototype.once = function (t, e, i) {
            return r(this, t, e, i, !0);
          }),
          (a.prototype.removeListener = function (t, e, n, s) {
            var r = i ? i + t : t;
            if (!this._events[r]) return this;
            if (!e) return o(this, r), this;
            var a = this._events[r];
            if (a.fn)
              a.fn !== e ||
                (s && !a.once) ||
                (n && a.context !== n) ||
                o(this, r);
            else {
              for (var l = 0, u = [], h = a.length; l < h; l++)
                (a[l].fn !== e ||
                  (s && !a[l].once) ||
                  (n && a[l].context !== n)) &&
                  u.push(a[l]);
              u.length
                ? (this._events[r] = 1 === u.length ? u[0] : u)
                : o(this, r);
            }
            return this;
          }),
          (a.prototype.removeAllListeners = function (t) {
            var e;
            return (
              t
                ? ((e = i ? i + t : t), this._events[e] && o(this, e))
                : ((this._events = new n()), (this._eventsCount = 0)),
              this
            );
          }),
          (a.prototype.off = a.prototype.removeListener),
          (a.prototype.addListener = a.prototype.on),
          (a.prefixed = i),
          (a.EventEmitter = a),
          (t.exports = a);
      },
      2543: function (t, e, i) {
        var n;
        (t = i.nmd(t)),
          function () {
            var s,
              r = "Expected a function",
              o = "__lodash_hash_undefined__",
              a = "__lodash_placeholder__",
              l = 16,
              u = 32,
              h = 64,
              c = 128,
              d = 256,
              p = 1 / 0,
              f = 9007199254740991,
              m = NaN,
              g = 4294967295,
              v = [
                ["ary", c],
                ["bind", 1],
                ["bindKey", 2],
                ["curry", 8],
                ["curryRight", l],
                ["flip", 512],
                ["partial", u],
                ["partialRight", h],
                ["rearg", d],
              ],
              y = "[object Arguments]",
              x = "[object Array]",
              b = "[object Boolean]",
              S = "[object Date]",
              C = "[object Error]",
              _ = "[object Function]",
              T = "[object GeneratorFunction]",
              w = "[object Map]",
              P = "[object Number]",
              A = "[object Object]",
              k = "[object Promise]",
              M = "[object RegExp]",
              E = "[object Set]",
              I = "[object String]",
              D = "[object Symbol]",
              R = "[object WeakMap]",
              B = "[object ArrayBuffer]",
              F = "[object DataView]",
              O = "[object Float32Array]",
              z = "[object Float64Array]",
              L = "[object Int8Array]",
              H = "[object Int16Array]",
              U = "[object Int32Array]",
              N = "[object Uint8Array]",
              G = "[object Uint8ClampedArray]",
              V = "[object Uint16Array]",
              j = "[object Uint32Array]",
              $ = /\b__p \+= '';/g,
              q = /\b(__p \+=) '' \+/g,
              W = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
              X = /&(?:amp|lt|gt|quot|#39);/g,
              Y = /[&<>"']/g,
              K = RegExp(X.source),
              Z = RegExp(Y.source),
              Q = /<%-([\s\S]+?)%>/g,
              J = /<%([\s\S]+?)%>/g,
              tt = /<%=([\s\S]+?)%>/g,
              et = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
              it = /^\w*$/,
              nt =
                /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
              st = /[\\^$.*+?()[\]{}|]/g,
              rt = RegExp(st.source),
              ot = /^\s+/,
              at = /\s/,
              lt = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
              ut = /\{\n\/\* \[wrapped with (.+)\] \*/,
              ht = /,? & /,
              ct = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
              dt = /[()=,{}\[\]\/\s]/,
              pt = /\\(\\)?/g,
              ft = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
              mt = /\w*$/,
              gt = /^[-+]0x[0-9a-f]+$/i,
              vt = /^0b[01]+$/i,
              yt = /^\[object .+?Constructor\]$/,
              xt = /^0o[0-7]+$/i,
              bt = /^(?:0|[1-9]\d*)$/,
              St = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
              Ct = /($^)/,
              _t = /['\n\r\u2028\u2029\\]/g,
              Tt = "\\ud800-\\udfff",
              wt = "\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",
              Pt = "\\u2700-\\u27bf",
              At = "a-z\\xdf-\\xf6\\xf8-\\xff",
              kt = "A-Z\\xc0-\\xd6\\xd8-\\xde",
              Mt = "\\ufe0e\\ufe0f",
              Et =
                "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
              It = "['’]",
              Dt = "[" + Tt + "]",
              Rt = "[" + Et + "]",
              Bt = "[" + wt + "]",
              Ft = "\\d+",
              Ot = "[" + Pt + "]",
              zt = "[" + At + "]",
              Lt = "[^" + Tt + Et + Ft + Pt + At + kt + "]",
              Ht = "\\ud83c[\\udffb-\\udfff]",
              Ut = "[^" + Tt + "]",
              Nt = "(?:\\ud83c[\\udde6-\\uddff]){2}",
              Gt = "[\\ud800-\\udbff][\\udc00-\\udfff]",
              Vt = "[" + kt + "]",
              jt = "\\u200d",
              $t = "(?:" + zt + "|" + Lt + ")",
              qt = "(?:" + Vt + "|" + Lt + ")",
              Wt = "(?:['’](?:d|ll|m|re|s|t|ve))?",
              Xt = "(?:['’](?:D|LL|M|RE|S|T|VE))?",
              Yt = "(?:" + Bt + "|" + Ht + ")" + "?",
              Kt = "[" + Mt + "]?",
              Zt =
                Kt +
                Yt +
                ("(?:" +
                  jt +
                  "(?:" +
                  [Ut, Nt, Gt].join("|") +
                  ")" +
                  Kt +
                  Yt +
                  ")*"),
              Qt = "(?:" + [Ot, Nt, Gt].join("|") + ")" + Zt,
              Jt = "(?:" + [Ut + Bt + "?", Bt, Nt, Gt, Dt].join("|") + ")",
              te = RegExp(It, "g"),
              ee = RegExp(Bt, "g"),
              ie = RegExp(Ht + "(?=" + Ht + ")|" + Jt + Zt, "g"),
              ne = RegExp(
                [
                  Vt +
                    "?" +
                    zt +
                    "+" +
                    Wt +
                    "(?=" +
                    [Rt, Vt, "$"].join("|") +
                    ")",
                  qt + "+" + Xt + "(?=" + [Rt, Vt + $t, "$"].join("|") + ")",
                  Vt + "?" + $t + "+" + Wt,
                  Vt + "+" + Xt,
                  "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
                  "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
                  Ft,
                  Qt,
                ].join("|"),
                "g"
              ),
              se = RegExp("[" + jt + Tt + wt + Mt + "]"),
              re =
                /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
              oe = [
                "Array",
                "Buffer",
                "DataView",
                "Date",
                "Error",
                "Float32Array",
                "Float64Array",
                "Function",
                "Int8Array",
                "Int16Array",
                "Int32Array",
                "Map",
                "Math",
                "Object",
                "Promise",
                "RegExp",
                "Set",
                "String",
                "Symbol",
                "TypeError",
                "Uint8Array",
                "Uint8ClampedArray",
                "Uint16Array",
                "Uint32Array",
                "WeakMap",
                "_",
                "clearTimeout",
                "isFinite",
                "parseInt",
                "setTimeout",
              ],
              ae = -1,
              le = {};
            (le[O] =
              le[z] =
              le[L] =
              le[H] =
              le[U] =
              le[N] =
              le[G] =
              le[V] =
              le[j] =
                !0),
              (le[y] =
                le[x] =
                le[B] =
                le[b] =
                le[F] =
                le[S] =
                le[C] =
                le[_] =
                le[w] =
                le[P] =
                le[A] =
                le[M] =
                le[E] =
                le[I] =
                le[R] =
                  !1);
            var ue = {};
            (ue[y] =
              ue[x] =
              ue[B] =
              ue[F] =
              ue[b] =
              ue[S] =
              ue[O] =
              ue[z] =
              ue[L] =
              ue[H] =
              ue[U] =
              ue[w] =
              ue[P] =
              ue[A] =
              ue[M] =
              ue[E] =
              ue[I] =
              ue[D] =
              ue[N] =
              ue[G] =
              ue[V] =
              ue[j] =
                !0),
              (ue[C] = ue[_] = ue[R] = !1);
            var he = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029",
              },
              ce = parseFloat,
              de = parseInt,
              pe =
                "object" == typeof i.g && i.g && i.g.Object === Object && i.g,
              fe =
                "object" == typeof self &&
                self &&
                self.Object === Object &&
                self,
              me = pe || fe || Function("return this")(),
              ge = e && !e.nodeType && e,
              ve = ge && t && !t.nodeType && t,
              ye = ve && ve.exports === ge,
              xe = ye && pe.process,
              be = (function () {
                try {
                  var t = ve && ve.require && ve.require("util").types;
                  return t || (xe && xe.binding && xe.binding("util"));
                } catch (t) {}
              })(),
              Se = be && be.isArrayBuffer,
              Ce = be && be.isDate,
              _e = be && be.isMap,
              Te = be && be.isRegExp,
              we = be && be.isSet,
              Pe = be && be.isTypedArray;
            function Ae(t, e, i) {
              switch (i.length) {
                case 0:
                  return t.call(e);
                case 1:
                  return t.call(e, i[0]);
                case 2:
                  return t.call(e, i[0], i[1]);
                case 3:
                  return t.call(e, i[0], i[1], i[2]);
              }
              return t.apply(e, i);
            }
            function ke(t, e, i, n) {
              for (var s = -1, r = null == t ? 0 : t.length; ++s < r; ) {
                var o = t[s];
                e(n, o, i(o), t);
              }
              return n;
            }
            function Me(t, e) {
              for (
                var i = -1, n = null == t ? 0 : t.length;
                ++i < n && !1 !== e(t[i], i, t);

              );
              return t;
            }
            function Ee(t, e) {
              for (
                var i = null == t ? 0 : t.length;
                i-- && !1 !== e(t[i], i, t);

              );
              return t;
            }
            function Ie(t, e) {
              for (var i = -1, n = null == t ? 0 : t.length; ++i < n; )
                if (!e(t[i], i, t)) return !1;
              return !0;
            }
            function De(t, e) {
              for (
                var i = -1, n = null == t ? 0 : t.length, s = 0, r = [];
                ++i < n;

              ) {
                var o = t[i];
                e(o, i, t) && (r[s++] = o);
              }
              return r;
            }
            function Re(t, e) {
              return !!(null == t ? 0 : t.length) && Ve(t, e, 0) > -1;
            }
            function Be(t, e, i) {
              for (var n = -1, s = null == t ? 0 : t.length; ++n < s; )
                if (i(e, t[n])) return !0;
              return !1;
            }
            function Fe(t, e) {
              for (
                var i = -1, n = null == t ? 0 : t.length, s = Array(n);
                ++i < n;

              )
                s[i] = e(t[i], i, t);
              return s;
            }
            function Oe(t, e) {
              for (var i = -1, n = e.length, s = t.length; ++i < n; )
                t[s + i] = e[i];
              return t;
            }
            function ze(t, e, i, n) {
              var s = -1,
                r = null == t ? 0 : t.length;
              for (n && r && (i = t[++s]); ++s < r; ) i = e(i, t[s], s, t);
              return i;
            }
            function Le(t, e, i, n) {
              var s = null == t ? 0 : t.length;
              for (n && s && (i = t[--s]); s--; ) i = e(i, t[s], s, t);
              return i;
            }
            function He(t, e) {
              for (var i = -1, n = null == t ? 0 : t.length; ++i < n; )
                if (e(t[i], i, t)) return !0;
              return !1;
            }
            var Ue = We("length");
            function Ne(t, e, i) {
              var n;
              return (
                i(t, function (t, i, s) {
                  if (e(t, i, s)) return (n = i), !1;
                }),
                n
              );
            }
            function Ge(t, e, i, n) {
              for (var s = t.length, r = i + (n ? 1 : -1); n ? r-- : ++r < s; )
                if (e(t[r], r, t)) return r;
              return -1;
            }
            function Ve(t, e, i) {
              return e == e
                ? (function (t, e, i) {
                    var n = i - 1,
                      s = t.length;
                    for (; ++n < s; ) if (t[n] === e) return n;
                    return -1;
                  })(t, e, i)
                : Ge(t, $e, i);
            }
            function je(t, e, i, n) {
              for (var s = i - 1, r = t.length; ++s < r; )
                if (n(t[s], e)) return s;
              return -1;
            }
            function $e(t) {
              return t != t;
            }
            function qe(t, e) {
              var i = null == t ? 0 : t.length;
              return i ? Ke(t, e) / i : m;
            }
            function We(t) {
              return function (e) {
                return null == e ? s : e[t];
              };
            }
            function Xe(t) {
              return function (e) {
                return null == t ? s : t[e];
              };
            }
            function Ye(t, e, i, n, s) {
              return (
                s(t, function (t, s, r) {
                  i = n ? ((n = !1), t) : e(i, t, s, r);
                }),
                i
              );
            }
            function Ke(t, e) {
              for (var i, n = -1, r = t.length; ++n < r; ) {
                var o = e(t[n]);
                o !== s && (i = i === s ? o : i + o);
              }
              return i;
            }
            function Ze(t, e) {
              for (var i = -1, n = Array(t); ++i < t; ) n[i] = e(i);
              return n;
            }
            function Qe(t) {
              return t ? t.slice(0, mi(t) + 1).replace(ot, "") : t;
            }
            function Je(t) {
              return function (e) {
                return t(e);
              };
            }
            function ti(t, e) {
              return Fe(e, function (e) {
                return t[e];
              });
            }
            function ei(t, e) {
              return t.has(e);
            }
            function ii(t, e) {
              for (var i = -1, n = t.length; ++i < n && Ve(e, t[i], 0) > -1; );
              return i;
            }
            function ni(t, e) {
              for (var i = t.length; i-- && Ve(e, t[i], 0) > -1; );
              return i;
            }
            var si = Xe({
                À: "A",
                Á: "A",
                Â: "A",
                Ã: "A",
                Ä: "A",
                Å: "A",
                à: "a",
                á: "a",
                â: "a",
                ã: "a",
                ä: "a",
                å: "a",
                Ç: "C",
                ç: "c",
                Ð: "D",
                ð: "d",
                È: "E",
                É: "E",
                Ê: "E",
                Ë: "E",
                è: "e",
                é: "e",
                ê: "e",
                ë: "e",
                Ì: "I",
                Í: "I",
                Î: "I",
                Ï: "I",
                ì: "i",
                í: "i",
                î: "i",
                ï: "i",
                Ñ: "N",
                ñ: "n",
                Ò: "O",
                Ó: "O",
                Ô: "O",
                Õ: "O",
                Ö: "O",
                Ø: "O",
                ò: "o",
                ó: "o",
                ô: "o",
                õ: "o",
                ö: "o",
                ø: "o",
                Ù: "U",
                Ú: "U",
                Û: "U",
                Ü: "U",
                ù: "u",
                ú: "u",
                û: "u",
                ü: "u",
                Ý: "Y",
                ý: "y",
                ÿ: "y",
                Æ: "Ae",
                æ: "ae",
                Þ: "Th",
                þ: "th",
                ß: "ss",
                Ā: "A",
                Ă: "A",
                Ą: "A",
                ā: "a",
                ă: "a",
                ą: "a",
                Ć: "C",
                Ĉ: "C",
                Ċ: "C",
                Č: "C",
                ć: "c",
                ĉ: "c",
                ċ: "c",
                č: "c",
                Ď: "D",
                Đ: "D",
                ď: "d",
                đ: "d",
                Ē: "E",
                Ĕ: "E",
                Ė: "E",
                Ę: "E",
                Ě: "E",
                ē: "e",
                ĕ: "e",
                ė: "e",
                ę: "e",
                ě: "e",
                Ĝ: "G",
                Ğ: "G",
                Ġ: "G",
                Ģ: "G",
                ĝ: "g",
                ğ: "g",
                ġ: "g",
                ģ: "g",
                Ĥ: "H",
                Ħ: "H",
                ĥ: "h",
                ħ: "h",
                Ĩ: "I",
                Ī: "I",
                Ĭ: "I",
                Į: "I",
                İ: "I",
                ĩ: "i",
                ī: "i",
                ĭ: "i",
                į: "i",
                ı: "i",
                Ĵ: "J",
                ĵ: "j",
                Ķ: "K",
                ķ: "k",
                ĸ: "k",
                Ĺ: "L",
                Ļ: "L",
                Ľ: "L",
                Ŀ: "L",
                Ł: "L",
                ĺ: "l",
                ļ: "l",
                ľ: "l",
                ŀ: "l",
                ł: "l",
                Ń: "N",
                Ņ: "N",
                Ň: "N",
                Ŋ: "N",
                ń: "n",
                ņ: "n",
                ň: "n",
                ŋ: "n",
                Ō: "O",
                Ŏ: "O",
                Ő: "O",
                ō: "o",
                ŏ: "o",
                ő: "o",
                Ŕ: "R",
                Ŗ: "R",
                Ř: "R",
                ŕ: "r",
                ŗ: "r",
                ř: "r",
                Ś: "S",
                Ŝ: "S",
                Ş: "S",
                Š: "S",
                ś: "s",
                ŝ: "s",
                ş: "s",
                š: "s",
                Ţ: "T",
                Ť: "T",
                Ŧ: "T",
                ţ: "t",
                ť: "t",
                ŧ: "t",
                Ũ: "U",
                Ū: "U",
                Ŭ: "U",
                Ů: "U",
                Ű: "U",
                Ų: "U",
                ũ: "u",
                ū: "u",
                ŭ: "u",
                ů: "u",
                ű: "u",
                ų: "u",
                Ŵ: "W",
                ŵ: "w",
                Ŷ: "Y",
                ŷ: "y",
                Ÿ: "Y",
                Ź: "Z",
                Ż: "Z",
                Ž: "Z",
                ź: "z",
                ż: "z",
                ž: "z",
                Ĳ: "IJ",
                ĳ: "ij",
                Œ: "Oe",
                œ: "oe",
                ŉ: "'n",
                ſ: "s",
              }),
              ri = Xe({
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
              });
            function oi(t) {
              return "\\" + he[t];
            }
            function ai(t) {
              return se.test(t);
            }
            function li(t) {
              var e = -1,
                i = Array(t.size);
              return (
                t.forEach(function (t, n) {
                  i[++e] = [n, t];
                }),
                i
              );
            }
            function ui(t, e) {
              return function (i) {
                return t(e(i));
              };
            }
            function hi(t, e) {
              for (var i = -1, n = t.length, s = 0, r = []; ++i < n; ) {
                var o = t[i];
                (o !== e && o !== a) || ((t[i] = a), (r[s++] = i));
              }
              return r;
            }
            function ci(t) {
              var e = -1,
                i = Array(t.size);
              return (
                t.forEach(function (t) {
                  i[++e] = t;
                }),
                i
              );
            }
            function di(t) {
              var e = -1,
                i = Array(t.size);
              return (
                t.forEach(function (t) {
                  i[++e] = [t, t];
                }),
                i
              );
            }
            function pi(t) {
              return ai(t)
                ? (function (t) {
                    var e = (ie.lastIndex = 0);
                    for (; ie.test(t); ) ++e;
                    return e;
                  })(t)
                : Ue(t);
            }
            function fi(t) {
              return ai(t)
                ? (function (t) {
                    return t.match(ie) || [];
                  })(t)
                : (function (t) {
                    return t.split("");
                  })(t);
            }
            function mi(t) {
              for (var e = t.length; e-- && at.test(t.charAt(e)); );
              return e;
            }
            var gi = Xe({
              "&amp;": "&",
              "&lt;": "<",
              "&gt;": ">",
              "&quot;": '"',
              "&#39;": "'",
            });
            var vi = (function t(e) {
              var i,
                n = (e =
                  null == e ? me : vi.defaults(me.Object(), e, vi.pick(me, oe)))
                  .Array,
                at = e.Date,
                Tt = e.Error,
                wt = e.Function,
                Pt = e.Math,
                At = e.Object,
                kt = e.RegExp,
                Mt = e.String,
                Et = e.TypeError,
                It = n.prototype,
                Dt = wt.prototype,
                Rt = At.prototype,
                Bt = e["__core-js_shared__"],
                Ft = Dt.toString,
                Ot = Rt.hasOwnProperty,
                zt = 0,
                Lt = (i = /[^.]+$/.exec(
                  (Bt && Bt.keys && Bt.keys.IE_PROTO) || ""
                ))
                  ? "Symbol(src)_1." + i
                  : "",
                Ht = Rt.toString,
                Ut = Ft.call(At),
                Nt = me._,
                Gt = kt(
                  "^" +
                    Ft.call(Ot)
                      .replace(st, "\\$&")
                      .replace(
                        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                        "$1.*?"
                      ) +
                    "$"
                ),
                Vt = ye ? e.Buffer : s,
                jt = e.Symbol,
                $t = e.Uint8Array,
                qt = Vt ? Vt.allocUnsafe : s,
                Wt = ui(At.getPrototypeOf, At),
                Xt = At.create,
                Yt = Rt.propertyIsEnumerable,
                Kt = It.splice,
                Zt = jt ? jt.isConcatSpreadable : s,
                Qt = jt ? jt.iterator : s,
                Jt = jt ? jt.toStringTag : s,
                ie = (function () {
                  try {
                    var t = dr(At, "defineProperty");
                    return t({}, "", {}), t;
                  } catch (t) {}
                })(),
                se = e.clearTimeout !== me.clearTimeout && e.clearTimeout,
                he = at && at.now !== me.Date.now && at.now,
                pe = e.setTimeout !== me.setTimeout && e.setTimeout,
                fe = Pt.ceil,
                ge = Pt.floor,
                ve = At.getOwnPropertySymbols,
                xe = Vt ? Vt.isBuffer : s,
                be = e.isFinite,
                Ue = It.join,
                Xe = ui(At.keys, At),
                yi = Pt.max,
                xi = Pt.min,
                bi = at.now,
                Si = e.parseInt,
                Ci = Pt.random,
                _i = It.reverse,
                Ti = dr(e, "DataView"),
                wi = dr(e, "Map"),
                Pi = dr(e, "Promise"),
                Ai = dr(e, "Set"),
                ki = dr(e, "WeakMap"),
                Mi = dr(At, "create"),
                Ei = ki && new ki(),
                Ii = {},
                Di = Lr(Ti),
                Ri = Lr(wi),
                Bi = Lr(Pi),
                Fi = Lr(Ai),
                Oi = Lr(ki),
                zi = jt ? jt.prototype : s,
                Li = zi ? zi.valueOf : s,
                Hi = zi ? zi.toString : s;
              function Ui(t) {
                if (ia(t) && !$o(t) && !(t instanceof ji)) {
                  if (t instanceof Vi) return t;
                  if (Ot.call(t, "__wrapped__")) return Hr(t);
                }
                return new Vi(t);
              }
              var Ni = (function () {
                function t() {}
                return function (e) {
                  if (!ea(e)) return {};
                  if (Xt) return Xt(e);
                  t.prototype = e;
                  var i = new t();
                  return (t.prototype = s), i;
                };
              })();
              function Gi() {}
              function Vi(t, e) {
                (this.__wrapped__ = t),
                  (this.__actions__ = []),
                  (this.__chain__ = !!e),
                  (this.__index__ = 0),
                  (this.__values__ = s);
              }
              function ji(t) {
                (this.__wrapped__ = t),
                  (this.__actions__ = []),
                  (this.__dir__ = 1),
                  (this.__filtered__ = !1),
                  (this.__iteratees__ = []),
                  (this.__takeCount__ = g),
                  (this.__views__ = []);
              }
              function $i(t) {
                var e = -1,
                  i = null == t ? 0 : t.length;
                for (this.clear(); ++e < i; ) {
                  var n = t[e];
                  this.set(n[0], n[1]);
                }
              }
              function qi(t) {
                var e = -1,
                  i = null == t ? 0 : t.length;
                for (this.clear(); ++e < i; ) {
                  var n = t[e];
                  this.set(n[0], n[1]);
                }
              }
              function Wi(t) {
                var e = -1,
                  i = null == t ? 0 : t.length;
                for (this.clear(); ++e < i; ) {
                  var n = t[e];
                  this.set(n[0], n[1]);
                }
              }
              function Xi(t) {
                var e = -1,
                  i = null == t ? 0 : t.length;
                for (this.__data__ = new Wi(); ++e < i; ) this.add(t[e]);
              }
              function Yi(t) {
                var e = (this.__data__ = new qi(t));
                this.size = e.size;
              }
              function Ki(t, e) {
                var i = $o(t),
                  n = !i && jo(t),
                  s = !i && !n && Yo(t),
                  r = !i && !n && !s && ha(t),
                  o = i || n || s || r,
                  a = o ? Ze(t.length, Mt) : [],
                  l = a.length;
                for (var u in t)
                  (!e && !Ot.call(t, u)) ||
                    (o &&
                      ("length" == u ||
                        (s && ("offset" == u || "parent" == u)) ||
                        (r &&
                          ("buffer" == u ||
                            "byteLength" == u ||
                            "byteOffset" == u)) ||
                        xr(u, l))) ||
                    a.push(u);
                return a;
              }
              function Zi(t) {
                var e = t.length;
                return e ? t[Yn(0, e - 1)] : s;
              }
              function Qi(t, e) {
                return Fr(Es(t), ln(e, 0, t.length));
              }
              function Ji(t) {
                return Fr(Es(t));
              }
              function tn(t, e, i) {
                ((i !== s && !No(t[e], i)) || (i === s && !(e in t))) &&
                  on(t, e, i);
              }
              function en(t, e, i) {
                var n = t[e];
                (Ot.call(t, e) && No(n, i) && (i !== s || e in t)) ||
                  on(t, e, i);
              }
              function nn(t, e) {
                for (var i = t.length; i--; ) if (No(t[i][0], e)) return i;
                return -1;
              }
              function sn(t, e, i, n) {
                return (
                  pn(t, function (t, s, r) {
                    e(n, t, i(t), r);
                  }),
                  n
                );
              }
              function rn(t, e) {
                return t && Is(e, Da(e), t);
              }
              function on(t, e, i) {
                "__proto__" == e && ie
                  ? ie(t, e, {
                      configurable: !0,
                      enumerable: !0,
                      value: i,
                      writable: !0,
                    })
                  : (t[e] = i);
              }
              function an(t, e) {
                for (
                  var i = -1, r = e.length, o = n(r), a = null == t;
                  ++i < r;

                )
                  o[i] = a ? s : Aa(t, e[i]);
                return o;
              }
              function ln(t, e, i) {
                return (
                  t == t &&
                    (i !== s && (t = t <= i ? t : i),
                    e !== s && (t = t >= e ? t : e)),
                  t
                );
              }
              function un(t, e, i, n, r, o) {
                var a,
                  l = 1 & e,
                  u = 2 & e,
                  h = 4 & e;
                if ((i && (a = r ? i(t, n, r, o) : i(t)), a !== s)) return a;
                if (!ea(t)) return t;
                var c = $o(t);
                if (c) {
                  if (
                    ((a = (function (t) {
                      var e = t.length,
                        i = new t.constructor(e);
                      e &&
                        "string" == typeof t[0] &&
                        Ot.call(t, "index") &&
                        ((i.index = t.index), (i.input = t.input));
                      return i;
                    })(t)),
                    !l)
                  )
                    return Es(t, a);
                } else {
                  var d = mr(t),
                    p = d == _ || d == T;
                  if (Yo(t)) return Ts(t, l);
                  if (d == A || d == y || (p && !r)) {
                    if (((a = u || p ? {} : vr(t)), !l))
                      return u
                        ? (function (t, e) {
                            return Is(t, fr(t), e);
                          })(
                            t,
                            (function (t, e) {
                              return t && Is(e, Ra(e), t);
                            })(a, t)
                          )
                        : (function (t, e) {
                            return Is(t, pr(t), e);
                          })(t, rn(a, t));
                  } else {
                    if (!ue[d]) return r ? t : {};
                    a = (function (t, e, i) {
                      var n = t.constructor;
                      switch (e) {
                        case B:
                          return ws(t);
                        case b:
                        case S:
                          return new n(+t);
                        case F:
                          return (function (t, e) {
                            var i = e ? ws(t.buffer) : t.buffer;
                            return new t.constructor(
                              i,
                              t.byteOffset,
                              t.byteLength
                            );
                          })(t, i);
                        case O:
                        case z:
                        case L:
                        case H:
                        case U:
                        case N:
                        case G:
                        case V:
                        case j:
                          return Ps(t, i);
                        case w:
                          return new n();
                        case P:
                        case I:
                          return new n(t);
                        case M:
                          return (function (t) {
                            var e = new t.constructor(t.source, mt.exec(t));
                            return (e.lastIndex = t.lastIndex), e;
                          })(t);
                        case E:
                          return new n();
                        case D:
                          return (s = t), Li ? At(Li.call(s)) : {};
                      }
                      var s;
                    })(t, d, l);
                  }
                }
                o || (o = new Yi());
                var f = o.get(t);
                if (f) return f;
                o.set(t, a),
                  aa(t)
                    ? t.forEach(function (n) {
                        a.add(un(n, e, i, n, t, o));
                      })
                    : na(t) &&
                      t.forEach(function (n, s) {
                        a.set(s, un(n, e, i, s, t, o));
                      });
                var m = c ? s : (h ? (u ? rr : sr) : u ? Ra : Da)(t);
                return (
                  Me(m || t, function (n, s) {
                    m && (n = t[(s = n)]), en(a, s, un(n, e, i, s, t, o));
                  }),
                  a
                );
              }
              function hn(t, e, i) {
                var n = i.length;
                if (null == t) return !n;
                for (t = At(t); n--; ) {
                  var r = i[n],
                    o = e[r],
                    a = t[r];
                  if ((a === s && !(r in t)) || !o(a)) return !1;
                }
                return !0;
              }
              function cn(t, e, i) {
                if ("function" != typeof t) throw new Et(r);
                return Ir(function () {
                  t.apply(s, i);
                }, e);
              }
              function dn(t, e, i, n) {
                var s = -1,
                  r = Re,
                  o = !0,
                  a = t.length,
                  l = [],
                  u = e.length;
                if (!a) return l;
                i && (e = Fe(e, Je(i))),
                  n
                    ? ((r = Be), (o = !1))
                    : e.length >= 200 && ((r = ei), (o = !1), (e = new Xi(e)));
                t: for (; ++s < a; ) {
                  var h = t[s],
                    c = null == i ? h : i(h);
                  if (((h = n || 0 !== h ? h : 0), o && c == c)) {
                    for (var d = u; d--; ) if (e[d] === c) continue t;
                    l.push(h);
                  } else r(e, c, n) || l.push(h);
                }
                return l;
              }
              (Ui.templateSettings = {
                escape: Q,
                evaluate: J,
                interpolate: tt,
                variable: "",
                imports: { _: Ui },
              }),
                (Ui.prototype = Gi.prototype),
                (Ui.prototype.constructor = Ui),
                (Vi.prototype = Ni(Gi.prototype)),
                (Vi.prototype.constructor = Vi),
                (ji.prototype = Ni(Gi.prototype)),
                (ji.prototype.constructor = ji),
                ($i.prototype.clear = function () {
                  (this.__data__ = Mi ? Mi(null) : {}), (this.size = 0);
                }),
                ($i.prototype.delete = function (t) {
                  var e = this.has(t) && delete this.__data__[t];
                  return (this.size -= e ? 1 : 0), e;
                }),
                ($i.prototype.get = function (t) {
                  var e = this.__data__;
                  if (Mi) {
                    var i = e[t];
                    return i === o ? s : i;
                  }
                  return Ot.call(e, t) ? e[t] : s;
                }),
                ($i.prototype.has = function (t) {
                  var e = this.__data__;
                  return Mi ? e[t] !== s : Ot.call(e, t);
                }),
                ($i.prototype.set = function (t, e) {
                  var i = this.__data__;
                  return (
                    (this.size += this.has(t) ? 0 : 1),
                    (i[t] = Mi && e === s ? o : e),
                    this
                  );
                }),
                (qi.prototype.clear = function () {
                  (this.__data__ = []), (this.size = 0);
                }),
                (qi.prototype.delete = function (t) {
                  var e = this.__data__,
                    i = nn(e, t);
                  return (
                    !(i < 0) &&
                    (i == e.length - 1 ? e.pop() : Kt.call(e, i, 1),
                    --this.size,
                    !0)
                  );
                }),
                (qi.prototype.get = function (t) {
                  var e = this.__data__,
                    i = nn(e, t);
                  return i < 0 ? s : e[i][1];
                }),
                (qi.prototype.has = function (t) {
                  return nn(this.__data__, t) > -1;
                }),
                (qi.prototype.set = function (t, e) {
                  var i = this.__data__,
                    n = nn(i, t);
                  return (
                    n < 0 ? (++this.size, i.push([t, e])) : (i[n][1] = e), this
                  );
                }),
                (Wi.prototype.clear = function () {
                  (this.size = 0),
                    (this.__data__ = {
                      hash: new $i(),
                      map: new (wi || qi)(),
                      string: new $i(),
                    });
                }),
                (Wi.prototype.delete = function (t) {
                  var e = hr(this, t).delete(t);
                  return (this.size -= e ? 1 : 0), e;
                }),
                (Wi.prototype.get = function (t) {
                  return hr(this, t).get(t);
                }),
                (Wi.prototype.has = function (t) {
                  return hr(this, t).has(t);
                }),
                (Wi.prototype.set = function (t, e) {
                  var i = hr(this, t),
                    n = i.size;
                  return i.set(t, e), (this.size += i.size == n ? 0 : 1), this;
                }),
                (Xi.prototype.add = Xi.prototype.push =
                  function (t) {
                    return this.__data__.set(t, o), this;
                  }),
                (Xi.prototype.has = function (t) {
                  return this.__data__.has(t);
                }),
                (Yi.prototype.clear = function () {
                  (this.__data__ = new qi()), (this.size = 0);
                }),
                (Yi.prototype.delete = function (t) {
                  var e = this.__data__,
                    i = e.delete(t);
                  return (this.size = e.size), i;
                }),
                (Yi.prototype.get = function (t) {
                  return this.__data__.get(t);
                }),
                (Yi.prototype.has = function (t) {
                  return this.__data__.has(t);
                }),
                (Yi.prototype.set = function (t, e) {
                  var i = this.__data__;
                  if (i instanceof qi) {
                    var n = i.__data__;
                    if (!wi || n.length < 199)
                      return n.push([t, e]), (this.size = ++i.size), this;
                    i = this.__data__ = new Wi(n);
                  }
                  return i.set(t, e), (this.size = i.size), this;
                });
              var pn = Bs(Sn),
                fn = Bs(Cn, !0);
              function mn(t, e) {
                var i = !0;
                return (
                  pn(t, function (t, n, s) {
                    return (i = !!e(t, n, s));
                  }),
                  i
                );
              }
              function gn(t, e, i) {
                for (var n = -1, r = t.length; ++n < r; ) {
                  var o = t[n],
                    a = e(o);
                  if (null != a && (l === s ? a == a && !ua(a) : i(a, l)))
                    var l = a,
                      u = o;
                }
                return u;
              }
              function vn(t, e) {
                var i = [];
                return (
                  pn(t, function (t, n, s) {
                    e(t, n, s) && i.push(t);
                  }),
                  i
                );
              }
              function yn(t, e, i, n, s) {
                var r = -1,
                  o = t.length;
                for (i || (i = yr), s || (s = []); ++r < o; ) {
                  var a = t[r];
                  e > 0 && i(a)
                    ? e > 1
                      ? yn(a, e - 1, i, n, s)
                      : Oe(s, a)
                    : n || (s[s.length] = a);
                }
                return s;
              }
              var xn = Fs(),
                bn = Fs(!0);
              function Sn(t, e) {
                return t && xn(t, e, Da);
              }
              function Cn(t, e) {
                return t && bn(t, e, Da);
              }
              function _n(t, e) {
                return De(e, function (e) {
                  return Qo(t[e]);
                });
              }
              function Tn(t, e) {
                for (var i = 0, n = (e = bs(e, t)).length; null != t && i < n; )
                  t = t[zr(e[i++])];
                return i && i == n ? t : s;
              }
              function wn(t, e, i) {
                var n = e(t);
                return $o(t) ? n : Oe(n, i(t));
              }
              function Pn(t) {
                return null == t
                  ? t === s
                    ? "[object Undefined]"
                    : "[object Null]"
                  : Jt && Jt in At(t)
                  ? (function (t) {
                      var e = Ot.call(t, Jt),
                        i = t[Jt];
                      try {
                        t[Jt] = s;
                        var n = !0;
                      } catch (t) {}
                      var r = Ht.call(t);
                      n && (e ? (t[Jt] = i) : delete t[Jt]);
                      return r;
                    })(t)
                  : (function (t) {
                      return Ht.call(t);
                    })(t);
              }
              function An(t, e) {
                return t > e;
              }
              function kn(t, e) {
                return null != t && Ot.call(t, e);
              }
              function Mn(t, e) {
                return null != t && e in At(t);
              }
              function En(t, e, i) {
                for (
                  var r = i ? Be : Re,
                    o = t[0].length,
                    a = t.length,
                    l = a,
                    u = n(a),
                    h = 1 / 0,
                    c = [];
                  l--;

                ) {
                  var d = t[l];
                  l && e && (d = Fe(d, Je(e))),
                    (h = xi(d.length, h)),
                    (u[l] =
                      !i && (e || (o >= 120 && d.length >= 120))
                        ? new Xi(l && d)
                        : s);
                }
                d = t[0];
                var p = -1,
                  f = u[0];
                t: for (; ++p < o && c.length < h; ) {
                  var m = d[p],
                    g = e ? e(m) : m;
                  if (
                    ((m = i || 0 !== m ? m : 0), !(f ? ei(f, g) : r(c, g, i)))
                  ) {
                    for (l = a; --l; ) {
                      var v = u[l];
                      if (!(v ? ei(v, g) : r(t[l], g, i))) continue t;
                    }
                    f && f.push(g), c.push(m);
                  }
                }
                return c;
              }
              function In(t, e, i) {
                var n = null == (t = kr(t, (e = bs(e, t)))) ? t : t[zr(Kr(e))];
                return null == n ? s : Ae(n, t, i);
              }
              function Dn(t) {
                return ia(t) && Pn(t) == y;
              }
              function Rn(t, e, i, n, r) {
                return (
                  t === e ||
                  (null == t || null == e || (!ia(t) && !ia(e))
                    ? t != t && e != e
                    : (function (t, e, i, n, r, o) {
                        var a = $o(t),
                          l = $o(e),
                          u = a ? x : mr(t),
                          h = l ? x : mr(e),
                          c = (u = u == y ? A : u) == A,
                          d = (h = h == y ? A : h) == A,
                          p = u == h;
                        if (p && Yo(t)) {
                          if (!Yo(e)) return !1;
                          (a = !0), (c = !1);
                        }
                        if (p && !c)
                          return (
                            o || (o = new Yi()),
                            a || ha(t)
                              ? ir(t, e, i, n, r, o)
                              : (function (t, e, i, n, s, r, o) {
                                  switch (i) {
                                    case F:
                                      if (
                                        t.byteLength != e.byteLength ||
                                        t.byteOffset != e.byteOffset
                                      )
                                        return !1;
                                      (t = t.buffer), (e = e.buffer);
                                    case B:
                                      return !(
                                        t.byteLength != e.byteLength ||
                                        !r(new $t(t), new $t(e))
                                      );
                                    case b:
                                    case S:
                                    case P:
                                      return No(+t, +e);
                                    case C:
                                      return (
                                        t.name == e.name &&
                                        t.message == e.message
                                      );
                                    case M:
                                    case I:
                                      return t == e + "";
                                    case w:
                                      var a = li;
                                    case E:
                                      var l = 1 & n;
                                      if (
                                        (a || (a = ci), t.size != e.size && !l)
                                      )
                                        return !1;
                                      var u = o.get(t);
                                      if (u) return u == e;
                                      (n |= 2), o.set(t, e);
                                      var h = ir(a(t), a(e), n, s, r, o);
                                      return o.delete(t), h;
                                    case D:
                                      if (Li) return Li.call(t) == Li.call(e);
                                  }
                                  return !1;
                                })(t, e, u, i, n, r, o)
                          );
                        if (!(1 & i)) {
                          var f = c && Ot.call(t, "__wrapped__"),
                            m = d && Ot.call(e, "__wrapped__");
                          if (f || m) {
                            var g = f ? t.value() : t,
                              v = m ? e.value() : e;
                            return o || (o = new Yi()), r(g, v, i, n, o);
                          }
                        }
                        if (!p) return !1;
                        return (
                          o || (o = new Yi()),
                          (function (t, e, i, n, r, o) {
                            var a = 1 & i,
                              l = sr(t),
                              u = l.length,
                              h = sr(e),
                              c = h.length;
                            if (u != c && !a) return !1;
                            var d = u;
                            for (; d--; ) {
                              var p = l[d];
                              if (!(a ? p in e : Ot.call(e, p))) return !1;
                            }
                            var f = o.get(t),
                              m = o.get(e);
                            if (f && m) return f == e && m == t;
                            var g = !0;
                            o.set(t, e), o.set(e, t);
                            var v = a;
                            for (; ++d < u; ) {
                              var y = t[(p = l[d])],
                                x = e[p];
                              if (n)
                                var b = a
                                  ? n(x, y, p, e, t, o)
                                  : n(y, x, p, t, e, o);
                              if (
                                !(b === s ? y === x || r(y, x, i, n, o) : b)
                              ) {
                                g = !1;
                                break;
                              }
                              v || (v = "constructor" == p);
                            }
                            if (g && !v) {
                              var S = t.constructor,
                                C = e.constructor;
                              S == C ||
                                !("constructor" in t) ||
                                !("constructor" in e) ||
                                ("function" == typeof S &&
                                  S instanceof S &&
                                  "function" == typeof C &&
                                  C instanceof C) ||
                                (g = !1);
                            }
                            return o.delete(t), o.delete(e), g;
                          })(t, e, i, n, r, o)
                        );
                      })(t, e, i, n, Rn, r))
                );
              }
              function Bn(t, e, i, n) {
                var r = i.length,
                  o = r,
                  a = !n;
                if (null == t) return !o;
                for (t = At(t); r--; ) {
                  var l = i[r];
                  if (a && l[2] ? l[1] !== t[l[0]] : !(l[0] in t)) return !1;
                }
                for (; ++r < o; ) {
                  var u = (l = i[r])[0],
                    h = t[u],
                    c = l[1];
                  if (a && l[2]) {
                    if (h === s && !(u in t)) return !1;
                  } else {
                    var d = new Yi();
                    if (n) var p = n(h, c, u, t, e, d);
                    if (!(p === s ? Rn(c, h, 3, n, d) : p)) return !1;
                  }
                }
                return !0;
              }
              function Fn(t) {
                return (
                  !(!ea(t) || ((e = t), Lt && Lt in e)) &&
                  (Qo(t) ? Gt : yt).test(Lr(t))
                );
                var e;
              }
              function On(t) {
                return "function" == typeof t
                  ? t
                  : null == t
                  ? sl
                  : "object" == typeof t
                  ? $o(t)
                    ? Gn(t[0], t[1])
                    : Nn(t)
                  : pl(t);
              }
              function zn(t) {
                if (!Tr(t)) return Xe(t);
                var e = [];
                for (var i in At(t))
                  Ot.call(t, i) && "constructor" != i && e.push(i);
                return e;
              }
              function Ln(t) {
                if (!ea(t))
                  return (function (t) {
                    var e = [];
                    if (null != t) for (var i in At(t)) e.push(i);
                    return e;
                  })(t);
                var e = Tr(t),
                  i = [];
                for (var n in t)
                  ("constructor" != n || (!e && Ot.call(t, n))) && i.push(n);
                return i;
              }
              function Hn(t, e) {
                return t < e;
              }
              function Un(t, e) {
                var i = -1,
                  s = Wo(t) ? n(t.length) : [];
                return (
                  pn(t, function (t, n, r) {
                    s[++i] = e(t, n, r);
                  }),
                  s
                );
              }
              function Nn(t) {
                var e = cr(t);
                return 1 == e.length && e[0][2]
                  ? Pr(e[0][0], e[0][1])
                  : function (i) {
                      return i === t || Bn(i, t, e);
                    };
              }
              function Gn(t, e) {
                return Sr(t) && wr(e)
                  ? Pr(zr(t), e)
                  : function (i) {
                      var n = Aa(i, t);
                      return n === s && n === e ? ka(i, t) : Rn(e, n, 3);
                    };
              }
              function Vn(t, e, i, n, r) {
                t !== e &&
                  xn(
                    e,
                    function (o, a) {
                      if ((r || (r = new Yi()), ea(o)))
                        !(function (t, e, i, n, r, o, a) {
                          var l = Mr(t, i),
                            u = Mr(e, i),
                            h = a.get(u);
                          if (h) return void tn(t, i, h);
                          var c = o ? o(l, u, i + "", t, e, a) : s,
                            d = c === s;
                          if (d) {
                            var p = $o(u),
                              f = !p && Yo(u),
                              m = !p && !f && ha(u);
                            (c = u),
                              p || f || m
                                ? $o(l)
                                  ? (c = l)
                                  : Xo(l)
                                  ? (c = Es(l))
                                  : f
                                  ? ((d = !1), (c = Ts(u, !0)))
                                  : m
                                  ? ((d = !1), (c = Ps(u, !0)))
                                  : (c = [])
                                : ra(u) || jo(u)
                                ? ((c = l),
                                  jo(l)
                                    ? (c = ya(l))
                                    : (ea(l) && !Qo(l)) || (c = vr(u)))
                                : (d = !1);
                          }
                          d && (a.set(u, c), r(c, u, n, o, a), a.delete(u));
                          tn(t, i, c);
                        })(t, e, a, i, Vn, n, r);
                      else {
                        var l = n ? n(Mr(t, a), o, a + "", t, e, r) : s;
                        l === s && (l = o), tn(t, a, l);
                      }
                    },
                    Ra
                  );
              }
              function jn(t, e) {
                var i = t.length;
                if (i) return xr((e += e < 0 ? i : 0), i) ? t[e] : s;
              }
              function $n(t, e, i) {
                e = e.length
                  ? Fe(e, function (t) {
                      return $o(t)
                        ? function (e) {
                            return Tn(e, 1 === t.length ? t[0] : t);
                          }
                        : t;
                    })
                  : [sl];
                var n = -1;
                e = Fe(e, Je(ur()));
                var s = Un(t, function (t, i, s) {
                  var r = Fe(e, function (e) {
                    return e(t);
                  });
                  return { criteria: r, index: ++n, value: t };
                });
                return (function (t, e) {
                  var i = t.length;
                  for (t.sort(e); i--; ) t[i] = t[i].value;
                  return t;
                })(s, function (t, e) {
                  return (function (t, e, i) {
                    var n = -1,
                      s = t.criteria,
                      r = e.criteria,
                      o = s.length,
                      a = i.length;
                    for (; ++n < o; ) {
                      var l = As(s[n], r[n]);
                      if (l) return n >= a ? l : l * ("desc" == i[n] ? -1 : 1);
                    }
                    return t.index - e.index;
                  })(t, e, i);
                });
              }
              function qn(t, e, i) {
                for (var n = -1, s = e.length, r = {}; ++n < s; ) {
                  var o = e[n],
                    a = Tn(t, o);
                  i(a, o) && ts(r, bs(o, t), a);
                }
                return r;
              }
              function Wn(t, e, i, n) {
                var s = n ? je : Ve,
                  r = -1,
                  o = e.length,
                  a = t;
                for (t === e && (e = Es(e)), i && (a = Fe(t, Je(i))); ++r < o; )
                  for (
                    var l = 0, u = e[r], h = i ? i(u) : u;
                    (l = s(a, h, l, n)) > -1;

                  )
                    a !== t && Kt.call(a, l, 1), Kt.call(t, l, 1);
                return t;
              }
              function Xn(t, e) {
                for (var i = t ? e.length : 0, n = i - 1; i--; ) {
                  var s = e[i];
                  if (i == n || s !== r) {
                    var r = s;
                    xr(s) ? Kt.call(t, s, 1) : ds(t, s);
                  }
                }
                return t;
              }
              function Yn(t, e) {
                return t + ge(Ci() * (e - t + 1));
              }
              function Kn(t, e) {
                var i = "";
                if (!t || e < 1 || e > f) return i;
                do {
                  e % 2 && (i += t), (e = ge(e / 2)) && (t += t);
                } while (e);
                return i;
              }
              function Zn(t, e) {
                return Dr(Ar(t, e, sl), t + "");
              }
              function Qn(t) {
                return Zi(Na(t));
              }
              function Jn(t, e) {
                var i = Na(t);
                return Fr(i, ln(e, 0, i.length));
              }
              function ts(t, e, i, n) {
                if (!ea(t)) return t;
                for (
                  var r = -1, o = (e = bs(e, t)).length, a = o - 1, l = t;
                  null != l && ++r < o;

                ) {
                  var u = zr(e[r]),
                    h = i;
                  if (
                    "__proto__" === u ||
                    "constructor" === u ||
                    "prototype" === u
                  )
                    return t;
                  if (r != a) {
                    var c = l[u];
                    (h = n ? n(c, u, l) : s) === s &&
                      (h = ea(c) ? c : xr(e[r + 1]) ? [] : {});
                  }
                  en(l, u, h), (l = l[u]);
                }
                return t;
              }
              var es = Ei
                  ? function (t, e) {
                      return Ei.set(t, e), t;
                    }
                  : sl,
                is = ie
                  ? function (t, e) {
                      return ie(t, "toString", {
                        configurable: !0,
                        enumerable: !1,
                        value: el(e),
                        writable: !0,
                      });
                    }
                  : sl;
              function ns(t) {
                return Fr(Na(t));
              }
              function ss(t, e, i) {
                var s = -1,
                  r = t.length;
                e < 0 && (e = -e > r ? 0 : r + e),
                  (i = i > r ? r : i) < 0 && (i += r),
                  (r = e > i ? 0 : (i - e) >>> 0),
                  (e >>>= 0);
                for (var o = n(r); ++s < r; ) o[s] = t[s + e];
                return o;
              }
              function rs(t, e) {
                var i;
                return (
                  pn(t, function (t, n, s) {
                    return !(i = e(t, n, s));
                  }),
                  !!i
                );
              }
              function os(t, e, i) {
                var n = 0,
                  s = null == t ? n : t.length;
                if ("number" == typeof e && e == e && s <= 2147483647) {
                  for (; n < s; ) {
                    var r = (n + s) >>> 1,
                      o = t[r];
                    null !== o && !ua(o) && (i ? o <= e : o < e)
                      ? (n = r + 1)
                      : (s = r);
                  }
                  return s;
                }
                return as(t, e, sl, i);
              }
              function as(t, e, i, n) {
                var r = 0,
                  o = null == t ? 0 : t.length;
                if (0 === o) return 0;
                for (
                  var a = (e = i(e)) != e,
                    l = null === e,
                    u = ua(e),
                    h = e === s;
                  r < o;

                ) {
                  var c = ge((r + o) / 2),
                    d = i(t[c]),
                    p = d !== s,
                    f = null === d,
                    m = d == d,
                    g = ua(d);
                  if (a) var v = n || m;
                  else
                    v = h
                      ? m && (n || p)
                      : l
                      ? m && p && (n || !f)
                      : u
                      ? m && p && !f && (n || !g)
                      : !f && !g && (n ? d <= e : d < e);
                  v ? (r = c + 1) : (o = c);
                }
                return xi(o, 4294967294);
              }
              function ls(t, e) {
                for (var i = -1, n = t.length, s = 0, r = []; ++i < n; ) {
                  var o = t[i],
                    a = e ? e(o) : o;
                  if (!i || !No(a, l)) {
                    var l = a;
                    r[s++] = 0 === o ? 0 : o;
                  }
                }
                return r;
              }
              function us(t) {
                return "number" == typeof t ? t : ua(t) ? m : +t;
              }
              function hs(t) {
                if ("string" == typeof t) return t;
                if ($o(t)) return Fe(t, hs) + "";
                if (ua(t)) return Hi ? Hi.call(t) : "";
                var e = t + "";
                return "0" == e && 1 / t == -1 / 0 ? "-0" : e;
              }
              function cs(t, e, i) {
                var n = -1,
                  s = Re,
                  r = t.length,
                  o = !0,
                  a = [],
                  l = a;
                if (i) (o = !1), (s = Be);
                else if (r >= 200) {
                  var u = e ? null : Ks(t);
                  if (u) return ci(u);
                  (o = !1), (s = ei), (l = new Xi());
                } else l = e ? [] : a;
                t: for (; ++n < r; ) {
                  var h = t[n],
                    c = e ? e(h) : h;
                  if (((h = i || 0 !== h ? h : 0), o && c == c)) {
                    for (var d = l.length; d--; ) if (l[d] === c) continue t;
                    e && l.push(c), a.push(h);
                  } else s(l, c, i) || (l !== a && l.push(c), a.push(h));
                }
                return a;
              }
              function ds(t, e) {
                return (
                  null == (t = kr(t, (e = bs(e, t)))) || delete t[zr(Kr(e))]
                );
              }
              function ps(t, e, i, n) {
                return ts(t, e, i(Tn(t, e)), n);
              }
              function fs(t, e, i, n) {
                for (
                  var s = t.length, r = n ? s : -1;
                  (n ? r-- : ++r < s) && e(t[r], r, t);

                );
                return i
                  ? ss(t, n ? 0 : r, n ? r + 1 : s)
                  : ss(t, n ? r + 1 : 0, n ? s : r);
              }
              function ms(t, e) {
                var i = t;
                return (
                  i instanceof ji && (i = i.value()),
                  ze(
                    e,
                    function (t, e) {
                      return e.func.apply(e.thisArg, Oe([t], e.args));
                    },
                    i
                  )
                );
              }
              function gs(t, e, i) {
                var s = t.length;
                if (s < 2) return s ? cs(t[0]) : [];
                for (var r = -1, o = n(s); ++r < s; )
                  for (var a = t[r], l = -1; ++l < s; )
                    l != r && (o[r] = dn(o[r] || a, t[l], e, i));
                return cs(yn(o, 1), e, i);
              }
              function vs(t, e, i) {
                for (
                  var n = -1, r = t.length, o = e.length, a = {};
                  ++n < r;

                ) {
                  var l = n < o ? e[n] : s;
                  i(a, t[n], l);
                }
                return a;
              }
              function ys(t) {
                return Xo(t) ? t : [];
              }
              function xs(t) {
                return "function" == typeof t ? t : sl;
              }
              function bs(t, e) {
                return $o(t) ? t : Sr(t, e) ? [t] : Or(xa(t));
              }
              var Ss = Zn;
              function Cs(t, e, i) {
                var n = t.length;
                return (i = i === s ? n : i), !e && i >= n ? t : ss(t, e, i);
              }
              var _s =
                se ||
                function (t) {
                  return me.clearTimeout(t);
                };
              function Ts(t, e) {
                if (e) return t.slice();
                var i = t.length,
                  n = qt ? qt(i) : new t.constructor(i);
                return t.copy(n), n;
              }
              function ws(t) {
                var e = new t.constructor(t.byteLength);
                return new $t(e).set(new $t(t)), e;
              }
              function Ps(t, e) {
                var i = e ? ws(t.buffer) : t.buffer;
                return new t.constructor(i, t.byteOffset, t.length);
              }
              function As(t, e) {
                if (t !== e) {
                  var i = t !== s,
                    n = null === t,
                    r = t == t,
                    o = ua(t),
                    a = e !== s,
                    l = null === e,
                    u = e == e,
                    h = ua(e);
                  if (
                    (!l && !h && !o && t > e) ||
                    (o && a && u && !l && !h) ||
                    (n && a && u) ||
                    (!i && u) ||
                    !r
                  )
                    return 1;
                  if (
                    (!n && !o && !h && t < e) ||
                    (h && i && r && !n && !o) ||
                    (l && i && r) ||
                    (!a && r) ||
                    !u
                  )
                    return -1;
                }
                return 0;
              }
              function ks(t, e, i, s) {
                for (
                  var r = -1,
                    o = t.length,
                    a = i.length,
                    l = -1,
                    u = e.length,
                    h = yi(o - a, 0),
                    c = n(u + h),
                    d = !s;
                  ++l < u;

                )
                  c[l] = e[l];
                for (; ++r < a; ) (d || r < o) && (c[i[r]] = t[r]);
                for (; h--; ) c[l++] = t[r++];
                return c;
              }
              function Ms(t, e, i, s) {
                for (
                  var r = -1,
                    o = t.length,
                    a = -1,
                    l = i.length,
                    u = -1,
                    h = e.length,
                    c = yi(o - l, 0),
                    d = n(c + h),
                    p = !s;
                  ++r < c;

                )
                  d[r] = t[r];
                for (var f = r; ++u < h; ) d[f + u] = e[u];
                for (; ++a < l; ) (p || r < o) && (d[f + i[a]] = t[r++]);
                return d;
              }
              function Es(t, e) {
                var i = -1,
                  s = t.length;
                for (e || (e = n(s)); ++i < s; ) e[i] = t[i];
                return e;
              }
              function Is(t, e, i, n) {
                var r = !i;
                i || (i = {});
                for (var o = -1, a = e.length; ++o < a; ) {
                  var l = e[o],
                    u = n ? n(i[l], t[l], l, i, t) : s;
                  u === s && (u = t[l]), r ? on(i, l, u) : en(i, l, u);
                }
                return i;
              }
              function Ds(t, e) {
                return function (i, n) {
                  var s = $o(i) ? ke : sn,
                    r = e ? e() : {};
                  return s(i, t, ur(n, 2), r);
                };
              }
              function Rs(t) {
                return Zn(function (e, i) {
                  var n = -1,
                    r = i.length,
                    o = r > 1 ? i[r - 1] : s,
                    a = r > 2 ? i[2] : s;
                  for (
                    o = t.length > 3 && "function" == typeof o ? (r--, o) : s,
                      a && br(i[0], i[1], a) && ((o = r < 3 ? s : o), (r = 1)),
                      e = At(e);
                    ++n < r;

                  ) {
                    var l = i[n];
                    l && t(e, l, n, o);
                  }
                  return e;
                });
              }
              function Bs(t, e) {
                return function (i, n) {
                  if (null == i) return i;
                  if (!Wo(i)) return t(i, n);
                  for (
                    var s = i.length, r = e ? s : -1, o = At(i);
                    (e ? r-- : ++r < s) && !1 !== n(o[r], r, o);

                  );
                  return i;
                };
              }
              function Fs(t) {
                return function (e, i, n) {
                  for (var s = -1, r = At(e), o = n(e), a = o.length; a--; ) {
                    var l = o[t ? a : ++s];
                    if (!1 === i(r[l], l, r)) break;
                  }
                  return e;
                };
              }
              function Os(t) {
                return function (e) {
                  var i = ai((e = xa(e))) ? fi(e) : s,
                    n = i ? i[0] : e.charAt(0),
                    r = i ? Cs(i, 1).join("") : e.slice(1);
                  return n[t]() + r;
                };
              }
              function zs(t) {
                return function (e) {
                  return ze(Qa(ja(e).replace(te, "")), t, "");
                };
              }
              function Ls(t) {
                return function () {
                  var e = arguments;
                  switch (e.length) {
                    case 0:
                      return new t();
                    case 1:
                      return new t(e[0]);
                    case 2:
                      return new t(e[0], e[1]);
                    case 3:
                      return new t(e[0], e[1], e[2]);
                    case 4:
                      return new t(e[0], e[1], e[2], e[3]);
                    case 5:
                      return new t(e[0], e[1], e[2], e[3], e[4]);
                    case 6:
                      return new t(e[0], e[1], e[2], e[3], e[4], e[5]);
                    case 7:
                      return new t(e[0], e[1], e[2], e[3], e[4], e[5], e[6]);
                  }
                  var i = Ni(t.prototype),
                    n = t.apply(i, e);
                  return ea(n) ? n : i;
                };
              }
              function Hs(t) {
                return function (e, i, n) {
                  var r = At(e);
                  if (!Wo(e)) {
                    var o = ur(i, 3);
                    (e = Da(e)),
                      (i = function (t) {
                        return o(r[t], t, r);
                      });
                  }
                  var a = t(e, i, n);
                  return a > -1 ? r[o ? e[a] : a] : s;
                };
              }
              function Us(t) {
                return nr(function (e) {
                  var i = e.length,
                    n = i,
                    o = Vi.prototype.thru;
                  for (t && e.reverse(); n--; ) {
                    var a = e[n];
                    if ("function" != typeof a) throw new Et(r);
                    if (o && !l && "wrapper" == ar(a)) var l = new Vi([], !0);
                  }
                  for (n = l ? n : i; ++n < i; ) {
                    var u = ar((a = e[n])),
                      h = "wrapper" == u ? or(a) : s;
                    l =
                      h && Cr(h[0]) && 424 == h[1] && !h[4].length && 1 == h[9]
                        ? l[ar(h[0])].apply(l, h[3])
                        : 1 == a.length && Cr(a)
                        ? l[u]()
                        : l.thru(a);
                  }
                  return function () {
                    var t = arguments,
                      n = t[0];
                    if (l && 1 == t.length && $o(n)) return l.plant(n).value();
                    for (var s = 0, r = i ? e[s].apply(this, t) : n; ++s < i; )
                      r = e[s].call(this, r);
                    return r;
                  };
                });
              }
              function Ns(t, e, i, r, o, a, l, u, h, d) {
                var p = e & c,
                  f = 1 & e,
                  m = 2 & e,
                  g = 24 & e,
                  v = 512 & e,
                  y = m ? s : Ls(t);
                return function c() {
                  for (var x = arguments.length, b = n(x), S = x; S--; )
                    b[S] = arguments[S];
                  if (g)
                    var C = lr(c),
                      _ = (function (t, e) {
                        for (var i = t.length, n = 0; i--; ) t[i] === e && ++n;
                        return n;
                      })(b, C);
                  if (
                    (r && (b = ks(b, r, o, g)),
                    a && (b = Ms(b, a, l, g)),
                    (x -= _),
                    g && x < d)
                  ) {
                    var T = hi(b, C);
                    return Xs(t, e, Ns, c.placeholder, i, b, T, u, h, d - x);
                  }
                  var w = f ? i : this,
                    P = m ? w[t] : t;
                  return (
                    (x = b.length),
                    u
                      ? (b = (function (t, e) {
                          var i = t.length,
                            n = xi(e.length, i),
                            r = Es(t);
                          for (; n--; ) {
                            var o = e[n];
                            t[n] = xr(o, i) ? r[o] : s;
                          }
                          return t;
                        })(b, u))
                      : v && x > 1 && b.reverse(),
                    p && h < x && (b.length = h),
                    this &&
                      this !== me &&
                      this instanceof c &&
                      (P = y || Ls(P)),
                    P.apply(w, b)
                  );
                };
              }
              function Gs(t, e) {
                return function (i, n) {
                  return (function (t, e, i, n) {
                    return (
                      Sn(t, function (t, s, r) {
                        e(n, i(t), s, r);
                      }),
                      n
                    );
                  })(i, t, e(n), {});
                };
              }
              function Vs(t, e) {
                return function (i, n) {
                  var r;
                  if (i === s && n === s) return e;
                  if ((i !== s && (r = i), n !== s)) {
                    if (r === s) return n;
                    "string" == typeof i || "string" == typeof n
                      ? ((i = hs(i)), (n = hs(n)))
                      : ((i = us(i)), (n = us(n))),
                      (r = t(i, n));
                  }
                  return r;
                };
              }
              function js(t) {
                return nr(function (e) {
                  return (
                    (e = Fe(e, Je(ur()))),
                    Zn(function (i) {
                      var n = this;
                      return t(e, function (t) {
                        return Ae(t, n, i);
                      });
                    })
                  );
                });
              }
              function $s(t, e) {
                var i = (e = e === s ? " " : hs(e)).length;
                if (i < 2) return i ? Kn(e, t) : e;
                var n = Kn(e, fe(t / pi(e)));
                return ai(e) ? Cs(fi(n), 0, t).join("") : n.slice(0, t);
              }
              function qs(t) {
                return function (e, i, r) {
                  return (
                    r && "number" != typeof r && br(e, i, r) && (i = r = s),
                    (e = fa(e)),
                    i === s ? ((i = e), (e = 0)) : (i = fa(i)),
                    (function (t, e, i, s) {
                      for (
                        var r = -1, o = yi(fe((e - t) / (i || 1)), 0), a = n(o);
                        o--;

                      )
                        (a[s ? o : ++r] = t), (t += i);
                      return a;
                    })(e, i, (r = r === s ? (e < i ? 1 : -1) : fa(r)), t)
                  );
                };
              }
              function Ws(t) {
                return function (e, i) {
                  return (
                    ("string" == typeof e && "string" == typeof i) ||
                      ((e = va(e)), (i = va(i))),
                    t(e, i)
                  );
                };
              }
              function Xs(t, e, i, n, r, o, a, l, c, d) {
                var p = 8 & e;
                (e |= p ? u : h), 4 & (e &= ~(p ? h : u)) || (e &= -4);
                var f = [
                    t,
                    e,
                    r,
                    p ? o : s,
                    p ? a : s,
                    p ? s : o,
                    p ? s : a,
                    l,
                    c,
                    d,
                  ],
                  m = i.apply(s, f);
                return Cr(t) && Er(m, f), (m.placeholder = n), Rr(m, t, e);
              }
              function Ys(t) {
                var e = Pt[t];
                return function (t, i) {
                  if (
                    ((t = va(t)), (i = null == i ? 0 : xi(ma(i), 292)) && be(t))
                  ) {
                    var n = (xa(t) + "e").split("e");
                    return +(
                      (n = (xa(e(n[0] + "e" + (+n[1] + i))) + "e").split(
                        "e"
                      ))[0] +
                      "e" +
                      (+n[1] - i)
                    );
                  }
                  return e(t);
                };
              }
              var Ks =
                Ai && 1 / ci(new Ai([, -0]))[1] == p
                  ? function (t) {
                      return new Ai(t);
                    }
                  : ul;
              function Zs(t) {
                return function (e) {
                  var i = mr(e);
                  return i == w
                    ? li(e)
                    : i == E
                    ? di(e)
                    : (function (t, e) {
                        return Fe(e, function (e) {
                          return [e, t[e]];
                        });
                      })(e, t(e));
                };
              }
              function Qs(t, e, i, o, p, f, m, g) {
                var v = 2 & e;
                if (!v && "function" != typeof t) throw new Et(r);
                var y = o ? o.length : 0;
                if (
                  (y || ((e &= -97), (o = p = s)),
                  (m = m === s ? m : yi(ma(m), 0)),
                  (g = g === s ? g : ma(g)),
                  (y -= p ? p.length : 0),
                  e & h)
                ) {
                  var x = o,
                    b = p;
                  o = p = s;
                }
                var S = v ? s : or(t),
                  C = [t, e, i, o, p, x, b, f, m, g];
                if (
                  (S &&
                    (function (t, e) {
                      var i = t[1],
                        n = e[1],
                        s = i | n,
                        r = s < 131,
                        o =
                          (n == c && 8 == i) ||
                          (n == c && i == d && t[7].length <= e[8]) ||
                          (384 == n && e[7].length <= e[8] && 8 == i);
                      if (!r && !o) return t;
                      1 & n && ((t[2] = e[2]), (s |= 1 & i ? 0 : 4));
                      var l = e[3];
                      if (l) {
                        var u = t[3];
                        (t[3] = u ? ks(u, l, e[4]) : l),
                          (t[4] = u ? hi(t[3], a) : e[4]);
                      }
                      (l = e[5]) &&
                        ((u = t[5]),
                        (t[5] = u ? Ms(u, l, e[6]) : l),
                        (t[6] = u ? hi(t[5], a) : e[6]));
                      (l = e[7]) && (t[7] = l);
                      n & c && (t[8] = null == t[8] ? e[8] : xi(t[8], e[8]));
                      null == t[9] && (t[9] = e[9]);
                      (t[0] = e[0]), (t[1] = s);
                    })(C, S),
                  (t = C[0]),
                  (e = C[1]),
                  (i = C[2]),
                  (o = C[3]),
                  (p = C[4]),
                  !(g = C[9] =
                    C[9] === s ? (v ? 0 : t.length) : yi(C[9] - y, 0)) &&
                    24 & e &&
                    (e &= -25),
                  e && 1 != e)
                )
                  _ =
                    8 == e || e == l
                      ? (function (t, e, i) {
                          var r = Ls(t);
                          return function o() {
                            for (
                              var a = arguments.length,
                                l = n(a),
                                u = a,
                                h = lr(o);
                              u--;

                            )
                              l[u] = arguments[u];
                            var c =
                              a < 3 && l[0] !== h && l[a - 1] !== h
                                ? []
                                : hi(l, h);
                            return (a -= c.length) < i
                              ? Xs(
                                  t,
                                  e,
                                  Ns,
                                  o.placeholder,
                                  s,
                                  l,
                                  c,
                                  s,
                                  s,
                                  i - a
                                )
                              : Ae(
                                  this && this !== me && this instanceof o
                                    ? r
                                    : t,
                                  this,
                                  l
                                );
                          };
                        })(t, e, g)
                      : (e != u && 33 != e) || p.length
                      ? Ns.apply(s, C)
                      : (function (t, e, i, s) {
                          var r = 1 & e,
                            o = Ls(t);
                          return function e() {
                            for (
                              var a = -1,
                                l = arguments.length,
                                u = -1,
                                h = s.length,
                                c = n(h + l),
                                d =
                                  this && this !== me && this instanceof e
                                    ? o
                                    : t;
                              ++u < h;

                            )
                              c[u] = s[u];
                            for (; l--; ) c[u++] = arguments[++a];
                            return Ae(d, r ? i : this, c);
                          };
                        })(t, e, i, o);
                else
                  var _ = (function (t, e, i) {
                    var n = 1 & e,
                      s = Ls(t);
                    return function e() {
                      return (
                        this && this !== me && this instanceof e ? s : t
                      ).apply(n ? i : this, arguments);
                    };
                  })(t, e, i);
                return Rr((S ? es : Er)(_, C), t, e);
              }
              function Js(t, e, i, n) {
                return t === s || (No(t, Rt[i]) && !Ot.call(n, i)) ? e : t;
              }
              function tr(t, e, i, n, r, o) {
                return (
                  ea(t) &&
                    ea(e) &&
                    (o.set(e, t), Vn(t, e, s, tr, o), o.delete(e)),
                  t
                );
              }
              function er(t) {
                return ra(t) ? s : t;
              }
              function ir(t, e, i, n, r, o) {
                var a = 1 & i,
                  l = t.length,
                  u = e.length;
                if (l != u && !(a && u > l)) return !1;
                var h = o.get(t),
                  c = o.get(e);
                if (h && c) return h == e && c == t;
                var d = -1,
                  p = !0,
                  f = 2 & i ? new Xi() : s;
                for (o.set(t, e), o.set(e, t); ++d < l; ) {
                  var m = t[d],
                    g = e[d];
                  if (n) var v = a ? n(g, m, d, e, t, o) : n(m, g, d, t, e, o);
                  if (v !== s) {
                    if (v) continue;
                    p = !1;
                    break;
                  }
                  if (f) {
                    if (
                      !He(e, function (t, e) {
                        if (!ei(f, e) && (m === t || r(m, t, i, n, o)))
                          return f.push(e);
                      })
                    ) {
                      p = !1;
                      break;
                    }
                  } else if (m !== g && !r(m, g, i, n, o)) {
                    p = !1;
                    break;
                  }
                }
                return o.delete(t), o.delete(e), p;
              }
              function nr(t) {
                return Dr(Ar(t, s, $r), t + "");
              }
              function sr(t) {
                return wn(t, Da, pr);
              }
              function rr(t) {
                return wn(t, Ra, fr);
              }
              var or = Ei
                ? function (t) {
                    return Ei.get(t);
                  }
                : ul;
              function ar(t) {
                for (
                  var e = t.name + "",
                    i = Ii[e],
                    n = Ot.call(Ii, e) ? i.length : 0;
                  n--;

                ) {
                  var s = i[n],
                    r = s.func;
                  if (null == r || r == t) return s.name;
                }
                return e;
              }
              function lr(t) {
                return (Ot.call(Ui, "placeholder") ? Ui : t).placeholder;
              }
              function ur() {
                var t = Ui.iteratee || rl;
                return (
                  (t = t === rl ? On : t),
                  arguments.length ? t(arguments[0], arguments[1]) : t
                );
              }
              function hr(t, e) {
                var i,
                  n,
                  s = t.__data__;
                return (
                  "string" == (n = typeof (i = e)) ||
                  "number" == n ||
                  "symbol" == n ||
                  "boolean" == n
                    ? "__proto__" !== i
                    : null === i
                )
                  ? s["string" == typeof e ? "string" : "hash"]
                  : s.map;
              }
              function cr(t) {
                for (var e = Da(t), i = e.length; i--; ) {
                  var n = e[i],
                    s = t[n];
                  e[i] = [n, s, wr(s)];
                }
                return e;
              }
              function dr(t, e) {
                var i = (function (t, e) {
                  return null == t ? s : t[e];
                })(t, e);
                return Fn(i) ? i : s;
              }
              var pr = ve
                  ? function (t) {
                      return null == t
                        ? []
                        : ((t = At(t)),
                          De(ve(t), function (e) {
                            return Yt.call(t, e);
                          }));
                    }
                  : gl,
                fr = ve
                  ? function (t) {
                      for (var e = []; t; ) Oe(e, pr(t)), (t = Wt(t));
                      return e;
                    }
                  : gl,
                mr = Pn;
              function gr(t, e, i) {
                for (var n = -1, s = (e = bs(e, t)).length, r = !1; ++n < s; ) {
                  var o = zr(e[n]);
                  if (!(r = null != t && i(t, o))) break;
                  t = t[o];
                }
                return r || ++n != s
                  ? r
                  : !!(s = null == t ? 0 : t.length) &&
                      ta(s) &&
                      xr(o, s) &&
                      ($o(t) || jo(t));
              }
              function vr(t) {
                return "function" != typeof t.constructor || Tr(t)
                  ? {}
                  : Ni(Wt(t));
              }
              function yr(t) {
                return $o(t) || jo(t) || !!(Zt && t && t[Zt]);
              }
              function xr(t, e) {
                var i = typeof t;
                return (
                  !!(e = null == e ? f : e) &&
                  ("number" == i || ("symbol" != i && bt.test(t))) &&
                  t > -1 &&
                  t % 1 == 0 &&
                  t < e
                );
              }
              function br(t, e, i) {
                if (!ea(i)) return !1;
                var n = typeof e;
                return (
                  !!("number" == n
                    ? Wo(i) && xr(e, i.length)
                    : "string" == n && e in i) && No(i[e], t)
                );
              }
              function Sr(t, e) {
                if ($o(t)) return !1;
                var i = typeof t;
                return (
                  !(
                    "number" != i &&
                    "symbol" != i &&
                    "boolean" != i &&
                    null != t &&
                    !ua(t)
                  ) ||
                  it.test(t) ||
                  !et.test(t) ||
                  (null != e && t in At(e))
                );
              }
              function Cr(t) {
                var e = ar(t),
                  i = Ui[e];
                if ("function" != typeof i || !(e in ji.prototype)) return !1;
                if (t === i) return !0;
                var n = or(i);
                return !!n && t === n[0];
              }
              ((Ti && mr(new Ti(new ArrayBuffer(1))) != F) ||
                (wi && mr(new wi()) != w) ||
                (Pi && mr(Pi.resolve()) != k) ||
                (Ai && mr(new Ai()) != E) ||
                (ki && mr(new ki()) != R)) &&
                (mr = function (t) {
                  var e = Pn(t),
                    i = e == A ? t.constructor : s,
                    n = i ? Lr(i) : "";
                  if (n)
                    switch (n) {
                      case Di:
                        return F;
                      case Ri:
                        return w;
                      case Bi:
                        return k;
                      case Fi:
                        return E;
                      case Oi:
                        return R;
                    }
                  return e;
                });
              var _r = Bt ? Qo : vl;
              function Tr(t) {
                var e = t && t.constructor;
                return t === (("function" == typeof e && e.prototype) || Rt);
              }
              function wr(t) {
                return t == t && !ea(t);
              }
              function Pr(t, e) {
                return function (i) {
                  return null != i && i[t] === e && (e !== s || t in At(i));
                };
              }
              function Ar(t, e, i) {
                return (
                  (e = yi(e === s ? t.length - 1 : e, 0)),
                  function () {
                    for (
                      var s = arguments,
                        r = -1,
                        o = yi(s.length - e, 0),
                        a = n(o);
                      ++r < o;

                    )
                      a[r] = s[e + r];
                    r = -1;
                    for (var l = n(e + 1); ++r < e; ) l[r] = s[r];
                    return (l[e] = i(a)), Ae(t, this, l);
                  }
                );
              }
              function kr(t, e) {
                return e.length < 2 ? t : Tn(t, ss(e, 0, -1));
              }
              function Mr(t, e) {
                if (
                  ("constructor" !== e || "function" != typeof t[e]) &&
                  "__proto__" != e
                )
                  return t[e];
              }
              var Er = Br(es),
                Ir =
                  pe ||
                  function (t, e) {
                    return me.setTimeout(t, e);
                  },
                Dr = Br(is);
              function Rr(t, e, i) {
                var n = e + "";
                return Dr(
                  t,
                  (function (t, e) {
                    var i = e.length;
                    if (!i) return t;
                    var n = i - 1;
                    return (
                      (e[n] = (i > 1 ? "& " : "") + e[n]),
                      (e = e.join(i > 2 ? ", " : " ")),
                      t.replace(lt, "{\n/* [wrapped with " + e + "] */\n")
                    );
                  })(
                    n,
                    (function (t, e) {
                      return (
                        Me(v, function (i) {
                          var n = "_." + i[0];
                          e & i[1] && !Re(t, n) && t.push(n);
                        }),
                        t.sort()
                      );
                    })(
                      (function (t) {
                        var e = t.match(ut);
                        return e ? e[1].split(ht) : [];
                      })(n),
                      i
                    )
                  )
                );
              }
              function Br(t) {
                var e = 0,
                  i = 0;
                return function () {
                  var n = bi(),
                    r = 16 - (n - i);
                  if (((i = n), r > 0)) {
                    if (++e >= 800) return arguments[0];
                  } else e = 0;
                  return t.apply(s, arguments);
                };
              }
              function Fr(t, e) {
                var i = -1,
                  n = t.length,
                  r = n - 1;
                for (e = e === s ? n : e; ++i < e; ) {
                  var o = Yn(i, r),
                    a = t[o];
                  (t[o] = t[i]), (t[i] = a);
                }
                return (t.length = e), t;
              }
              var Or = (function (t) {
                var e = Fo(t, function (t) {
                    return 500 === i.size && i.clear(), t;
                  }),
                  i = e.cache;
                return e;
              })(function (t) {
                var e = [];
                return (
                  46 === t.charCodeAt(0) && e.push(""),
                  t.replace(nt, function (t, i, n, s) {
                    e.push(n ? s.replace(pt, "$1") : i || t);
                  }),
                  e
                );
              });
              function zr(t) {
                if ("string" == typeof t || ua(t)) return t;
                var e = t + "";
                return "0" == e && 1 / t == -1 / 0 ? "-0" : e;
              }
              function Lr(t) {
                if (null != t) {
                  try {
                    return Ft.call(t);
                  } catch (t) {}
                  try {
                    return t + "";
                  } catch (t) {}
                }
                return "";
              }
              function Hr(t) {
                if (t instanceof ji) return t.clone();
                var e = new Vi(t.__wrapped__, t.__chain__);
                return (
                  (e.__actions__ = Es(t.__actions__)),
                  (e.__index__ = t.__index__),
                  (e.__values__ = t.__values__),
                  e
                );
              }
              var Ur = Zn(function (t, e) {
                  return Xo(t) ? dn(t, yn(e, 1, Xo, !0)) : [];
                }),
                Nr = Zn(function (t, e) {
                  var i = Kr(e);
                  return (
                    Xo(i) && (i = s),
                    Xo(t) ? dn(t, yn(e, 1, Xo, !0), ur(i, 2)) : []
                  );
                }),
                Gr = Zn(function (t, e) {
                  var i = Kr(e);
                  return (
                    Xo(i) && (i = s), Xo(t) ? dn(t, yn(e, 1, Xo, !0), s, i) : []
                  );
                });
              function Vr(t, e, i) {
                var n = null == t ? 0 : t.length;
                if (!n) return -1;
                var s = null == i ? 0 : ma(i);
                return s < 0 && (s = yi(n + s, 0)), Ge(t, ur(e, 3), s);
              }
              function jr(t, e, i) {
                var n = null == t ? 0 : t.length;
                if (!n) return -1;
                var r = n - 1;
                return (
                  i !== s &&
                    ((r = ma(i)), (r = i < 0 ? yi(n + r, 0) : xi(r, n - 1))),
                  Ge(t, ur(e, 3), r, !0)
                );
              }
              function $r(t) {
                return (null == t ? 0 : t.length) ? yn(t, 1) : [];
              }
              function qr(t) {
                return t && t.length ? t[0] : s;
              }
              var Wr = Zn(function (t) {
                  var e = Fe(t, ys);
                  return e.length && e[0] === t[0] ? En(e) : [];
                }),
                Xr = Zn(function (t) {
                  var e = Kr(t),
                    i = Fe(t, ys);
                  return (
                    e === Kr(i) ? (e = s) : i.pop(),
                    i.length && i[0] === t[0] ? En(i, ur(e, 2)) : []
                  );
                }),
                Yr = Zn(function (t) {
                  var e = Kr(t),
                    i = Fe(t, ys);
                  return (
                    (e = "function" == typeof e ? e : s) && i.pop(),
                    i.length && i[0] === t[0] ? En(i, s, e) : []
                  );
                });
              function Kr(t) {
                var e = null == t ? 0 : t.length;
                return e ? t[e - 1] : s;
              }
              var Zr = Zn(Qr);
              function Qr(t, e) {
                return t && t.length && e && e.length ? Wn(t, e) : t;
              }
              var Jr = nr(function (t, e) {
                var i = null == t ? 0 : t.length,
                  n = an(t, e);
                return (
                  Xn(
                    t,
                    Fe(e, function (t) {
                      return xr(t, i) ? +t : t;
                    }).sort(As)
                  ),
                  n
                );
              });
              function to(t) {
                return null == t ? t : _i.call(t);
              }
              var eo = Zn(function (t) {
                  return cs(yn(t, 1, Xo, !0));
                }),
                io = Zn(function (t) {
                  var e = Kr(t);
                  return Xo(e) && (e = s), cs(yn(t, 1, Xo, !0), ur(e, 2));
                }),
                no = Zn(function (t) {
                  var e = Kr(t);
                  return (
                    (e = "function" == typeof e ? e : s),
                    cs(yn(t, 1, Xo, !0), s, e)
                  );
                });
              function so(t) {
                if (!t || !t.length) return [];
                var e = 0;
                return (
                  (t = De(t, function (t) {
                    if (Xo(t)) return (e = yi(t.length, e)), !0;
                  })),
                  Ze(e, function (e) {
                    return Fe(t, We(e));
                  })
                );
              }
              function ro(t, e) {
                if (!t || !t.length) return [];
                var i = so(t);
                return null == e
                  ? i
                  : Fe(i, function (t) {
                      return Ae(e, s, t);
                    });
              }
              var oo = Zn(function (t, e) {
                  return Xo(t) ? dn(t, e) : [];
                }),
                ao = Zn(function (t) {
                  return gs(De(t, Xo));
                }),
                lo = Zn(function (t) {
                  var e = Kr(t);
                  return Xo(e) && (e = s), gs(De(t, Xo), ur(e, 2));
                }),
                uo = Zn(function (t) {
                  var e = Kr(t);
                  return (
                    (e = "function" == typeof e ? e : s), gs(De(t, Xo), s, e)
                  );
                }),
                ho = Zn(so);
              var co = Zn(function (t) {
                var e = t.length,
                  i = e > 1 ? t[e - 1] : s;
                return (
                  (i = "function" == typeof i ? (t.pop(), i) : s), ro(t, i)
                );
              });
              function po(t) {
                var e = Ui(t);
                return (e.__chain__ = !0), e;
              }
              function fo(t, e) {
                return e(t);
              }
              var mo = nr(function (t) {
                var e = t.length,
                  i = e ? t[0] : 0,
                  n = this.__wrapped__,
                  r = function (e) {
                    return an(e, t);
                  };
                return !(e > 1 || this.__actions__.length) &&
                  n instanceof ji &&
                  xr(i)
                  ? ((n = n.slice(i, +i + (e ? 1 : 0))).__actions__.push({
                      func: fo,
                      args: [r],
                      thisArg: s,
                    }),
                    new Vi(n, this.__chain__).thru(function (t) {
                      return e && !t.length && t.push(s), t;
                    }))
                  : this.thru(r);
              });
              var go = Ds(function (t, e, i) {
                Ot.call(t, i) ? ++t[i] : on(t, i, 1);
              });
              var vo = Hs(Vr),
                yo = Hs(jr);
              function xo(t, e) {
                return ($o(t) ? Me : pn)(t, ur(e, 3));
              }
              function bo(t, e) {
                return ($o(t) ? Ee : fn)(t, ur(e, 3));
              }
              var So = Ds(function (t, e, i) {
                Ot.call(t, i) ? t[i].push(e) : on(t, i, [e]);
              });
              var Co = Zn(function (t, e, i) {
                  var s = -1,
                    r = "function" == typeof e,
                    o = Wo(t) ? n(t.length) : [];
                  return (
                    pn(t, function (t) {
                      o[++s] = r ? Ae(e, t, i) : In(t, e, i);
                    }),
                    o
                  );
                }),
                _o = Ds(function (t, e, i) {
                  on(t, i, e);
                });
              function To(t, e) {
                return ($o(t) ? Fe : Un)(t, ur(e, 3));
              }
              var wo = Ds(
                function (t, e, i) {
                  t[i ? 0 : 1].push(e);
                },
                function () {
                  return [[], []];
                }
              );
              var Po = Zn(function (t, e) {
                  if (null == t) return [];
                  var i = e.length;
                  return (
                    i > 1 && br(t, e[0], e[1])
                      ? (e = [])
                      : i > 2 && br(e[0], e[1], e[2]) && (e = [e[0]]),
                    $n(t, yn(e, 1), [])
                  );
                }),
                Ao =
                  he ||
                  function () {
                    return me.Date.now();
                  };
              function ko(t, e, i) {
                return (
                  (e = i ? s : e),
                  (e = t && null == e ? t.length : e),
                  Qs(t, c, s, s, s, s, e)
                );
              }
              function Mo(t, e) {
                var i;
                if ("function" != typeof e) throw new Et(r);
                return (
                  (t = ma(t)),
                  function () {
                    return (
                      --t > 0 && (i = e.apply(this, arguments)),
                      t <= 1 && (e = s),
                      i
                    );
                  }
                );
              }
              var Eo = Zn(function (t, e, i) {
                  var n = 1;
                  if (i.length) {
                    var s = hi(i, lr(Eo));
                    n |= u;
                  }
                  return Qs(t, n, e, i, s);
                }),
                Io = Zn(function (t, e, i) {
                  var n = 3;
                  if (i.length) {
                    var s = hi(i, lr(Io));
                    n |= u;
                  }
                  return Qs(e, n, t, i, s);
                });
              function Do(t, e, i) {
                var n,
                  o,
                  a,
                  l,
                  u,
                  h,
                  c = 0,
                  d = !1,
                  p = !1,
                  f = !0;
                if ("function" != typeof t) throw new Et(r);
                function m(e) {
                  var i = n,
                    r = o;
                  return (n = o = s), (c = e), (l = t.apply(r, i));
                }
                function g(t) {
                  var i = t - h;
                  return h === s || i >= e || i < 0 || (p && t - c >= a);
                }
                function v() {
                  var t = Ao();
                  if (g(t)) return y(t);
                  u = Ir(
                    v,
                    (function (t) {
                      var i = e - (t - h);
                      return p ? xi(i, a - (t - c)) : i;
                    })(t)
                  );
                }
                function y(t) {
                  return (u = s), f && n ? m(t) : ((n = o = s), l);
                }
                function x() {
                  var t = Ao(),
                    i = g(t);
                  if (((n = arguments), (o = this), (h = t), i)) {
                    if (u === s)
                      return (function (t) {
                        return (c = t), (u = Ir(v, e)), d ? m(t) : l;
                      })(h);
                    if (p) return _s(u), (u = Ir(v, e)), m(h);
                  }
                  return u === s && (u = Ir(v, e)), l;
                }
                return (
                  (e = va(e) || 0),
                  ea(i) &&
                    ((d = !!i.leading),
                    (a = (p = "maxWait" in i) ? yi(va(i.maxWait) || 0, e) : a),
                    (f = "trailing" in i ? !!i.trailing : f)),
                  (x.cancel = function () {
                    u !== s && _s(u), (c = 0), (n = h = o = u = s);
                  }),
                  (x.flush = function () {
                    return u === s ? l : y(Ao());
                  }),
                  x
                );
              }
              var Ro = Zn(function (t, e) {
                  return cn(t, 1, e);
                }),
                Bo = Zn(function (t, e, i) {
                  return cn(t, va(e) || 0, i);
                });
              function Fo(t, e) {
                if (
                  "function" != typeof t ||
                  (null != e && "function" != typeof e)
                )
                  throw new Et(r);
                var i = function () {
                  var n = arguments,
                    s = e ? e.apply(this, n) : n[0],
                    r = i.cache;
                  if (r.has(s)) return r.get(s);
                  var o = t.apply(this, n);
                  return (i.cache = r.set(s, o) || r), o;
                };
                return (i.cache = new (Fo.Cache || Wi)()), i;
              }
              function Oo(t) {
                if ("function" != typeof t) throw new Et(r);
                return function () {
                  var e = arguments;
                  switch (e.length) {
                    case 0:
                      return !t.call(this);
                    case 1:
                      return !t.call(this, e[0]);
                    case 2:
                      return !t.call(this, e[0], e[1]);
                    case 3:
                      return !t.call(this, e[0], e[1], e[2]);
                  }
                  return !t.apply(this, e);
                };
              }
              Fo.Cache = Wi;
              var zo = Ss(function (t, e) {
                  var i = (e =
                    1 == e.length && $o(e[0])
                      ? Fe(e[0], Je(ur()))
                      : Fe(yn(e, 1), Je(ur()))).length;
                  return Zn(function (n) {
                    for (var s = -1, r = xi(n.length, i); ++s < r; )
                      n[s] = e[s].call(this, n[s]);
                    return Ae(t, this, n);
                  });
                }),
                Lo = Zn(function (t, e) {
                  var i = hi(e, lr(Lo));
                  return Qs(t, u, s, e, i);
                }),
                Ho = Zn(function (t, e) {
                  var i = hi(e, lr(Ho));
                  return Qs(t, h, s, e, i);
                }),
                Uo = nr(function (t, e) {
                  return Qs(t, d, s, s, s, e);
                });
              function No(t, e) {
                return t === e || (t != t && e != e);
              }
              var Go = Ws(An),
                Vo = Ws(function (t, e) {
                  return t >= e;
                }),
                jo = Dn(
                  (function () {
                    return arguments;
                  })()
                )
                  ? Dn
                  : function (t) {
                      return (
                        ia(t) && Ot.call(t, "callee") && !Yt.call(t, "callee")
                      );
                    },
                $o = n.isArray,
                qo = Se
                  ? Je(Se)
                  : function (t) {
                      return ia(t) && Pn(t) == B;
                    };
              function Wo(t) {
                return null != t && ta(t.length) && !Qo(t);
              }
              function Xo(t) {
                return ia(t) && Wo(t);
              }
              var Yo = xe || vl,
                Ko = Ce
                  ? Je(Ce)
                  : function (t) {
                      return ia(t) && Pn(t) == S;
                    };
              function Zo(t) {
                if (!ia(t)) return !1;
                var e = Pn(t);
                return (
                  e == C ||
                  "[object DOMException]" == e ||
                  ("string" == typeof t.message &&
                    "string" == typeof t.name &&
                    !ra(t))
                );
              }
              function Qo(t) {
                if (!ea(t)) return !1;
                var e = Pn(t);
                return (
                  e == _ ||
                  e == T ||
                  "[object AsyncFunction]" == e ||
                  "[object Proxy]" == e
                );
              }
              function Jo(t) {
                return "number" == typeof t && t == ma(t);
              }
              function ta(t) {
                return "number" == typeof t && t > -1 && t % 1 == 0 && t <= f;
              }
              function ea(t) {
                var e = typeof t;
                return null != t && ("object" == e || "function" == e);
              }
              function ia(t) {
                return null != t && "object" == typeof t;
              }
              var na = _e
                ? Je(_e)
                : function (t) {
                    return ia(t) && mr(t) == w;
                  };
              function sa(t) {
                return "number" == typeof t || (ia(t) && Pn(t) == P);
              }
              function ra(t) {
                if (!ia(t) || Pn(t) != A) return !1;
                var e = Wt(t);
                if (null === e) return !0;
                var i = Ot.call(e, "constructor") && e.constructor;
                return (
                  "function" == typeof i && i instanceof i && Ft.call(i) == Ut
                );
              }
              var oa = Te
                ? Je(Te)
                : function (t) {
                    return ia(t) && Pn(t) == M;
                  };
              var aa = we
                ? Je(we)
                : function (t) {
                    return ia(t) && mr(t) == E;
                  };
              function la(t) {
                return "string" == typeof t || (!$o(t) && ia(t) && Pn(t) == I);
              }
              function ua(t) {
                return "symbol" == typeof t || (ia(t) && Pn(t) == D);
              }
              var ha = Pe
                ? Je(Pe)
                : function (t) {
                    return ia(t) && ta(t.length) && !!le[Pn(t)];
                  };
              var ca = Ws(Hn),
                da = Ws(function (t, e) {
                  return t <= e;
                });
              function pa(t) {
                if (!t) return [];
                if (Wo(t)) return la(t) ? fi(t) : Es(t);
                if (Qt && t[Qt])
                  return (function (t) {
                    for (var e, i = []; !(e = t.next()).done; ) i.push(e.value);
                    return i;
                  })(t[Qt]());
                var e = mr(t);
                return (e == w ? li : e == E ? ci : Na)(t);
              }
              function fa(t) {
                return t
                  ? (t = va(t)) === p || t === -1 / 0
                    ? 17976931348623157e292 * (t < 0 ? -1 : 1)
                    : t == t
                    ? t
                    : 0
                  : 0 === t
                  ? t
                  : 0;
              }
              function ma(t) {
                var e = fa(t),
                  i = e % 1;
                return e == e ? (i ? e - i : e) : 0;
              }
              function ga(t) {
                return t ? ln(ma(t), 0, g) : 0;
              }
              function va(t) {
                if ("number" == typeof t) return t;
                if (ua(t)) return m;
                if (ea(t)) {
                  var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                  t = ea(e) ? e + "" : e;
                }
                if ("string" != typeof t) return 0 === t ? t : +t;
                t = Qe(t);
                var i = vt.test(t);
                return i || xt.test(t)
                  ? de(t.slice(2), i ? 2 : 8)
                  : gt.test(t)
                  ? m
                  : +t;
              }
              function ya(t) {
                return Is(t, Ra(t));
              }
              function xa(t) {
                return null == t ? "" : hs(t);
              }
              var ba = Rs(function (t, e) {
                  if (Tr(e) || Wo(e)) Is(e, Da(e), t);
                  else for (var i in e) Ot.call(e, i) && en(t, i, e[i]);
                }),
                Sa = Rs(function (t, e) {
                  Is(e, Ra(e), t);
                }),
                Ca = Rs(function (t, e, i, n) {
                  Is(e, Ra(e), t, n);
                }),
                _a = Rs(function (t, e, i, n) {
                  Is(e, Da(e), t, n);
                }),
                Ta = nr(an);
              var wa = Zn(function (t, e) {
                  t = At(t);
                  var i = -1,
                    n = e.length,
                    r = n > 2 ? e[2] : s;
                  for (r && br(e[0], e[1], r) && (n = 1); ++i < n; )
                    for (
                      var o = e[i], a = Ra(o), l = -1, u = a.length;
                      ++l < u;

                    ) {
                      var h = a[l],
                        c = t[h];
                      (c === s || (No(c, Rt[h]) && !Ot.call(t, h))) &&
                        (t[h] = o[h]);
                    }
                  return t;
                }),
                Pa = Zn(function (t) {
                  return t.push(s, tr), Ae(Fa, s, t);
                });
              function Aa(t, e, i) {
                var n = null == t ? s : Tn(t, e);
                return n === s ? i : n;
              }
              function ka(t, e) {
                return null != t && gr(t, e, Mn);
              }
              var Ma = Gs(function (t, e, i) {
                  null != e &&
                    "function" != typeof e.toString &&
                    (e = Ht.call(e)),
                    (t[e] = i);
                }, el(sl)),
                Ea = Gs(function (t, e, i) {
                  null != e &&
                    "function" != typeof e.toString &&
                    (e = Ht.call(e)),
                    Ot.call(t, e) ? t[e].push(i) : (t[e] = [i]);
                }, ur),
                Ia = Zn(In);
              function Da(t) {
                return Wo(t) ? Ki(t) : zn(t);
              }
              function Ra(t) {
                return Wo(t) ? Ki(t, !0) : Ln(t);
              }
              var Ba = Rs(function (t, e, i) {
                  Vn(t, e, i);
                }),
                Fa = Rs(function (t, e, i, n) {
                  Vn(t, e, i, n);
                }),
                Oa = nr(function (t, e) {
                  var i = {};
                  if (null == t) return i;
                  var n = !1;
                  (e = Fe(e, function (e) {
                    return (e = bs(e, t)), n || (n = e.length > 1), e;
                  })),
                    Is(t, rr(t), i),
                    n && (i = un(i, 7, er));
                  for (var s = e.length; s--; ) ds(i, e[s]);
                  return i;
                });
              var za = nr(function (t, e) {
                return null == t
                  ? {}
                  : (function (t, e) {
                      return qn(t, e, function (e, i) {
                        return ka(t, i);
                      });
                    })(t, e);
              });
              function La(t, e) {
                if (null == t) return {};
                var i = Fe(rr(t), function (t) {
                  return [t];
                });
                return (
                  (e = ur(e)),
                  qn(t, i, function (t, i) {
                    return e(t, i[0]);
                  })
                );
              }
              var Ha = Zs(Da),
                Ua = Zs(Ra);
              function Na(t) {
                return null == t ? [] : ti(t, Da(t));
              }
              var Ga = zs(function (t, e, i) {
                return (e = e.toLowerCase()), t + (i ? Va(e) : e);
              });
              function Va(t) {
                return Za(xa(t).toLowerCase());
              }
              function ja(t) {
                return (t = xa(t)) && t.replace(St, si).replace(ee, "");
              }
              var $a = zs(function (t, e, i) {
                  return t + (i ? "-" : "") + e.toLowerCase();
                }),
                qa = zs(function (t, e, i) {
                  return t + (i ? " " : "") + e.toLowerCase();
                }),
                Wa = Os("toLowerCase");
              var Xa = zs(function (t, e, i) {
                return t + (i ? "_" : "") + e.toLowerCase();
              });
              var Ya = zs(function (t, e, i) {
                return t + (i ? " " : "") + Za(e);
              });
              var Ka = zs(function (t, e, i) {
                  return t + (i ? " " : "") + e.toUpperCase();
                }),
                Za = Os("toUpperCase");
              function Qa(t, e, i) {
                return (
                  (t = xa(t)),
                  (e = i ? s : e) === s
                    ? (function (t) {
                        return re.test(t);
                      })(t)
                      ? (function (t) {
                          return t.match(ne) || [];
                        })(t)
                      : (function (t) {
                          return t.match(ct) || [];
                        })(t)
                    : t.match(e) || []
                );
              }
              var Ja = Zn(function (t, e) {
                  try {
                    return Ae(t, s, e);
                  } catch (t) {
                    return Zo(t) ? t : new Tt(t);
                  }
                }),
                tl = nr(function (t, e) {
                  return (
                    Me(e, function (e) {
                      (e = zr(e)), on(t, e, Eo(t[e], t));
                    }),
                    t
                  );
                });
              function el(t) {
                return function () {
                  return t;
                };
              }
              var il = Us(),
                nl = Us(!0);
              function sl(t) {
                return t;
              }
              function rl(t) {
                return On("function" == typeof t ? t : un(t, 1));
              }
              var ol = Zn(function (t, e) {
                  return function (i) {
                    return In(i, t, e);
                  };
                }),
                al = Zn(function (t, e) {
                  return function (i) {
                    return In(t, i, e);
                  };
                });
              function ll(t, e, i) {
                var n = Da(e),
                  s = _n(e, n);
                null != i ||
                  (ea(e) && (s.length || !n.length)) ||
                  ((i = e), (e = t), (t = this), (s = _n(e, Da(e))));
                var r = !(ea(i) && "chain" in i && !i.chain),
                  o = Qo(t);
                return (
                  Me(s, function (i) {
                    var n = e[i];
                    (t[i] = n),
                      o &&
                        (t.prototype[i] = function () {
                          var e = this.__chain__;
                          if (r || e) {
                            var i = t(this.__wrapped__);
                            return (
                              (i.__actions__ = Es(this.__actions__)).push({
                                func: n,
                                args: arguments,
                                thisArg: t,
                              }),
                              (i.__chain__ = e),
                              i
                            );
                          }
                          return n.apply(t, Oe([this.value()], arguments));
                        });
                  }),
                  t
                );
              }
              function ul() {}
              var hl = js(Fe),
                cl = js(Ie),
                dl = js(He);
              function pl(t) {
                return Sr(t)
                  ? We(zr(t))
                  : (function (t) {
                      return function (e) {
                        return Tn(e, t);
                      };
                    })(t);
              }
              var fl = qs(),
                ml = qs(!0);
              function gl() {
                return [];
              }
              function vl() {
                return !1;
              }
              var yl = Vs(function (t, e) {
                  return t + e;
                }, 0),
                xl = Ys("ceil"),
                bl = Vs(function (t, e) {
                  return t / e;
                }, 1),
                Sl = Ys("floor");
              var Cl,
                _l = Vs(function (t, e) {
                  return t * e;
                }, 1),
                Tl = Ys("round"),
                wl = Vs(function (t, e) {
                  return t - e;
                }, 0);
              return (
                (Ui.after = function (t, e) {
                  if ("function" != typeof e) throw new Et(r);
                  return (
                    (t = ma(t)),
                    function () {
                      if (--t < 1) return e.apply(this, arguments);
                    }
                  );
                }),
                (Ui.ary = ko),
                (Ui.assign = ba),
                (Ui.assignIn = Sa),
                (Ui.assignInWith = Ca),
                (Ui.assignWith = _a),
                (Ui.at = Ta),
                (Ui.before = Mo),
                (Ui.bind = Eo),
                (Ui.bindAll = tl),
                (Ui.bindKey = Io),
                (Ui.castArray = function () {
                  if (!arguments.length) return [];
                  var t = arguments[0];
                  return $o(t) ? t : [t];
                }),
                (Ui.chain = po),
                (Ui.chunk = function (t, e, i) {
                  e = (i ? br(t, e, i) : e === s) ? 1 : yi(ma(e), 0);
                  var r = null == t ? 0 : t.length;
                  if (!r || e < 1) return [];
                  for (var o = 0, a = 0, l = n(fe(r / e)); o < r; )
                    l[a++] = ss(t, o, (o += e));
                  return l;
                }),
                (Ui.compact = function (t) {
                  for (
                    var e = -1, i = null == t ? 0 : t.length, n = 0, s = [];
                    ++e < i;

                  ) {
                    var r = t[e];
                    r && (s[n++] = r);
                  }
                  return s;
                }),
                (Ui.concat = function () {
                  var t = arguments.length;
                  if (!t) return [];
                  for (var e = n(t - 1), i = arguments[0], s = t; s--; )
                    e[s - 1] = arguments[s];
                  return Oe($o(i) ? Es(i) : [i], yn(e, 1));
                }),
                (Ui.cond = function (t) {
                  var e = null == t ? 0 : t.length,
                    i = ur();
                  return (
                    (t = e
                      ? Fe(t, function (t) {
                          if ("function" != typeof t[1]) throw new Et(r);
                          return [i(t[0]), t[1]];
                        })
                      : []),
                    Zn(function (i) {
                      for (var n = -1; ++n < e; ) {
                        var s = t[n];
                        if (Ae(s[0], this, i)) return Ae(s[1], this, i);
                      }
                    })
                  );
                }),
                (Ui.conforms = function (t) {
                  return (function (t) {
                    var e = Da(t);
                    return function (i) {
                      return hn(i, t, e);
                    };
                  })(un(t, 1));
                }),
                (Ui.constant = el),
                (Ui.countBy = go),
                (Ui.create = function (t, e) {
                  var i = Ni(t);
                  return null == e ? i : rn(i, e);
                }),
                (Ui.curry = function t(e, i, n) {
                  var r = Qs(e, 8, s, s, s, s, s, (i = n ? s : i));
                  return (r.placeholder = t.placeholder), r;
                }),
                (Ui.curryRight = function t(e, i, n) {
                  var r = Qs(e, l, s, s, s, s, s, (i = n ? s : i));
                  return (r.placeholder = t.placeholder), r;
                }),
                (Ui.debounce = Do),
                (Ui.defaults = wa),
                (Ui.defaultsDeep = Pa),
                (Ui.defer = Ro),
                (Ui.delay = Bo),
                (Ui.difference = Ur),
                (Ui.differenceBy = Nr),
                (Ui.differenceWith = Gr),
                (Ui.drop = function (t, e, i) {
                  var n = null == t ? 0 : t.length;
                  return n
                    ? ss(t, (e = i || e === s ? 1 : ma(e)) < 0 ? 0 : e, n)
                    : [];
                }),
                (Ui.dropRight = function (t, e, i) {
                  var n = null == t ? 0 : t.length;
                  return n
                    ? ss(
                        t,
                        0,
                        (e = n - (e = i || e === s ? 1 : ma(e))) < 0 ? 0 : e
                      )
                    : [];
                }),
                (Ui.dropRightWhile = function (t, e) {
                  return t && t.length ? fs(t, ur(e, 3), !0, !0) : [];
                }),
                (Ui.dropWhile = function (t, e) {
                  return t && t.length ? fs(t, ur(e, 3), !0) : [];
                }),
                (Ui.fill = function (t, e, i, n) {
                  var r = null == t ? 0 : t.length;
                  return r
                    ? (i &&
                        "number" != typeof i &&
                        br(t, e, i) &&
                        ((i = 0), (n = r)),
                      (function (t, e, i, n) {
                        var r = t.length;
                        for (
                          (i = ma(i)) < 0 && (i = -i > r ? 0 : r + i),
                            (n = n === s || n > r ? r : ma(n)) < 0 && (n += r),
                            n = i > n ? 0 : ga(n);
                          i < n;

                        )
                          t[i++] = e;
                        return t;
                      })(t, e, i, n))
                    : [];
                }),
                (Ui.filter = function (t, e) {
                  return ($o(t) ? De : vn)(t, ur(e, 3));
                }),
                (Ui.flatMap = function (t, e) {
                  return yn(To(t, e), 1);
                }),
                (Ui.flatMapDeep = function (t, e) {
                  return yn(To(t, e), p);
                }),
                (Ui.flatMapDepth = function (t, e, i) {
                  return (i = i === s ? 1 : ma(i)), yn(To(t, e), i);
                }),
                (Ui.flatten = $r),
                (Ui.flattenDeep = function (t) {
                  return (null == t ? 0 : t.length) ? yn(t, p) : [];
                }),
                (Ui.flattenDepth = function (t, e) {
                  return (null == t ? 0 : t.length)
                    ? yn(t, (e = e === s ? 1 : ma(e)))
                    : [];
                }),
                (Ui.flip = function (t) {
                  return Qs(t, 512);
                }),
                (Ui.flow = il),
                (Ui.flowRight = nl),
                (Ui.fromPairs = function (t) {
                  for (
                    var e = -1, i = null == t ? 0 : t.length, n = {};
                    ++e < i;

                  ) {
                    var s = t[e];
                    n[s[0]] = s[1];
                  }
                  return n;
                }),
                (Ui.functions = function (t) {
                  return null == t ? [] : _n(t, Da(t));
                }),
                (Ui.functionsIn = function (t) {
                  return null == t ? [] : _n(t, Ra(t));
                }),
                (Ui.groupBy = So),
                (Ui.initial = function (t) {
                  return (null == t ? 0 : t.length) ? ss(t, 0, -1) : [];
                }),
                (Ui.intersection = Wr),
                (Ui.intersectionBy = Xr),
                (Ui.intersectionWith = Yr),
                (Ui.invert = Ma),
                (Ui.invertBy = Ea),
                (Ui.invokeMap = Co),
                (Ui.iteratee = rl),
                (Ui.keyBy = _o),
                (Ui.keys = Da),
                (Ui.keysIn = Ra),
                (Ui.map = To),
                (Ui.mapKeys = function (t, e) {
                  var i = {};
                  return (
                    (e = ur(e, 3)),
                    Sn(t, function (t, n, s) {
                      on(i, e(t, n, s), t);
                    }),
                    i
                  );
                }),
                (Ui.mapValues = function (t, e) {
                  var i = {};
                  return (
                    (e = ur(e, 3)),
                    Sn(t, function (t, n, s) {
                      on(i, n, e(t, n, s));
                    }),
                    i
                  );
                }),
                (Ui.matches = function (t) {
                  return Nn(un(t, 1));
                }),
                (Ui.matchesProperty = function (t, e) {
                  return Gn(t, un(e, 1));
                }),
                (Ui.memoize = Fo),
                (Ui.merge = Ba),
                (Ui.mergeWith = Fa),
                (Ui.method = ol),
                (Ui.methodOf = al),
                (Ui.mixin = ll),
                (Ui.negate = Oo),
                (Ui.nthArg = function (t) {
                  return (
                    (t = ma(t)),
                    Zn(function (e) {
                      return jn(e, t);
                    })
                  );
                }),
                (Ui.omit = Oa),
                (Ui.omitBy = function (t, e) {
                  return La(t, Oo(ur(e)));
                }),
                (Ui.once = function (t) {
                  return Mo(2, t);
                }),
                (Ui.orderBy = function (t, e, i, n) {
                  return null == t
                    ? []
                    : ($o(e) || (e = null == e ? [] : [e]),
                      $o((i = n ? s : i)) || (i = null == i ? [] : [i]),
                      $n(t, e, i));
                }),
                (Ui.over = hl),
                (Ui.overArgs = zo),
                (Ui.overEvery = cl),
                (Ui.overSome = dl),
                (Ui.partial = Lo),
                (Ui.partialRight = Ho),
                (Ui.partition = wo),
                (Ui.pick = za),
                (Ui.pickBy = La),
                (Ui.property = pl),
                (Ui.propertyOf = function (t) {
                  return function (e) {
                    return null == t ? s : Tn(t, e);
                  };
                }),
                (Ui.pull = Zr),
                (Ui.pullAll = Qr),
                (Ui.pullAllBy = function (t, e, i) {
                  return t && t.length && e && e.length
                    ? Wn(t, e, ur(i, 2))
                    : t;
                }),
                (Ui.pullAllWith = function (t, e, i) {
                  return t && t.length && e && e.length ? Wn(t, e, s, i) : t;
                }),
                (Ui.pullAt = Jr),
                (Ui.range = fl),
                (Ui.rangeRight = ml),
                (Ui.rearg = Uo),
                (Ui.reject = function (t, e) {
                  return ($o(t) ? De : vn)(t, Oo(ur(e, 3)));
                }),
                (Ui.remove = function (t, e) {
                  var i = [];
                  if (!t || !t.length) return i;
                  var n = -1,
                    s = [],
                    r = t.length;
                  for (e = ur(e, 3); ++n < r; ) {
                    var o = t[n];
                    e(o, n, t) && (i.push(o), s.push(n));
                  }
                  return Xn(t, s), i;
                }),
                (Ui.rest = function (t, e) {
                  if ("function" != typeof t) throw new Et(r);
                  return Zn(t, (e = e === s ? e : ma(e)));
                }),
                (Ui.reverse = to),
                (Ui.sampleSize = function (t, e, i) {
                  return (
                    (e = (i ? br(t, e, i) : e === s) ? 1 : ma(e)),
                    ($o(t) ? Qi : Jn)(t, e)
                  );
                }),
                (Ui.set = function (t, e, i) {
                  return null == t ? t : ts(t, e, i);
                }),
                (Ui.setWith = function (t, e, i, n) {
                  return (
                    (n = "function" == typeof n ? n : s),
                    null == t ? t : ts(t, e, i, n)
                  );
                }),
                (Ui.shuffle = function (t) {
                  return ($o(t) ? Ji : ns)(t);
                }),
                (Ui.slice = function (t, e, i) {
                  var n = null == t ? 0 : t.length;
                  return n
                    ? (i && "number" != typeof i && br(t, e, i)
                        ? ((e = 0), (i = n))
                        : ((e = null == e ? 0 : ma(e)),
                          (i = i === s ? n : ma(i))),
                      ss(t, e, i))
                    : [];
                }),
                (Ui.sortBy = Po),
                (Ui.sortedUniq = function (t) {
                  return t && t.length ? ls(t) : [];
                }),
                (Ui.sortedUniqBy = function (t, e) {
                  return t && t.length ? ls(t, ur(e, 2)) : [];
                }),
                (Ui.split = function (t, e, i) {
                  return (
                    i && "number" != typeof i && br(t, e, i) && (e = i = s),
                    (i = i === s ? g : i >>> 0)
                      ? (t = xa(t)) &&
                        ("string" == typeof e || (null != e && !oa(e))) &&
                        !(e = hs(e)) &&
                        ai(t)
                        ? Cs(fi(t), 0, i)
                        : t.split(e, i)
                      : []
                  );
                }),
                (Ui.spread = function (t, e) {
                  if ("function" != typeof t) throw new Et(r);
                  return (
                    (e = null == e ? 0 : yi(ma(e), 0)),
                    Zn(function (i) {
                      var n = i[e],
                        s = Cs(i, 0, e);
                      return n && Oe(s, n), Ae(t, this, s);
                    })
                  );
                }),
                (Ui.tail = function (t) {
                  var e = null == t ? 0 : t.length;
                  return e ? ss(t, 1, e) : [];
                }),
                (Ui.take = function (t, e, i) {
                  return t && t.length
                    ? ss(t, 0, (e = i || e === s ? 1 : ma(e)) < 0 ? 0 : e)
                    : [];
                }),
                (Ui.takeRight = function (t, e, i) {
                  var n = null == t ? 0 : t.length;
                  return n
                    ? ss(
                        t,
                        (e = n - (e = i || e === s ? 1 : ma(e))) < 0 ? 0 : e,
                        n
                      )
                    : [];
                }),
                (Ui.takeRightWhile = function (t, e) {
                  return t && t.length ? fs(t, ur(e, 3), !1, !0) : [];
                }),
                (Ui.takeWhile = function (t, e) {
                  return t && t.length ? fs(t, ur(e, 3)) : [];
                }),
                (Ui.tap = function (t, e) {
                  return e(t), t;
                }),
                (Ui.throttle = function (t, e, i) {
                  var n = !0,
                    s = !0;
                  if ("function" != typeof t) throw new Et(r);
                  return (
                    ea(i) &&
                      ((n = "leading" in i ? !!i.leading : n),
                      (s = "trailing" in i ? !!i.trailing : s)),
                    Do(t, e, { leading: n, maxWait: e, trailing: s })
                  );
                }),
                (Ui.thru = fo),
                (Ui.toArray = pa),
                (Ui.toPairs = Ha),
                (Ui.toPairsIn = Ua),
                (Ui.toPath = function (t) {
                  return $o(t) ? Fe(t, zr) : ua(t) ? [t] : Es(Or(xa(t)));
                }),
                (Ui.toPlainObject = ya),
                (Ui.transform = function (t, e, i) {
                  var n = $o(t),
                    s = n || Yo(t) || ha(t);
                  if (((e = ur(e, 4)), null == i)) {
                    var r = t && t.constructor;
                    i = s
                      ? n
                        ? new r()
                        : []
                      : ea(t) && Qo(r)
                      ? Ni(Wt(t))
                      : {};
                  }
                  return (
                    (s ? Me : Sn)(t, function (t, n, s) {
                      return e(i, t, n, s);
                    }),
                    i
                  );
                }),
                (Ui.unary = function (t) {
                  return ko(t, 1);
                }),
                (Ui.union = eo),
                (Ui.unionBy = io),
                (Ui.unionWith = no),
                (Ui.uniq = function (t) {
                  return t && t.length ? cs(t) : [];
                }),
                (Ui.uniqBy = function (t, e) {
                  return t && t.length ? cs(t, ur(e, 2)) : [];
                }),
                (Ui.uniqWith = function (t, e) {
                  return (
                    (e = "function" == typeof e ? e : s),
                    t && t.length ? cs(t, s, e) : []
                  );
                }),
                (Ui.unset = function (t, e) {
                  return null == t || ds(t, e);
                }),
                (Ui.unzip = so),
                (Ui.unzipWith = ro),
                (Ui.update = function (t, e, i) {
                  return null == t ? t : ps(t, e, xs(i));
                }),
                (Ui.updateWith = function (t, e, i, n) {
                  return (
                    (n = "function" == typeof n ? n : s),
                    null == t ? t : ps(t, e, xs(i), n)
                  );
                }),
                (Ui.values = Na),
                (Ui.valuesIn = function (t) {
                  return null == t ? [] : ti(t, Ra(t));
                }),
                (Ui.without = oo),
                (Ui.words = Qa),
                (Ui.wrap = function (t, e) {
                  return Lo(xs(e), t);
                }),
                (Ui.xor = ao),
                (Ui.xorBy = lo),
                (Ui.xorWith = uo),
                (Ui.zip = ho),
                (Ui.zipObject = function (t, e) {
                  return vs(t || [], e || [], en);
                }),
                (Ui.zipObjectDeep = function (t, e) {
                  return vs(t || [], e || [], ts);
                }),
                (Ui.zipWith = co),
                (Ui.entries = Ha),
                (Ui.entriesIn = Ua),
                (Ui.extend = Sa),
                (Ui.extendWith = Ca),
                ll(Ui, Ui),
                (Ui.add = yl),
                (Ui.attempt = Ja),
                (Ui.camelCase = Ga),
                (Ui.capitalize = Va),
                (Ui.ceil = xl),
                (Ui.clamp = function (t, e, i) {
                  return (
                    i === s && ((i = e), (e = s)),
                    i !== s && (i = (i = va(i)) == i ? i : 0),
                    e !== s && (e = (e = va(e)) == e ? e : 0),
                    ln(va(t), e, i)
                  );
                }),
                (Ui.clone = function (t) {
                  return un(t, 4);
                }),
                (Ui.cloneDeep = function (t) {
                  return un(t, 5);
                }),
                (Ui.cloneDeepWith = function (t, e) {
                  return un(t, 5, (e = "function" == typeof e ? e : s));
                }),
                (Ui.cloneWith = function (t, e) {
                  return un(t, 4, (e = "function" == typeof e ? e : s));
                }),
                (Ui.conformsTo = function (t, e) {
                  return null == e || hn(t, e, Da(e));
                }),
                (Ui.deburr = ja),
                (Ui.defaultTo = function (t, e) {
                  return null == t || t != t ? e : t;
                }),
                (Ui.divide = bl),
                (Ui.endsWith = function (t, e, i) {
                  (t = xa(t)), (e = hs(e));
                  var n = t.length,
                    r = (i = i === s ? n : ln(ma(i), 0, n));
                  return (i -= e.length) >= 0 && t.slice(i, r) == e;
                }),
                (Ui.eq = No),
                (Ui.escape = function (t) {
                  return (t = xa(t)) && Z.test(t) ? t.replace(Y, ri) : t;
                }),
                (Ui.escapeRegExp = function (t) {
                  return (t = xa(t)) && rt.test(t) ? t.replace(st, "\\$&") : t;
                }),
                (Ui.every = function (t, e, i) {
                  var n = $o(t) ? Ie : mn;
                  return i && br(t, e, i) && (e = s), n(t, ur(e, 3));
                }),
                (Ui.find = vo),
                (Ui.findIndex = Vr),
                (Ui.findKey = function (t, e) {
                  return Ne(t, ur(e, 3), Sn);
                }),
                (Ui.findLast = yo),
                (Ui.findLastIndex = jr),
                (Ui.findLastKey = function (t, e) {
                  return Ne(t, ur(e, 3), Cn);
                }),
                (Ui.floor = Sl),
                (Ui.forEach = xo),
                (Ui.forEachRight = bo),
                (Ui.forIn = function (t, e) {
                  return null == t ? t : xn(t, ur(e, 3), Ra);
                }),
                (Ui.forInRight = function (t, e) {
                  return null == t ? t : bn(t, ur(e, 3), Ra);
                }),
                (Ui.forOwn = function (t, e) {
                  return t && Sn(t, ur(e, 3));
                }),
                (Ui.forOwnRight = function (t, e) {
                  return t && Cn(t, ur(e, 3));
                }),
                (Ui.get = Aa),
                (Ui.gt = Go),
                (Ui.gte = Vo),
                (Ui.has = function (t, e) {
                  return null != t && gr(t, e, kn);
                }),
                (Ui.hasIn = ka),
                (Ui.head = qr),
                (Ui.identity = sl),
                (Ui.includes = function (t, e, i, n) {
                  (t = Wo(t) ? t : Na(t)), (i = i && !n ? ma(i) : 0);
                  var s = t.length;
                  return (
                    i < 0 && (i = yi(s + i, 0)),
                    la(t)
                      ? i <= s && t.indexOf(e, i) > -1
                      : !!s && Ve(t, e, i) > -1
                  );
                }),
                (Ui.indexOf = function (t, e, i) {
                  var n = null == t ? 0 : t.length;
                  if (!n) return -1;
                  var s = null == i ? 0 : ma(i);
                  return s < 0 && (s = yi(n + s, 0)), Ve(t, e, s);
                }),
                (Ui.inRange = function (t, e, i) {
                  return (
                    (e = fa(e)),
                    i === s ? ((i = e), (e = 0)) : (i = fa(i)),
                    (function (t, e, i) {
                      return t >= xi(e, i) && t < yi(e, i);
                    })((t = va(t)), e, i)
                  );
                }),
                (Ui.invoke = Ia),
                (Ui.isArguments = jo),
                (Ui.isArray = $o),
                (Ui.isArrayBuffer = qo),
                (Ui.isArrayLike = Wo),
                (Ui.isArrayLikeObject = Xo),
                (Ui.isBoolean = function (t) {
                  return !0 === t || !1 === t || (ia(t) && Pn(t) == b);
                }),
                (Ui.isBuffer = Yo),
                (Ui.isDate = Ko),
                (Ui.isElement = function (t) {
                  return ia(t) && 1 === t.nodeType && !ra(t);
                }),
                (Ui.isEmpty = function (t) {
                  if (null == t) return !0;
                  if (
                    Wo(t) &&
                    ($o(t) ||
                      "string" == typeof t ||
                      "function" == typeof t.splice ||
                      Yo(t) ||
                      ha(t) ||
                      jo(t))
                  )
                    return !t.length;
                  var e = mr(t);
                  if (e == w || e == E) return !t.size;
                  if (Tr(t)) return !zn(t).length;
                  for (var i in t) if (Ot.call(t, i)) return !1;
                  return !0;
                }),
                (Ui.isEqual = function (t, e) {
                  return Rn(t, e);
                }),
                (Ui.isEqualWith = function (t, e, i) {
                  var n = (i = "function" == typeof i ? i : s) ? i(t, e) : s;
                  return n === s ? Rn(t, e, s, i) : !!n;
                }),
                (Ui.isError = Zo),
                (Ui.isFinite = function (t) {
                  return "number" == typeof t && be(t);
                }),
                (Ui.isFunction = Qo),
                (Ui.isInteger = Jo),
                (Ui.isLength = ta),
                (Ui.isMap = na),
                (Ui.isMatch = function (t, e) {
                  return t === e || Bn(t, e, cr(e));
                }),
                (Ui.isMatchWith = function (t, e, i) {
                  return (
                    (i = "function" == typeof i ? i : s), Bn(t, e, cr(e), i)
                  );
                }),
                (Ui.isNaN = function (t) {
                  return sa(t) && t != +t;
                }),
                (Ui.isNative = function (t) {
                  if (_r(t))
                    throw new Tt(
                      "Unsupported core-js use. Try https://npms.io/search?q=ponyfill."
                    );
                  return Fn(t);
                }),
                (Ui.isNil = function (t) {
                  return null == t;
                }),
                (Ui.isNull = function (t) {
                  return null === t;
                }),
                (Ui.isNumber = sa),
                (Ui.isObject = ea),
                (Ui.isObjectLike = ia),
                (Ui.isPlainObject = ra),
                (Ui.isRegExp = oa),
                (Ui.isSafeInteger = function (t) {
                  return Jo(t) && t >= -9007199254740991 && t <= f;
                }),
                (Ui.isSet = aa),
                (Ui.isString = la),
                (Ui.isSymbol = ua),
                (Ui.isTypedArray = ha),
                (Ui.isUndefined = function (t) {
                  return t === s;
                }),
                (Ui.isWeakMap = function (t) {
                  return ia(t) && mr(t) == R;
                }),
                (Ui.isWeakSet = function (t) {
                  return ia(t) && "[object WeakSet]" == Pn(t);
                }),
                (Ui.join = function (t, e) {
                  return null == t ? "" : Ue.call(t, e);
                }),
                (Ui.kebabCase = $a),
                (Ui.last = Kr),
                (Ui.lastIndexOf = function (t, e, i) {
                  var n = null == t ? 0 : t.length;
                  if (!n) return -1;
                  var r = n;
                  return (
                    i !== s &&
                      (r = (r = ma(i)) < 0 ? yi(n + r, 0) : xi(r, n - 1)),
                    e == e
                      ? (function (t, e, i) {
                          for (var n = i + 1; n--; ) if (t[n] === e) return n;
                          return n;
                        })(t, e, r)
                      : Ge(t, $e, r, !0)
                  );
                }),
                (Ui.lowerCase = qa),
                (Ui.lowerFirst = Wa),
                (Ui.lt = ca),
                (Ui.lte = da),
                (Ui.max = function (t) {
                  return t && t.length ? gn(t, sl, An) : s;
                }),
                (Ui.maxBy = function (t, e) {
                  return t && t.length ? gn(t, ur(e, 2), An) : s;
                }),
                (Ui.mean = function (t) {
                  return qe(t, sl);
                }),
                (Ui.meanBy = function (t, e) {
                  return qe(t, ur(e, 2));
                }),
                (Ui.min = function (t) {
                  return t && t.length ? gn(t, sl, Hn) : s;
                }),
                (Ui.minBy = function (t, e) {
                  return t && t.length ? gn(t, ur(e, 2), Hn) : s;
                }),
                (Ui.stubArray = gl),
                (Ui.stubFalse = vl),
                (Ui.stubObject = function () {
                  return {};
                }),
                (Ui.stubString = function () {
                  return "";
                }),
                (Ui.stubTrue = function () {
                  return !0;
                }),
                (Ui.multiply = _l),
                (Ui.nth = function (t, e) {
                  return t && t.length ? jn(t, ma(e)) : s;
                }),
                (Ui.noConflict = function () {
                  return me._ === this && (me._ = Nt), this;
                }),
                (Ui.noop = ul),
                (Ui.now = Ao),
                (Ui.pad = function (t, e, i) {
                  t = xa(t);
                  var n = (e = ma(e)) ? pi(t) : 0;
                  if (!e || n >= e) return t;
                  var s = (e - n) / 2;
                  return $s(ge(s), i) + t + $s(fe(s), i);
                }),
                (Ui.padEnd = function (t, e, i) {
                  t = xa(t);
                  var n = (e = ma(e)) ? pi(t) : 0;
                  return e && n < e ? t + $s(e - n, i) : t;
                }),
                (Ui.padStart = function (t, e, i) {
                  t = xa(t);
                  var n = (e = ma(e)) ? pi(t) : 0;
                  return e && n < e ? $s(e - n, i) + t : t;
                }),
                (Ui.parseInt = function (t, e, i) {
                  return (
                    i || null == e ? (e = 0) : e && (e = +e),
                    Si(xa(t).replace(ot, ""), e || 0)
                  );
                }),
                (Ui.random = function (t, e, i) {
                  if (
                    (i && "boolean" != typeof i && br(t, e, i) && (e = i = s),
                    i === s &&
                      ("boolean" == typeof e
                        ? ((i = e), (e = s))
                        : "boolean" == typeof t && ((i = t), (t = s))),
                    t === s && e === s
                      ? ((t = 0), (e = 1))
                      : ((t = fa(t)),
                        e === s ? ((e = t), (t = 0)) : (e = fa(e))),
                    t > e)
                  ) {
                    var n = t;
                    (t = e), (e = n);
                  }
                  if (i || t % 1 || e % 1) {
                    var r = Ci();
                    return xi(
                      t + r * (e - t + ce("1e-" + ((r + "").length - 1))),
                      e
                    );
                  }
                  return Yn(t, e);
                }),
                (Ui.reduce = function (t, e, i) {
                  var n = $o(t) ? ze : Ye,
                    s = arguments.length < 3;
                  return n(t, ur(e, 4), i, s, pn);
                }),
                (Ui.reduceRight = function (t, e, i) {
                  var n = $o(t) ? Le : Ye,
                    s = arguments.length < 3;
                  return n(t, ur(e, 4), i, s, fn);
                }),
                (Ui.repeat = function (t, e, i) {
                  return (
                    (e = (i ? br(t, e, i) : e === s) ? 1 : ma(e)), Kn(xa(t), e)
                  );
                }),
                (Ui.replace = function () {
                  var t = arguments,
                    e = xa(t[0]);
                  return t.length < 3 ? e : e.replace(t[1], t[2]);
                }),
                (Ui.result = function (t, e, i) {
                  var n = -1,
                    r = (e = bs(e, t)).length;
                  for (r || ((r = 1), (t = s)); ++n < r; ) {
                    var o = null == t ? s : t[zr(e[n])];
                    o === s && ((n = r), (o = i)), (t = Qo(o) ? o.call(t) : o);
                  }
                  return t;
                }),
                (Ui.round = Tl),
                (Ui.runInContext = t),
                (Ui.sample = function (t) {
                  return ($o(t) ? Zi : Qn)(t);
                }),
                (Ui.size = function (t) {
                  if (null == t) return 0;
                  if (Wo(t)) return la(t) ? pi(t) : t.length;
                  var e = mr(t);
                  return e == w || e == E ? t.size : zn(t).length;
                }),
                (Ui.snakeCase = Xa),
                (Ui.some = function (t, e, i) {
                  var n = $o(t) ? He : rs;
                  return i && br(t, e, i) && (e = s), n(t, ur(e, 3));
                }),
                (Ui.sortedIndex = function (t, e) {
                  return os(t, e);
                }),
                (Ui.sortedIndexBy = function (t, e, i) {
                  return as(t, e, ur(i, 2));
                }),
                (Ui.sortedIndexOf = function (t, e) {
                  var i = null == t ? 0 : t.length;
                  if (i) {
                    var n = os(t, e);
                    if (n < i && No(t[n], e)) return n;
                  }
                  return -1;
                }),
                (Ui.sortedLastIndex = function (t, e) {
                  return os(t, e, !0);
                }),
                (Ui.sortedLastIndexBy = function (t, e, i) {
                  return as(t, e, ur(i, 2), !0);
                }),
                (Ui.sortedLastIndexOf = function (t, e) {
                  if (null == t ? 0 : t.length) {
                    var i = os(t, e, !0) - 1;
                    if (No(t[i], e)) return i;
                  }
                  return -1;
                }),
                (Ui.startCase = Ya),
                (Ui.startsWith = function (t, e, i) {
                  return (
                    (t = xa(t)),
                    (i = null == i ? 0 : ln(ma(i), 0, t.length)),
                    (e = hs(e)),
                    t.slice(i, i + e.length) == e
                  );
                }),
                (Ui.subtract = wl),
                (Ui.sum = function (t) {
                  return t && t.length ? Ke(t, sl) : 0;
                }),
                (Ui.sumBy = function (t, e) {
                  return t && t.length ? Ke(t, ur(e, 2)) : 0;
                }),
                (Ui.template = function (t, e, i) {
                  var n = Ui.templateSettings;
                  i && br(t, e, i) && (e = s),
                    (t = xa(t)),
                    (e = Ca({}, e, n, Js));
                  var r,
                    o,
                    a = Ca({}, e.imports, n.imports, Js),
                    l = Da(a),
                    u = ti(a, l),
                    h = 0,
                    c = e.interpolate || Ct,
                    d = "__p += '",
                    p = kt(
                      (e.escape || Ct).source +
                        "|" +
                        c.source +
                        "|" +
                        (c === tt ? ft : Ct).source +
                        "|" +
                        (e.evaluate || Ct).source +
                        "|$",
                      "g"
                    ),
                    f =
                      "//# sourceURL=" +
                      (Ot.call(e, "sourceURL")
                        ? (e.sourceURL + "").replace(/\s/g, " ")
                        : "lodash.templateSources[" + ++ae + "]") +
                      "\n";
                  t.replace(p, function (e, i, n, s, a, l) {
                    return (
                      n || (n = s),
                      (d += t.slice(h, l).replace(_t, oi)),
                      i && ((r = !0), (d += "' +\n__e(" + i + ") +\n'")),
                      a && ((o = !0), (d += "';\n" + a + ";\n__p += '")),
                      n &&
                        (d +=
                          "' +\n((__t = (" + n + ")) == null ? '' : __t) +\n'"),
                      (h = l + e.length),
                      e
                    );
                  }),
                    (d += "';\n");
                  var m = Ot.call(e, "variable") && e.variable;
                  if (m) {
                    if (dt.test(m))
                      throw new Tt(
                        "Invalid `variable` option passed into `_.template`"
                      );
                  } else d = "with (obj) {\n" + d + "\n}\n";
                  (d = (o ? d.replace($, "") : d)
                    .replace(q, "$1")
                    .replace(W, "$1;")),
                    (d =
                      "function(" +
                      (m || "obj") +
                      ") {\n" +
                      (m ? "" : "obj || (obj = {});\n") +
                      "var __t, __p = ''" +
                      (r ? ", __e = _.escape" : "") +
                      (o
                        ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n"
                        : ";\n") +
                      d +
                      "return __p\n}");
                  var g = Ja(function () {
                    return wt(l, f + "return " + d).apply(s, u);
                  });
                  if (((g.source = d), Zo(g))) throw g;
                  return g;
                }),
                (Ui.times = function (t, e) {
                  if ((t = ma(t)) < 1 || t > f) return [];
                  var i = g,
                    n = xi(t, g);
                  (e = ur(e)), (t -= g);
                  for (var s = Ze(n, e); ++i < t; ) e(i);
                  return s;
                }),
                (Ui.toFinite = fa),
                (Ui.toInteger = ma),
                (Ui.toLength = ga),
                (Ui.toLower = function (t) {
                  return xa(t).toLowerCase();
                }),
                (Ui.toNumber = va),
                (Ui.toSafeInteger = function (t) {
                  return t ? ln(ma(t), -9007199254740991, f) : 0 === t ? t : 0;
                }),
                (Ui.toString = xa),
                (Ui.toUpper = function (t) {
                  return xa(t).toUpperCase();
                }),
                (Ui.trim = function (t, e, i) {
                  if ((t = xa(t)) && (i || e === s)) return Qe(t);
                  if (!t || !(e = hs(e))) return t;
                  var n = fi(t),
                    r = fi(e);
                  return Cs(n, ii(n, r), ni(n, r) + 1).join("");
                }),
                (Ui.trimEnd = function (t, e, i) {
                  if ((t = xa(t)) && (i || e === s))
                    return t.slice(0, mi(t) + 1);
                  if (!t || !(e = hs(e))) return t;
                  var n = fi(t);
                  return Cs(n, 0, ni(n, fi(e)) + 1).join("");
                }),
                (Ui.trimStart = function (t, e, i) {
                  if ((t = xa(t)) && (i || e === s)) return t.replace(ot, "");
                  if (!t || !(e = hs(e))) return t;
                  var n = fi(t);
                  return Cs(n, ii(n, fi(e))).join("");
                }),
                (Ui.truncate = function (t, e) {
                  var i = 30,
                    n = "...";
                  if (ea(e)) {
                    var r = "separator" in e ? e.separator : r;
                    (i = "length" in e ? ma(e.length) : i),
                      (n = "omission" in e ? hs(e.omission) : n);
                  }
                  var o = (t = xa(t)).length;
                  if (ai(t)) {
                    var a = fi(t);
                    o = a.length;
                  }
                  if (i >= o) return t;
                  var l = i - pi(n);
                  if (l < 1) return n;
                  var u = a ? Cs(a, 0, l).join("") : t.slice(0, l);
                  if (r === s) return u + n;
                  if ((a && (l += u.length - l), oa(r))) {
                    if (t.slice(l).search(r)) {
                      var h,
                        c = u;
                      for (
                        r.global || (r = kt(r.source, xa(mt.exec(r)) + "g")),
                          r.lastIndex = 0;
                        (h = r.exec(c));

                      )
                        var d = h.index;
                      u = u.slice(0, d === s ? l : d);
                    }
                  } else if (t.indexOf(hs(r), l) != l) {
                    var p = u.lastIndexOf(r);
                    p > -1 && (u = u.slice(0, p));
                  }
                  return u + n;
                }),
                (Ui.unescape = function (t) {
                  return (t = xa(t)) && K.test(t) ? t.replace(X, gi) : t;
                }),
                (Ui.uniqueId = function (t) {
                  var e = ++zt;
                  return xa(t) + e;
                }),
                (Ui.upperCase = Ka),
                (Ui.upperFirst = Za),
                (Ui.each = xo),
                (Ui.eachRight = bo),
                (Ui.first = qr),
                ll(
                  Ui,
                  ((Cl = {}),
                  Sn(Ui, function (t, e) {
                    Ot.call(Ui.prototype, e) || (Cl[e] = t);
                  }),
                  Cl),
                  { chain: !1 }
                ),
                (Ui.VERSION = "4.17.21"),
                Me(
                  [
                    "bind",
                    "bindKey",
                    "curry",
                    "curryRight",
                    "partial",
                    "partialRight",
                  ],
                  function (t) {
                    Ui[t].placeholder = Ui;
                  }
                ),
                Me(["drop", "take"], function (t, e) {
                  (ji.prototype[t] = function (i) {
                    i = i === s ? 1 : yi(ma(i), 0);
                    var n =
                      this.__filtered__ && !e ? new ji(this) : this.clone();
                    return (
                      n.__filtered__
                        ? (n.__takeCount__ = xi(i, n.__takeCount__))
                        : n.__views__.push({
                            size: xi(i, g),
                            type: t + (n.__dir__ < 0 ? "Right" : ""),
                          }),
                      n
                    );
                  }),
                    (ji.prototype[t + "Right"] = function (e) {
                      return this.reverse()[t](e).reverse();
                    });
                }),
                Me(["filter", "map", "takeWhile"], function (t, e) {
                  var i = e + 1,
                    n = 1 == i || 3 == i;
                  ji.prototype[t] = function (t) {
                    var e = this.clone();
                    return (
                      e.__iteratees__.push({ iteratee: ur(t, 3), type: i }),
                      (e.__filtered__ = e.__filtered__ || n),
                      e
                    );
                  };
                }),
                Me(["head", "last"], function (t, e) {
                  var i = "take" + (e ? "Right" : "");
                  ji.prototype[t] = function () {
                    return this[i](1).value()[0];
                  };
                }),
                Me(["initial", "tail"], function (t, e) {
                  var i = "drop" + (e ? "" : "Right");
                  ji.prototype[t] = function () {
                    return this.__filtered__ ? new ji(this) : this[i](1);
                  };
                }),
                (ji.prototype.compact = function () {
                  return this.filter(sl);
                }),
                (ji.prototype.find = function (t) {
                  return this.filter(t).head();
                }),
                (ji.prototype.findLast = function (t) {
                  return this.reverse().find(t);
                }),
                (ji.prototype.invokeMap = Zn(function (t, e) {
                  return "function" == typeof t
                    ? new ji(this)
                    : this.map(function (i) {
                        return In(i, t, e);
                      });
                })),
                (ji.prototype.reject = function (t) {
                  return this.filter(Oo(ur(t)));
                }),
                (ji.prototype.slice = function (t, e) {
                  t = ma(t);
                  var i = this;
                  return i.__filtered__ && (t > 0 || e < 0)
                    ? new ji(i)
                    : (t < 0 ? (i = i.takeRight(-t)) : t && (i = i.drop(t)),
                      e !== s &&
                        (i = (e = ma(e)) < 0 ? i.dropRight(-e) : i.take(e - t)),
                      i);
                }),
                (ji.prototype.takeRightWhile = function (t) {
                  return this.reverse().takeWhile(t).reverse();
                }),
                (ji.prototype.toArray = function () {
                  return this.take(g);
                }),
                Sn(ji.prototype, function (t, e) {
                  var i = /^(?:filter|find|map|reject)|While$/.test(e),
                    n = /^(?:head|last)$/.test(e),
                    r = Ui[n ? "take" + ("last" == e ? "Right" : "") : e],
                    o = n || /^find/.test(e);
                  r &&
                    (Ui.prototype[e] = function () {
                      var e = this.__wrapped__,
                        a = n ? [1] : arguments,
                        l = e instanceof ji,
                        u = a[0],
                        h = l || $o(e),
                        c = function (t) {
                          var e = r.apply(Ui, Oe([t], a));
                          return n && d ? e[0] : e;
                        };
                      h &&
                        i &&
                        "function" == typeof u &&
                        1 != u.length &&
                        (l = h = !1);
                      var d = this.__chain__,
                        p = !!this.__actions__.length,
                        f = o && !d,
                        m = l && !p;
                      if (!o && h) {
                        e = m ? e : new ji(this);
                        var g = t.apply(e, a);
                        return (
                          g.__actions__.push({
                            func: fo,
                            args: [c],
                            thisArg: s,
                          }),
                          new Vi(g, d)
                        );
                      }
                      return f && m
                        ? t.apply(this, a)
                        : ((g = this.thru(c)),
                          f ? (n ? g.value()[0] : g.value()) : g);
                    });
                }),
                Me(
                  ["pop", "push", "shift", "sort", "splice", "unshift"],
                  function (t) {
                    var e = It[t],
                      i = /^(?:push|sort|unshift)$/.test(t) ? "tap" : "thru",
                      n = /^(?:pop|shift)$/.test(t);
                    Ui.prototype[t] = function () {
                      var t = arguments;
                      if (n && !this.__chain__) {
                        var s = this.value();
                        return e.apply($o(s) ? s : [], t);
                      }
                      return this[i](function (i) {
                        return e.apply($o(i) ? i : [], t);
                      });
                    };
                  }
                ),
                Sn(ji.prototype, function (t, e) {
                  var i = Ui[e];
                  if (i) {
                    var n = i.name + "";
                    Ot.call(Ii, n) || (Ii[n] = []),
                      Ii[n].push({ name: e, func: i });
                  }
                }),
                (Ii[Ns(s, 2).name] = [{ name: "wrapper", func: s }]),
                (ji.prototype.clone = function () {
                  var t = new ji(this.__wrapped__);
                  return (
                    (t.__actions__ = Es(this.__actions__)),
                    (t.__dir__ = this.__dir__),
                    (t.__filtered__ = this.__filtered__),
                    (t.__iteratees__ = Es(this.__iteratees__)),
                    (t.__takeCount__ = this.__takeCount__),
                    (t.__views__ = Es(this.__views__)),
                    t
                  );
                }),
                (ji.prototype.reverse = function () {
                  if (this.__filtered__) {
                    var t = new ji(this);
                    (t.__dir__ = -1), (t.__filtered__ = !0);
                  } else (t = this.clone()).__dir__ *= -1;
                  return t;
                }),
                (ji.prototype.value = function () {
                  var t = this.__wrapped__.value(),
                    e = this.__dir__,
                    i = $o(t),
                    n = e < 0,
                    s = i ? t.length : 0,
                    r = (function (t, e, i) {
                      var n = -1,
                        s = i.length;
                      for (; ++n < s; ) {
                        var r = i[n],
                          o = r.size;
                        switch (r.type) {
                          case "drop":
                            t += o;
                            break;
                          case "dropRight":
                            e -= o;
                            break;
                          case "take":
                            e = xi(e, t + o);
                            break;
                          case "takeRight":
                            t = yi(t, e - o);
                        }
                      }
                      return { start: t, end: e };
                    })(0, s, this.__views__),
                    o = r.start,
                    a = r.end,
                    l = a - o,
                    u = n ? a : o - 1,
                    h = this.__iteratees__,
                    c = h.length,
                    d = 0,
                    p = xi(l, this.__takeCount__);
                  if (!i || (!n && s == l && p == l))
                    return ms(t, this.__actions__);
                  var f = [];
                  t: for (; l-- && d < p; ) {
                    for (var m = -1, g = t[(u += e)]; ++m < c; ) {
                      var v = h[m],
                        y = v.iteratee,
                        x = v.type,
                        b = y(g);
                      if (2 == x) g = b;
                      else if (!b) {
                        if (1 == x) continue t;
                        break t;
                      }
                    }
                    f[d++] = g;
                  }
                  return f;
                }),
                (Ui.prototype.at = mo),
                (Ui.prototype.chain = function () {
                  return po(this);
                }),
                (Ui.prototype.commit = function () {
                  return new Vi(this.value(), this.__chain__);
                }),
                (Ui.prototype.next = function () {
                  this.__values__ === s && (this.__values__ = pa(this.value()));
                  var t = this.__index__ >= this.__values__.length;
                  return {
                    done: t,
                    value: t ? s : this.__values__[this.__index__++],
                  };
                }),
                (Ui.prototype.plant = function (t) {
                  for (var e, i = this; i instanceof Gi; ) {
                    var n = Hr(i);
                    (n.__index__ = 0),
                      (n.__values__ = s),
                      e ? (r.__wrapped__ = n) : (e = n);
                    var r = n;
                    i = i.__wrapped__;
                  }
                  return (r.__wrapped__ = t), e;
                }),
                (Ui.prototype.reverse = function () {
                  var t = this.__wrapped__;
                  if (t instanceof ji) {
                    var e = t;
                    return (
                      this.__actions__.length && (e = new ji(this)),
                      (e = e.reverse()).__actions__.push({
                        func: fo,
                        args: [to],
                        thisArg: s,
                      }),
                      new Vi(e, this.__chain__)
                    );
                  }
                  return this.thru(to);
                }),
                (Ui.prototype.toJSON =
                  Ui.prototype.valueOf =
                  Ui.prototype.value =
                    function () {
                      return ms(this.__wrapped__, this.__actions__);
                    }),
                (Ui.prototype.first = Ui.prototype.head),
                Qt &&
                  (Ui.prototype[Qt] = function () {
                    return this;
                  }),
                Ui
              );
            })();
            (me._ = vi),
              (n = function () {
                return vi;
              }.call(e, i, e, t)) === s || (t.exports = n);
          }.call(this);
      },
      8133: (t) => {
        t.exports = function (t) {
          var s = [];
          return (
            t.replace(i, function (t, i, r) {
              var o = i.toLowerCase();
              for (
                r = (function (t) {
                  var e = t.match(n);
                  return e ? e.map(Number) : [];
                })(r),
                  "m" == o &&
                    r.length > 2 &&
                    (s.push([i].concat(r.splice(0, 2))),
                    (o = "l"),
                    (i = "m" == i ? "l" : "L"));
                ;

              ) {
                if (r.length == e[o]) return r.unshift(i), s.push(r);
                if (r.length < e[o]) throw new Error("malformed path data");
                s.push([i].concat(r.splice(0, e[o])));
              }
            }),
            s
          );
        };
        var e = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 },
          i = /([astvzqmhlc])([^astvzqmhlc]*)/gi;
        var n = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/gi;
      },
      8343: function (t, e) {
        var i, n, s;
        !(function (r, o) {
          "use strict";
          (n = []),
            void 0 ===
              (s =
                "function" ==
                typeof (i = function (t) {
                  return function (e) {
                    var i = "3.4.4";
                    function n() {
                      (e.arrayAccessForm = e.arrayAccessForm || "none"),
                        (e.emptyNodeForm = e.emptyNodeForm || "text"),
                        (e.jsAttributeFilter = e.jsAttributeFilter),
                        (e.jsAttributeConverter = e.jsAttributeConverter),
                        (e.attributeConverters = e.attributeConverters || []),
                        (e.datetimeAccessFormPaths =
                          e.datetimeAccessFormPaths || []),
                        (e.arrayAccessFormPaths = e.arrayAccessFormPaths || []),
                        (e.xmldomOptions = e.xmldomOptions || {}),
                        void 0 === e.enableToStringFunc &&
                          (e.enableToStringFunc = !0),
                        void 0 === e.skipEmptyTextNodesForObj &&
                          (e.skipEmptyTextNodesForObj = !0),
                        void 0 === e.stripWhitespaces &&
                          (e.stripWhitespaces = !0),
                        void 0 === e.useDoubleQuotes &&
                          (e.useDoubleQuotes = !0),
                        void 0 === e.ignoreRoot && (e.ignoreRoot = !1),
                        void 0 === e.escapeMode && (e.escapeMode = !0),
                        void 0 === e.attributePrefix &&
                          (e.attributePrefix = "_"),
                        void 0 === e.selfClosingElements &&
                          (e.selfClosingElements = !0),
                        void 0 === e.keepCData && (e.keepCData = !1),
                        void 0 === e.keepText && (e.keepText = !1),
                        void 0 === e.jsDateUTC && (e.jsDateUTC = !1);
                    }
                    function s() {
                      function t(t) {
                        var e = String(t);
                        return 1 === e.length && (e = "0" + e), e;
                      }
                      "function" != typeof String.prototype.trim &&
                        (String.prototype.trim = function () {
                          return this.replace(/^\s+|^\n+|(\s|\n)+$/g, "");
                        }),
                        "function" != typeof Date.prototype.toISOString &&
                          (Date.prototype.toISOString = function () {
                            var e = 1e3;
                            return (
                              this.getUTCFullYear() +
                              "-" +
                              t(this.getUTCMonth() + 1) +
                              "-" +
                              t(this.getUTCDate()) +
                              "T" +
                              t(this.getUTCHours()) +
                              ":" +
                              t(this.getUTCMinutes()) +
                              ":" +
                              t(this.getUTCSeconds()) +
                              "." +
                              String(
                                (this.getUTCMilliseconds() / e).toFixed(3)
                              ).slice(2, 5) +
                              "Z"
                            );
                          });
                    }
                    (e = e || {}), n(), s();
                    var r = {
                      ELEMENT_NODE: 1,
                      TEXT_NODE: 3,
                      CDATA_SECTION_NODE: 4,
                      COMMENT_NODE: 8,
                      DOCUMENT_NODE: 9,
                    };
                    function o(t) {
                      var e = t.localName;
                      return (
                        null == e && (e = t.baseName),
                        (null != e && "" !== e) || (e = t.nodeName),
                        e
                      );
                    }
                    function a(t) {
                      return t.prefix;
                    }
                    function l(t) {
                      return "string" == typeof t
                        ? t
                            .replace(/&/g, "&amp;")
                            .replace(/</g, "&lt;")
                            .replace(/>/g, "&gt;")
                            .replace(/"/g, "&quot;")
                            .replace(/'/g, "&#x27;")
                        : t;
                    }
                    function u(t) {
                      return t
                        .replace(/&lt;/g, "<")
                        .replace(/&gt;/g, ">")
                        .replace(/&quot;/g, '"')
                        .replace(/&#x27;/g, "'")
                        .replace(/&amp;/g, "&");
                    }
                    function h(t, i, n) {
                      if ("property" === e.arrayAccessForm)
                        t[i] instanceof Array
                          ? (t[i + "_asArray"] = t[i])
                          : (t[i + "_asArray"] = [t[i]]);
                      if (
                        !(t[i] instanceof Array) &&
                        e.arrayAccessFormPaths.length > 0
                      ) {
                        for (
                          var s = !1, r = 0;
                          r < e.arrayAccessFormPaths.length;
                          r++
                        ) {
                          var o = e.arrayAccessFormPaths[r];
                          if ("string" == typeof o) {
                            if (o === n) {
                              s = !0;
                              break;
                            }
                          } else if (o instanceof RegExp) {
                            if (o.test(n)) {
                              s = !0;
                              break;
                            }
                          } else if ("function" == typeof o && o(i, n)) {
                            s = !0;
                            break;
                          }
                        }
                        s && (t[i] = [t[i]]);
                      }
                    }
                    function c(t) {
                      var e = 60,
                        i = t.split(/[-T:+Z]/g),
                        n = new Date(i[0], i[1] - 1, i[2]),
                        s = i[5].split(".");
                      if (
                        (n.setHours(i[3], i[4], s[0]),
                        s.length > 1 && n.setMilliseconds(s[1]),
                        i[6] && i[7])
                      ) {
                        var r = i[6] * e + Number(i[7]);
                        (r =
                          0 +
                          ("-" === (/\d\d-\d\d:\d\d$/.test(t) ? "-" : "+")
                            ? -1 * r
                            : r)),
                          n.setMinutes(
                            n.getMinutes() - r - n.getTimezoneOffset()
                          );
                      } else
                        -1 !== t.indexOf("Z", t.length - 1) &&
                          (n = new Date(
                            Date.UTC(
                              n.getFullYear(),
                              n.getMonth(),
                              n.getDate(),
                              n.getHours(),
                              n.getMinutes(),
                              n.getSeconds(),
                              n.getMilliseconds()
                            )
                          ));
                      return n;
                    }
                    function d(t, i, n) {
                      if (e.datetimeAccessFormPaths.length > 0)
                        for (
                          var s = n.split(".#")[0], r = 0;
                          r < e.datetimeAccessFormPaths.length;
                          r++
                        ) {
                          var o = e.datetimeAccessFormPaths[r];
                          if ("string" == typeof o) {
                            if (o === s) return c(t);
                          } else if (o instanceof RegExp) {
                            if (o.test(s)) return c(t);
                          } else if ("function" == typeof o && o(s))
                            return c(t);
                        }
                      return t;
                    }
                    function p(t) {
                      for (
                        var i = {}, n = t.childNodes, s = 0;
                        s < n.length;
                        s++
                      ) {
                        var a = n.item(s);
                        if (a.nodeType === r.ELEMENT_NODE) {
                          var l = o(a);
                          e.ignoreRoot ? (i = m(a, l)) : (i[l] = m(a, l));
                        }
                      }
                      return i;
                    }
                    function f(t, i) {
                      for (
                        var n = { __cnt: 0 }, s = t.childNodes, l = 0;
                        l < s.length;
                        l++
                      ) {
                        var c = s.item(l),
                          p = o(c);
                        c.nodeType !== r.COMMENT_NODE &&
                          (n.__cnt++,
                          null == n[p]
                            ? ((n[p] = m(c, i + "." + p)), h(n, p, i + "." + p))
                            : (n[p] instanceof Array ||
                                ((n[p] = [n[p]]), h(n, p, i + "." + p)),
                              (n[p][n[p].length] = m(c, i + "." + p))));
                      }
                      for (var f = 0; f < t.attributes.length; f++) {
                        var g = t.attributes.item(f);
                        n.__cnt++;
                        for (
                          var v = g.value, y = 0;
                          y < e.attributeConverters.length;
                          y++
                        ) {
                          var x = e.attributeConverters[y];
                          x.test.call(null, g.name, g.value) &&
                            (v = x.convert.call(null, g.name, g.value));
                        }
                        n[e.attributePrefix + g.name] = v;
                      }
                      var b = a(t);
                      return (
                        b && (n.__cnt++, (n.__prefix = b)),
                        n["#text"] &&
                          ((n.__text = n["#text"]),
                          n.__text instanceof Array &&
                            (n.__text = n.__text.join("\n")),
                          e.escapeMode && (n.__text = u(n.__text)),
                          e.stripWhitespaces && (n.__text = n.__text.trim()),
                          delete n["#text"],
                          "property" === e.arrayAccessForm &&
                            delete n["#text_asArray"],
                          (n.__text = d(n.__text, "#text", i + ".#text"))),
                        n.hasOwnProperty("#cdata-section") &&
                          ((n.__cdata = n["#cdata-section"]),
                          delete n["#cdata-section"],
                          "property" === e.arrayAccessForm &&
                            delete n["#cdata-section_asArray"]),
                        1 === n.__cnt && n.__text && !e.keepText
                          ? (n = n.__text)
                          : 0 === n.__cnt && "text" === e.emptyNodeForm
                          ? (n = "")
                          : n.__cnt > 1 &&
                            void 0 !== n.__text &&
                            e.skipEmptyTextNodesForObj &&
                            ((e.stripWhitespaces && "" === n.__text) ||
                              "" === n.__text.trim()) &&
                            delete n.__text,
                        delete n.__cnt,
                        e.keepCData ||
                        n.hasOwnProperty("__text") ||
                        !n.hasOwnProperty("__cdata") ||
                        1 !== Object.keys(n).length
                          ? (e.enableToStringFunc &&
                              (n.__text || n.__cdata) &&
                              (n.toString = function () {
                                return (
                                  (this.__text ? this.__text : "") +
                                  (this.__cdata ? this.__cdata : "")
                                );
                              }),
                            n)
                          : n.__cdata
                          ? n.__cdata
                          : ""
                      );
                    }
                    function m(t, e) {
                      return t.nodeType === r.DOCUMENT_NODE
                        ? p(t)
                        : t.nodeType === r.ELEMENT_NODE
                        ? f(t, e)
                        : t.nodeType === r.TEXT_NODE ||
                          t.nodeType === r.CDATA_SECTION_NODE
                        ? t.nodeValue
                        : null;
                    }
                    function g(t, i, n, s) {
                      var r =
                        "<" + (t && t.__prefix ? t.__prefix + ":" : "") + i;
                      if (n)
                        for (var o = 0; o < n.length; o++) {
                          var a = n[o],
                            u = t[a];
                          e.escapeMode && (u = l(u)),
                            (r +=
                              " " + a.substr(e.attributePrefix.length) + "="),
                            e.useDoubleQuotes
                              ? (r += '"' + u + '"')
                              : (r += "'" + u + "'");
                        }
                      return (r += s ? " />" : ">");
                    }
                    function v(t, e) {
                      return (
                        "</" +
                        (t && t.__prefix ? t.__prefix + ":" : "") +
                        e +
                        ">"
                      );
                    }
                    function y(t, e) {
                      return -1 !== t.indexOf(e, t.length - e.length);
                    }
                    function x(t, i) {
                      return !!(
                        ("property" === e.arrayAccessForm &&
                          y(i.toString(), "_asArray")) ||
                        0 === i.toString().indexOf(e.attributePrefix) ||
                        0 === i.toString().indexOf("__") ||
                        t[i] instanceof Function
                      );
                    }
                    function b(t) {
                      var e = 0;
                      if (t instanceof Object) for (var i in t) x(t, i) || e++;
                      return e;
                    }
                    function S(t) {
                      var i = [];
                      if (t instanceof Object)
                        for (var n in t)
                          -1 === n.toString().indexOf("__") &&
                            0 === n.toString().indexOf(e.attributePrefix) &&
                            i.push(n);
                      return i;
                    }
                    function C(t) {
                      var i = "";
                      return (
                        t.__cdata && (i += "<![CDATA[" + t.__cdata + "]]>"),
                        (t.__text ||
                          "number" == typeof t.__text ||
                          "boolean" == typeof t.__text) &&
                          (e.escapeMode ? (i += l(t.__text)) : (i += t.__text)),
                        i
                      );
                    }
                    function _(t) {
                      var i = "";
                      return (
                        t instanceof Object
                          ? (i += C(t))
                          : null !== t &&
                            (e.escapeMode ? (i += l(t)) : (i += t)),
                        i
                      );
                    }
                    function T(t, e, i) {
                      var n = "";
                      if (0 === t.length) n += g(t, e, i, !0);
                      else
                        for (var s = 0; s < t.length; s++)
                          n += w(t[s], e, S(t[s]));
                      return n;
                    }
                    function w(t, i, n) {
                      var s = "";
                      if (
                        e.jsAttributeFilter &&
                        e.jsAttributeFilter.call(null, i, t)
                      )
                        return s;
                      if (
                        (e.jsAttributeConverter &&
                          (t = e.jsAttributeConverter.call(null, i, t)),
                        (null != t && "" !== t) || !e.selfClosingElements)
                      )
                        if ("object" == typeof t)
                          if (
                            "[object Array]" ===
                            Object.prototype.toString.call(t)
                          )
                            s += T(t, i, n);
                          else if (t instanceof Date)
                            (s += g(t, i, n, !1)),
                              (s += e.jsDateUTC
                                ? t.toUTCString()
                                : t.toISOString()),
                              (s += v(t, i));
                          else {
                            b(t) > 0 ||
                            "number" == typeof t.__text ||
                            "boolean" == typeof t.__text ||
                            t.__text ||
                            t.__cdata
                              ? ((s += g(t, i, n, !1)),
                                (s += P(t)),
                                (s += v(t, i)))
                              : e.selfClosingElements
                              ? (s += g(t, i, n, !0))
                              : ((s += g(t, i, n, !1)), (s += v(t, i)));
                          }
                        else (s += g(t, i, n, !1)), (s += _(t)), (s += v(t, i));
                      else s += g(t, i, n, !0);
                      return s;
                    }
                    function P(t) {
                      var e = "";
                      if (b(t) > 0)
                        for (var i in t)
                          if (!x(t, i)) {
                            var n = t[i];
                            e += w(n, i, S(n));
                          }
                      return (e += _(t));
                    }
                    function A(i) {
                      if (void 0 === i) return null;
                      if ("string" != typeof i) return null;
                      var n = null,
                        s = null;
                      if (t)
                        s = (n = new t(e.xmldomOptions)).parseFromString(
                          i,
                          "text/xml"
                        );
                      else if (window && window.DOMParser) {
                        n = new window.DOMParser();
                        var r = null;
                        if (
                          !(
                            window.ActiveXObject || "ActiveXObject" in window
                          ) &&
                          document.all &&
                          !document.addEventListener
                        )
                          try {
                            r = n.parseFromString("INVALID", "text/xml")
                              .childNodes[0].namespaceURI;
                          } catch (t) {
                            r = null;
                          }
                        try {
                          (s = n.parseFromString(i, "text/xml")),
                            null !== r &&
                              s.getElementsByTagNameNS(r, "parsererror")
                                .length > 0 &&
                              (s = null);
                        } catch (t) {
                          s = null;
                        }
                      } else
                        0 === i.indexOf("<?") &&
                          (i = i.substr(i.indexOf("?>") + 2)),
                          ((s = new ActiveXObject("Microsoft.XMLDOM")).async =
                            "false"),
                          s.loadXML(i);
                      return s;
                    }
                    (this.asArray = function (t) {
                      return null == t ? [] : t instanceof Array ? t : [t];
                    }),
                      (this.toXmlDateTime = function (t) {
                        return t instanceof Date
                          ? t.toISOString()
                          : "number" == typeof t
                          ? new Date(t).toISOString()
                          : null;
                      }),
                      (this.asDateTime = function (t) {
                        return "string" == typeof t ? c(t) : t;
                      }),
                      (this.xml2dom = function (t) {
                        return A(t);
                      }),
                      (this.dom2js = function (t) {
                        return m(t, null);
                      }),
                      (this.js2dom = function (t) {
                        return A(this.js2xml(t));
                      }),
                      (this.xml2js = function (t) {
                        var e = A(t);
                        return null != e ? this.dom2js(e) : null;
                      }),
                      (this.js2xml = function (t) {
                        return P(t);
                      }),
                      (this.getVersion = function () {
                        return i;
                      });
                  };
                })
                  ? i.apply(e, n)
                  : i) || (t.exports = s);
        })();
      },
      4486: (t, e, i) => {
        "use strict";
        i.d(e, { A: () => n });
        const n = i(228);
      },
      1979: (t, e, i) => {
        "use strict";
        i.d(e, { l: () => r });
        var n = i(268),
          s = i(2406);
        const r = new (class {
          constructor() {
            (this._parsers = []),
              (this._cache = new Map()),
              (this._cacheMap = new Map());
          }
          reset() {
            this._cacheMap.clear(), this._cache.clear();
          }
          has(t) {
            return this._cache.has(t);
          }
          get(t) {
            const e = this._cache.get(t);
            return (
              e ||
                (0, n.R)(`[Assets] Asset id ${t} was not found in the Cache`),
              e
            );
          }
          set(t, e) {
            const i = (0, s.z)(t);
            let r;
            for (let t = 0; t < this.parsers.length; t++) {
              const n = this.parsers[t];
              if (n.test(e)) {
                r = n.getCacheableAssets(i, e);
                break;
              }
            }
            const o = new Map(Object.entries(r || {}));
            r ||
              i.forEach((t) => {
                o.set(t, e);
              });
            const a = [...o.keys()],
              l = { cacheKeys: a, keys: i };
            i.forEach((t) => {
              this._cacheMap.set(t, l);
            }),
              a.forEach((t) => {
                const i = r ? r[t] : e;
                this._cache.has(t) &&
                  this._cache.get(t) !== i &&
                  (0, n.R)("[Cache] already has key:", t),
                  this._cache.set(t, o.get(t));
              });
          }
          remove(t) {
            if (!this._cacheMap.has(t))
              return void (0, n.R)(
                `[Assets] Asset id ${t} was not found in the Cache`
              );
            const e = this._cacheMap.get(t);
            e.cacheKeys.forEach((t) => {
              this._cache.delete(t);
            }),
              e.keys.forEach((t) => {
                this._cacheMap.delete(t);
              });
          }
          get parsers() {
            return this._parsers;
          }
        })();
      },
      4589: (t, e, i) => {
        "use strict";
        i.d(e, { T: () => n });
        var n = ((t) => (
          (t[(t.Low = 0)] = "Low"),
          (t[(t.Normal = 1)] = "Normal"),
          (t[(t.High = 2)] = "High"),
          t
        ))(n || {});
      },
      1173: (t, e, i) => {
        "use strict";
        i.d(e, { x: () => u });
        var n = i(268),
          s = i(2927),
          r = i(2406);
        function o(t, e, i, n, s) {
          const r = e[i];
          for (let a = 0; a < r.length; a++) {
            const l = r[a];
            i < e.length - 1
              ? o(t.replace(n[i], l), e, i + 1, n, s)
              : s.push(t.replace(n[i], l));
          }
        }
        function a(t) {
          const e = t.match(/\{(.*?)\}/g),
            i = [];
          if (e) {
            const n = [];
            e.forEach((t) => {
              const e = t.substring(1, t.length - 1).split(",");
              n.push(e);
            }),
              o(t, n, 0, e, i);
          } else i.push(t);
          return i;
        }
        var l = i(2217);
        class u {
          constructor() {
            (this._defaultBundleIdentifierOptions = {
              connector: "-",
              createBundleAssetId: (t, e) =>
                `${t}${this._bundleIdConnector}${e}`,
              extractAssetIdFromBundle: (t, e) =>
                e.replace(`${t}${this._bundleIdConnector}`, ""),
            }),
              (this._bundleIdConnector =
                this._defaultBundleIdentifierOptions.connector),
              (this._createBundleAssetId =
                this._defaultBundleIdentifierOptions.createBundleAssetId),
              (this._extractAssetIdFromBundle =
                this._defaultBundleIdentifierOptions.extractAssetIdFromBundle),
              (this._assetMap = {}),
              (this._preferredOrder = []),
              (this._parsers = []),
              (this._resolverHash = {}),
              (this._bundles = {});
          }
          setBundleIdentifier(t) {
            if (
              ((this._bundleIdConnector =
                t.connector ?? this._bundleIdConnector),
              (this._createBundleAssetId =
                t.createBundleAssetId ?? this._createBundleAssetId),
              (this._extractAssetIdFromBundle =
                t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle),
              "bar" !==
                this._extractAssetIdFromBundle(
                  "foo",
                  this._createBundleAssetId("foo", "bar")
                ))
            )
              throw new Error(
                "[Resolver] GenerateBundleAssetId are not working correctly"
              );
          }
          prefer(...t) {
            t.forEach((t) => {
              this._preferredOrder.push(t),
                t.priority || (t.priority = Object.keys(t.params));
            }),
              (this._resolverHash = {});
          }
          set basePath(t) {
            this._basePath = t;
          }
          get basePath() {
            return this._basePath;
          }
          set rootPath(t) {
            this._rootPath = t;
          }
          get rootPath() {
            return this._rootPath;
          }
          get parsers() {
            return this._parsers;
          }
          reset() {
            this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
              (this._assetMap = {}),
              (this._preferredOrder = []),
              (this._resolverHash = {}),
              (this._rootPath = null),
              (this._basePath = null),
              (this._manifest = null),
              (this._bundles = {}),
              (this._defaultSearchParams = null);
          }
          setDefaultSearchParams(t) {
            if ("string" == typeof t) this._defaultSearchParams = t;
            else {
              const e = t;
              this._defaultSearchParams = Object.keys(e)
                .map(
                  (t) => `${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`
                )
                .join("&");
            }
          }
          getAlias(t) {
            const { alias: e, src: i } = t;
            return (0, r.z)(
              e || i,
              (t) =>
                "string" == typeof t
                  ? t
                  : Array.isArray(t)
                  ? t.map((t) => t?.src ?? t)
                  : t?.src
                  ? t.src
                  : t,
              !0
            );
          }
          addManifest(t) {
            this._manifest &&
              (0, n.R)(
                "[Resolver] Manifest already exists, this will be overwritten"
              ),
              (this._manifest = t),
              t.bundles.forEach((t) => {
                this.addBundle(t.name, t.assets);
              });
          }
          addBundle(t, e) {
            const i = [];
            let n = e;
            Array.isArray(e) ||
              (n = Object.entries(e).map(([t, e]) =>
                "string" == typeof e || Array.isArray(e)
                  ? { alias: t, src: e }
                  : { alias: t, ...e }
              )),
              n.forEach((e) => {
                const n = e.src,
                  s = e.alias;
                let r;
                if ("string" == typeof s) {
                  const e = this._createBundleAssetId(t, s);
                  i.push(e), (r = [s, e]);
                } else {
                  const e = s.map((e) => this._createBundleAssetId(t, e));
                  i.push(...e), (r = [...s, ...e]);
                }
                this.add({ ...e, alias: r, src: n });
              }),
              (this._bundles[t] = i);
          }
          add(t) {
            const e = [];
            let i;
            Array.isArray(t) ? e.push(...t) : e.push(t),
              (i = (t) => {
                this.hasKey(t) &&
                  (0, n.R)(`[Resolver] already has key: ${t} overwriting`);
              });
            (0, r.z)(e).forEach((t) => {
              const { src: e } = t;
              let { data: n, format: s, loadParser: o } = t;
              const l = (0, r.z)(e).map((t) =>
                  "string" == typeof t ? a(t) : Array.isArray(t) ? t : [t]
                ),
                u = this.getAlias(t);
              Array.isArray(u) ? u.forEach(i) : i(u);
              const h = [];
              l.forEach((t) => {
                t.forEach((t) => {
                  let e = {};
                  if ("object" != typeof t) {
                    e.src = t;
                    for (let i = 0; i < this._parsers.length; i++) {
                      const n = this._parsers[i];
                      if (n.test(t)) {
                        e = n.parse(t);
                        break;
                      }
                    }
                  } else
                    (n = t.data ?? n),
                      (s = t.format ?? s),
                      (o = t.loadParser ?? o),
                      (e = { ...e, ...t });
                  if (!u)
                    throw new Error(
                      `[Resolver] alias is undefined for this asset: ${e.src}`
                    );
                  (e = this._buildResolvedAsset(e, {
                    aliases: u,
                    data: n,
                    format: s,
                    loadParser: o,
                  })),
                    h.push(e);
                });
              }),
                u.forEach((t) => {
                  this._assetMap[t] = h;
                });
            });
          }
          resolveBundle(t) {
            const e = (0, l.a)(t);
            t = (0, r.z)(t);
            const i = {};
            return (
              t.forEach((t) => {
                const e = this._bundles[t];
                if (e) {
                  const n = this.resolve(e),
                    s = {};
                  for (const e in n) {
                    const i = n[e];
                    s[this._extractAssetIdFromBundle(t, e)] = i;
                  }
                  i[t] = s;
                }
              }),
              e ? i[t[0]] : i
            );
          }
          resolveUrl(t) {
            const e = this.resolve(t);
            if ("string" != typeof t) {
              const t = {};
              for (const i in e) t[i] = e[i].src;
              return t;
            }
            return e.src;
          }
          resolve(t) {
            const e = (0, l.a)(t);
            t = (0, r.z)(t);
            const i = {};
            return (
              t.forEach((t) => {
                if (!this._resolverHash[t])
                  if (this._assetMap[t]) {
                    let e = this._assetMap[t];
                    const i = this._getPreferredOrder(e);
                    i?.priority.forEach((t) => {
                      i.params[t].forEach((i) => {
                        const n = e.filter((e) => !!e[t] && e[t] === i);
                        n.length && (e = n);
                      });
                    }),
                      (this._resolverHash[t] = e[0]);
                  } else
                    this._resolverHash[t] = this._buildResolvedAsset(
                      { alias: [t], src: t },
                      {}
                    );
                i[t] = this._resolverHash[t];
              }),
              e ? i[t[0]] : i
            );
          }
          hasKey(t) {
            return !!this._assetMap[t];
          }
          hasBundle(t) {
            return !!this._bundles[t];
          }
          _getPreferredOrder(t) {
            for (let e = 0; e < t.length; e++) {
              const e = t[0],
                i = this._preferredOrder.find((t) =>
                  t.params.format.includes(e.format)
                );
              if (i) return i;
            }
            return this._preferredOrder[0];
          }
          _appendDefaultSearchParams(t) {
            if (!this._defaultSearchParams) return t;
            return `${t}${/\?/.test(t) ? "&" : "?"}${
              this._defaultSearchParams
            }`;
          }
          _buildResolvedAsset(t, e) {
            const { aliases: i, data: n, loadParser: r, format: o } = e;
            return (
              (this._basePath || this._rootPath) &&
                (t.src = s.A.toAbsolute(t.src, this._basePath, this._rootPath)),
              (t.alias = i ?? t.alias ?? [t.src]),
              (t.src = this._appendDefaultSearchParams(t.src)),
              (t.data = { ...(n || {}), ...t.data }),
              (t.loadParser = r ?? t.loadParser),
              (t.format =
                o ??
                t.format ??
                t.src.split(".").pop().split("?").shift().split("#").shift()),
              t
            );
          }
        }
        u.RETINA_PREFIX = /@([0-9\.]+)x/;
      },
      2406: (t, e, i) => {
        "use strict";
        i.d(e, { z: () => n });
        const n = (t, e, i = !1) => (
          Array.isArray(t) || (t = [t]),
          e ? t.map((t) => ("string" == typeof t || i ? e(t) : t)) : t
        );
      },
      2233: (t, e, i) => {
        "use strict";
        i.d(e, { Y: () => n });
        const n = (t, e) => {
          const i = e.split("?")[1];
          return i && (t += `?${i}`), t;
        };
      },
      2217: (t, e, i) => {
        "use strict";
        i.d(e, { a: () => n });
        const n = (t) => !Array.isArray(t);
      },
      2577: (t, e, i) => {
        "use strict";
        i.d(e, { Q: () => D });
        var n = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) },
          s = function (t) {
            return "string" == typeof t ? t.length > 0 : "number" == typeof t;
          },
          r = function (t, e, i) {
            return (
              void 0 === e && (e = 0),
              void 0 === i && (i = Math.pow(10, e)),
              Math.round(i * t) / i + 0
            );
          },
          o = function (t, e, i) {
            return (
              void 0 === e && (e = 0),
              void 0 === i && (i = 1),
              t > i ? i : t > e ? t : e
            );
          },
          a = function (t) {
            return (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360;
          },
          l = function (t) {
            return {
              r: o(t.r, 0, 255),
              g: o(t.g, 0, 255),
              b: o(t.b, 0, 255),
              a: o(t.a),
            };
          },
          u = function (t) {
            return { r: r(t.r), g: r(t.g), b: r(t.b), a: r(t.a, 3) };
          },
          h = /^#([0-9a-f]{3,8})$/i,
          c = function (t) {
            var e = t.toString(16);
            return e.length < 2 ? "0" + e : e;
          },
          d = function (t) {
            var e = t.r,
              i = t.g,
              n = t.b,
              s = t.a,
              r = Math.max(e, i, n),
              o = r - Math.min(e, i, n),
              a = o
                ? r === e
                  ? (i - n) / o
                  : r === i
                  ? 2 + (n - e) / o
                  : 4 + (e - i) / o
                : 0;
            return {
              h: 60 * (a < 0 ? a + 6 : a),
              s: r ? (o / r) * 100 : 0,
              v: (r / 255) * 100,
              a: s,
            };
          },
          p = function (t) {
            var e = t.h,
              i = t.s,
              n = t.v,
              s = t.a;
            (e = (e / 360) * 6), (i /= 100), (n /= 100);
            var r = Math.floor(e),
              o = n * (1 - i),
              a = n * (1 - (e - r) * i),
              l = n * (1 - (1 - e + r) * i),
              u = r % 6;
            return {
              r: 255 * [n, a, o, o, l, n][u],
              g: 255 * [l, n, n, a, o, o][u],
              b: 255 * [o, o, l, n, n, a][u],
              a: s,
            };
          },
          f = function (t) {
            return {
              h: a(t.h),
              s: o(t.s, 0, 100),
              l: o(t.l, 0, 100),
              a: o(t.a),
            };
          },
          m = function (t) {
            return { h: r(t.h), s: r(t.s), l: r(t.l), a: r(t.a, 3) };
          },
          g = function (t) {
            return p(
              ((i = (e = t).s),
              {
                h: e.h,
                s:
                  (i *= ((n = e.l) < 50 ? n : 100 - n) / 100) > 0
                    ? ((2 * i) / (n + i)) * 100
                    : 0,
                v: n + i,
                a: e.a,
              })
            );
            var e, i, n;
          },
          v = function (t) {
            return {
              h: (e = d(t)).h,
              s:
                (s = ((200 - (i = e.s)) * (n = e.v)) / 100) > 0 && s < 200
                  ? ((i * n) / 100 / (s <= 100 ? s : 200 - s)) * 100
                  : 0,
              l: s / 2,
              a: e.a,
            };
            var e, i, n, s;
          },
          y =
            /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
          x =
            /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
          b =
            /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
          S =
            /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
          C = {
            string: [
              [
                function (t) {
                  var e = h.exec(t);
                  return e
                    ? (t = e[1]).length <= 4
                      ? {
                          r: parseInt(t[0] + t[0], 16),
                          g: parseInt(t[1] + t[1], 16),
                          b: parseInt(t[2] + t[2], 16),
                          a:
                            4 === t.length
                              ? r(parseInt(t[3] + t[3], 16) / 255, 2)
                              : 1,
                        }
                      : 6 === t.length || 8 === t.length
                      ? {
                          r: parseInt(t.substr(0, 2), 16),
                          g: parseInt(t.substr(2, 2), 16),
                          b: parseInt(t.substr(4, 2), 16),
                          a:
                            8 === t.length
                              ? r(parseInt(t.substr(6, 2), 16) / 255, 2)
                              : 1,
                        }
                      : null
                    : null;
                },
                "hex",
              ],
              [
                function (t) {
                  var e = b.exec(t) || S.exec(t);
                  return e
                    ? e[2] !== e[4] || e[4] !== e[6]
                      ? null
                      : l({
                          r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                          g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                          b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                          a:
                            void 0 === e[7]
                              ? 1
                              : Number(e[7]) / (e[8] ? 100 : 1),
                        })
                    : null;
                },
                "rgb",
              ],
              [
                function (t) {
                  var e = y.exec(t) || x.exec(t);
                  if (!e) return null;
                  var i,
                    s,
                    r = f({
                      h:
                        ((i = e[1]),
                        (s = e[2]),
                        void 0 === s && (s = "deg"),
                        Number(i) * (n[s] || 1)),
                      s: Number(e[3]),
                      l: Number(e[4]),
                      a: void 0 === e[5] ? 1 : Number(e[5]) / (e[6] ? 100 : 1),
                    });
                  return g(r);
                },
                "hsl",
              ],
            ],
            object: [
              [
                function (t) {
                  var e = t.r,
                    i = t.g,
                    n = t.b,
                    r = t.a,
                    o = void 0 === r ? 1 : r;
                  return s(e) && s(i) && s(n)
                    ? l({
                        r: Number(e),
                        g: Number(i),
                        b: Number(n),
                        a: Number(o),
                      })
                    : null;
                },
                "rgb",
              ],
              [
                function (t) {
                  var e = t.h,
                    i = t.s,
                    n = t.l,
                    r = t.a,
                    o = void 0 === r ? 1 : r;
                  if (!s(e) || !s(i) || !s(n)) return null;
                  var a = f({
                    h: Number(e),
                    s: Number(i),
                    l: Number(n),
                    a: Number(o),
                  });
                  return g(a);
                },
                "hsl",
              ],
              [
                function (t) {
                  var e = t.h,
                    i = t.s,
                    n = t.v,
                    r = t.a,
                    l = void 0 === r ? 1 : r;
                  if (!s(e) || !s(i) || !s(n)) return null;
                  var u = (function (t) {
                    return {
                      h: a(t.h),
                      s: o(t.s, 0, 100),
                      v: o(t.v, 0, 100),
                      a: o(t.a),
                    };
                  })({
                    h: Number(e),
                    s: Number(i),
                    v: Number(n),
                    a: Number(l),
                  });
                  return p(u);
                },
                "hsv",
              ],
            ],
          },
          _ = function (t, e) {
            for (var i = 0; i < e.length; i++) {
              var n = e[i][0](t);
              if (n) return [n, e[i][1]];
            }
            return [null, void 0];
          },
          T = function (t) {
            return "string" == typeof t
              ? _(t.trim(), C.string)
              : "object" == typeof t && null !== t
              ? _(t, C.object)
              : [null, void 0];
          },
          w = function (t, e) {
            var i = v(t);
            return { h: i.h, s: o(i.s + 100 * e, 0, 100), l: i.l, a: i.a };
          },
          P = function (t) {
            return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 / 255;
          },
          A = function (t, e) {
            var i = v(t);
            return { h: i.h, s: i.s, l: o(i.l + 100 * e, 0, 100), a: i.a };
          },
          k = (function () {
            function t(t) {
              (this.parsed = T(t)[0]),
                (this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 });
            }
            return (
              (t.prototype.isValid = function () {
                return null !== this.parsed;
              }),
              (t.prototype.brightness = function () {
                return r(P(this.rgba), 2);
              }),
              (t.prototype.isDark = function () {
                return P(this.rgba) < 0.5;
              }),
              (t.prototype.isLight = function () {
                return P(this.rgba) >= 0.5;
              }),
              (t.prototype.toHex = function () {
                return (
                  (e = (t = u(this.rgba)).r),
                  (i = t.g),
                  (n = t.b),
                  (o = (s = t.a) < 1 ? c(r(255 * s)) : ""),
                  "#" + c(e) + c(i) + c(n) + o
                );
                var t, e, i, n, s, o;
              }),
              (t.prototype.toRgb = function () {
                return u(this.rgba);
              }),
              (t.prototype.toRgbString = function () {
                return (
                  (e = (t = u(this.rgba)).r),
                  (i = t.g),
                  (n = t.b),
                  (s = t.a) < 1
                    ? "rgba(" + e + ", " + i + ", " + n + ", " + s + ")"
                    : "rgb(" + e + ", " + i + ", " + n + ")"
                );
                var t, e, i, n, s;
              }),
              (t.prototype.toHsl = function () {
                return m(v(this.rgba));
              }),
              (t.prototype.toHslString = function () {
                return (
                  (e = (t = m(v(this.rgba))).h),
                  (i = t.s),
                  (n = t.l),
                  (s = t.a) < 1
                    ? "hsla(" + e + ", " + i + "%, " + n + "%, " + s + ")"
                    : "hsl(" + e + ", " + i + "%, " + n + "%)"
                );
                var t, e, i, n, s;
              }),
              (t.prototype.toHsv = function () {
                return (
                  (t = d(this.rgba)),
                  { h: r(t.h), s: r(t.s), v: r(t.v), a: r(t.a, 3) }
                );
                var t;
              }),
              (t.prototype.invert = function () {
                return M({
                  r: 255 - (t = this.rgba).r,
                  g: 255 - t.g,
                  b: 255 - t.b,
                  a: t.a,
                });
                var t;
              }),
              (t.prototype.saturate = function (t) {
                return void 0 === t && (t = 0.1), M(w(this.rgba, t));
              }),
              (t.prototype.desaturate = function (t) {
                return void 0 === t && (t = 0.1), M(w(this.rgba, -t));
              }),
              (t.prototype.grayscale = function () {
                return M(w(this.rgba, -1));
              }),
              (t.prototype.lighten = function (t) {
                return void 0 === t && (t = 0.1), M(A(this.rgba, t));
              }),
              (t.prototype.darken = function (t) {
                return void 0 === t && (t = 0.1), M(A(this.rgba, -t));
              }),
              (t.prototype.rotate = function (t) {
                return void 0 === t && (t = 15), this.hue(this.hue() + t);
              }),
              (t.prototype.alpha = function (t) {
                return "number" == typeof t
                  ? M({ r: (e = this.rgba).r, g: e.g, b: e.b, a: t })
                  : r(this.rgba.a, 3);
                var e;
              }),
              (t.prototype.hue = function (t) {
                var e = v(this.rgba);
                return "number" == typeof t
                  ? M({ h: t, s: e.s, l: e.l, a: e.a })
                  : r(e.h);
              }),
              (t.prototype.isEqual = function (t) {
                return this.toHex() === M(t).toHex();
              }),
              t
            );
          })(),
          M = function (t) {
            return t instanceof k ? t : new k(t);
          },
          E = [];
        !(function (t) {
          t.forEach(function (t) {
            E.indexOf(t) < 0 && (t(k, C), E.push(t));
          });
        })([
          function (t, e) {
            var i = {
                white: "#ffffff",
                bisque: "#ffe4c4",
                blue: "#0000ff",
                cadetblue: "#5f9ea0",
                chartreuse: "#7fff00",
                chocolate: "#d2691e",
                coral: "#ff7f50",
                antiquewhite: "#faebd7",
                aqua: "#00ffff",
                azure: "#f0ffff",
                whitesmoke: "#f5f5f5",
                papayawhip: "#ffefd5",
                plum: "#dda0dd",
                blanchedalmond: "#ffebcd",
                black: "#000000",
                gold: "#ffd700",
                goldenrod: "#daa520",
                gainsboro: "#dcdcdc",
                cornsilk: "#fff8dc",
                cornflowerblue: "#6495ed",
                burlywood: "#deb887",
                aquamarine: "#7fffd4",
                beige: "#f5f5dc",
                crimson: "#dc143c",
                cyan: "#00ffff",
                darkblue: "#00008b",
                darkcyan: "#008b8b",
                darkgoldenrod: "#b8860b",
                darkkhaki: "#bdb76b",
                darkgray: "#a9a9a9",
                darkgreen: "#006400",
                darkgrey: "#a9a9a9",
                peachpuff: "#ffdab9",
                darkmagenta: "#8b008b",
                darkred: "#8b0000",
                darkorchid: "#9932cc",
                darkorange: "#ff8c00",
                darkslateblue: "#483d8b",
                gray: "#808080",
                darkslategray: "#2f4f4f",
                darkslategrey: "#2f4f4f",
                deeppink: "#ff1493",
                deepskyblue: "#00bfff",
                wheat: "#f5deb3",
                firebrick: "#b22222",
                floralwhite: "#fffaf0",
                ghostwhite: "#f8f8ff",
                darkviolet: "#9400d3",
                magenta: "#ff00ff",
                green: "#008000",
                dodgerblue: "#1e90ff",
                grey: "#808080",
                honeydew: "#f0fff0",
                hotpink: "#ff69b4",
                blueviolet: "#8a2be2",
                forestgreen: "#228b22",
                lawngreen: "#7cfc00",
                indianred: "#cd5c5c",
                indigo: "#4b0082",
                fuchsia: "#ff00ff",
                brown: "#a52a2a",
                maroon: "#800000",
                mediumblue: "#0000cd",
                lightcoral: "#f08080",
                darkturquoise: "#00ced1",
                lightcyan: "#e0ffff",
                ivory: "#fffff0",
                lightyellow: "#ffffe0",
                lightsalmon: "#ffa07a",
                lightseagreen: "#20b2aa",
                linen: "#faf0e6",
                mediumaquamarine: "#66cdaa",
                lemonchiffon: "#fffacd",
                lime: "#00ff00",
                khaki: "#f0e68c",
                mediumseagreen: "#3cb371",
                limegreen: "#32cd32",
                mediumspringgreen: "#00fa9a",
                lightskyblue: "#87cefa",
                lightblue: "#add8e6",
                midnightblue: "#191970",
                lightpink: "#ffb6c1",
                mistyrose: "#ffe4e1",
                moccasin: "#ffe4b5",
                mintcream: "#f5fffa",
                lightslategray: "#778899",
                lightslategrey: "#778899",
                navajowhite: "#ffdead",
                navy: "#000080",
                mediumvioletred: "#c71585",
                powderblue: "#b0e0e6",
                palegoldenrod: "#eee8aa",
                oldlace: "#fdf5e6",
                paleturquoise: "#afeeee",
                mediumturquoise: "#48d1cc",
                mediumorchid: "#ba55d3",
                rebeccapurple: "#663399",
                lightsteelblue: "#b0c4de",
                mediumslateblue: "#7b68ee",
                thistle: "#d8bfd8",
                tan: "#d2b48c",
                orchid: "#da70d6",
                mediumpurple: "#9370db",
                purple: "#800080",
                pink: "#ffc0cb",
                skyblue: "#87ceeb",
                springgreen: "#00ff7f",
                palegreen: "#98fb98",
                red: "#ff0000",
                yellow: "#ffff00",
                slateblue: "#6a5acd",
                lavenderblush: "#fff0f5",
                peru: "#cd853f",
                palevioletred: "#db7093",
                violet: "#ee82ee",
                teal: "#008080",
                slategray: "#708090",
                slategrey: "#708090",
                aliceblue: "#f0f8ff",
                darkseagreen: "#8fbc8f",
                darkolivegreen: "#556b2f",
                greenyellow: "#adff2f",
                seagreen: "#2e8b57",
                seashell: "#fff5ee",
                tomato: "#ff6347",
                silver: "#c0c0c0",
                sienna: "#a0522d",
                lavender: "#e6e6fa",
                lightgreen: "#90ee90",
                orange: "#ffa500",
                orangered: "#ff4500",
                steelblue: "#4682b4",
                royalblue: "#4169e1",
                turquoise: "#40e0d0",
                yellowgreen: "#9acd32",
                salmon: "#fa8072",
                saddlebrown: "#8b4513",
                sandybrown: "#f4a460",
                rosybrown: "#bc8f8f",
                darksalmon: "#e9967a",
                lightgoldenrodyellow: "#fafad2",
                snow: "#fffafa",
                lightgrey: "#d3d3d3",
                lightgray: "#d3d3d3",
                dimgray: "#696969",
                dimgrey: "#696969",
                olivedrab: "#6b8e23",
                olive: "#808000",
              },
              n = {};
            for (var s in i) n[i[s]] = s;
            var r = {};
            (t.prototype.toName = function (e) {
              if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
                return "transparent";
              var s,
                o,
                a = n[this.toHex()];
              if (a) return a;
              if (null == e ? void 0 : e.closest) {
                var l = this.toRgb(),
                  u = 1 / 0,
                  h = "black";
                if (!r.length) for (var c in i) r[c] = new t(i[c]).toRgb();
                for (var d in i) {
                  var p =
                    ((s = l),
                    (o = r[d]),
                    Math.pow(s.r - o.r, 2) +
                      Math.pow(s.g - o.g, 2) +
                      Math.pow(s.b - o.b, 2));
                  p < u && ((u = p), (h = d));
                }
                return h;
              }
            }),
              e.string.push([
                function (e) {
                  var n = e.toLowerCase(),
                    s = "transparent" === n ? "#0000" : i[n];
                  return s ? new t(s).toRgb() : null;
                },
                "name",
              ]);
          },
        ]);
        const I = class t {
          constructor(t = 16777215) {
            (this._value = null),
              (this._components = new Float32Array(4)),
              this._components.fill(1),
              (this._int = 16777215),
              (this.value = t);
          }
          get red() {
            return this._components[0];
          }
          get green() {
            return this._components[1];
          }
          get blue() {
            return this._components[2];
          }
          get alpha() {
            return this._components[3];
          }
          setValue(t) {
            return (this.value = t), this;
          }
          set value(e) {
            if (e instanceof t)
              (this._value = this._cloneSource(e._value)),
                (this._int = e._int),
                this._components.set(e._components);
            else {
              if (null === e) throw new Error("Cannot set Color#value to null");
              (null !== this._value && this._isSourceEqual(this._value, e)) ||
                (this._normalize(e), (this._value = this._cloneSource(e)));
            }
          }
          get value() {
            return this._value;
          }
          _cloneSource(t) {
            return "string" == typeof t ||
              "number" == typeof t ||
              t instanceof Number ||
              null === t
              ? t
              : Array.isArray(t) || ArrayBuffer.isView(t)
              ? t.slice(0)
              : "object" == typeof t && null !== t
              ? { ...t }
              : t;
          }
          _isSourceEqual(t, e) {
            const i = typeof t;
            if (i !== typeof e) return !1;
            if ("number" === i || "string" === i || t instanceof Number)
              return t === e;
            if (
              (Array.isArray(t) && Array.isArray(e)) ||
              (ArrayBuffer.isView(t) && ArrayBuffer.isView(e))
            )
              return t.length === e.length && t.every((t, i) => t === e[i]);
            if (null !== t && null !== e) {
              const i = Object.keys(t),
                n = Object.keys(e);
              return i.length === n.length && i.every((i) => t[i] === e[i]);
            }
            return t === e;
          }
          toRgba() {
            const [t, e, i, n] = this._components;
            return { r: t, g: e, b: i, a: n };
          }
          toRgb() {
            const [t, e, i] = this._components;
            return { r: t, g: e, b: i };
          }
          toRgbaString() {
            const [t, e, i] = this.toUint8RgbArray();
            return `rgba(${t},${e},${i},${this.alpha})`;
          }
          toUint8RgbArray(t) {
            const [e, i, n] = this._components;
            return (
              this._arrayRgb || (this._arrayRgb = []),
              ((t = t || this._arrayRgb)[0] = Math.round(255 * e)),
              (t[1] = Math.round(255 * i)),
              (t[2] = Math.round(255 * n)),
              t
            );
          }
          toArray(t) {
            this._arrayRgba || (this._arrayRgba = []),
              (t = t || this._arrayRgba);
            const [e, i, n, s] = this._components;
            return (t[0] = e), (t[1] = i), (t[2] = n), (t[3] = s), t;
          }
          toRgbArray(t) {
            this._arrayRgb || (this._arrayRgb = []), (t = t || this._arrayRgb);
            const [e, i, n] = this._components;
            return (t[0] = e), (t[1] = i), (t[2] = n), t;
          }
          toNumber() {
            return this._int;
          }
          toBgrNumber() {
            const [t, e, i] = this.toUint8RgbArray();
            return (i << 16) + (e << 8) + t;
          }
          toLittleEndianNumber() {
            const t = this._int;
            return (t >> 16) + (65280 & t) + ((255 & t) << 16);
          }
          multiply(e) {
            const [i, n, s, r] = t._temp.setValue(e)._components;
            return (
              (this._components[0] *= i),
              (this._components[1] *= n),
              (this._components[2] *= s),
              (this._components[3] *= r),
              this._refreshInt(),
              (this._value = null),
              this
            );
          }
          premultiply(t, e = !0) {
            return (
              e &&
                ((this._components[0] *= t),
                (this._components[1] *= t),
                (this._components[2] *= t)),
              (this._components[3] = t),
              this._refreshInt(),
              (this._value = null),
              this
            );
          }
          toPremultiplied(t, e = !0) {
            if (1 === t) return (255 << 24) + this._int;
            if (0 === t) return e ? 0 : this._int;
            let i = (this._int >> 16) & 255,
              n = (this._int >> 8) & 255,
              s = 255 & this._int;
            return (
              e &&
                ((i = (i * t + 0.5) | 0),
                (n = (n * t + 0.5) | 0),
                (s = (s * t + 0.5) | 0)),
              ((255 * t) << 24) + (i << 16) + (n << 8) + s
            );
          }
          toHex() {
            const t = this._int.toString(16);
            return `#${"000000".substring(0, 6 - t.length) + t}`;
          }
          toHexa() {
            const t = Math.round(255 * this._components[3]).toString(16);
            return this.toHex() + "00".substring(0, 2 - t.length) + t;
          }
          setAlpha(t) {
            return (this._components[3] = this._clamp(t)), this;
          }
          _normalize(e) {
            let i, n, s, r;
            if (
              ("number" == typeof e || e instanceof Number) &&
              e >= 0 &&
              e <= 16777215
            ) {
              (i = ((e >> 16) & 255) / 255),
                (n = ((e >> 8) & 255) / 255),
                (s = (255 & e) / 255),
                (r = 1);
            } else if (
              (Array.isArray(e) || e instanceof Float32Array) &&
              e.length >= 3 &&
              e.length <= 4
            )
              (e = this._clamp(e)), ([i, n, s, r = 1] = e);
            else if (
              (e instanceof Uint8Array || e instanceof Uint8ClampedArray) &&
              e.length >= 3 &&
              e.length <= 4
            )
              (e = this._clamp(e, 0, 255)),
                ([i, n, s, r = 255] = e),
                (i /= 255),
                (n /= 255),
                (s /= 255),
                (r /= 255);
            else if ("string" == typeof e || "object" == typeof e) {
              if ("string" == typeof e) {
                const i = t.HEX_PATTERN.exec(e);
                i && (e = `#${i[2]}`);
              }
              const o = M(e);
              o.isValid() &&
                (({ r: i, g: n, b: s, a: r } = o.rgba),
                (i /= 255),
                (n /= 255),
                (s /= 255));
            }
            if (void 0 === i) throw new Error(`Unable to convert color ${e}`);
            (this._components[0] = i),
              (this._components[1] = n),
              (this._components[2] = s),
              (this._components[3] = r),
              this._refreshInt();
          }
          _refreshInt() {
            this._clamp(this._components);
            const [t, e, i] = this._components;
            this._int = ((255 * t) << 16) + ((255 * e) << 8) + ((255 * i) | 0);
          }
          _clamp(t, e = 0, i = 1) {
            return "number" == typeof t
              ? Math.min(Math.max(t, e), i)
              : (t.forEach((n, s) => {
                  t[s] = Math.min(Math.max(n, e), i);
                }),
                t);
          }
          static isColorLike(e) {
            return (
              "number" == typeof e ||
              "string" == typeof e ||
              e instanceof Number ||
              e instanceof t ||
              Array.isArray(e) ||
              e instanceof Uint8Array ||
              e instanceof Uint8ClampedArray ||
              e instanceof Float32Array ||
              (void 0 !== e.r && void 0 !== e.g && void 0 !== e.b) ||
              (void 0 !== e.r &&
                void 0 !== e.g &&
                void 0 !== e.b &&
                void 0 !== e.a) ||
              (void 0 !== e.h && void 0 !== e.s && void 0 !== e.l) ||
              (void 0 !== e.h &&
                void 0 !== e.s &&
                void 0 !== e.l &&
                void 0 !== e.a) ||
              (void 0 !== e.h && void 0 !== e.s && void 0 !== e.v) ||
              (void 0 !== e.h &&
                void 0 !== e.s &&
                void 0 !== e.v &&
                void 0 !== e.a)
            );
          }
        };
        (I.shared = new I()),
          (I._temp = new I()),
          (I.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i);
        let D = I;
      },
      1761: (t, e, i) => {
        "use strict";
        i.d(e, { e: () => s });
        let n = {
          createCanvas: (t, e) => {
            const i = document.createElement("canvas");
            return (i.width = t), (i.height = e), i;
          },
          getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
          getWebGLRenderingContext: () => WebGLRenderingContext,
          getNavigator: () => navigator,
          getBaseUrl: () => document.baseURI ?? window.location.href,
          getFontFaceSet: () => document.fonts,
          fetch: (t, e) => fetch(t, e),
          parseXML: (t) => new DOMParser().parseFromString(t, "text/xml"),
        };
        const s = {
          get: () => n,
          set(t) {
            n = t;
          },
        };
      },
      8507: (t, e, i) => {
        "use strict";
        i.d(e, { Ag: () => n, XO: () => o });
        var n = ((t) => (
          (t.Application = "application"),
          (t.WebGLPipes = "webgl-pipes"),
          (t.WebGLPipesAdaptor = "webgl-pipes-adaptor"),
          (t.WebGLSystem = "webgl-system"),
          (t.WebGPUPipes = "webgpu-pipes"),
          (t.WebGPUPipesAdaptor = "webgpu-pipes-adaptor"),
          (t.WebGPUSystem = "webgpu-system"),
          (t.CanvasSystem = "canvas-system"),
          (t.CanvasPipesAdaptor = "canvas-pipes-adaptor"),
          (t.CanvasPipes = "canvas-pipes"),
          (t.Asset = "asset"),
          (t.LoadParser = "load-parser"),
          (t.ResolveParser = "resolve-parser"),
          (t.CacheParser = "cache-parser"),
          (t.DetectionParser = "detection-parser"),
          (t.MaskEffect = "mask-effect"),
          (t.BlendMode = "blend-mode"),
          (t.TextureSource = "texture-source"),
          (t.Environment = "environment"),
          t
        ))(n || {});
        const s = (t) => {
            if (
              "function" == typeof t ||
              ("object" == typeof t && t.extension)
            ) {
              if (!t.extension)
                throw new Error(
                  "Extension class must have an extension object"
                );
              t = {
                ...("object" != typeof t.extension
                  ? { type: t.extension }
                  : t.extension),
                ref: t,
              };
            }
            if ("object" != typeof t) throw new Error("Invalid extension type");
            return (
              "string" == typeof (t = { ...t }).type && (t.type = [t.type]), t
            );
          },
          r = (t, e) => s(t).priority ?? e,
          o = {
            _addHandlers: {},
            _removeHandlers: {},
            _queue: {},
            remove(...t) {
              return (
                t.map(s).forEach((t) => {
                  t.type.forEach((e) => this._removeHandlers[e]?.(t));
                }),
                this
              );
            },
            add(...t) {
              return (
                t.map(s).forEach((t) => {
                  t.type.forEach((e) => {
                    const i = this._addHandlers,
                      n = this._queue;
                    i[e] ? i[e]?.(t) : ((n[e] = n[e] || []), n[e]?.push(t));
                  });
                }),
                this
              );
            },
            handle(t, e, i) {
              const n = this._addHandlers,
                s = this._removeHandlers;
              if (n[t] || s[t])
                throw new Error(`Extension type ${t} already has a handler`);
              (n[t] = e), (s[t] = i);
              const r = this._queue;
              return r[t] && (r[t]?.forEach((t) => e(t)), delete r[t]), this;
            },
            handleByMap(t, e) {
              return this.handle(
                t,
                (t) => {
                  t.name && (e[t.name] = t.ref);
                },
                (t) => {
                  t.name && delete e[t.name];
                }
              );
            },
            handleByNamedList(t, e, i = -1) {
              return this.handle(
                t,
                (t) => {
                  e.findIndex((e) => e.name === t.name) >= 0 ||
                    (e.push({ name: t.name, value: t.ref }),
                    e.sort((t, e) => r(e.value, i) - r(t.value, i)));
                },
                (t) => {
                  const i = e.findIndex((e) => e.name === t.name);
                  -1 !== i && e.splice(i, 1);
                }
              );
            },
            handleByList(t, e, i = -1) {
              return this.handle(
                t,
                (t) => {
                  e.includes(t.ref) ||
                    (e.push(t.ref), e.sort((t, e) => r(e, i) - r(t, i)));
                },
                (t) => {
                  const i = e.indexOf(t.ref);
                  -1 !== i && e.splice(i, 1);
                }
              );
            },
          };
      },
      6554: (t, e, i) => {
        "use strict";
        i.d(e, { d: () => l });
        var n = i(9114),
          s = i(3012),
          r = i(8475),
          o = i(7547);
        const a = class t extends r.M {
          constructor(e) {
            super((e = { ...t.defaultOptions, ...e })),
              (this.enabled = !0),
              (this._state = o.U.for2d()),
              (this.padding = e.padding),
              "boolean" == typeof e.antialias
                ? (this.antialias = e.antialias ? "on" : "off")
                : (this.antialias = e.antialias),
              (this.resolution = e.resolution),
              (this.blendRequired = e.blendRequired),
              this.addResource("uTexture", 0, 1);
          }
          apply(t, e, i, n) {
            t.applyFilter(this, e, i, n);
          }
          get blendMode() {
            return this._state.blendMode;
          }
          set blendMode(t) {
            this._state.blendMode = t;
          }
          static from(e) {
            const { gpu: i, gl: r, ...o } = e;
            let a, l;
            return (
              i && (a = s.B.from(i)),
              r && (l = n.M.from(r)),
              new t({ gpuProgram: a, glProgram: l, ...o })
            );
          }
        };
        a.defaultOptions = {
          blendMode: "normal",
          resolution: 1,
          padding: 0,
          antialias: "off",
          blendRequired: !1,
        };
        let l = a;
      },
      9049: (t, e, i) => {
        "use strict";
        i.d(e, { a: () => n });
        class n {
          constructor(t) {
            (this.pipe = "filter"),
              (this.priority = 1),
              (this.filters = t?.filters),
              (this.filterArea = t?.filterArea);
          }
          destroy() {
            for (let t = 0; t < this.filters.length; t++)
              this.filters[t].destroy();
            (this.filters = null), (this.filterArea = null);
          }
        }
      },
      9313: (t, e, i) => {
        "use strict";
        i.d(e, { u: () => r });
        var n = i(1652),
          s = i(5101);
        class r {
          constructor(t = 1, e = 0, i = 0, n = 1, s = 0, r = 0) {
            (this.array = null),
              (this.a = t),
              (this.b = e),
              (this.c = i),
              (this.d = n),
              (this.tx = s),
              (this.ty = r);
          }
          fromArray(t) {
            (this.a = t[0]),
              (this.b = t[1]),
              (this.c = t[3]),
              (this.d = t[4]),
              (this.tx = t[2]),
              (this.ty = t[5]);
          }
          set(t, e, i, n, s, r) {
            return (
              (this.a = t),
              (this.b = e),
              (this.c = i),
              (this.d = n),
              (this.tx = s),
              (this.ty = r),
              this
            );
          }
          toArray(t, e) {
            this.array || (this.array = new Float32Array(9));
            const i = e || this.array;
            return (
              t
                ? ((i[0] = this.a),
                  (i[1] = this.b),
                  (i[2] = 0),
                  (i[3] = this.c),
                  (i[4] = this.d),
                  (i[5] = 0),
                  (i[6] = this.tx),
                  (i[7] = this.ty),
                  (i[8] = 1))
                : ((i[0] = this.a),
                  (i[1] = this.c),
                  (i[2] = this.tx),
                  (i[3] = this.b),
                  (i[4] = this.d),
                  (i[5] = this.ty),
                  (i[6] = 0),
                  (i[7] = 0),
                  (i[8] = 1)),
              i
            );
          }
          apply(t, e) {
            e = e || new s.b();
            const i = t.x,
              n = t.y;
            return (
              (e.x = this.a * i + this.c * n + this.tx),
              (e.y = this.b * i + this.d * n + this.ty),
              e
            );
          }
          applyInverse(t, e) {
            e = e || new s.b();
            const i = this.a,
              n = this.b,
              r = this.c,
              o = this.d,
              a = this.tx,
              l = this.ty,
              u = 1 / (i * o + r * -n),
              h = t.x,
              c = t.y;
            return (
              (e.x = o * u * h + -r * u * c + (l * r - a * o) * u),
              (e.y = i * u * c + -n * u * h + (-l * i + a * n) * u),
              e
            );
          }
          translate(t, e) {
            return (this.tx += t), (this.ty += e), this;
          }
          scale(t, e) {
            return (
              (this.a *= t),
              (this.d *= e),
              (this.c *= t),
              (this.b *= e),
              (this.tx *= t),
              (this.ty *= e),
              this
            );
          }
          rotate(t) {
            const e = Math.cos(t),
              i = Math.sin(t),
              n = this.a,
              s = this.c,
              r = this.tx;
            return (
              (this.a = n * e - this.b * i),
              (this.b = n * i + this.b * e),
              (this.c = s * e - this.d * i),
              (this.d = s * i + this.d * e),
              (this.tx = r * e - this.ty * i),
              (this.ty = r * i + this.ty * e),
              this
            );
          }
          append(t) {
            const e = this.a,
              i = this.b,
              n = this.c,
              s = this.d;
            return (
              (this.a = t.a * e + t.b * n),
              (this.b = t.a * i + t.b * s),
              (this.c = t.c * e + t.d * n),
              (this.d = t.c * i + t.d * s),
              (this.tx = t.tx * e + t.ty * n + this.tx),
              (this.ty = t.tx * i + t.ty * s + this.ty),
              this
            );
          }
          appendFrom(t, e) {
            const i = t.a,
              n = t.b,
              s = t.c,
              r = t.d,
              o = t.tx,
              a = t.ty,
              l = e.a,
              u = e.b,
              h = e.c,
              c = e.d;
            return (
              (this.a = i * l + n * h),
              (this.b = i * u + n * c),
              (this.c = s * l + r * h),
              (this.d = s * u + r * c),
              (this.tx = o * l + a * h + e.tx),
              (this.ty = o * u + a * c + e.ty),
              this
            );
          }
          setTransform(t, e, i, n, s, r, o, a, l) {
            return (
              (this.a = Math.cos(o + l) * s),
              (this.b = Math.sin(o + l) * s),
              (this.c = -Math.sin(o - a) * r),
              (this.d = Math.cos(o - a) * r),
              (this.tx = t - (i * this.a + n * this.c)),
              (this.ty = e - (i * this.b + n * this.d)),
              this
            );
          }
          prepend(t) {
            const e = this.tx;
            if (1 !== t.a || 0 !== t.b || 0 !== t.c || 1 !== t.d) {
              const e = this.a,
                i = this.c;
              (this.a = e * t.a + this.b * t.c),
                (this.b = e * t.b + this.b * t.d),
                (this.c = i * t.a + this.d * t.c),
                (this.d = i * t.b + this.d * t.d);
            }
            return (
              (this.tx = e * t.a + this.ty * t.c + t.tx),
              (this.ty = e * t.b + this.ty * t.d + t.ty),
              this
            );
          }
          decompose(t) {
            const e = this.a,
              i = this.b,
              s = this.c,
              r = this.d,
              o = t.pivot,
              a = -Math.atan2(-s, r),
              l = Math.atan2(i, e),
              u = Math.abs(a + l);
            return (
              u < 1e-5 || Math.abs(n.TO - u) < 1e-5
                ? ((t.rotation = l), (t.skew.x = t.skew.y = 0))
                : ((t.rotation = 0), (t.skew.x = a), (t.skew.y = l)),
              (t.scale.x = Math.sqrt(e * e + i * i)),
              (t.scale.y = Math.sqrt(s * s + r * r)),
              (t.position.x = this.tx + (o.x * e + o.y * s)),
              (t.position.y = this.ty + (o.x * i + o.y * r)),
              t
            );
          }
          invert() {
            const t = this.a,
              e = this.b,
              i = this.c,
              n = this.d,
              s = this.tx,
              r = t * n - e * i;
            return (
              (this.a = n / r),
              (this.b = -e / r),
              (this.c = -i / r),
              (this.d = t / r),
              (this.tx = (i * this.ty - n * s) / r),
              (this.ty = -(t * this.ty - e * s) / r),
              this
            );
          }
          isIdentity() {
            return (
              1 === this.a &&
              0 === this.b &&
              0 === this.c &&
              1 === this.d &&
              0 === this.tx &&
              0 === this.ty
            );
          }
          identity() {
            return (
              (this.a = 1),
              (this.b = 0),
              (this.c = 0),
              (this.d = 1),
              (this.tx = 0),
              (this.ty = 0),
              this
            );
          }
          clone() {
            const t = new r();
            return (
              (t.a = this.a),
              (t.b = this.b),
              (t.c = this.c),
              (t.d = this.d),
              (t.tx = this.tx),
              (t.ty = this.ty),
              t
            );
          }
          copyTo(t) {
            return (
              (t.a = this.a),
              (t.b = this.b),
              (t.c = this.c),
              (t.d = this.d),
              (t.tx = this.tx),
              (t.ty = this.ty),
              t
            );
          }
          copyFrom(t) {
            return (
              (this.a = t.a),
              (this.b = t.b),
              (this.c = t.c),
              (this.d = t.d),
              (this.tx = t.tx),
              (this.ty = t.ty),
              this
            );
          }
          equals(t) {
            return (
              t.a === this.a &&
              t.b === this.b &&
              t.c === this.c &&
              t.d === this.d &&
              t.tx === this.tx &&
              t.ty === this.ty
            );
          }
          toString() {
            return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
          }
          static get IDENTITY() {
            return a.identity();
          }
          static get shared() {
            return o.identity();
          }
        }
        const o = new r(),
          a = new r();
      },
      1652: (t, e, i) => {
        "use strict";
        i.d(e, { TO: () => n, Td: () => r, bO: () => s });
        const n = 2 * Math.PI,
          s = 180 / Math.PI,
          r = Math.PI / 180;
      },
      9939: (t, e, i) => {
        "use strict";
        function n(t) {
          return (
            (t += 0 === t ? 1 : 0),
            --t,
            (t |= t >>> 1),
            (t |= t >>> 2),
            (t |= t >>> 4),
            (t |= t >>> 8),
            (t |= t >>> 16) + 1
          );
        }
        function s(t) {
          return !(t & (t - 1) || !t);
        }
        i.d(e, { U5: () => n, f3: () => s });
      },
      2812: (t, e, i) => {
        "use strict";
        i.d(e, { o: () => n });
        class n {
          constructor(t, e, i) {
            (this._x = e || 0), (this._y = i || 0), (this._observer = t);
          }
          clone(t) {
            return new n(t ?? this._observer, this._x, this._y);
          }
          set(t = 0, e = t) {
            return (
              (this._x === t && this._y === e) ||
                ((this._x = t), (this._y = e), this._observer._onUpdate(this)),
              this
            );
          }
          copyFrom(t) {
            return (
              (this._x === t.x && this._y === t.y) ||
                ((this._x = t.x),
                (this._y = t.y),
                this._observer._onUpdate(this)),
              this
            );
          }
          copyTo(t) {
            return t.set(this._x, this._y), t;
          }
          equals(t) {
            return t.x === this._x && t.y === this._y;
          }
          toString() {
            return `[pixi.js/math:ObservablePoint x=0 y=0 scope=${this._observer}]`;
          }
          get x() {
            return this._x;
          }
          set x(t) {
            this._x !== t && ((this._x = t), this._observer._onUpdate(this));
          }
          get y() {
            return this._y;
          }
          set y(t) {
            this._y !== t && ((this._y = t), this._observer._onUpdate(this));
          }
        }
      },
      5101: (t, e, i) => {
        "use strict";
        i.d(e, { b: () => n });
        class n {
          constructor(t = 0, e = 0) {
            (this.x = 0), (this.y = 0), (this.x = t), (this.y = e);
          }
          clone() {
            return new n(this.x, this.y);
          }
          copyFrom(t) {
            return this.set(t.x, t.y), this;
          }
          copyTo(t) {
            return t.set(this.x, this.y), t;
          }
          equals(t) {
            return t.x === this.x && t.y === this.y;
          }
          set(t = 0, e = t) {
            return (this.x = t), (this.y = e), this;
          }
          toString() {
            return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;
          }
          static get shared() {
            return (s.x = 0), (s.y = 0), s;
          }
        }
        const s = new n();
      },
      9252: (t, e, i) => {
        "use strict";
        i.d(e, { M: () => r });
        var n = i(5101);
        const s = [new n.b(), new n.b(), new n.b(), new n.b()];
        class r {
          constructor(t = 0, e = 0, i = 0, n = 0) {
            (this.type = "rectangle"),
              (this.x = Number(t)),
              (this.y = Number(e)),
              (this.width = Number(i)),
              (this.height = Number(n));
          }
          get left() {
            return this.x;
          }
          get right() {
            return this.x + this.width;
          }
          get top() {
            return this.y;
          }
          get bottom() {
            return this.y + this.height;
          }
          isEmpty() {
            return this.left === this.right || this.top === this.bottom;
          }
          static get EMPTY() {
            return new r(0, 0, 0, 0);
          }
          clone() {
            return new r(this.x, this.y, this.width, this.height);
          }
          copyFromBounds(t) {
            return (
              (this.x = t.minX),
              (this.y = t.minY),
              (this.width = t.maxX - t.minX),
              (this.height = t.maxY - t.minY),
              this
            );
          }
          copyFrom(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.width = t.width),
              (this.height = t.height),
              this
            );
          }
          copyTo(t) {
            return t.copyFrom(this), t;
          }
          contains(t, e) {
            return (
              !(this.width <= 0 || this.height <= 0) &&
              t >= this.x &&
              t < this.x + this.width &&
              e >= this.y &&
              e < this.y + this.height
            );
          }
          strokeContains(t, e, i) {
            const { width: n, height: s } = this;
            if (n <= 0 || s <= 0) return !1;
            const r = this.x,
              o = this.y;
            return (
              t >= r - i / 2 &&
              t <= r + n + i / 2 &&
              e >= o - i / 2 &&
              e <= o + s + i / 2 &&
              !(
                t > r + i / 2 &&
                t < r + n - i / 2 &&
                e > o + i / 2 &&
                e < o + s - i / 2
              )
            );
          }
          intersects(t, e) {
            if (!e) {
              const e = this.x < t.x ? t.x : this.x;
              if ((this.right > t.right ? t.right : this.right) <= e) return !1;
              const i = this.y < t.y ? t.y : this.y;
              return (this.bottom > t.bottom ? t.bottom : this.bottom) > i;
            }
            const i = this.left,
              n = this.right,
              r = this.top,
              o = this.bottom;
            if (n <= i || o <= r) return !1;
            const a = s[0].set(t.left, t.top),
              l = s[1].set(t.left, t.bottom),
              u = s[2].set(t.right, t.top),
              h = s[3].set(t.right, t.bottom);
            if (u.x <= a.x || l.y <= a.y) return !1;
            const c = Math.sign(e.a * e.d - e.b * e.c);
            if (0 === c) return !1;
            if (
              (e.apply(a, a),
              e.apply(l, l),
              e.apply(u, u),
              e.apply(h, h),
              Math.max(a.x, l.x, u.x, h.x) <= i ||
                Math.min(a.x, l.x, u.x, h.x) >= n ||
                Math.max(a.y, l.y, u.y, h.y) <= r ||
                Math.min(a.y, l.y, u.y, h.y) >= o)
            )
              return !1;
            const d = c * (l.y - a.y),
              p = c * (a.x - l.x),
              f = d * i + p * r,
              m = d * n + p * r,
              g = d * i + p * o,
              v = d * n + p * o;
            if (
              Math.max(f, m, g, v) <= d * a.x + p * a.y ||
              Math.min(f, m, g, v) >= d * h.x + p * h.y
            )
              return !1;
            const y = c * (a.y - u.y),
              x = c * (u.x - a.x),
              b = y * i + x * r,
              S = y * n + x * r,
              C = y * i + x * o,
              _ = y * n + x * o;
            return !(
              Math.max(b, S, C, _) <= y * a.x + x * a.y ||
              Math.min(b, S, C, _) >= y * h.x + x * h.y
            );
          }
          pad(t = 0, e = t) {
            return (
              (this.x -= t),
              (this.y -= e),
              (this.width += 2 * t),
              (this.height += 2 * e),
              this
            );
          }
          fit(t) {
            const e = Math.max(this.x, t.x),
              i = Math.min(this.x + this.width, t.x + t.width),
              n = Math.max(this.y, t.y),
              s = Math.min(this.y + this.height, t.y + t.height);
            return (
              (this.x = e),
              (this.width = Math.max(i - e, 0)),
              (this.y = n),
              (this.height = Math.max(s - n, 0)),
              this
            );
          }
          ceil(t = 1, e = 0.001) {
            const i = Math.ceil((this.x + this.width - e) * t) / t,
              n = Math.ceil((this.y + this.height - e) * t) / t;
            return (
              (this.x = Math.floor((this.x + e) * t) / t),
              (this.y = Math.floor((this.y + e) * t) / t),
              (this.width = i - this.x),
              (this.height = n - this.y),
              this
            );
          }
          enlarge(t) {
            const e = Math.min(this.x, t.x),
              i = Math.max(this.x + this.width, t.x + t.width),
              n = Math.min(this.y, t.y),
              s = Math.max(this.y + this.height, t.y + t.height);
            return (
              (this.x = e),
              (this.width = i - e),
              (this.y = n),
              (this.height = s - n),
              this
            );
          }
          getBounds(t) {
            return (t = t || new r()).copyFrom(this), t;
          }
          toString() {
            return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
          }
        }
      },
      8634: (t, e, i) => {
        "use strict";
        i.d(e, { J: () => l });
        var n = i(949),
          s = i(1132),
          r = i(6011);
        const o = new Float32Array(1),
          a = new Uint32Array(1);
        class l extends r.V {
          constructor() {
            const t = new n.h({
              data: o,
              label: "attribute-batch-buffer",
              usage: s.S.VERTEX | s.S.COPY_DST,
              shrinkToFit: !1,
            });
            super({
              attributes: {
                aPosition: {
                  buffer: t,
                  format: "float32x2",
                  stride: 24,
                  offset: 0,
                  location: 1,
                },
                aUV: {
                  buffer: t,
                  format: "float32x2",
                  stride: 24,
                  offset: 8,
                  location: 3,
                },
                aColor: {
                  buffer: t,
                  format: "unorm8x4",
                  stride: 24,
                  offset: 16,
                  location: 0,
                },
                aTextureIdAndRound: {
                  buffer: t,
                  format: "uint16x2",
                  stride: 24,
                  offset: 20,
                  location: 2,
                },
              },
              indexBuffer: new n.h({
                data: a,
                label: "index-batch-buffer",
                usage: s.S.INDEX | s.S.COPY_DST,
                shrinkToFit: !1,
              }),
            });
          }
        }
      },
      341: (t, e, i) => {
        "use strict";
        i.d(e, { w: () => a });
        var n = i(3513),
          s = i(4492),
          r = i(9104);
        const o = {};
        function a(t, e) {
          let i = 0;
          for (let n = 0; n < e; n++) i = (31 * i + t[n].uid) >>> 0;
          return (
            o[i] ||
            (function (t, e) {
              const i = {};
              let a = 0;
              for (let e = 0; e < r.k; e++) {
                const n = e < t.length ? t[e] : s.g.EMPTY.source;
                (i[a++] = n.source), (i[a++] = n.style);
              }
              const l = new n.T(i);
              return (o[e] = l), l;
            })(t, i)
          );
        }
      },
      1478: (t, e, i) => {
        "use strict";
        i.d(e, { i: () => p });
        var n = i(133);
        class s {
          constructor(t) {
            "number" == typeof t
              ? (this.rawBinaryData = new ArrayBuffer(t))
              : t instanceof Uint8Array
              ? (this.rawBinaryData = t.buffer)
              : (this.rawBinaryData = t),
              (this.uint32View = new Uint32Array(this.rawBinaryData)),
              (this.float32View = new Float32Array(this.rawBinaryData)),
              (this.size = this.rawBinaryData.byteLength);
          }
          get int8View() {
            return (
              this._int8View ||
                (this._int8View = new Int8Array(this.rawBinaryData)),
              this._int8View
            );
          }
          get uint8View() {
            return (
              this._uint8View ||
                (this._uint8View = new Uint8Array(this.rawBinaryData)),
              this._uint8View
            );
          }
          get int16View() {
            return (
              this._int16View ||
                (this._int16View = new Int16Array(this.rawBinaryData)),
              this._int16View
            );
          }
          get int32View() {
            return (
              this._int32View ||
                (this._int32View = new Int32Array(this.rawBinaryData)),
              this._int32View
            );
          }
          get float64View() {
            return (
              this._float64Array ||
                (this._float64Array = new Float64Array(this.rawBinaryData)),
              this._float64Array
            );
          }
          get bigUint64View() {
            return (
              this._bigUint64Array ||
                (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)),
              this._bigUint64Array
            );
          }
          view(t) {
            return this[`${t}View`];
          }
          destroy() {
            (this.rawBinaryData = null),
              (this._int8View = null),
              (this._uint8View = null),
              (this._int16View = null),
              (this.uint16View = null),
              (this._int32View = null),
              (this.uint32View = null),
              (this.float32View = null);
          }
          static sizeOf(t) {
            switch (t) {
              case "int8":
              case "uint8":
                return 1;
              case "int16":
              case "uint16":
                return 2;
              case "int32":
              case "uint32":
              case "float32":
                return 4;
              default:
                throw new Error(`${t} isn't a valid view type`);
            }
          }
        }
        var r = i(6736),
          o = i(1957);
        function a(t, e) {
          return ("no-premultiply-alpha" === e.alphaMode && o.Q[t]) || t;
        }
        class l {
          constructor() {
            (this.ids = Object.create(null)),
              (this.textures = []),
              (this.count = 0);
          }
          clear() {
            for (let t = 0; t < this.count; t++) {
              const e = this.textures[t];
              (this.textures[t] = null), (this.ids[e.uid] = null);
            }
            this.count = 0;
          }
        }
        var u = i(9104);
        class h {
          constructor() {
            (this.renderPipeId = "batch"),
              (this.action = "startBatch"),
              (this.start = 0),
              (this.size = 0),
              (this.blendMode = "normal"),
              (this.canBundle = !0);
          }
          destroy() {
            (this.textures = null),
              (this.gpuBindGroup = null),
              (this.bindGroup = null),
              (this.batcher = null);
          }
        }
        let c = 0;
        const d = class t {
          constructor(e = {}) {
            (this.uid = (0, n.L)("batcher")),
              (this.dirty = !0),
              (this.batchIndex = 0),
              (this.batches = []),
              (this._vertexSize = 6),
              (this._elements = []),
              (this._batchPool = []),
              (this._batchPoolIndex = 0),
              (this._textureBatchPool = []),
              (this._textureBatchPoolIndex = 0),
              (e = { ...t.defaultOptions, ...e });
            const { vertexSize: i, indexSize: r } = e;
            (this.attributeBuffer = new s(i * this._vertexSize * 4)),
              (this.indexBuffer = new Uint16Array(r));
          }
          begin() {
            (this.batchIndex = 0),
              (this.elementSize = 0),
              (this.elementStart = 0),
              (this.indexSize = 0),
              (this.attributeSize = 0),
              (this._batchPoolIndex = 0),
              (this._textureBatchPoolIndex = 0),
              (this._batchIndexStart = 0),
              (this._batchIndexSize = 0),
              (this.dirty = !0);
          }
          add(t) {
            (this._elements[this.elementSize++] = t),
              (t.indexStart = this.indexSize),
              (t.location = this.attributeSize),
              (t.batcher = this),
              (this.indexSize += t.indexSize),
              (this.attributeSize += t.vertexSize * this._vertexSize);
          }
          checkAndUpdateTexture(t, e) {
            const i = t.batch.textures.ids[e._source.uid];
            return !(!i && 0 !== i) && ((t.textureId = i), (t.texture = e), !0);
          }
          updateElement(t) {
            (this.dirty = !0),
              t.packAttributes(
                this.attributeBuffer.float32View,
                this.attributeBuffer.uint32View,
                t.location,
                t.textureId
              );
          }
          break(t) {
            const e = this._elements;
            let i =
              this._textureBatchPool[this._textureBatchPoolIndex++] || new l();
            if ((i.clear(), !e[this.elementStart])) return;
            const n = e[this.elementStart];
            let s = a(n.blendMode, n.texture._source);
            4 * this.attributeSize > this.attributeBuffer.size &&
              this._resizeAttributeBuffer(4 * this.attributeSize),
              this.indexSize > this.indexBuffer.length &&
                this._resizeIndexBuffer(this.indexSize);
            const r = this.attributeBuffer.float32View,
              o = this.attributeBuffer.uint32View,
              d = this.indexBuffer;
            let p = this._batchIndexSize,
              f = this._batchIndexStart,
              m = "startBatch",
              g = this._batchPool[this._batchPoolIndex++] || new h();
            for (let n = this.elementStart; n < this.elementSize; ++n) {
              const v = e[n];
              e[n] = null;
              const y = v.texture._source,
                x = a(v.blendMode, y),
                b = s !== x;
              y._batchTick !== c || b
                ? ((y._batchTick = c),
                  (i.count >= u.k || b) &&
                    (this._finishBatch(g, f, p - f, i, s, t, m),
                    (m = "renderBatch"),
                    (f = p),
                    (s = x),
                    (i =
                      this._textureBatchPool[this._textureBatchPoolIndex++] ||
                      new l()),
                    i.clear(),
                    (g = this._batchPool[this._batchPoolIndex++] || new h()),
                    ++c),
                  (v.textureId = y._textureBindLocation = i.count),
                  (i.ids[y.uid] = i.count),
                  (i.textures[i.count++] = y),
                  (v.batch = g),
                  (p += v.indexSize),
                  v.packAttributes(r, o, v.location, v.textureId),
                  v.packIndex(d, v.indexStart, v.location / this._vertexSize))
                : ((v.textureId = y._textureBindLocation),
                  (p += v.indexSize),
                  v.packAttributes(r, o, v.location, v.textureId),
                  v.packIndex(d, v.indexStart, v.location / this._vertexSize),
                  (v.batch = g));
            }
            i.count > 0 &&
              (this._finishBatch(g, f, p - f, i, s, t, m), (f = p), ++c),
              (this.elementStart = this.elementSize),
              (this._batchIndexStart = f),
              (this._batchIndexSize = p);
          }
          _finishBatch(t, e, i, n, s, r, o) {
            (t.gpuBindGroup = null),
              (t.action = o),
              (t.batcher = this),
              (t.textures = n),
              (t.blendMode = s),
              (t.start = e),
              (t.size = i),
              ++c,
              r.add(t);
          }
          finish(t) {
            this.break(t);
          }
          ensureAttributeBuffer(t) {
            4 * t <= this.attributeBuffer.size ||
              this._resizeAttributeBuffer(4 * t);
          }
          ensureIndexBuffer(t) {
            t <= this.indexBuffer.length || this._resizeIndexBuffer(t);
          }
          _resizeAttributeBuffer(t) {
            const e = Math.max(t, 2 * this.attributeBuffer.size),
              i = new s(e);
            (0, r.W)(this.attributeBuffer.rawBinaryData, i.rawBinaryData),
              (this.attributeBuffer = i);
          }
          _resizeIndexBuffer(t) {
            const e = this.indexBuffer;
            let i = Math.max(t, 1.5 * e.length);
            i += i % 2;
            const n = i > 65535 ? new Uint32Array(i) : new Uint16Array(i);
            if (n.BYTES_PER_ELEMENT !== e.BYTES_PER_ELEMENT)
              for (let t = 0; t < e.length; t++) n[t] = e[t];
            else (0, r.W)(e.buffer, n.buffer);
            this.indexBuffer = n;
          }
          destroy() {
            for (let t = 0; t < this.batches.length; t++)
              this.batches[t].destroy();
            this.batches = null;
            for (let t = 0; t < this._elements.length; t++)
              this._elements[t].batch = null;
            (this._elements = null),
              (this.indexBuffer = null),
              this.attributeBuffer.destroy(),
              (this.attributeBuffer = null);
          }
        };
        d.defaultOptions = { vertexSize: 4, indexSize: 6 };
        let p = d;
      },
      9104: (t, e, i) => {
        "use strict";
        i.d(e, { k: () => n });
        const n = 16;
      },
      5611: (t, e, i) => {
        "use strict";
        i.d(e, { I: () => A, v: () => P });
        var n = i(9114),
          s = i(3012),
          r = i(268);
        function o(t, e, i) {
          if (t)
            for (const n in t) {
              const s = e[n.toLocaleLowerCase()];
              if (s) {
                let e = t[n];
                "header" === n &&
                  (e = e
                    .replace(/@in\s+[^;]+;\s*/g, "")
                    .replace(/@out\s+[^;]+;\s*/g, "")),
                  i && s.push(`//----${i}----//`),
                  s.push(e);
              } else (0, r.R)(`${n} placement hook does not exist in shader`);
            }
        }
        const a = /\{\{(.*?)\}\}/g;
        function l(t) {
          const e = {};
          return (
            (t.match(a)?.map((t) => t.replace(/[{()}]/g, "")) ?? []).forEach(
              (t) => {
                e[t] = [];
              }
            ),
            e
          );
        }
        function u(t, e) {
          let i;
          const n = /@in\s+([^;]+);/g;
          for (; null !== (i = n.exec(t)); ) e.push(i[1]);
        }
        function h(t, e, i = !1) {
          const n = [];
          u(e, n),
            t.forEach((t) => {
              t.header && u(t.header, n);
            });
          const s = n;
          i && s.sort();
          const r = s.map((t, e) => `       @location(${e}) ${t},`).join("\n");
          let o = e.replace(/@in\s+[^;]+;\s*/g, "");
          return (o = o.replace("{{in}}", `\n${r}\n`)), o;
        }
        function c(t, e) {
          let i;
          const n = /@out\s+([^;]+);/g;
          for (; null !== (i = n.exec(t)); ) e.push(i[1]);
        }
        function d(t, e) {
          let i = t;
          for (const t in e) {
            const n = e[t];
            i = n.join("\n").length
              ? i.replace(
                  `{{${t}}}`,
                  `//-----${t} START-----//\n${n.join(
                    "\n"
                  )}\n//----${t} FINISH----//`
                )
              : i.replace(`{{${t}}}`, "");
          }
          return i;
        }
        const p = Object.create(null),
          f = new Map();
        let m = 0;
        function g({ template: t, bits: e }) {
          const i = y(t, e);
          if (p[i]) return p[i];
          const { vertex: n, fragment: s } = (function (t, e) {
            const i = e.map((t) => t.vertex).filter((t) => !!t),
              n = e.map((t) => t.fragment).filter((t) => !!t);
            let s = h(i, t.vertex, !0);
            s = (function (t, e) {
              const i = [];
              c(e, i),
                t.forEach((t) => {
                  t.header && c(t.header, i);
                });
              let n = 0;
              const s = i
                  .sort()
                  .map((t) =>
                    t.indexOf("builtin") > -1 ? t : `@location(${n++}) ${t}`
                  )
                  .join(",\n"),
                r = i
                  .sort()
                  .map((t) => {
                    return `       var ${
                      ((e = t), e.replace(/@.*?\s+/g, ""))
                    };`;
                    var e;
                  })
                  .join("\n"),
                o = `return VSOutput(\n                ${i
                  .sort()
                  .map(
                    (t) =>
                      ` ${(function (t) {
                        const e = /\b(\w+)\s*:/g.exec(t);
                        return e ? e[1] : "";
                      })(t)}`
                  )
                  .join(",\n")});`;
              let a = e.replace(/@out\s+[^;]+;\s*/g, "");
              return (
                (a = a.replace("{{struct}}", `\n${s}\n`)),
                (a = a.replace("{{start}}", `\n${r}\n`)),
                (a = a.replace("{{return}}", `\n${o}\n`)),
                a
              );
            })(i, s);
            const r = h(n, t.fragment, !0);
            return { vertex: s, fragment: r };
          })(t, e);
          return (p[i] = x(n, s, e)), p[i];
        }
        function v({ template: t, bits: e }) {
          const i = y(t, e);
          return p[i] || (p[i] = x(t.vertex, t.fragment, e)), p[i];
        }
        function y(t, e) {
          return (
            e
              .map((t) => (f.has(t) || f.set(t, m++), f.get(t)))
              .sort((t, e) => t - e)
              .join("-") +
            t.vertex +
            t.fragment
          );
        }
        function x(t, e, i) {
          const n = l(t),
            s = l(e);
          return (
            i.forEach((t) => {
              o(t.vertex, n, t.name), o(t.fragment, s, t.name);
            }),
            { vertex: d(t, n), fragment: d(e, s) }
          );
        }
        const b =
            "\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n",
          S =
            "\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n",
          C =
            "\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n",
          _ =
            "\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n",
          T = {
            name: "global-uniforms-bit",
            vertex: {
              header:
                "\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        ",
            },
          },
          w = {
            name: "global-uniforms-bit",
            vertex: {
              header:
                "\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        ",
            },
          };
        function P({ bits: t, name: e }) {
          const i = g({
            template: { fragment: S, vertex: b },
            bits: [T, ...t],
          });
          return s.B.from({
            name: e,
            vertex: { source: i.vertex, entryPoint: "main" },
            fragment: { source: i.fragment, entryPoint: "main" },
          });
        }
        function A({ bits: t, name: e }) {
          return new n.M({
            name: e,
            ...v({ template: { vertex: C, fragment: _ }, bits: [w, ...t] }),
          });
        }
      },
      4459: (t, e, i) => {
        "use strict";
        i.d(e, { F: () => n, a: () => s });
        const n = {
            name: "color-bit",
            vertex: {
              header: "\n            @in aColor: vec4<f32>;\n        ",
              main: "\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        ",
            },
          },
          s = {
            name: "color-bit",
            vertex: {
              header: "\n            in vec4 aColor;\n        ",
              main: "\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        ",
            },
          };
      },
      4e3: (t, e, i) => {
        "use strict";
        i.d(e, { P: () => u, _: () => o });
        const n = {};
        function s(t) {
          const e = [];
          if (1 === t)
            e.push(
              "@group(1) @binding(0) var textureSource1: texture_2d<f32>;"
            ),
              e.push("@group(1) @binding(1) var textureSampler1: sampler;");
          else {
            let i = 0;
            for (let n = 0; n < t; n++)
              e.push(
                `@group(1) @binding(${i++}) var textureSource${
                  n + 1
                }: texture_2d<f32>;`
              ),
                e.push(
                  `@group(1) @binding(${i++}) var textureSampler${
                    n + 1
                  }: sampler;`
                );
          }
          return e.join("\n");
        }
        function r(t) {
          const e = [];
          if (1 === t)
            e.push(
              "outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);"
            );
          else {
            e.push("switch vTextureId {");
            for (let i = 0; i < t; i++)
              i === t - 1 ? e.push("  default:{") : e.push(`  case ${i}:{`),
                e.push(
                  `      outColor = textureSampleGrad(textureSource${
                    i + 1
                  }, textureSampler${i + 1}, vUV, uvDx, uvDy);`
                ),
                e.push("      break;}");
            e.push("}");
          }
          return e.join("\n");
        }
        function o(t) {
          return (
            n[t] ||
              (n[t] = {
                name: "texture-batch-bit",
                vertex: {
                  header:
                    "\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            ",
                  main: "\n                vTextureId = aTextureIdAndRound.y;\n            ",
                  end: "\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            ",
                },
                fragment: {
                  header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${s(
                    16
                  )}\n            `,
                  main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${r(
                    16
                  )}\n            `,
                },
              }),
            n[t]
          );
        }
        const a = {};
        function l(t) {
          const e = [];
          for (let i = 0; i < t; i++)
            i > 0 && e.push("else"),
              i < t - 1 && e.push(`if(vTextureId < ${i}.5)`),
              e.push("{"),
              e.push(`\toutColor = texture(uTextures[${i}], vUV);`),
              e.push("}");
          return e.join("\n");
        }
        function u(t) {
          return (
            a[t] ||
              (a[t] = {
                name: "texture-batch-bit",
                vertex: {
                  header:
                    "\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            ",
                  main: "\n                vTextureId = aTextureIdAndRound.y;\n            ",
                  end: "\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            ",
                },
                fragment: {
                  header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${t}];\n              \n            `,
                  main: `\n    \n                ${l(16)}\n            `,
                },
              }),
            a[t]
          );
        }
      },
      2067: (t, e, i) => {
        "use strict";
        i.d(e, { Ls: () => n, _Q: () => s, mA: () => r });
        const n = {
            name: "local-uniform-bit",
            vertex: {
              header:
                "\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        ",
              main: "\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        ",
              end: "\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        ",
            },
          },
          s = {
            ...n,
            vertex: {
              ...n.vertex,
              header: n.vertex.header.replace("group(1)", "group(2)"),
            },
          },
          r = {
            name: "local-uniform-bit",
            vertex: {
              header:
                "\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        ",
              main: "\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        ",
              end: "\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        ",
            },
          };
      },
      6665: (t, e, i) => {
        "use strict";
        i.d(e, { b: () => n, m: () => s });
        const n = {
            name: "round-pixels-bit",
            vertex: {
              header:
                "\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        ",
            },
          },
          s = {
            name: "round-pixels-bit",
            vertex: {
              header:
                "   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        ",
            },
          };
      },
      3391: (t, e, i) => {
        "use strict";
        i.d(e, { R: () => n, m: () => s });
        const n = {
            name: "texture-bit",
            vertex: {
              header:
                "\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        ",
              main: "\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        ",
            },
            fragment: {
              header:
                "\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        ",
              main: "\n            outColor = textureSample(uTexture, uSampler, vUV);\n        ",
            },
          },
          s = {
            name: "texture-bit",
            vertex: {
              header: "\n            uniform mat3 uTextureMatrix;\n        ",
              main: "\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        ",
            },
            fragment: {
              header:
                "\n        uniform sampler2D uTexture;\n\n         \n        ",
              main: "\n            outColor = texture(uTexture, vUV);\n        ",
            },
          };
      },
      8480: (t, e, i) => {
        "use strict";
        var n = i(8507),
          s = i(6844),
          r = i(9636),
          o = i(9443);
        const a = new r.c();
        function l(t, e, i) {
          const n = a;
          (t.measurable = !0),
            (0, o.fB)(t, i, n),
            e.addBoundsMask(n),
            (t.measurable = !1);
        }
        var u = i(7269),
          h = i(2208),
          c = i(268);
        function d(t, e, i) {
          const n = h.o.get();
          t.measurable = !0;
          const s = h.u.get().identity(),
            r = p(t, i, s);
          (0, u.n)(t, n, r),
            (t.measurable = !1),
            e.addBoundsMask(n),
            h.u.return(s),
            h.o.return(n);
        }
        function p(t, e, i) {
          return t
            ? (t !== e &&
                (p(t.parent, e, i),
                t.updateLocalTransform(),
                i.append(t.localTransform)),
              i)
            : ((0, c.R)(
                "Mask bounds, renderable is not inside the root container"
              ),
              i);
        }
        class f {
          constructor(t) {
            (this.priority = 0),
              (this.pipe = "alphaMask"),
              t?.mask && this.init(t.mask);
          }
          init(t) {
            (this.mask = t),
              (this.renderMaskToTexture = !(t instanceof s.k)),
              (this.mask.renderable = this.renderMaskToTexture),
              (this.mask.includeInBuild = !this.renderMaskToTexture),
              (this.mask.measurable = !1);
          }
          reset() {
            (this.mask.measurable = !0), (this.mask = null);
          }
          addBounds(t, e) {
            l(this.mask, t, e);
          }
          addLocalBounds(t, e) {
            d(this.mask, t, e);
          }
          containsPoint(t, e) {
            return e(this.mask, t);
          }
          destroy() {
            this.reset();
          }
          static test(t) {
            return t instanceof s.k;
          }
        }
        f.extension = n.Ag.MaskEffect;
        class m {
          constructor(t) {
            (this.priority = 0),
              (this.pipe = "colorMask"),
              t?.mask && this.init(t.mask);
          }
          init(t) {
            this.mask = t;
          }
          destroy() {}
          static test(t) {
            return "number" == typeof t;
          }
        }
        m.extension = n.Ag.MaskEffect;
        var g = i(4263);
        class v {
          constructor(t) {
            (this.priority = 0),
              (this.pipe = "stencilMask"),
              t?.mask && this.init(t.mask);
          }
          init(t) {
            (this.mask = t),
              (this.mask.includeInBuild = !1),
              (this.mask.measurable = !1);
          }
          reset() {
            (this.mask.measurable = !0),
              (this.mask.includeInBuild = !0),
              (this.mask = null);
          }
          addBounds(t, e) {
            l(this.mask, t, e);
          }
          addLocalBounds(t, e) {
            d(this.mask, t, e);
          }
          containsPoint(t, e) {
            return e(this.mask, t);
          }
          destroy() {
            this.reset();
          }
          static test(t) {
            return t instanceof g.mc;
          }
        }
        v.extension = n.Ag.MaskEffect;
        var y = i(2518),
          x = i(4884),
          b = i(8293),
          S = i(6139);
        i(6557);
        n.XO.add(f, m, v, S.$, b.b, x.q, y.P);
      },
      3151: (t, e, i) => {
        "use strict";
        i.d(e, { WebGLRenderer: () => Yt });
        var n = i(8507),
          s = i(9313),
          r = i(9104),
          o = i(5611),
          a = i(4459),
          l = i(4e3),
          u = i(2067),
          h = i(6665),
          c = i(108),
          d = i(8475),
          p = i(7222);
        class f {
          init() {
            const t = new p.k({
                uColor: {
                  value: new Float32Array([1, 1, 1, 1]),
                  type: "vec4<f32>",
                },
                uTransformMatrix: { value: new s.u(), type: "mat3x3<f32>" },
                uRound: { value: 0, type: "f32" },
              }),
              e = (0, o.I)({
                name: "graphics",
                bits: [a.a, (0, l.P)(r.k), u.mA, h.m],
              });
            this.shader = new d.M({
              glProgram: e,
              resources: { localUniforms: t, batchSamplers: c.v },
            });
          }
          execute(t, e) {
            const i = e.context,
              n = i.customShader || this.shader,
              s = t.renderer,
              r = s.graphicsContext,
              { geometry: o, instructions: a } = r.getContextRenderData(i);
            (n.groups[0] = s.globalUniforms.bindGroup),
              s.shader.bind(n),
              s.geometry.bind(o, n.glProgram);
            const l = a.instructions;
            for (let t = 0; t < a.instructionSize; t++) {
              const e = l[t];
              if (e.size) {
                for (let t = 0; t < e.textures.textures.length; t++)
                  s.texture.bind(e.textures.textures[t], t);
                s.geometry.draw("triangle-list", e.size, e.start);
              }
            }
          }
          destroy() {
            this.shader.destroy(!0), (this.shader = null);
          }
        }
        f.extension = { type: [n.Ag.WebGLPipesAdaptor], name: "graphics" };
        var m = i(3391),
          g = i(4492),
          v = i(268);
        class y {
          init() {
            const t = (0, o.I)({ name: "mesh", bits: [u.mA, m.m, h.m] });
            this._shader = new d.M({
              glProgram: t,
              resources: {
                uTexture: g.g.EMPTY.source,
                textureUniforms: {
                  uTextureMatrix: { type: "mat3x3<f32>", value: new s.u() },
                },
              },
            });
          }
          execute(t, e) {
            const i = t.renderer;
            let n = e._shader;
            if (n) {
              if (!n.glProgram)
                return void (0, v.R)("Mesh shader has no glProgram", e.shader);
            } else {
              n = this._shader;
              const t = e.texture,
                i = t.source;
              (n.resources.uTexture = i),
                (n.resources.uSampler = i.style),
                (n.resources.textureUniforms.uniforms.uTextureMatrix =
                  t.textureMatrix.mapCoord);
            }
            (n.groups[100] = i.globalUniforms.bindGroup),
              (n.groups[101] = t.localUniformsBindGroup),
              i.encoder.draw({
                geometry: e._geometry,
                shader: n,
                state: e.state,
              });
          }
          destroy() {
            this._shader.destroy(!0), (this._shader = null);
          }
        }
        y.extension = { type: [n.Ag.WebGLPipesAdaptor], name: "mesh" };
        var x = i(7547);
        class b {
          constructor() {
            (this._didUpload = !1), (this._tempState = x.U.for2d());
          }
          init(t) {
            const e = (0, o.I)({
              name: "batch",
              bits: [a.a, (0, l.P)(r.k), h.m],
            });
            (this._shader = new d.M({
              glProgram: e,
              resources: { batchSamplers: c.v },
            })),
              t.renderer.runners.contextChange.add(this);
          }
          contextChange() {
            this._didUpload = !1;
          }
          start(t, e) {
            const i = t.renderer;
            i.shader.bind(this._shader, this._didUpload),
              i.shader.updateUniformGroup(i.globalUniforms.uniformGroup),
              i.geometry.bind(e, this._shader.glProgram);
          }
          execute(t, e) {
            const i = t.renderer;
            (this._didUpload = !0),
              (this._tempState.blendMode = e.blendMode),
              i.state.set(this._tempState);
            const n = e.textures.textures;
            for (let t = 0; t < n.length; t++) i.texture.bind(n[t], t);
            i.geometry.draw("triangle-list", e.size, e.start);
          }
          destroy() {
            this._shader.destroy(!0), (this._shader = null);
          }
        }
        b.extension = { type: [n.Ag.WebGLPipesAdaptor], name: "batch" };
        var S = i(2855),
          C = i(3864),
          _ = i(5099),
          T = i(1132),
          w = ((t) => (
            (t[(t.ELEMENT_ARRAY_BUFFER = 34963)] = "ELEMENT_ARRAY_BUFFER"),
            (t[(t.ARRAY_BUFFER = 34962)] = "ARRAY_BUFFER"),
            (t[(t.UNIFORM_BUFFER = 35345)] = "UNIFORM_BUFFER"),
            t
          ))(w || {});
        class P {
          constructor(t, e) {
            (this.buffer = t || null),
              (this.updateID = -1),
              (this.byteLength = -1),
              (this.type = e);
          }
        }
        class A {
          constructor(t) {
            (this._gpuBuffers = Object.create(null)),
              (this._boundBufferBases = Object.create(null)),
              (this._renderer = t);
          }
          destroy() {
            (this._renderer = null),
              (this._gl = null),
              (this._gpuBuffers = null),
              (this._boundBufferBases = null);
          }
          contextChange() {
            (this._gpuBuffers = Object.create(null)),
              (this._gl = this._renderer.gl);
          }
          getGlBuffer(t) {
            return this._gpuBuffers[t.uid] || this.createGLBuffer(t);
          }
          bind(t) {
            const { _gl: e } = this,
              i = this.getGlBuffer(t);
            e.bindBuffer(i.type, i.buffer);
          }
          bindBufferBase(t, e) {
            const { _gl: i } = this;
            if (this._boundBufferBases[e] !== t) {
              const n = this.getGlBuffer(t);
              (this._boundBufferBases[e] = t),
                i.bindBufferBase(i.UNIFORM_BUFFER, e, n.buffer);
            }
          }
          bindBufferRange(t, e, i) {
            const { _gl: n } = this;
            i = i || 0;
            const s = this.getGlBuffer(t);
            n.bindBufferRange(n.UNIFORM_BUFFER, e || 0, s.buffer, 256 * i, 256);
          }
          updateBuffer(t) {
            const { _gl: e } = this,
              i = this.getGlBuffer(t);
            if (t._updateID === i.updateID) return i;
            (i.updateID = t._updateID), e.bindBuffer(i.type, i.buffer);
            const n = t.data;
            if (i.byteLength >= t.data.byteLength)
              e.bufferSubData(
                i.type,
                0,
                n,
                0,
                t._updateSize / n.BYTES_PER_ELEMENT
              );
            else {
              const s =
                t.descriptor.usage & T.S.STATIC
                  ? e.STATIC_DRAW
                  : e.DYNAMIC_DRAW;
              (i.byteLength = n.byteLength), e.bufferData(i.type, n, s);
            }
            return i;
          }
          destroyAll() {
            const t = this._gl;
            for (const e in this._gpuBuffers)
              t.deleteBuffer(this._gpuBuffers[e].buffer);
            this._gpuBuffers = Object.create(null);
          }
          onBufferDestroy(t, e) {
            const i = this._gpuBuffers[t.uid],
              n = this._gl;
            e || n.deleteBuffer(i.buffer), (this._gpuBuffers[t.uid] = null);
          }
          createGLBuffer(t) {
            const { _gl: e } = this;
            let i = w.ARRAY_BUFFER;
            t.descriptor.usage & T.S.INDEX
              ? (i = w.ELEMENT_ARRAY_BUFFER)
              : t.descriptor.usage & T.S.UNIFORM && (i = w.UNIFORM_BUFFER);
            const n = new P(e.createBuffer(), i);
            return (
              (this._gpuBuffers[t.uid] = n),
              t.on("destroy", this.onBufferDestroy, this),
              n
            );
          }
        }
        A.extension = { type: [n.Ag.WebGLSystem], name: "buffer" };
        var k = i(1761);
        const M = class t {
          constructor(t) {
            (this.supports = {
              uint32Indices: !0,
              uniformBufferObject: !0,
              vertexArrayObject: !0,
              srgbTextures: !0,
              nonPowOf2wrapping: !0,
              msaa: !0,
              nonPowOf2mipmaps: !0,
            }),
              (this._renderer = t),
              (this.extensions = Object.create(null)),
              (this.handleContextLost = this.handleContextLost.bind(this)),
              (this.handleContextRestored =
                this.handleContextRestored.bind(this));
          }
          get isLost() {
            return !this.gl || this.gl.isContextLost();
          }
          contextChange(t) {
            (this.gl = t), (this._renderer.gl = t);
          }
          init(e) {
            if ((e = { ...t.defaultOptions, ...e }).context)
              this.initFromContext(e.context);
            else {
              const t = this._renderer.background.alpha < 1,
                i = e.premultipliedAlpha ?? !0,
                n = e.antialias && !this._renderer.backBuffer.useBackBuffer;
              this.createContext(e.preferWebGLVersion, {
                alpha: t,
                premultipliedAlpha: i,
                antialias: n,
                stencil: !0,
                preserveDrawingBuffer: e.preserveDrawingBuffer,
                powerPreference: e.powerPreference ?? "default",
              });
            }
          }
          initFromContext(t) {
            (this.gl = t),
              (this.webGLVersion =
                t instanceof k.e.get().getWebGLRenderingContext() ? 1 : 2),
              this.getExtensions(),
              this.validateContext(t),
              this._renderer.runners.contextChange.emit(t);
            const e = this._renderer.view.canvas;
            e.addEventListener("webglcontextlost", this.handleContextLost, !1),
              e.addEventListener(
                "webglcontextrestored",
                this.handleContextRestored,
                !1
              );
          }
          createContext(t, e) {
            let i;
            const n = this._renderer.view.canvas;
            if (
              (2 === t && (i = n.getContext("webgl2", e)),
              !i && ((i = n.getContext("webgl", e)), !i))
            )
              throw new Error(
                "This browser does not support WebGL. Try using the canvas renderer"
              );
            (this.gl = i), this.initFromContext(this.gl);
          }
          getExtensions() {
            const { gl: t } = this,
              e = {
                anisotropicFiltering: t.getExtension(
                  "EXT_texture_filter_anisotropic"
                ),
                floatTextureLinear: t.getExtension("OES_texture_float_linear"),
                s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
                s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
                etc: t.getExtension("WEBGL_compressed_texture_etc"),
                etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
                pvrtc:
                  t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                atc: t.getExtension("WEBGL_compressed_texture_atc"),
                astc: t.getExtension("WEBGL_compressed_texture_astc"),
                bptc: t.getExtension("EXT_texture_compression_bptc"),
                rgtc: t.getExtension("EXT_texture_compression_rgtc"),
                loseContext: t.getExtension("WEBGL_lose_context"),
              };
            if (1 === this.webGLVersion)
              this.extensions = {
                ...e,
                drawBuffers: t.getExtension("WEBGL_draw_buffers"),
                depthTexture: t.getExtension("WEBGL_depth_texture"),
                vertexArrayObject:
                  t.getExtension("OES_vertex_array_object") ||
                  t.getExtension("MOZ_OES_vertex_array_object") ||
                  t.getExtension("WEBKIT_OES_vertex_array_object"),
                uint32ElementIndex: t.getExtension("OES_element_index_uint"),
                floatTexture: t.getExtension("OES_texture_float"),
                floatTextureLinear: t.getExtension("OES_texture_float_linear"),
                textureHalfFloat: t.getExtension("OES_texture_half_float"),
                textureHalfFloatLinear: t.getExtension(
                  "OES_texture_half_float_linear"
                ),
                vertexAttribDivisorANGLE: t.getExtension(
                  "ANGLE_instanced_arrays"
                ),
                srgb: t.getExtension("EXT_sRGB"),
              };
            else {
              this.extensions = {
                ...e,
                colorBufferFloat: t.getExtension("EXT_color_buffer_float"),
              };
              const i = t.getExtension("WEBGL_provoking_vertex");
              i && i.provokingVertexWEBGL(i.FIRST_VERTEX_CONVENTION_WEBGL);
            }
          }
          handleContextLost(t) {
            t.preventDefault(),
              this._contextLossForced &&
                ((this._contextLossForced = !1),
                setTimeout(() => {
                  this.gl.isContextLost() &&
                    this.extensions.loseContext?.restoreContext();
                }, 0));
          }
          handleContextRestored() {
            this._renderer.runners.contextChange.emit(this.gl);
          }
          destroy() {
            const t = this._renderer.view.canvas;
            (this._renderer = null),
              t.removeEventListener("webglcontextlost", this.handleContextLost),
              t.removeEventListener(
                "webglcontextrestored",
                this.handleContextRestored
              ),
              this.gl.useProgram(null),
              this.extensions.loseContext?.loseContext();
          }
          forceContextLoss() {
            this.extensions.loseContext?.loseContext(),
              (this._contextLossForced = !0);
          }
          validateContext(t) {
            const e = t.getContextAttributes();
            e &&
              !e.stencil &&
              (0, v.R)(
                "Provided WebGL context does not have a stencil buffer, masks may not render correctly"
              );
            const i = this.supports,
              n = 2 === this.webGLVersion,
              s = this.extensions;
            (i.uint32Indices = n || !!s.uint32ElementIndex),
              (i.uniformBufferObject = n),
              (i.vertexArrayObject = n || !!s.vertexArrayObject),
              (i.srgbTextures = n || !!s.srgb),
              (i.nonPowOf2wrapping = n),
              (i.nonPowOf2mipmaps = n),
              (i.msaa = n),
              i.uint32Indices ||
                (0, v.R)(
                  "Provided WebGL context does not support 32 index buffer, large scenes may not render correctly"
                );
          }
        };
        (M.extension = { type: [n.Ag.WebGLSystem], name: "context" }),
          (M.defaultOptions = {
            context: null,
            premultipliedAlpha: !0,
            preserveDrawingBuffer: !1,
            powerPreference: void 0,
            preferWebGLVersion: 2,
          });
        let E = M;
        var I = i(8306),
          D = i(7084),
          R = ((t) => (
            (t[(t.RGBA = 6408)] = "RGBA"),
            (t[(t.RGB = 6407)] = "RGB"),
            (t[(t.RG = 33319)] = "RG"),
            (t[(t.RED = 6403)] = "RED"),
            (t[(t.RGBA_INTEGER = 36249)] = "RGBA_INTEGER"),
            (t[(t.RGB_INTEGER = 36248)] = "RGB_INTEGER"),
            (t[(t.RG_INTEGER = 33320)] = "RG_INTEGER"),
            (t[(t.RED_INTEGER = 36244)] = "RED_INTEGER"),
            (t[(t.ALPHA = 6406)] = "ALPHA"),
            (t[(t.LUMINANCE = 6409)] = "LUMINANCE"),
            (t[(t.LUMINANCE_ALPHA = 6410)] = "LUMINANCE_ALPHA"),
            (t[(t.DEPTH_COMPONENT = 6402)] = "DEPTH_COMPONENT"),
            (t[(t.DEPTH_STENCIL = 34041)] = "DEPTH_STENCIL"),
            t
          ))(R || {}),
          B = ((t) => (
            (t[(t.TEXTURE_2D = 3553)] = "TEXTURE_2D"),
            (t[(t.TEXTURE_CUBE_MAP = 34067)] = "TEXTURE_CUBE_MAP"),
            (t[(t.TEXTURE_2D_ARRAY = 35866)] = "TEXTURE_2D_ARRAY"),
            (t[(t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
              "TEXTURE_CUBE_MAP_POSITIVE_X"),
            (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
              "TEXTURE_CUBE_MAP_NEGATIVE_X"),
            (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
              "TEXTURE_CUBE_MAP_POSITIVE_Y"),
            (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
              "TEXTURE_CUBE_MAP_NEGATIVE_Y"),
            (t[(t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
              "TEXTURE_CUBE_MAP_POSITIVE_Z"),
            (t[(t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
              "TEXTURE_CUBE_MAP_NEGATIVE_Z"),
            t
          ))(B || {}),
          F = ((t) => (
            (t[(t.UNSIGNED_BYTE = 5121)] = "UNSIGNED_BYTE"),
            (t[(t.UNSIGNED_SHORT = 5123)] = "UNSIGNED_SHORT"),
            (t[(t.UNSIGNED_SHORT_5_6_5 = 33635)] = "UNSIGNED_SHORT_5_6_5"),
            (t[(t.UNSIGNED_SHORT_4_4_4_4 = 32819)] = "UNSIGNED_SHORT_4_4_4_4"),
            (t[(t.UNSIGNED_SHORT_5_5_5_1 = 32820)] = "UNSIGNED_SHORT_5_5_5_1"),
            (t[(t.UNSIGNED_INT = 5125)] = "UNSIGNED_INT"),
            (t[(t.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
              "UNSIGNED_INT_10F_11F_11F_REV"),
            (t[(t.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
              "UNSIGNED_INT_2_10_10_10_REV"),
            (t[(t.UNSIGNED_INT_24_8 = 34042)] = "UNSIGNED_INT_24_8"),
            (t[(t.UNSIGNED_INT_5_9_9_9_REV = 35902)] =
              "UNSIGNED_INT_5_9_9_9_REV"),
            (t[(t.BYTE = 5120)] = "BYTE"),
            (t[(t.SHORT = 5122)] = "SHORT"),
            (t[(t.INT = 5124)] = "INT"),
            (t[(t.FLOAT = 5126)] = "FLOAT"),
            (t[(t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
              "FLOAT_32_UNSIGNED_INT_24_8_REV"),
            (t[(t.HALF_FLOAT = 36193)] = "HALF_FLOAT"),
            t
          ))(F || {});
        const O = {
          uint8x2: F.UNSIGNED_BYTE,
          uint8x4: F.UNSIGNED_BYTE,
          sint8x2: F.BYTE,
          sint8x4: F.BYTE,
          unorm8x2: F.UNSIGNED_BYTE,
          unorm8x4: F.UNSIGNED_BYTE,
          snorm8x2: F.BYTE,
          snorm8x4: F.BYTE,
          uint16x2: F.UNSIGNED_SHORT,
          uint16x4: F.UNSIGNED_SHORT,
          sint16x2: F.SHORT,
          sint16x4: F.SHORT,
          unorm16x2: F.UNSIGNED_SHORT,
          unorm16x4: F.UNSIGNED_SHORT,
          snorm16x2: F.SHORT,
          snorm16x4: F.SHORT,
          float16x2: F.HALF_FLOAT,
          float16x4: F.HALF_FLOAT,
          float32: F.FLOAT,
          float32x2: F.FLOAT,
          float32x3: F.FLOAT,
          float32x4: F.FLOAT,
          uint32: F.UNSIGNED_INT,
          uint32x2: F.UNSIGNED_INT,
          uint32x3: F.UNSIGNED_INT,
          uint32x4: F.UNSIGNED_INT,
          sint32: F.INT,
          sint32x2: F.INT,
          sint32x3: F.INT,
          sint32x4: F.INT,
        };
        const z = {
          "point-list": 0,
          "line-list": 1,
          "line-strip": 3,
          "triangle-list": 4,
          "triangle-strip": 5,
        };
        class L {
          constructor(t) {
            (this._geometryVaoHash = Object.create(null)),
              (this._renderer = t),
              (this._activeGeometry = null),
              (this._activeVao = null),
              (this.hasVao = !0),
              (this.hasInstance = !0);
          }
          contextChange() {
            const t = (this.gl = this._renderer.gl);
            if (!this._renderer.context.supports.vertexArrayObject)
              throw new Error(
                "[PixiJS] Vertex Array Objects are not supported on this device"
              );
            const e = this._renderer.context.extensions.vertexArrayObject;
            e &&
              ((t.createVertexArray = () => e.createVertexArrayOES()),
              (t.bindVertexArray = (t) => e.bindVertexArrayOES(t)),
              (t.deleteVertexArray = (t) => e.deleteVertexArrayOES(t)));
            const i =
              this._renderer.context.extensions.vertexAttribDivisorANGLE;
            i &&
              ((t.drawArraysInstanced = (t, e, n, s) => {
                i.drawArraysInstancedANGLE(t, e, n, s);
              }),
              (t.drawElementsInstanced = (t, e, n, s, r) => {
                i.drawElementsInstancedANGLE(t, e, n, s, r);
              }),
              (t.vertexAttribDivisor = (t, e) =>
                i.vertexAttribDivisorANGLE(t, e))),
              (this._activeGeometry = null),
              (this._activeVao = null),
              (this._geometryVaoHash = Object.create(null));
          }
          bind(t, e) {
            const i = this.gl;
            this._activeGeometry = t;
            const n = this.getVao(t, e);
            this._activeVao !== n &&
              ((this._activeVao = n), i.bindVertexArray(n)),
              this.updateBuffers();
          }
          reset() {
            this.unbind();
          }
          updateBuffers() {
            const t = this._activeGeometry,
              e = this._renderer.buffer;
            for (let i = 0; i < t.buffers.length; i++) {
              const n = t.buffers[i];
              e.updateBuffer(n);
            }
          }
          checkCompatibility(t, e) {
            const i = t.attributes,
              n = e._attributeData;
            for (const t in n)
              if (!i[t])
                throw new Error(
                  `shader and geometry incompatible, geometry missing the "${t}" attribute`
                );
          }
          getSignature(t, e) {
            const i = t.attributes,
              n = e._attributeData,
              s = ["g", t.uid];
            for (const t in i) n[t] && s.push(t, n[t].location);
            return s.join("-");
          }
          getVao(t, e) {
            return (
              this._geometryVaoHash[t.uid]?.[e._key] ||
              this.initGeometryVao(t, e)
            );
          }
          initGeometryVao(t, e, i = !0) {
            const n = this._renderer.gl,
              s = this._renderer.buffer;
            this._renderer.shader._getProgramData(e),
              this.checkCompatibility(t, e);
            const r = this.getSignature(t, e);
            this._geometryVaoHash[t.uid] ||
              ((this._geometryVaoHash[t.uid] = Object.create(null)),
              t.on("destroy", this.onGeometryDestroy, this));
            const o = this._geometryVaoHash[t.uid];
            let a = o[r];
            if (a) return (o[e._key] = a), a;
            (0, D.q)(t, e._attributeData);
            const l = t.buffers;
            (a = n.createVertexArray()), n.bindVertexArray(a);
            for (let t = 0; t < l.length; t++) {
              const e = l[t];
              s.bind(e);
            }
            return (
              this.activateVao(t, e),
              (o[e._key] = a),
              (o[r] = a),
              n.bindVertexArray(null),
              a
            );
          }
          onGeometryDestroy(t, e) {
            const i = this._geometryVaoHash[t.uid],
              n = this.gl;
            if (i) {
              if (e)
                for (const t in i)
                  this._activeVao !== i[t] && this.unbind(),
                    n.deleteVertexArray(i[t]);
              this._geometryVaoHash[t.uid] = null;
            }
          }
          destroyAll(t = !1) {
            const e = this.gl;
            for (const i in this._geometryVaoHash) {
              if (t)
                for (const t in this._geometryVaoHash[i]) {
                  const n = this._geometryVaoHash[i];
                  this._activeVao !== n && this.unbind(),
                    e.deleteVertexArray(n[t]);
                }
              this._geometryVaoHash[i] = null;
            }
          }
          activateVao(t, e) {
            const i = this._renderer.gl,
              n = this._renderer.buffer,
              s = t.attributes;
            t.indexBuffer && n.bind(t.indexBuffer);
            let r = null;
            for (const t in s) {
              const a = s[t],
                l = a.buffer,
                u = n.getGlBuffer(l),
                h = e._attributeData[t];
              if (h) {
                r !== u && (n.bind(l), (r = u));
                const t = a.location;
                i.enableVertexAttribArray(t);
                const e = (0, I.m)(a.format),
                  s = ((o = a.format), O[o] ?? O.float32);
                if (
                  ("int" === h.format?.substring(1, 4)
                    ? i.vertexAttribIPointer(t, e.size, s, a.stride, a.offset)
                    : i.vertexAttribPointer(
                        t,
                        e.size,
                        s,
                        e.normalised,
                        a.stride,
                        a.offset
                      ),
                  a.instance)
                ) {
                  if (!this.hasInstance)
                    throw new Error(
                      "geometry error, GPU Instancing is not supported on this device"
                    );
                  i.vertexAttribDivisor(t, 1);
                }
              }
            }
            var o;
          }
          draw(t, e, i, n) {
            const { gl: s } = this._renderer,
              r = this._activeGeometry,
              o = z[r.topology || t];
            if ((n || (n = r.instanceCount), r.indexBuffer)) {
              const t = r.indexBuffer.data.BYTES_PER_ELEMENT,
                a = 2 === t ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
              n > 1
                ? s.drawElementsInstanced(
                    o,
                    e || r.indexBuffer.data.length,
                    a,
                    (i || 0) * t,
                    n
                  )
                : s.drawElements(
                    o,
                    e || r.indexBuffer.data.length,
                    a,
                    (i || 0) * t
                  );
            } else
              n > 1
                ? s.drawArraysInstanced(o, i || 0, e || r.getSize(), n)
                : s.drawArrays(o, i || 0, e || r.getSize());
            return this;
          }
          unbind() {
            this.gl.bindVertexArray(null),
              (this._activeVao = null),
              (this._activeGeometry = null);
          }
          destroy() {
            (this._renderer = null),
              (this.gl = null),
              (this._activeVao = null),
              (this._activeGeometry = null);
          }
        }
        L.extension = { type: [n.Ag.WebGLSystem], name: "geometry" };
        var H = i(6011),
          U = i(6932),
          N = i(9114);
        const G = new H.V({
            attributes: { aPosition: [-1, -1, 3, -1, -1, 3] },
          }),
          V = class t {
            constructor(t) {
              (this.useBackBuffer = !1),
                (this._useBackBufferThisRender = !1),
                (this._renderer = t);
            }
            init(e = {}) {
              const { useBackBuffer: i, antialias: n } = {
                ...t.defaultOptions,
                ...e,
              };
              (this.useBackBuffer = i),
                (this._antialias = n),
                this._renderer.context.supports.msaa ||
                  ((0, v.R)(
                    "antialiasing, is not supported on when using the back buffer"
                  ),
                  (this._antialias = !1)),
                (this._state = x.U.for2d());
              const s = new N.M({
                vertex:
                  "\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n\n                    vUv = (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y = 1.0 - vUv.y;\n                }",
                fragment:
                  "\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor = texture(uTexture, vUv);\n                }",
                name: "big-triangle",
              });
              this._bigTriangleShader = new d.M({
                glProgram: s,
                resources: { uTexture: g.g.WHITE.source },
              });
            }
            renderStart(t) {
              const e = this._renderer.renderTarget.getRenderTarget(t.target);
              if (
                ((this._useBackBufferThisRender =
                  this.useBackBuffer && !!e.isRoot),
                this._useBackBufferThisRender)
              ) {
                const e = this._renderer.renderTarget.getRenderTarget(t.target);
                (this._targetTexture = e.colorTexture),
                  (t.target = this._getBackBufferTexture(e.colorTexture));
              }
            }
            renderEnd() {
              this._presentBackBuffer();
            }
            _presentBackBuffer() {
              const t = this._renderer;
              t.renderTarget.finishRenderPass(),
                this._useBackBufferThisRender &&
                  (t.renderTarget.bind(this._targetTexture, !1),
                  (this._bigTriangleShader.resources.uTexture =
                    this._backBufferTexture.source),
                  t.encoder.draw({
                    geometry: G,
                    shader: this._bigTriangleShader,
                    state: this._state,
                  }));
            }
            _getBackBufferTexture(t) {
              return (
                (this._backBufferTexture =
                  this._backBufferTexture ||
                  new g.g({
                    source: new U.v({
                      width: t.width,
                      height: t.height,
                      resolution: t._resolution,
                      antialias: this._antialias,
                    }),
                  })),
                this._backBufferTexture.source.resize(
                  t.width,
                  t.height,
                  t._resolution
                ),
                this._backBufferTexture
              );
            }
            destroy() {
              this._backBufferTexture &&
                (this._backBufferTexture.destroy(),
                (this._backBufferTexture = null));
            }
          };
        (V.extension = {
          type: [n.Ag.WebGLSystem],
          name: "backBuffer",
          priority: 1,
        }),
          (V.defaultOptions = { useBackBuffer: !1 });
        let j = V;
        class $ {
          constructor(t) {
            (this._colorMaskCache = 15), (this._renderer = t);
          }
          setMask(t) {
            this._colorMaskCache !== t &&
              ((this._colorMaskCache = t),
              this._renderer.gl.colorMask(
                !!(8 & t),
                !!(4 & t),
                !!(2 & t),
                !!(1 & t)
              ));
          }
        }
        $.extension = { type: [n.Ag.WebGLSystem], name: "colorMask" };
        class q {
          constructor(t) {
            (this.commandFinished = Promise.resolve()), (this._renderer = t);
          }
          setGeometry(t, e) {
            this._renderer.geometry.bind(t, e.glProgram);
          }
          finishRenderPass() {}
          draw(t) {
            const e = this._renderer,
              {
                geometry: i,
                shader: n,
                state: s,
                skipSync: r,
                topology: o,
                size: a,
                start: l,
                instanceCount: u,
              } = t;
            e.shader.bind(n, r),
              e.geometry.bind(i, e.shader._activeProgram),
              s && e.state.set(s),
              e.geometry.draw(o, a, l, u ?? i.instanceCount);
          }
          destroy() {
            this._renderer = null;
          }
        }
        q.extension = { type: [n.Ag.WebGLSystem], name: "encoder" };
        var W = i(1172),
          X = i(1957);
        class Y {
          constructor(t) {
            (this._stencilCache = {
              enabled: !1,
              stencilReference: 0,
              stencilMode: X.K.NONE,
            }),
              (this._renderTargetStencilState = Object.create(null)),
              t.renderTarget.onRenderTargetChange.add(this);
          }
          contextChange(t) {
            (this._gl = t),
              (this._comparisonFuncMapping = {
                always: t.ALWAYS,
                never: t.NEVER,
                equal: t.EQUAL,
                "not-equal": t.NOTEQUAL,
                less: t.LESS,
                "less-equal": t.LEQUAL,
                greater: t.GREATER,
                "greater-equal": t.GEQUAL,
              }),
              (this._stencilOpsMapping = {
                keep: t.KEEP,
                zero: t.ZERO,
                replace: t.REPLACE,
                invert: t.INVERT,
                "increment-clamp": t.INCR,
                "decrement-clamp": t.DECR,
                "increment-wrap": t.INCR_WRAP,
                "decrement-wrap": t.DECR_WRAP,
              }),
              (this._stencilCache.enabled = !1),
              (this._stencilCache.stencilMode = X.K.NONE),
              (this._stencilCache.stencilReference = 0);
          }
          onRenderTargetChange(t) {
            if (this._activeRenderTarget === t) return;
            this._activeRenderTarget = t;
            let e = this._renderTargetStencilState[t.uid];
            e ||
              (e = this._renderTargetStencilState[t.uid] =
                { stencilMode: X.K.DISABLED, stencilReference: 0 }),
              this.setStencilMode(e.stencilMode, e.stencilReference);
          }
          setStencilMode(t, e) {
            const i =
                this._renderTargetStencilState[this._activeRenderTarget.uid],
              n = this._gl,
              s = W.g[t],
              r = this._stencilCache;
            (i.stencilMode = t),
              (i.stencilReference = e),
              t !== X.K.DISABLED
                ? (this._stencilCache.enabled ||
                    ((this._stencilCache.enabled = !0),
                    n.enable(n.STENCIL_TEST)),
                  (t === r.stencilMode && r.stencilReference === e) ||
                    ((r.stencilMode = t),
                    (r.stencilReference = e),
                    n.stencilFunc(
                      this._comparisonFuncMapping[s.stencilBack.compare],
                      e,
                      255
                    ),
                    n.stencilOp(
                      n.KEEP,
                      n.KEEP,
                      this._stencilOpsMapping[s.stencilBack.passOp]
                    )))
                : this._stencilCache.enabled &&
                  ((this._stencilCache.enabled = !1),
                  n.disable(n.STENCIL_TEST));
          }
        }
        Y.extension = { type: [n.Ag.WebGLSystem], name: "stencil" };
        var K = i(7047);
        const Z = {
          f32: 4,
          "vec2<f32>": 8,
          "vec3<f32>": 12,
          "vec4<f32>": 16,
          "mat2x2<f32>": 32,
          "mat3x3<f32>": 48,
          "mat4x4<f32>": 64,
        };
        function Q(t) {
          const e = t.map((t) => ({ data: t, offset: 0, size: 0 }));
          let i = 0,
            n = 0,
            s = 0;
          for (let t = 0; t < e.length; t++) {
            const r = e[t];
            if (((i = Z[r.data.type]), !i))
              throw new Error(`Unknown type ${r.data.type}`);
            if (
              (r.data.size > 1 && (i = Math.max(i, 16) * r.data.size),
              (r.size = i),
              n % i != 0 && n < 16)
            ) {
              const t = (n % i) % 16;
              (n += t), (s += t);
            }
            n + i > 16
              ? ((s = 16 * Math.ceil(s / 16)),
                (r.offset = s),
                (s += i),
                (n = i))
              : ((r.offset = s), (n += i), (s += i));
          }
          return (s = 16 * Math.ceil(s / 16)), { uboElements: e, size: s };
        }
        var J = i(6423),
          tt = i(1266);
        function et(t, e) {
          const i = Math.max(Z[t.data.type] / 16, 1),
            n = t.data.value.length / t.data.size,
            s = (4 - (n % 4)) % 4;
          return `\n        v = uv.${
            t.data.name
          };\n        offset += ${e};\n\n        arrayOffset = offset;\n\n        t = 0;\n\n        for(var i=0; i < ${
            t.data.size * i
          }; i++)\n        {\n            for(var j = 0; j < ${n}; j++)\n            {\n                data[arrayOffset++] = v[t++];\n            }\n            ${
            0 !== s ? `arrayOffset += ${s};` : ""
          }\n        }\n    `;
        }
        function it(t) {
          return (0, J.E)(t, "uboStd40", et, tt.g);
        }
        class nt extends K.W {
          constructor() {
            super({ createUboElements: Q, generateUboSync: it });
          }
        }
        nt.extension = { type: [n.Ag.WebGLSystem], name: "ubo" };
        var st = i(7238),
          rt = i(9252),
          ot = i(4884),
          at = i(1257);
        class lt {
          constructor() {
            (this.width = -1),
              (this.height = -1),
              (this.msaa = !1),
              (this.msaaRenderBuffer = []);
          }
        }
        class ut {
          constructor() {
            (this._clearColorCache = [0, 0, 0, 0]),
              (this._viewPortCache = new rt.M());
          }
          init(t, e) {
            (this._renderer = t),
              (this._renderTargetSystem = e),
              t.runners.contextChange.add(this);
          }
          contextChange() {
            (this._clearColorCache = [0, 0, 0, 0]),
              (this._viewPortCache = new rt.M());
          }
          copyToTexture(t, e, i, n, s) {
            const r = this._renderTargetSystem,
              o = this._renderer,
              a = r.getGpuRenderTarget(t),
              l = o.gl;
            return (
              this.finishRenderPass(t),
              l.bindFramebuffer(l.FRAMEBUFFER, a.resolveTargetFramebuffer),
              o.texture.bind(e, 0),
              l.copyTexSubImage2D(
                l.TEXTURE_2D,
                0,
                s.x,
                s.y,
                i.x,
                i.y,
                n.width,
                n.height
              ),
              e
            );
          }
          startRenderPass(t, e = !0, i, n) {
            const s = this._renderTargetSystem,
              r = t.colorTexture,
              o = s.getGpuRenderTarget(t);
            let a = n.y;
            t.isRoot && (a = r.pixelHeight - n.height),
              t.colorTextures.forEach((t) => {
                this._renderer.texture.unbind(t);
              });
            const l = this._renderer.gl;
            l.bindFramebuffer(l.FRAMEBUFFER, o.framebuffer);
            const u = this._viewPortCache;
            (u.x === n.x &&
              u.y === a &&
              u.width === n.width &&
              u.height === n.height) ||
              ((u.x = n.x),
              (u.y = a),
              (u.width = n.width),
              (u.height = n.height),
              l.viewport(n.x, a, n.width, n.height)),
              o.depthStencilRenderBuffer ||
                (!t.stencil && !t.depth) ||
                this._initStencil(o),
              this.clear(t, e, i);
          }
          finishRenderPass(t) {
            const e = this._renderTargetSystem.getGpuRenderTarget(t);
            if (!e.msaa) return;
            const i = this._renderer.gl;
            i.bindFramebuffer(i.FRAMEBUFFER, e.resolveTargetFramebuffer),
              i.bindFramebuffer(i.READ_FRAMEBUFFER, e.framebuffer),
              i.blitFramebuffer(
                0,
                0,
                e.width,
                e.height,
                0,
                0,
                e.width,
                e.height,
                i.COLOR_BUFFER_BIT,
                i.NEAREST
              ),
              i.bindFramebuffer(i.FRAMEBUFFER, e.framebuffer);
          }
          initGpuRenderTarget(t) {
            const e = this._renderer.gl,
              i = new lt();
            return ot.q.test(t.colorTexture.resource)
              ? ((i.framebuffer = null), i)
              : (this._initColor(t, i),
                e.bindFramebuffer(e.FRAMEBUFFER, null),
                i);
          }
          clear(t, e, i) {
            if (!e) return;
            const n = this._renderTargetSystem;
            "boolean" == typeof e && (e = e ? at.u.ALL : at.u.NONE);
            const s = this._renderer.gl;
            if (e & at.u.COLOR) {
              i ?? (i = n.defaultClearColor);
              const t = this._clearColorCache,
                e = i;
              (t[0] === e[0] &&
                t[1] === e[1] &&
                t[2] === e[2] &&
                t[3] === e[3]) ||
                ((t[0] = e[0]),
                (t[1] = e[1]),
                (t[2] = e[2]),
                (t[3] = e[3]),
                s.clearColor(e[0], e[1], e[2], e[3]));
            }
            s.clear(e);
          }
          resizeGpuRenderTarget(t) {
            if (t.isRoot) return;
            const e = this._renderTargetSystem.getGpuRenderTarget(t);
            this._resizeColor(t, e), t.stencil && this._resizeStencil(e);
          }
          _initColor(t, e) {
            const i = this._renderer,
              n = i.gl,
              s = n.createFramebuffer();
            if (
              ((e.resolveTargetFramebuffer = s),
              n.bindFramebuffer(n.FRAMEBUFFER, s),
              (e.width = t.colorTexture.source.pixelWidth),
              (e.height = t.colorTexture.source.pixelHeight),
              t.colorTextures.forEach((t, s) => {
                const r = t.source;
                r.antialias &&
                  (i.context.supports.msaa
                    ? (e.msaa = !0)
                    : (0, v.R)(
                        "[RenderTexture] Antialiasing on textures is not supported in WebGL1"
                      )),
                  i.texture.bindSource(r, 0);
                const o = i.texture.getGlSource(r).texture;
                n.framebufferTexture2D(
                  n.FRAMEBUFFER,
                  n.COLOR_ATTACHMENT0 + s,
                  3553,
                  o,
                  0
                );
              }),
              e.msaa)
            ) {
              const i = n.createFramebuffer();
              (e.framebuffer = i),
                n.bindFramebuffer(n.FRAMEBUFFER, i),
                t.colorTextures.forEach((t, i) => {
                  const s = n.createRenderbuffer();
                  e.msaaRenderBuffer[i] = s;
                });
            } else e.framebuffer = s;
            this._resizeColor(t, e);
          }
          _resizeColor(t, e) {
            const i = t.colorTexture.source;
            if (
              ((e.width = i.pixelWidth),
              (e.height = i.pixelHeight),
              t.colorTextures.forEach((t, e) => {
                0 !== e && t.source.resize(i.width, i.height, i._resolution);
              }),
              e.msaa)
            ) {
              const i = this._renderer,
                n = i.gl,
                s = e.framebuffer;
              n.bindFramebuffer(n.FRAMEBUFFER, s),
                t.colorTextures.forEach((t, s) => {
                  const r = t.source;
                  i.texture.bindSource(r, 0);
                  const o = i.texture.getGlSource(r).internalFormat,
                    a = e.msaaRenderBuffer[s];
                  n.bindRenderbuffer(n.RENDERBUFFER, a),
                    n.renderbufferStorageMultisample(
                      n.RENDERBUFFER,
                      4,
                      o,
                      r.pixelWidth,
                      r.pixelHeight
                    ),
                    n.framebufferRenderbuffer(
                      n.FRAMEBUFFER,
                      n.COLOR_ATTACHMENT0 + s,
                      n.RENDERBUFFER,
                      a
                    );
                });
            }
          }
          _initStencil(t) {
            if (null === t.framebuffer) return;
            const e = this._renderer.gl,
              i = e.createRenderbuffer();
            (t.depthStencilRenderBuffer = i),
              e.bindRenderbuffer(e.RENDERBUFFER, i),
              e.framebufferRenderbuffer(
                e.FRAMEBUFFER,
                e.DEPTH_STENCIL_ATTACHMENT,
                e.RENDERBUFFER,
                i
              ),
              this._resizeStencil(t);
          }
          _resizeStencil(t) {
            const e = this._renderer.gl;
            e.bindRenderbuffer(e.RENDERBUFFER, t.depthStencilRenderBuffer),
              t.msaa
                ? e.renderbufferStorageMultisample(
                    e.RENDERBUFFER,
                    4,
                    e.DEPTH24_STENCIL8,
                    t.width,
                    t.height
                  )
                : e.renderbufferStorage(
                    e.RENDERBUFFER,
                    2 === this._renderer.context.webGLVersion
                      ? e.DEPTH24_STENCIL8
                      : e.DEPTH_STENCIL,
                    t.width,
                    t.height
                  );
          }
        }
        class ht extends st.l {
          constructor(t) {
            super(t), (this.adaptor = new ut()), this.adaptor.init(t, this);
          }
        }
        ht.extension = { type: [n.Ag.WebGLSystem], name: "renderTarget" };
        var ct = i(581);
        class dt {
          constructor(t, e) {
            (this.program = t),
              (this.uniformData = e),
              (this.uniformGroups = {}),
              (this.uniformDirtyGroups = {}),
              (this.uniformBlockBindings = {});
          }
          destroy() {
            (this.uniformData = null),
              (this.uniformGroups = null),
              (this.uniformDirtyGroups = null),
              (this.uniformBlockBindings = null),
              (this.program = null);
          }
        }
        function pt(t, e, i) {
          const n = t.createShader(e);
          return t.shaderSource(n, i), t.compileShader(n), n;
        }
        function ft(t) {
          const e = new Array(t);
          for (let t = 0; t < e.length; t++) e[t] = !1;
          return e;
        }
        function mt(t, e) {
          switch (t) {
            case "float":
            case "int":
            case "uint":
            case "sampler2D":
            case "sampler2DArray":
              return 0;
            case "vec2":
              return new Float32Array(2 * e);
            case "vec3":
              return new Float32Array(3 * e);
            case "vec4":
              return new Float32Array(4 * e);
            case "ivec2":
              return new Int32Array(2 * e);
            case "ivec3":
              return new Int32Array(3 * e);
            case "ivec4":
              return new Int32Array(4 * e);
            case "uvec2":
              return new Uint32Array(2 * e);
            case "uvec3":
              return new Uint32Array(3 * e);
            case "uvec4":
              return new Uint32Array(4 * e);
            case "bool":
              return !1;
            case "bvec2":
              return ft(2 * e);
            case "bvec3":
              return ft(3 * e);
            case "bvec4":
              return ft(4 * e);
            case "mat2":
              return new Float32Array([1, 0, 0, 1]);
            case "mat3":
              return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
            case "mat4":
              return new Float32Array([
                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
              ]);
          }
          return null;
        }
        let gt = null;
        const vt = {
            FLOAT: "float",
            FLOAT_VEC2: "vec2",
            FLOAT_VEC3: "vec3",
            FLOAT_VEC4: "vec4",
            INT: "int",
            INT_VEC2: "ivec2",
            INT_VEC3: "ivec3",
            INT_VEC4: "ivec4",
            UNSIGNED_INT: "uint",
            UNSIGNED_INT_VEC2: "uvec2",
            UNSIGNED_INT_VEC3: "uvec3",
            UNSIGNED_INT_VEC4: "uvec4",
            BOOL: "bool",
            BOOL_VEC2: "bvec2",
            BOOL_VEC3: "bvec3",
            BOOL_VEC4: "bvec4",
            FLOAT_MAT2: "mat2",
            FLOAT_MAT3: "mat3",
            FLOAT_MAT4: "mat4",
            SAMPLER_2D: "sampler2D",
            INT_SAMPLER_2D: "sampler2D",
            UNSIGNED_INT_SAMPLER_2D: "sampler2D",
            SAMPLER_CUBE: "samplerCube",
            INT_SAMPLER_CUBE: "samplerCube",
            UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
            SAMPLER_2D_ARRAY: "sampler2DArray",
            INT_SAMPLER_2D_ARRAY: "sampler2DArray",
            UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray",
          },
          yt = {
            float: "float32",
            vec2: "float32x2",
            vec3: "float32x3",
            vec4: "float32x4",
            int: "sint32",
            ivec2: "sint32x2",
            ivec3: "sint32x3",
            ivec4: "sint32x4",
            uint: "uint32",
            uvec2: "uint32x2",
            uvec3: "uint32x3",
            uvec4: "uint32x4",
            bool: "uint32",
            bvec2: "uint32x2",
            bvec3: "uint32x3",
            bvec4: "uint32x4",
          };
        function xt(t, e) {
          if (!gt) {
            const e = Object.keys(vt);
            gt = {};
            for (let i = 0; i < e.length; ++i) {
              const n = e[i];
              gt[t[n]] = vt[n];
            }
          }
          return gt[e];
        }
        function bt(t, e) {
          const i = xt(t, e);
          return yt[i] || "float32";
        }
        function St(t, e) {
          const i = t
              .getShaderSource(e)
              .split("\n")
              .map((t, e) => `${e}: ${t}`),
            n = t.getShaderInfoLog(e),
            s = n.split("\n"),
            r = {},
            o = s
              .map((t) =>
                parseFloat(t.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))
              )
              .filter((t) => !(!t || r[t]) && ((r[t] = !0), !0)),
            a = [""];
          o.forEach((t) => {
            (i[t - 1] = `%c${i[t - 1]}%c`),
              a.push(
                "background: #FF0000; color:#FFFFFF; font-size: 10px",
                "font-size: 10px"
              );
          });
          const l = i.join("\n");
          (a[0] = l),
            console.error(n),
            console.groupCollapsed("click to view full shader code"),
            console.warn(...a),
            console.groupEnd();
        }
        function Ct(t, e) {
          const i = pt(t, t.VERTEX_SHADER, e.vertex),
            n = pt(t, t.FRAGMENT_SHADER, e.fragment),
            s = t.createProgram();
          t.attachShader(s, i), t.attachShader(s, n);
          const r = e.transformFeedbackVaryings;
          r &&
            ("function" != typeof t.transformFeedbackVaryings
              ? (0, v.R)(
                  "TransformFeedback is not supported but TransformFeedbackVaryings are given."
                )
              : t.transformFeedbackVaryings(
                  s,
                  r.names,
                  "separate" === r.bufferMode
                    ? t.SEPARATE_ATTRIBS
                    : t.INTERLEAVED_ATTRIBS
                )),
            t.linkProgram(s),
            t.getProgramParameter(s, t.LINK_STATUS) ||
              (function (t, e, i, n) {
                t.getProgramParameter(e, t.LINK_STATUS) ||
                  (t.getShaderParameter(i, t.COMPILE_STATUS) || St(t, i),
                  t.getShaderParameter(n, t.COMPILE_STATUS) || St(t, n),
                  console.error("PixiJS Error: Could not initialize shader."),
                  "" !== t.getProgramInfoLog(e) &&
                    console.warn(
                      "PixiJS Warning: gl.getProgramInfoLog()",
                      t.getProgramInfoLog(e)
                    ));
              })(t, s, i, n),
            (e._attributeData = (function (t, e, i = !1) {
              const n = {},
                s = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
              for (let i = 0; i < s; i++) {
                const s = e.getActiveAttrib(t, i);
                if (s.name.startsWith("gl_")) continue;
                const r = bt(e, s.type);
                n[s.name] = {
                  location: 0,
                  format: r,
                  stride: (0, I.m)(r).stride,
                  offset: 0,
                  instance: !1,
                  start: 0,
                };
              }
              const r = Object.keys(n);
              if (i) {
                r.sort((t, e) => (t > e ? 1 : -1));
                for (let i = 0; i < r.length; i++)
                  (n[r[i]].location = i), e.bindAttribLocation(t, i, r[i]);
                e.linkProgram(t);
              } else
                for (let i = 0; i < r.length; i++)
                  n[r[i]].location = e.getAttribLocation(t, r[i]);
              return n;
            })(
              s,
              t,
              !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertex)
            )),
            (e._uniformData = (function (t, e) {
              const i = {},
                n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
              for (let s = 0; s < n; s++) {
                const n = e.getActiveUniform(t, s),
                  r = n.name.replace(/\[.*?\]$/, ""),
                  o = !!n.name.match(/\[.*?\]$/),
                  a = xt(e, n.type);
                i[r] = {
                  name: r,
                  index: s,
                  type: a,
                  size: n.size,
                  isArray: o,
                  value: mt(a, n.size),
                };
              }
              return i;
            })(s, t)),
            (e._uniformBlockData = (function (t, e) {
              if (!e.ACTIVE_UNIFORM_BLOCKS) return {};
              const i = {},
                n = e.getProgramParameter(t, e.ACTIVE_UNIFORM_BLOCKS);
              for (let s = 0; s < n; s++) {
                const n = e.getActiveUniformBlockName(t, s),
                  r = e.getUniformBlockIndex(t, n),
                  o = e.getActiveUniformBlockParameter(
                    t,
                    s,
                    e.UNIFORM_BLOCK_DATA_SIZE
                  );
                i[n] = { name: n, index: r, size: o };
              }
              return i;
            })(s, t)),
            t.deleteShader(i),
            t.deleteShader(n);
          const o = {};
          for (const i in e._uniformData) {
            const n = e._uniformData[i];
            o[i] = {
              location: t.getUniformLocation(s, i),
              value: mt(n.type, n.size),
            };
          }
          return new dt(s, o);
        }
        const _t = { textureCount: 0, blockIndex: 0 };
        class Tt {
          constructor(t) {
            (this._activeProgram = null),
              (this._programDataHash = Object.create(null)),
              (this._nextIndex = 0),
              (this._boundUniformsIdsToIndexHash = Object.create(null)),
              (this._boundIndexToUniformsHash = Object.create(null)),
              (this._shaderSyncFunctions = Object.create(null)),
              (this._renderer = t);
          }
          contextChange(t) {
            (this._gl = t),
              (this._maxBindings = t.MAX_UNIFORM_BUFFER_BINDINGS
                ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS)
                : 0),
              (this._programDataHash = Object.create(null)),
              (this._boundUniformsIdsToIndexHash = Object.create(null)),
              (this._boundIndexToUniformsHash = Object.create(null)),
              (this._activeProgram = null);
          }
          bind(t, e) {
            if ((this._setProgram(t.glProgram), e)) return;
            (_t.textureCount = 0), (_t.blockIndex = 0);
            let i = this._shaderSyncFunctions[t.glProgram._key];
            i ||
              (i = this._shaderSyncFunctions[t.glProgram._key] =
                this._generateShaderSync(t, this)),
              i(this._renderer, t, _t);
          }
          updateUniformGroup(t) {
            this._renderer.uniformGroup.updateUniformGroup(
              t,
              this._activeProgram,
              _t
            );
          }
          bindUniformBlock(t, e, i = 0) {
            const n = this._renderer.buffer,
              s = this._getProgramData(this._activeProgram),
              r = t._bufferResource;
            r && this._renderer.ubo.updateUniformGroup(t),
              n.updateBuffer(t.buffer);
            let o = this._boundUniformsIdsToIndexHash[t.uid];
            if (void 0 === o) {
              const e = this._nextIndex++ % this._maxBindings,
                i = this._boundIndexToUniformsHash[e];
              i && (this._boundUniformsIdsToIndexHash[i.uid] = void 0),
                (o = this._boundUniformsIdsToIndexHash[t.uid] = e),
                (this._boundIndexToUniformsHash[e] = t),
                r
                  ? n.bindBufferRange(t.buffer, e, t.offset)
                  : n.bindBufferBase(t.buffer, e);
            }
            const a = this._gl,
              l = this._activeProgram._uniformBlockData[e].index;
            s.uniformBlockBindings[i] !== o &&
              ((s.uniformBlockBindings[i] = o),
              a.uniformBlockBinding(s.program, l, o));
          }
          _setProgram(t) {
            if (this._activeProgram === t) return;
            this._activeProgram = t;
            const e = this._getProgramData(t);
            this._gl.useProgram(e.program);
          }
          _getProgramData(t) {
            return this._programDataHash[t._key] || this._createProgramData(t);
          }
          _createProgramData(t) {
            const e = t._key;
            return (
              (this._programDataHash[e] = Ct(this._gl, t)),
              this._programDataHash[e]
            );
          }
          destroy() {
            for (const t of Object.keys(this._programDataHash)) {
              this._programDataHash[t].destroy(),
                (this._programDataHash[t] = null);
            }
            (this._programDataHash = null),
              (this._boundUniformsIdsToIndexHash = null);
          }
          _generateShaderSync(t, e) {
            return (function (t, e) {
              const i = [],
                n = [
                  "\n        var g = s.groups;\n        var sS = r.shader;\n        var p = s.glProgram;\n        var ugS = r.uniformGroup;\n        var resources;\n    ",
                ];
              let s = !1,
                r = 0,
                o = 0;
              const a = e._getProgramData(t.glProgram);
              for (const l in t.groups) {
                const u = t.groups[l];
                i.push(
                  `\n            resources = g[${l}].resources;\n        `
                );
                for (const h in u.resources) {
                  const c = u.resources[h];
                  if (c instanceof p.k)
                    c.ubo
                      ? i.push(
                          `\n                        sS.bindUniformBlock(\n                            resources[${h}],\n                            sS._uniformBindMap[${l}[${h}],\n                            ${r++}\n                        );\n                    `
                        )
                      : i.push(
                          `\n                        ugS.updateUniformGroup(resources[${h}], p, sD);\n                    `
                        );
                  else if (c instanceof ct.d)
                    i.push(
                      `\n                    sS.bindUniformBlock(\n                        resources[${h}],\n                        sS._uniformBindMap[${l}[${h}],\n                        ${r++}\n                    );\n                `
                    );
                  else if (c instanceof U.v) {
                    const r = t._uniformBindMap[l][h],
                      u = a.uniformData[r];
                    u &&
                      (s ||
                        ((s = !0),
                        n.push(
                          "\n                        var tS = r.texture;\n                        "
                        )),
                      e._gl.uniform1i(u.location, o),
                      i.push(
                        `\n                        tS.bind(resources[${h}], ${o});\n                    `
                      ),
                      o++);
                  }
                }
              }
              const l = [...n, ...i].join("\n");
              return new Function("r", "s", "sD", l);
            })(t, e);
          }
        }
        Tt.extension = { type: [n.Ag.WebGLSystem], name: "shader" };
        var wt = i(8166);
        const Pt = {
            f32: "if (cv !== v) {\n            cu.value = v;\n            gl.uniform1f(location, v);\n        }",
            "vec2<f32>":
              "if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2f(location, v[0], v[1]);\n        }",
            "vec3<f32>":
              "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3f(location, v[0], v[1], v[2]);\n        }",
            "vec4<f32>":
              "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n        }",
            i32: "if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }",
            "vec2<i32>":
              "if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }",
            "vec3<i32>":
              "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }",
            "vec4<i32>":
              "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }",
            u32: "if (cv !== v) {\n            cu.value = v;\n            gl.uniform1ui(location, v);\n        }",
            "vec2<u32>":
              "if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2ui(location, v[0], v[1]);\n        }",
            "vec3<u32>":
              "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3ui(location, v[0], v[1], v[2]);\n        }",
            "vec4<u32>":
              "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n        }",
            bool: "if (cv !== v) {\n            cu.value = v;\n            gl.uniform1i(location, v);\n        }",
            "vec2<bool>":
              "if (cv[0] !== v[0] || cv[1] !== v[1]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            gl.uniform2i(location, v[0], v[1]);\n        }",
            "vec3<bool>":
              "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            gl.uniform3i(location, v[0], v[1], v[2]);\n        }",
            "vec4<bool>":
              "if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {\n            cv[0] = v[0];\n            cv[1] = v[1];\n            cv[2] = v[2];\n            cv[3] = v[3];\n            gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n        }",
            "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
            "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
            "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
          },
          At = {
            f32: "gl.uniform1fv(location, v);",
            "vec2<f32>": "gl.uniform2fv(location, v);",
            "vec3<f32>": "gl.uniform3fv(location, v);",
            "vec4<f32>": "gl.uniform4fv(location, v);",
            "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
            "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
            "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
            i32: "gl.uniform1iv(location, v);",
            "vec2<i32>": "gl.uniform2iv(location, v);",
            "vec3<i32>": "gl.uniform3iv(location, v);",
            "vec4<i32>": "gl.uniform4iv(location, v);",
            u32: "gl.uniform1iv(location, v);",
            "vec2<u32>": "gl.uniform2iv(location, v);",
            "vec3<u32>": "gl.uniform3iv(location, v);",
            "vec4<u32>": "gl.uniform4iv(location, v);",
            bool: "gl.uniform1iv(location, v);",
            "vec2<bool>": "gl.uniform2iv(location, v);",
            "vec3<bool>": "gl.uniform3iv(location, v);",
            "vec4<bool>": "gl.uniform4iv(location, v);",
          };
        class kt {
          constructor(t) {
            (this._cache = {}),
              (this._uniformGroupSyncHash = {}),
              (this._renderer = t),
              (this.gl = null),
              (this._cache = {});
          }
          contextChange(t) {
            this.gl = t;
          }
          updateUniformGroup(t, e, i) {
            const n = this._renderer.shader._getProgramData(e);
            if (!t.isStatic || t._dirtyId !== n.uniformDirtyGroups[t.uid]) {
              n.uniformDirtyGroups[t.uid] = t._dirtyId;
              this._getUniformSyncFunction(t, e)(
                n.uniformData,
                t.uniforms,
                this._renderer,
                i
              );
            }
          }
          _getUniformSyncFunction(t, e) {
            return (
              this._uniformGroupSyncHash[t._signature]?.[e._key] ||
              this._createUniformSyncFunction(t, e)
            );
          }
          _createUniformSyncFunction(t, e) {
            const i =
                this._uniformGroupSyncHash[t._signature] ||
                (this._uniformGroupSyncHash[t._signature] = {}),
              n = this._getSignature(t, e._uniformData, "u");
            return (
              this._cache[n] ||
                (this._cache[n] = this._generateUniformsSync(
                  t,
                  e._uniformData
                )),
              (i[e._key] = this._cache[n]),
              i[e._key]
            );
          }
          _generateUniformsSync(t, e) {
            return (function (t, e) {
              const i = [
                "\n        var v = null;\n        var cv = null;\n        var cu = null;\n        var t = 0;\n        var gl = renderer.gl;\n        var name = null;\n    ",
              ];
              for (const n in t.uniforms) {
                if (!e[n]) {
                  t.uniforms[n] instanceof p.k
                    ? t.uniforms[n].ubo
                      ? i.push(
                          `\n                        renderer.shader.bindUniformBlock(uv.${n}, "${n}");\n                    `
                        )
                      : i.push(
                          `\n                        renderer.shader.updateUniformGroup(uv.${n});\n                    `
                        )
                    : t.uniforms[n] instanceof ct.d &&
                      i.push(
                        `\n                        renderer.shader.bindBufferResource(uv.${n}, "${n}");\n                    `
                      );
                  continue;
                }
                const s = t.uniformStructures[n];
                let r = !1;
                for (let t = 0; t < wt.$.length; t++) {
                  const e = wt.$[t];
                  if (s.type === e.type && e.test(s)) {
                    i.push(`name = "${n}";`, wt.$[t].uniform), (r = !0);
                    break;
                  }
                }
                if (!r) {
                  const t = (1 === s.size ? Pt : At)[s.type].replace(
                    "location",
                    `ud["${n}"].location`
                  );
                  i.push(
                    `\n            cu = ud["${n}"];\n            cv = cu.value;\n            v = uv["${n}"];\n            ${t};`
                  );
                }
              }
              return new Function(
                "ud",
                "uv",
                "renderer",
                "syncData",
                i.join("\n")
              );
            })(t, e);
          }
          _getSignature(t, e, i) {
            const n = t.uniforms,
              s = [`${i}-`];
            for (const t in n) s.push(t), e[t] && s.push(e[t].type);
            return s.join("-");
          }
          destroy() {
            (this._renderer = null), (this._cache = null);
          }
        }
        kt.extension = { type: [n.Ag.WebGLSystem], name: "uniformGroup" };
        const Mt = class t {
          constructor() {
            (this.gl = null),
              (this.stateId = 0),
              (this.polygonOffset = 0),
              (this.blendMode = "none"),
              (this._blendEq = !1),
              (this.map = []),
              (this.map[0] = this.setBlend),
              (this.map[1] = this.setOffset),
              (this.map[2] = this.setCullFace),
              (this.map[3] = this.setDepthTest),
              (this.map[4] = this.setFrontFace),
              (this.map[5] = this.setDepthMask),
              (this.checks = []),
              (this.defaultState = x.U.for2d());
          }
          contextChange(t) {
            (this.gl = t),
              (this.blendModesMap = (function (t) {
                const e = {};
                return (
                  (e.normal = [t.ONE, t.ONE_MINUS_SRC_ALPHA]),
                  (e.add = [t.ONE, t.ONE]),
                  (e.multiply = [
                    t.DST_COLOR,
                    t.ONE_MINUS_SRC_ALPHA,
                    t.ONE,
                    t.ONE_MINUS_SRC_ALPHA,
                  ]),
                  (e.screen = [
                    t.ONE,
                    t.ONE_MINUS_SRC_COLOR,
                    t.ONE,
                    t.ONE_MINUS_SRC_ALPHA,
                  ]),
                  (e.none = [0, 0]),
                  (e["normal-npm"] = [
                    t.SRC_ALPHA,
                    t.ONE_MINUS_SRC_ALPHA,
                    t.ONE,
                    t.ONE_MINUS_SRC_ALPHA,
                  ]),
                  (e["add-npm"] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE]),
                  (e["screen-npm"] = [
                    t.SRC_ALPHA,
                    t.ONE_MINUS_SRC_COLOR,
                    t.ONE,
                    t.ONE_MINUS_SRC_ALPHA,
                  ]),
                  (e.erase = [t.ZERO, t.ONE_MINUS_SRC_ALPHA]),
                  e
                );
              })(t)),
              this.reset();
          }
          set(t) {
            if (((t = t || this.defaultState), this.stateId !== t.data)) {
              let e = this.stateId ^ t.data,
                i = 0;
              for (; e; )
                1 & e && this.map[i].call(this, !!(t.data & (1 << i))),
                  (e >>= 1),
                  i++;
              this.stateId = t.data;
            }
            for (let e = 0; e < this.checks.length; e++)
              this.checks[e](this, t);
          }
          forceState(t) {
            t = t || this.defaultState;
            for (let e = 0; e < this.map.length; e++)
              this.map[e].call(this, !!(t.data & (1 << e)));
            for (let e = 0; e < this.checks.length; e++)
              this.checks[e](this, t);
            this.stateId = t.data;
          }
          setBlend(e) {
            this._updateCheck(t._checkBlendMode, e),
              this.gl[e ? "enable" : "disable"](this.gl.BLEND);
          }
          setOffset(e) {
            this._updateCheck(t._checkPolygonOffset, e),
              this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
          }
          setDepthTest(t) {
            this.gl[t ? "enable" : "disable"](this.gl.DEPTH_TEST);
          }
          setDepthMask(t) {
            this.gl.depthMask(t);
          }
          setCullFace(t) {
            this.gl[t ? "enable" : "disable"](this.gl.CULL_FACE);
          }
          setFrontFace(t) {
            this.gl.frontFace(this.gl[t ? "CW" : "CCW"]);
          }
          setBlendMode(t) {
            if ((this.blendModesMap[t] || (t = "normal"), t === this.blendMode))
              return;
            this.blendMode = t;
            const e = this.blendModesMap[t],
              i = this.gl;
            2 === e.length
              ? i.blendFunc(e[0], e[1])
              : i.blendFuncSeparate(e[0], e[1], e[2], e[3]),
              6 === e.length
                ? ((this._blendEq = !0), i.blendEquationSeparate(e[4], e[5]))
                : this._blendEq &&
                  ((this._blendEq = !1),
                  i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD));
          }
          setPolygonOffset(t, e) {
            this.gl.polygonOffset(t, e);
          }
          reset() {
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
              this.forceState(this.defaultState),
              (this._blendEq = !0),
              (this.blendMode = ""),
              this.setBlendMode("normal");
          }
          _updateCheck(t, e) {
            const i = this.checks.indexOf(t);
            e && -1 === i
              ? this.checks.push(t)
              : e || -1 === i || this.checks.splice(i, 1);
          }
          static _checkBlendMode(t, e) {
            t.setBlendMode(e.blendMode);
          }
          static _checkPolygonOffset(t, e) {
            t.setPolygonOffset(1, e.polygonOffset);
          }
          destroy() {
            (this.gl = null), (this.checks.length = 0);
          }
        };
        Mt.extension = { type: [n.Ag.WebGLSystem], name: "state" };
        let Et = Mt;
        class It {
          constructor(t) {
            (this.target = B.TEXTURE_2D),
              (this.texture = t),
              (this.width = -1),
              (this.height = -1),
              (this.type = F.UNSIGNED_BYTE),
              (this.internalFormat = R.RGBA),
              (this.format = R.RGBA),
              (this.samplerType = 0);
          }
        }
        const Dt = {
            id: "image",
            upload(t, e, i) {
              e.width === t.width || e.height === t.height
                ? i.texSubImage2D(
                    i.TEXTURE_2D,
                    0,
                    0,
                    0,
                    e.format,
                    e.type,
                    t.resource
                  )
                : i.texImage2D(
                    e.target,
                    0,
                    e.internalFormat,
                    t.width,
                    t.height,
                    0,
                    e.format,
                    e.type,
                    t.resource
                  ),
                (e.width = t.width),
                (e.height = t.height);
            },
          },
          Rt = {
            "bc1-rgba-unorm": !0,
            "bc1-rgba-unorm-srgb": !0,
            "bc2-rgba-unorm": !0,
            "bc2-rgba-unorm-srgb": !0,
            "bc3-rgba-unorm": !0,
            "bc3-rgba-unorm-srgb": !0,
            "bc4-r-unorm": !0,
            "bc4-r-snorm": !0,
            "bc5-rg-unorm": !0,
            "bc5-rg-snorm": !0,
            "bc6h-rgb-ufloat": !0,
            "bc6h-rgb-float": !0,
            "bc7-rgba-unorm": !0,
            "bc7-rgba-unorm-srgb": !0,
            "etc2-rgb8unorm": !0,
            "etc2-rgb8unorm-srgb": !0,
            "etc2-rgb8a1unorm": !0,
            "etc2-rgb8a1unorm-srgb": !0,
            "etc2-rgba8unorm": !0,
            "etc2-rgba8unorm-srgb": !0,
            "eac-r11unorm": !0,
            "eac-r11snorm": !0,
            "eac-rg11unorm": !0,
            "eac-rg11snorm": !0,
            "astc-4x4-unorm": !0,
            "astc-4x4-unorm-srgb": !0,
            "astc-5x4-unorm": !0,
            "astc-5x4-unorm-srgb": !0,
            "astc-5x5-unorm": !0,
            "astc-5x5-unorm-srgb": !0,
            "astc-6x5-unorm": !0,
            "astc-6x5-unorm-srgb": !0,
            "astc-6x6-unorm": !0,
            "astc-6x6-unorm-srgb": !0,
            "astc-8x5-unorm": !0,
            "astc-8x5-unorm-srgb": !0,
            "astc-8x6-unorm": !0,
            "astc-8x6-unorm-srgb": !0,
            "astc-8x8-unorm": !0,
            "astc-8x8-unorm-srgb": !0,
            "astc-10x5-unorm": !0,
            "astc-10x5-unorm-srgb": !0,
            "astc-10x6-unorm": !0,
            "astc-10x6-unorm-srgb": !0,
            "astc-10x8-unorm": !0,
            "astc-10x8-unorm-srgb": !0,
            "astc-10x10-unorm": !0,
            "astc-10x10-unorm-srgb": !0,
            "astc-12x10-unorm": !0,
            "astc-12x10-unorm-srgb": !0,
            "astc-12x12-unorm": !0,
            "astc-12x12-unorm-srgb": !0,
          },
          Bt = {
            id: "compressed",
            upload(t, e, i) {
              i.pixelStorei(i.UNPACK_ALIGNMENT, 4);
              let n = t.pixelWidth,
                s = t.pixelHeight;
              const r = !!Rt[t.format];
              for (let o = 0; o < t.resource.length; o++) {
                const a = t.resource[o];
                r
                  ? i.compressedTexImage2D(
                      i.TEXTURE_2D,
                      o,
                      e.internalFormat,
                      n,
                      s,
                      0,
                      a
                    )
                  : i.texImage2D(
                      i.TEXTURE_2D,
                      o,
                      e.internalFormat,
                      n,
                      s,
                      0,
                      e.format,
                      e.type,
                      a
                    ),
                  (n = Math.max(n >> 1, 1)),
                  (s = Math.max(s >> 1, 1));
              }
            },
          },
          Ft = {
            id: "image",
            upload(t, e, i, n) {
              const s = "premultiply-alpha-on-upload" === t.alphaMode;
              i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s);
              const r = e.width,
                o = e.height,
                a = t.pixelWidth,
                l = t.pixelHeight,
                u = t.resourceWidth,
                h = t.resourceHeight;
              u < a || h < l
                ? ((r === a && o === l) ||
                    i.texImage2D(
                      e.target,
                      0,
                      e.internalFormat,
                      a,
                      l,
                      0,
                      e.format,
                      e.type,
                      null
                    ),
                  2 === n
                    ? i.texSubImage2D(
                        i.TEXTURE_2D,
                        0,
                        0,
                        0,
                        u,
                        h,
                        e.format,
                        e.type,
                        t.resource
                      )
                    : i.texSubImage2D(
                        i.TEXTURE_2D,
                        0,
                        0,
                        0,
                        e.format,
                        e.type,
                        t.resource
                      ))
                : r === a || o === l
                ? i.texSubImage2D(
                    i.TEXTURE_2D,
                    0,
                    0,
                    0,
                    e.format,
                    e.type,
                    t.resource
                  )
                : 2 === n
                ? i.texImage2D(
                    e.target,
                    0,
                    e.internalFormat,
                    a,
                    l,
                    0,
                    e.format,
                    e.type,
                    t.resource
                  )
                : i.texImage2D(
                    e.target,
                    0,
                    e.internalFormat,
                    e.format,
                    e.type,
                    t.resource
                  ),
                (e.width = a),
                (e.height = l);
            },
          },
          Ot = {
            id: "video",
            upload(t, e, i, n) {
              t.isValid
                ? Ft.upload(t, e, i, n)
                : i.texImage2D(
                    e.target,
                    0,
                    e.internalFormat,
                    1,
                    1,
                    0,
                    e.format,
                    e.type,
                    null
                  );
            },
          },
          zt = { linear: 9729, nearest: 9728 },
          Lt = {
            linear: { linear: 9987, nearest: 9985 },
            nearest: { linear: 9986, nearest: 9984 },
          },
          Ht = {
            "clamp-to-edge": 33071,
            repeat: 10497,
            "mirror-repeat": 33648,
          },
          Ut = {
            never: 512,
            less: 513,
            equal: 514,
            "less-equal": 515,
            greater: 516,
            "not-equal": 517,
            "greater-equal": 518,
            always: 519,
          };
        function Nt(t, e, i, n, s, r, o, a) {
          const l = r;
          if (
            !a ||
            "repeat" !== t.addressModeU ||
            "repeat" !== t.addressModeV ||
            "repeat" !== t.addressModeW
          ) {
            const i = Ht[o ? "clamp-to-edge" : t.addressModeU],
              n = Ht[o ? "clamp-to-edge" : t.addressModeV],
              r = Ht[o ? "clamp-to-edge" : t.addressModeW];
            e[s](l, e.TEXTURE_WRAP_S, i),
              e[s](l, e.TEXTURE_WRAP_T, n),
              e.TEXTURE_WRAP_R && e[s](l, e.TEXTURE_WRAP_R, r);
          }
          if (
            ((a && "linear" === t.magFilter) ||
              e[s](l, e.TEXTURE_MAG_FILTER, zt[t.magFilter]),
            i)
          ) {
            if (!a || "linear" !== t.mipmapFilter) {
              const i = Lt[t.minFilter][t.mipmapFilter];
              e[s](l, e.TEXTURE_MIN_FILTER, i);
            }
          } else e[s](l, e.TEXTURE_MIN_FILTER, zt[t.minFilter]);
          if (n && t.maxAnisotropy > 1) {
            const i = Math.min(
              t.maxAnisotropy,
              e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
            );
            e[s](l, n.TEXTURE_MAX_ANISOTROPY_EXT, i);
          }
          t.compare && e[s](l, e.TEXTURE_COMPARE_FUNC, Ut[t.compare]);
        }
        class Gt {
          constructor(t) {
            (this.managedTextures = []),
              (this._glTextures = Object.create(null)),
              (this._glSamplers = Object.create(null)),
              (this._boundTextures = []),
              (this._activeTextureLocation = -1),
              (this._boundSamplers = Object.create(null)),
              (this._uploads = {
                image: Ft,
                buffer: Dt,
                video: Ot,
                compressed: Bt,
              }),
              (this._useSeparateSamplers = !1),
              (this._renderer = t);
          }
          contextChange(t) {
            (this._gl = t),
              this._mapFormatToInternalFormat ||
                ((this._mapFormatToInternalFormat = (function (t, e) {
                  let i = {},
                    n = t.RGBA;
                  return (
                    t instanceof k.e.get().getWebGLRenderingContext()
                      ? e.srgb &&
                        (i = {
                          "rgba8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT,
                          "bgra8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT,
                        })
                      : ((i = {
                          "rgba8unorm-srgb": t.SRGB8_ALPHA8,
                          "bgra8unorm-srgb": t.SRGB8_ALPHA8,
                        }),
                        (n = t.RGBA8)),
                    {
                      r8unorm: t.R8,
                      r8snorm: t.R8_SNORM,
                      r8uint: t.R8UI,
                      r8sint: t.R8I,
                      r16uint: t.R16UI,
                      r16sint: t.R16I,
                      r16float: t.R16F,
                      rg8unorm: t.RG8,
                      rg8snorm: t.RG8_SNORM,
                      rg8uint: t.RG8UI,
                      rg8sint: t.RG8I,
                      r32uint: t.R32UI,
                      r32sint: t.R32I,
                      r32float: t.R32F,
                      rg16uint: t.RG16UI,
                      rg16sint: t.RG16I,
                      rg16float: t.RG16F,
                      rgba8unorm: t.RGBA,
                      ...i,
                      rgba8snorm: t.RGBA8_SNORM,
                      rgba8uint: t.RGBA8UI,
                      rgba8sint: t.RGBA8I,
                      bgra8unorm: n,
                      rgb9e5ufloat: t.RGB9_E5,
                      rgb10a2unorm: t.RGB10_A2,
                      rg11b10ufloat: t.R11F_G11F_B10F,
                      rg32uint: t.RG32UI,
                      rg32sint: t.RG32I,
                      rg32float: t.RG32F,
                      rgba16uint: t.RGBA16UI,
                      rgba16sint: t.RGBA16I,
                      rgba16float: t.RGBA16F,
                      rgba32uint: t.RGBA32UI,
                      rgba32sint: t.RGBA32I,
                      rgba32float: t.RGBA32F,
                      stencil8: t.STENCIL_INDEX8,
                      depth16unorm: t.DEPTH_COMPONENT16,
                      depth24plus: t.DEPTH_COMPONENT24,
                      "depth24plus-stencil8": t.DEPTH24_STENCIL8,
                      depth32float: t.DEPTH_COMPONENT32F,
                      "depth32float-stencil8": t.DEPTH32F_STENCIL8,
                      ...(e.s3tc
                        ? {
                            "bc1-rgba-unorm":
                              e.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
                            "bc2-rgba-unorm":
                              e.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
                            "bc3-rgba-unorm":
                              e.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT,
                          }
                        : {}),
                      ...(e.s3tc_sRGB
                        ? {
                            "bc1-rgba-unorm-srgb":
                              e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
                            "bc2-rgba-unorm-srgb":
                              e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
                            "bc3-rgba-unorm-srgb":
                              e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
                          }
                        : {}),
                      ...(e.rgtc
                        ? {
                            "bc4-r-unorm": e.rgtc.COMPRESSED_RED_RGTC1_EXT,
                            "bc4-r-snorm":
                              e.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
                            "bc5-rg-unorm":
                              e.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
                            "bc5-rg-snorm":
                              e.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,
                          }
                        : {}),
                      ...(e.bptc
                        ? {
                            "bc6h-rgb-float":
                              e.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
                            "bc6h-rgb-ufloat":
                              e.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
                            "bc7-rgba-unorm":
                              e.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
                            "bc7-rgba-unorm-srgb":
                              e.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,
                          }
                        : {}),
                      ...(e.etc
                        ? {
                            "etc2-rgb8unorm": e.etc.COMPRESSED_RGB8_ETC2,
                            "etc2-rgb8unorm-srgb": e.etc.COMPRESSED_SRGB8_ETC2,
                            "etc2-rgb8a1unorm":
                              e.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
                            "etc2-rgb8a1unorm-srgb":
                              e.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
                            "etc2-rgba8unorm": e.etc.COMPRESSED_RGBA8_ETC2_EAC,
                            "etc2-rgba8unorm-srgb":
                              e.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
                            "eac-r11unorm": e.etc.COMPRESSED_R11_EAC,
                            "eac-rg11unorm": e.etc.COMPRESSED_SIGNED_RG11_EAC,
                          }
                        : {}),
                      ...(e.astc
                        ? {
                            "astc-4x4-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
                            "astc-4x4-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
                            "astc-5x4-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
                            "astc-5x4-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
                            "astc-5x5-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
                            "astc-5x5-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
                            "astc-6x5-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
                            "astc-6x5-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
                            "astc-6x6-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
                            "astc-6x6-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
                            "astc-8x5-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
                            "astc-8x5-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
                            "astc-8x6-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
                            "astc-8x6-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
                            "astc-8x8-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
                            "astc-8x8-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
                            "astc-10x5-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
                            "astc-10x5-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
                            "astc-10x6-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
                            "astc-10x6-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
                            "astc-10x8-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
                            "astc-10x8-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
                            "astc-10x10-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
                            "astc-10x10-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
                            "astc-12x10-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
                            "astc-12x10-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
                            "astc-12x12-unorm":
                              e.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
                            "astc-12x12-unorm-srgb":
                              e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,
                          }
                        : {}),
                    }
                  );
                })(t, this._renderer.context.extensions)),
                (this._mapFormatToType = (function (t) {
                  return {
                    r8unorm: t.UNSIGNED_BYTE,
                    r8snorm: t.BYTE,
                    r8uint: t.UNSIGNED_BYTE,
                    r8sint: t.BYTE,
                    r16uint: t.UNSIGNED_SHORT,
                    r16sint: t.SHORT,
                    r16float: t.HALF_FLOAT,
                    rg8unorm: t.UNSIGNED_BYTE,
                    rg8snorm: t.BYTE,
                    rg8uint: t.UNSIGNED_BYTE,
                    rg8sint: t.BYTE,
                    r32uint: t.UNSIGNED_INT,
                    r32sint: t.INT,
                    r32float: t.FLOAT,
                    rg16uint: t.UNSIGNED_SHORT,
                    rg16sint: t.SHORT,
                    rg16float: t.HALF_FLOAT,
                    rgba8unorm: t.UNSIGNED_BYTE,
                    "rgba8unorm-srgb": t.UNSIGNED_BYTE,
                    rgba8snorm: t.BYTE,
                    rgba8uint: t.UNSIGNED_BYTE,
                    rgba8sint: t.BYTE,
                    bgra8unorm: t.UNSIGNED_BYTE,
                    "bgra8unorm-srgb": t.UNSIGNED_BYTE,
                    rgb9e5ufloat: t.UNSIGNED_INT_5_9_9_9_REV,
                    rgb10a2unorm: t.UNSIGNED_INT_2_10_10_10_REV,
                    rg11b10ufloat: t.UNSIGNED_INT_10F_11F_11F_REV,
                    rg32uint: t.UNSIGNED_INT,
                    rg32sint: t.INT,
                    rg32float: t.FLOAT,
                    rgba16uint: t.UNSIGNED_SHORT,
                    rgba16sint: t.SHORT,
                    rgba16float: t.HALF_FLOAT,
                    rgba32uint: t.UNSIGNED_INT,
                    rgba32sint: t.INT,
                    rgba32float: t.FLOAT,
                    stencil8: t.UNSIGNED_BYTE,
                    depth16unorm: t.UNSIGNED_SHORT,
                    depth24plus: t.UNSIGNED_INT,
                    "depth24plus-stencil8": t.UNSIGNED_INT_24_8,
                    depth32float: t.FLOAT,
                    "depth32float-stencil8": t.FLOAT_32_UNSIGNED_INT_24_8_REV,
                  };
                })(t)),
                (this._mapFormatToFormat = (function (t) {
                  return {
                    r8unorm: t.RED,
                    r8snorm: t.RED,
                    r8uint: t.RED,
                    r8sint: t.RED,
                    r16uint: t.RED,
                    r16sint: t.RED,
                    r16float: t.RED,
                    rg8unorm: t.RG,
                    rg8snorm: t.RG,
                    rg8uint: t.RG,
                    rg8sint: t.RG,
                    r32uint: t.RED,
                    r32sint: t.RED,
                    r32float: t.RED,
                    rg16uint: t.RG,
                    rg16sint: t.RG,
                    rg16float: t.RG,
                    rgba8unorm: t.RGBA,
                    "rgba8unorm-srgb": t.RGBA,
                    rgba8snorm: t.RGBA,
                    rgba8uint: t.RGBA,
                    rgba8sint: t.RGBA,
                    bgra8unorm: t.RGBA,
                    "bgra8unorm-srgb": t.RGBA,
                    rgb9e5ufloat: t.RGB,
                    rgb10a2unorm: t.RGBA,
                    rg11b10ufloat: t.RGB,
                    rg32uint: t.RG,
                    rg32sint: t.RG,
                    rg32float: t.RG,
                    rgba16uint: t.RGBA,
                    rgba16sint: t.RGBA,
                    rgba16float: t.RGBA,
                    rgba32uint: t.RGBA,
                    rgba32sint: t.RGBA,
                    rgba32float: t.RGBA,
                    stencil8: t.STENCIL_INDEX8,
                    depth16unorm: t.DEPTH_COMPONENT,
                    depth24plus: t.DEPTH_COMPONENT,
                    "depth24plus-stencil8": t.DEPTH_STENCIL,
                    depth32float: t.DEPTH_COMPONENT,
                    "depth32float-stencil8": t.DEPTH_STENCIL,
                  };
                })(t))),
              (this._glTextures = Object.create(null)),
              (this._glSamplers = Object.create(null)),
              (this._boundSamplers = Object.create(null));
            for (let t = 0; t < 16; t++) this.bind(g.g.EMPTY, t);
          }
          initSource(t) {
            this.bind(t);
          }
          bind(t, e = 0) {
            const i = t.source;
            t
              ? (this.bindSource(i, e),
                this._useSeparateSamplers && this._bindSampler(i.style, e))
              : (this.bindSource(null, e),
                this._useSeparateSamplers && this._bindSampler(null, e));
          }
          bindSource(t, e = 0) {
            const i = this._gl;
            if (
              ((t._touched = this._renderer.textureGC.count),
              this._boundTextures[e] !== t)
            ) {
              (this._boundTextures[e] = t),
                this._activateLocation(e),
                (t = t || g.g.EMPTY.source);
              const n = this.getGlSource(t);
              i.bindTexture(n.target, n.texture);
            }
          }
          _bindSampler(t, e = 0) {
            const i = this._gl;
            if (!t)
              return (
                (this._boundSamplers[e] = null), void i.bindSampler(e, null)
              );
            const n = this._getGlSampler(t);
            this._boundSamplers[e] !== n &&
              ((this._boundSamplers[e] = n), i.bindSampler(e, n));
          }
          unbind(t) {
            const e = t.source,
              i = this._boundTextures,
              n = this._gl;
            for (let t = 0; t < i.length; t++)
              if (i[t] === e) {
                this._activateLocation(t);
                const s = this.getGlSource(e);
                n.bindTexture(s.target, null), (i[t] = null);
              }
          }
          _activateLocation(t) {
            this._activeTextureLocation !== t &&
              ((this._activeTextureLocation = t),
              this._gl.activeTexture(this._gl.TEXTURE0 + t));
          }
          _initSource(t) {
            const e = this._gl,
              i = new It(e.createTexture());
            if (
              ((i.type = this._mapFormatToType[t.format]),
              (i.internalFormat = this._mapFormatToInternalFormat[t.format]),
              (i.format = this._mapFormatToFormat[t.format]),
              t.autoGenerateMipmaps &&
                (this._renderer.context.supports.nonPowOf2mipmaps ||
                  t.isPowerOfTwo))
            ) {
              const e = Math.max(t.width, t.height);
              t.mipLevelCount = Math.floor(Math.log2(e)) + 1;
            }
            return (
              (this._glTextures[t.uid] = i),
              this.managedTextures.includes(t) ||
                (t.on("update", this.onSourceUpdate, this),
                t.on("resize", this.onSourceUpdate, this),
                t.on("styleChange", this.onStyleChange, this),
                t.on("destroy", this.onSourceDestroy, this),
                t.on("unload", this.onSourceUnload, this),
                t.on("updateMipmaps", this.onUpdateMipmaps, this),
                this.managedTextures.push(t)),
              this.onSourceUpdate(t),
              this.updateStyle(t, !1),
              i
            );
          }
          onStyleChange(t) {
            this.updateStyle(t, !1);
          }
          updateStyle(t, e) {
            const i = this._gl,
              n = this.getGlSource(t);
            i.bindTexture(i.TEXTURE_2D, n.texture),
              (this._boundTextures[this._activeTextureLocation] = t),
              Nt(
                t.style,
                i,
                t.mipLevelCount > 1,
                this._renderer.context.extensions.anisotropicFiltering,
                "texParameteri",
                i.TEXTURE_2D,
                !this._renderer.context.supports.nonPowOf2wrapping &&
                  !t.isPowerOfTwo,
                e
              );
          }
          onSourceUnload(t) {
            const e = this._glTextures[t.uid];
            e &&
              (this.unbind(t),
              (this._glTextures[t.uid] = null),
              this._gl.deleteTexture(e.texture));
          }
          onSourceUpdate(t) {
            const e = this._gl,
              i = this.getGlSource(t);
            e.bindTexture(e.TEXTURE_2D, i.texture),
              (this._boundTextures[this._activeTextureLocation] = t),
              this._uploads[t.uploadMethodId]
                ? this._uploads[t.uploadMethodId].upload(
                    t,
                    i,
                    e,
                    this._renderer.context.webGLVersion
                  )
                : e.texImage2D(
                    e.TEXTURE_2D,
                    0,
                    e.RGBA,
                    t.pixelWidth,
                    t.pixelHeight,
                    0,
                    e.RGBA,
                    e.UNSIGNED_BYTE,
                    null
                  ),
              t.autoGenerateMipmaps &&
                t.mipLevelCount > 1 &&
                this.onUpdateMipmaps(t, !1);
          }
          onUpdateMipmaps(t, e = !0) {
            e && this.bindSource(t, 0);
            const i = this.getGlSource(t);
            this._gl.generateMipmap(i.target);
          }
          onSourceDestroy(t) {
            t.off("destroy", this.onSourceDestroy, this),
              t.off("update", this.onSourceUpdate, this),
              t.off("resize", this.onSourceUpdate, this),
              t.off("unload", this.onSourceUnload, this),
              t.off("styleChange", this.onStyleChange, this),
              t.off("updateMipmaps", this.onUpdateMipmaps, this),
              this.managedTextures.splice(this.managedTextures.indexOf(t), 1),
              this.onSourceUnload(t);
          }
          _initSampler(t) {
            const e = this._gl,
              i = this._gl.createSampler();
            return (
              (this._glSamplers[t._resourceId] = i),
              Nt(
                t,
                e,
                this._boundTextures[this._activeTextureLocation].mipLevelCount >
                  1,
                this._renderer.context.extensions.anisotropicFiltering,
                "samplerParameteri",
                i,
                !1,
                !0
              ),
              this._glSamplers[t._resourceId]
            );
          }
          _getGlSampler(t) {
            return this._glSamplers[t._resourceId] || this._initSampler(t);
          }
          getGlSource(t) {
            return this._glTextures[t.uid] || this._initSource(t);
          }
          generateCanvas(t) {
            const { pixels: e, width: i, height: n } = this.getPixels(t),
              s = k.e.get().createCanvas();
            (s.width = i), (s.height = n);
            const r = s.getContext("2d");
            if (r) {
              const t = r.createImageData(i, n);
              t.data.set(e), r.putImageData(t, 0, 0);
            }
            return s;
          }
          getPixels(t) {
            const e = t.source.resolution,
              i = t.frame,
              n = Math.max(Math.round(i.width * e), 1),
              s = Math.max(Math.round(i.height * e), 1),
              r = new Uint8Array(4 * n * s),
              o = this._renderer,
              a = o.renderTarget.getRenderTarget(t),
              l = o.renderTarget.getGpuRenderTarget(a),
              u = o.gl;
            return (
              u.bindFramebuffer(u.FRAMEBUFFER, l.resolveTargetFramebuffer),
              u.readPixels(
                Math.round(i.x * e),
                Math.round(i.y * e),
                n,
                s,
                u.RGBA,
                u.UNSIGNED_BYTE,
                r
              ),
              { pixels: new Uint8ClampedArray(r.buffer), width: n, height: s }
            );
          }
          destroy() {
            this.managedTextures
              .slice()
              .forEach((t) => this.onSourceDestroy(t)),
              (this.managedTextures = null),
              (this._renderer = null);
          }
        }
        Gt.extension = { type: [n.Ag.WebGLSystem], name: "texture" };
        const Vt = [...C.i, nt, j, E, A, Gt, ht, L, kt, Tt, q, Et, Y, $],
          jt = [...C.f],
          $t = [b, y, f],
          qt = [],
          Wt = [],
          Xt = [];
        n.XO.handleByNamedList(n.Ag.WebGLSystem, qt),
          n.XO.handleByNamedList(n.Ag.WebGLPipes, Wt),
          n.XO.handleByNamedList(n.Ag.WebGLPipesAdaptor, Xt),
          n.XO.add(...Vt, ...jt, ...$t);
        class Yt extends S.k {
          constructor() {
            super({
              name: "webgl",
              type: _.W.WEBGL,
              systems: qt,
              renderPipes: Wt,
              renderPipeAdaptors: Xt,
            });
          }
        }
      },
      1257: (t, e, i) => {
        "use strict";
        i.d(e, { u: () => n });
        var n = ((t) => (
          (t[(t.NONE = 0)] = "NONE"),
          (t[(t.COLOR = 16384)] = "COLOR"),
          (t[(t.STENCIL = 1024)] = "STENCIL"),
          (t[(t.DEPTH = 256)] = "DEPTH"),
          (t[(t.COLOR_DEPTH = 16640)] = "COLOR_DEPTH"),
          (t[(t.COLOR_STENCIL = 17408)] = "COLOR_STENCIL"),
          (t[(t.DEPTH_STENCIL = 1280)] = "DEPTH_STENCIL"),
          (t[(t.ALL = 17664)] = "ALL"),
          t
        ))(n || {});
      },
      9114: (t, e, i) => {
        "use strict";
        i.d(e, { M: () => p });
        var n = i(7952),
          s = i(1761);
        let r, o;
        function a() {
          if (!o) {
            o = "mediump";
            const t = (function () {
              if (!r || r?.isContextLost()) {
                const t = s.e.get().createCanvas();
                r = t.getContext("webgl", {});
              }
              return r;
            })();
            if (t && t.getShaderPrecisionFormat) {
              const e = t.getShaderPrecisionFormat(
                t.FRAGMENT_SHADER,
                t.HIGH_FLOAT
              );
              o = e.precision ? "highp" : "mediump";
            }
          }
          return o;
        }
        const l = {},
          u = {};
        const h = {
            stripVersion: function (t, e) {
              return e ? t.replace("#version 300 es", "") : t;
            },
            ensurePrecision: function (t, e, i) {
              const n = i
                ? e.maxSupportedFragmentPrecision
                : e.maxSupportedVertexPrecision;
              if ("precision" !== t.substring(0, 9)) {
                let s = i
                  ? e.requestedFragmentPrecision
                  : e.requestedVertexPrecision;
                return (
                  "highp" === s && "highp" !== n && (s = "mediump"),
                  `precision ${s} float;\n${t}`
                );
              }
              return "highp" !== n && "precision highp" === t.substring(0, 15)
                ? t.replace("precision highp", "precision mediump")
                : t;
            },
            addProgramDefines: function (t, e, i) {
              return e
                ? t
                : i
                ? `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${(t =
                    t.replace("out vec4 finalColor;", ""))}\n        `
                : `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${t}\n        `;
            },
            setProgramName: function (t, { name: e = "pixi-program" }, i = !0) {
              e = e.replace(/\s+/g, "-");
              const n = i ? l : u;
              return (
                n[(e += i ? "-fragment" : "-vertex")]
                  ? (n[e]++, (e += `-${n[e]}`))
                  : (n[e] = 1),
                -1 !== t.indexOf("#define SHADER_NAME")
                  ? t
                  : `${`#define SHADER_NAME ${e}`}\n${t}`
              );
            },
            insertVersion: function (t, e) {
              return e ? `#version 300 es\n${t}` : t;
            },
          },
          c = Object.create(null),
          d = class t {
            constructor(e) {
              const i =
                  -1 !==
                  (e = { ...t.defaultOptions, ...e }).fragment.indexOf(
                    "#version 300 es"
                  ),
                s = {
                  stripVersion: i,
                  ensurePrecision: {
                    requestedFragmentPrecision: e.preferredFragmentPrecision,
                    requestedVertexPrecision: e.preferredVertexPrecision,
                    maxSupportedVertexPrecision: "highp",
                    maxSupportedFragmentPrecision: a(),
                  },
                  setProgramName: { name: e.name },
                  addProgramDefines: i,
                  insertVersion: i,
                };
              let r = e.fragment,
                o = e.vertex;
              Object.keys(h).forEach((t) => {
                const e = s[t];
                (r = h[t](r, e, !0)), (o = h[t](o, e, !1));
              }),
                (this.fragment = r),
                (this.vertex = o),
                (this._key = (0, n.X)(
                  `${this.vertex}:${this.fragment}`,
                  "gl-program"
                ));
            }
            destroy() {
              (this.fragment = null),
                (this.vertex = null),
                (this._attributeData = null),
                (this._uniformData = null),
                (this._uniformBlockData = null),
                (this.transformFeedbackVaryings = null);
            }
            static from(e) {
              const i = `${e.vertex}:${e.fragment}`;
              return c[i] || (c[i] = new t(e)), c[i];
            }
          };
        d.defaultOptions = {
          preferredVertexPrecision: "highp",
          preferredFragmentPrecision: "mediump",
        };
        let p = d;
      },
      108: (t, e, i) => {
        "use strict";
        i.d(e, { v: () => o });
        var n = i(9104),
          s = i(7222);
        const r = new Int32Array(n.k);
        for (let t = 0; t < n.k; t++) r[t] = t;
        const o = new s.k(
          { uTextures: { value: r, type: "i32", size: n.k } },
          { isStatic: !0 }
        );
      },
      7084: (t, e, i) => {
        "use strict";
        i.d(e, { q: () => r });
        var n = i(268),
          s = i(8306);
        function r(t, e) {
          for (const i in t.attributes) {
            const s = t.attributes[i],
              r = e[i];
            r
              ? (s.location ?? (s.location = r.location),
                s.format ?? (s.format = r.format),
                s.offset ?? (s.offset = r.offset),
                s.instance ?? (s.instance = r.instance))
              : (0, n.R)(
                  `Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`
                );
          }
          !(function (t) {
            const { buffers: e, attributes: i } = t,
              n = {},
              r = {};
            for (const t in e) {
              const i = e[t];
              (n[i.uid] = 0), (r[i.uid] = 0);
            }
            for (const t in i) {
              const e = i[t];
              n[e.buffer.uid] += (0, s.m)(e.format).stride;
            }
            for (const t in i) {
              const e = i[t];
              e.stride ?? (e.stride = n[e.buffer.uid]),
                e.start ?? (e.start = r[e.buffer.uid]),
                (r[e.buffer.uid] += (0, s.m)(e.format).stride);
            }
          })(t);
        }
      },
      3513: (t, e, i) => {
        "use strict";
        i.d(e, { T: () => n });
        class n {
          constructor(t) {
            (this.resources = Object.create(null)), (this._dirty = !0);
            let e = 0;
            for (const i in t) {
              const n = t[i];
              this.setResource(n, e++);
            }
            this._updateKey();
          }
          _updateKey() {
            if (!this._dirty) return;
            this._dirty = !1;
            const t = [];
            let e = 0;
            for (const i in this.resources)
              t[e++] = this.resources[i]._resourceId;
            this._key = t.join("|");
          }
          setResource(t, e) {
            const i = this.resources[e];
            t !== i &&
              (i && t.off?.("change", this.onResourceChange, this),
              t.on?.("change", this.onResourceChange, this),
              (this.resources[e] = t),
              (this._dirty = !0));
          }
          getResource(t) {
            return this.resources[t];
          }
          _touch(t) {
            const e = this.resources;
            for (const i in e) e[i]._touched = t;
          }
          destroy() {
            const t = this.resources;
            for (const e in t) {
              const i = t[e];
              i.off?.("change", this.onResourceChange, this);
            }
            this.resources = null;
          }
          onResourceChange(t) {
            if (((this._dirty = !0), t.destroyed)) {
              const e = this.resources;
              for (const i in e) e[i] === t && (e[i] = null);
            } else this._updateKey();
          }
        }
      },
      3012: (t, e, i) => {
        "use strict";
        i.d(e, { B: () => u });
        var n = i(7952),
          s = i(8306);
        const r = {
          f32: "float32",
          "vec2<f32>": "float32x2",
          "vec3<f32>": "float32x3",
          "vec4<f32>": "float32x4",
          vec2f: "float32x2",
          vec3f: "float32x3",
          vec4f: "float32x4",
          i32: "sint32",
          "vec2<i32>": "sint32x2",
          "vec3<i32>": "sint32x3",
          "vec4<i32>": "sint32x4",
          u32: "uint32",
          "vec2<u32>": "uint32x2",
          "vec3<u32>": "uint32x3",
          "vec4<u32>": "uint32x4",
          bool: "uint32",
          "vec2<bool>": "uint32x2",
          "vec3<bool>": "uint32x3",
          "vec4<bool>": "uint32x4",
        };
        function o(t) {
          const e = /@group\((\d+)\)/,
            i = /@binding\((\d+)\)/,
            n = /var(<[^>]+>)? (\w+)/,
            s = /:\s*(\w+)/,
            r = /(\w+)\s*:\s*([\w\<\>]+)/g,
            o = /struct\s+(\w+)/,
            a = t
              .match(/(^|[^/])@(group|binding)\(\d+\)[^;]+;/g)
              ?.map((t) => ({
                group: parseInt(t.match(e)[1], 10),
                binding: parseInt(t.match(i)[1], 10),
                name: t.match(n)[2],
                isUniform: "<uniform>" === t.match(n)[1],
                type: t.match(s)[1],
              }));
          if (!a) return { groups: [], structs: [] };
          const l =
            t
              .match(/struct\s+(\w+)\s*{([^}]+)}/g)
              ?.map((t) => {
                const e = t.match(o)[1],
                  i = t.match(r).reduce((t, e) => {
                    const [i, n] = e.split(":");
                    return (t[i.trim()] = n.trim()), t;
                  }, {});
                return i ? { name: e, members: i } : null;
              })
              .filter(({ name: t }) => a.some((e) => e.type === t)) ?? [];
          return { groups: a, structs: l };
        }
        var a = ((t) => (
          (t[(t.VERTEX = 1)] = "VERTEX"),
          (t[(t.FRAGMENT = 2)] = "FRAGMENT"),
          (t[(t.COMPUTE = 4)] = "COMPUTE"),
          t
        ))(a || {});
        const l = Object.create(null);
        class u {
          constructor(t) {
            this._layoutKey = 0;
            const {
              fragment: e,
              vertex: i,
              layout: n,
              gpuLayout: s,
              name: r,
            } = t;
            if (
              ((this.name = r),
              (this.fragment = e),
              (this.vertex = i),
              e.source === i.source)
            ) {
              const t = o(e.source);
              this.structsAndGroups = t;
            } else {
              const t = o(i.source),
                n = o(e.source);
              this.structsAndGroups = (function (t, e) {
                const i = new Set(),
                  n = new Set();
                return {
                  structs: [...t.structs, ...e.structs].filter(
                    (t) => !i.has(t.name) && (i.add(t.name), !0)
                  ),
                  groups: [...t.groups, ...e.groups].filter((t) => {
                    const e = `${t.name}-${t.binding}`;
                    return !n.has(e) && (n.add(e), !0);
                  }),
                };
              })(t, n);
            }
            (this.layout =
              n ??
              (function ({ groups: t }) {
                const e = [];
                for (let i = 0; i < t.length; i++) {
                  const n = t[i];
                  e[n.group] || (e[n.group] = {}),
                    (e[n.group][n.name] = n.binding);
                }
                return e;
              })(this.structsAndGroups)),
              (this.gpuLayout =
                s ??
                (function ({ groups: t }) {
                  const e = [];
                  for (let i = 0; i < t.length; i++) {
                    const n = t[i];
                    e[n.group] || (e[n.group] = []),
                      n.isUniform
                        ? e[n.group].push({
                            binding: n.binding,
                            visibility: a.VERTEX | a.FRAGMENT,
                            buffer: { type: "uniform" },
                          })
                        : "sampler" === n.type
                        ? e[n.group].push({
                            binding: n.binding,
                            visibility: a.FRAGMENT,
                            sampler: { type: "filtering" },
                          })
                        : "texture_2d" === n.type &&
                          e[n.group].push({
                            binding: n.binding,
                            visibility: a.FRAGMENT,
                            texture: {
                              sampleType: "float",
                              viewDimension: "2d",
                              multisampled: !1,
                            },
                          });
                  }
                  return e;
                })(this.structsAndGroups)),
              (this.autoAssignGlobalUniforms = !(
                void 0 === this.layout[0]?.globalUniforms
              )),
              (this.autoAssignLocalUniforms = !(
                void 0 === this.layout[1]?.localUniforms
              )),
              this._generateProgramKey();
          }
          _generateProgramKey() {
            const { vertex: t, fragment: e } = this,
              i = t.source + e.source + t.entryPoint + e.entryPoint;
            this._layoutKey = (0, n.X)(i, "program");
          }
          get attributeData() {
            return (
              this._attributeData ??
                (this._attributeData = (function ({
                  source: t,
                  entryPoint: e,
                }) {
                  const i = {},
                    n = t.indexOf(`fn ${e}`);
                  if (-1 !== n) {
                    const e = t.indexOf("->", n);
                    if (-1 !== e) {
                      const o = t.substring(n, e),
                        a =
                          /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
                      let l;
                      for (; null !== (l = a.exec(o)); ) {
                        const t = r[l[3]] ?? "float32";
                        i[l[2]] = {
                          location: parseInt(l[1], 10),
                          format: t,
                          stride: (0, s.m)(t).stride,
                          offset: 0,
                          instance: !1,
                          start: 0,
                        };
                      }
                    }
                  }
                  return i;
                })(this.vertex)),
              this._attributeData
            );
          }
          destroy() {
            (this.gpuLayout = null),
              (this.layout = null),
              (this.structsAndGroups = null),
              (this.fragment = null),
              (this.vertex = null);
          }
          static from(t) {
            const e = `${t.vertex.source}:${t.fragment.source}:${t.fragment.entryPoint}:${t.vertex.entryPoint}`;
            return l[e] || (l[e] = new u(t)), l[e];
          }
        }
      },
      1172: (t, e, i) => {
        "use strict";
        i.d(e, { g: () => s });
        var n = i(1957);
        const s = [];
        (s[n.K.NONE] = void 0),
          (s[n.K.DISABLED] = { stencilWriteMask: 0, stencilReadMask: 0 }),
          (s[n.K.RENDERING_MASK_ADD] = {
            stencilFront: { compare: "equal", passOp: "increment-clamp" },
            stencilBack: { compare: "equal", passOp: "increment-clamp" },
          }),
          (s[n.K.RENDERING_MASK_REMOVE] = {
            stencilFront: { compare: "equal", passOp: "decrement-clamp" },
            stencilBack: { compare: "equal", passOp: "decrement-clamp" },
          }),
          (s[n.K.MASK_ACTIVE] = {
            stencilWriteMask: 0,
            stencilFront: { compare: "equal", passOp: "keep" },
            stencilBack: { compare: "equal", passOp: "keep" },
          });
      },
      949: (t, e, i) => {
        "use strict";
        i.d(e, { h: () => o });
        var n = i(4486),
          s = i(133),
          r = i(1132);
        class o extends n.A {
          constructor(t) {
            let { data: e, size: i } = t;
            const { usage: n, label: r, shrinkToFit: o } = t;
            super(),
              (this.uid = (0, s.L)("buffer")),
              (this._resourceType = "buffer"),
              (this._resourceId = (0, s.L)("resource")),
              (this._touched = 0),
              (this._updateID = 1),
              (this.shrinkToFit = !0),
              (this.destroyed = !1),
              e instanceof Array && (e = new Float32Array(e)),
              (this._data = e),
              (i = i ?? e?.byteLength);
            const a = !!e;
            (this.descriptor = {
              size: i,
              usage: n,
              mappedAtCreation: a,
              label: r,
            }),
              (this.shrinkToFit = o ?? !0);
          }
          get data() {
            return this._data;
          }
          set data(t) {
            this.setDataWithSize(t, t.length, !0);
          }
          get static() {
            return !!(this.descriptor.usage & r.S.STATIC);
          }
          set static(t) {
            t
              ? (this.descriptor.usage |= r.S.STATIC)
              : (this.descriptor.usage &= ~r.S.STATIC);
          }
          setDataWithSize(t, e, i) {
            if (
              (this._updateID++,
              (this._updateSize = e * t.BYTES_PER_ELEMENT),
              this._data === t)
            )
              return void (i && this.emit("update", this));
            const n = this._data;
            (this._data = t),
              n.length === t.length ||
              (!this.shrinkToFit && t.byteLength < n.byteLength)
                ? i && this.emit("update", this)
                : ((this.descriptor.size = t.byteLength),
                  (this._resourceId = (0, s.L)("resource")),
                  this.emit("change", this));
          }
          update(t) {
            (this._updateSize = t ?? this._updateSize),
              this._updateID++,
              this.emit("update", this);
          }
          destroy() {
            (this.destroyed = !0),
              this.emit("destroy", this),
              this.emit("change", this),
              (this._data = null),
              (this.descriptor = null),
              this.removeAllListeners();
          }
        }
      },
      581: (t, e, i) => {
        "use strict";
        i.d(e, { d: () => r });
        var n = i(4486),
          s = i(133);
        class r extends n.A {
          constructor({ buffer: t, offset: e, size: i }) {
            super(),
              (this.uid = (0, s.L)("buffer")),
              (this._resourceType = "bufferResource"),
              (this._touched = 0),
              (this._resourceId = (0, s.L)("resource")),
              (this._bufferResource = !0),
              (this.destroyed = !1),
              (this.buffer = t),
              (this.offset = 0 | e),
              (this.size = i),
              this.buffer.on("change", this.onBufferChange, this);
          }
          onBufferChange() {
            (this._resourceId = (0, s.L)("resource")),
              this.emit("change", this);
          }
          destroy(t = !1) {
            (this.destroyed = !0),
              t && this.buffer.destroy(),
              this.emit("change", this),
              (this.buffer = null);
          }
        }
      },
      1132: (t, e, i) => {
        "use strict";
        i.d(e, { S: () => n });
        var n = ((t) => (
          (t[(t.MAP_READ = 1)] = "MAP_READ"),
          (t[(t.MAP_WRITE = 2)] = "MAP_WRITE"),
          (t[(t.COPY_SRC = 4)] = "COPY_SRC"),
          (t[(t.COPY_DST = 8)] = "COPY_DST"),
          (t[(t.INDEX = 16)] = "INDEX"),
          (t[(t.VERTEX = 32)] = "VERTEX"),
          (t[(t.UNIFORM = 64)] = "UNIFORM"),
          (t[(t.STORAGE = 128)] = "STORAGE"),
          (t[(t.INDIRECT = 256)] = "INDIRECT"),
          (t[(t.QUERY_RESOLVE = 512)] = "QUERY_RESOLVE"),
          (t[(t.STATIC = 1024)] = "STATIC"),
          t
        ))(n || {});
      },
      6736: (t, e, i) => {
        "use strict";
        function n(t, e) {
          const i = (t.byteLength / 8) | 0,
            n = new Float64Array(t, 0, i);
          new Float64Array(e, 0, i).set(n);
          const s = t.byteLength - 8 * i;
          if (s > 0) {
            const n = new Uint8Array(t, 8 * i, s);
            new Uint8Array(e, 8 * i, s).set(n);
          }
        }
        i.d(e, { W: () => n });
      },
      6011: (t, e, i) => {
        "use strict";
        i.d(e, { V: () => h });
        var n = i(4486),
          s = i(9636),
          r = i(133),
          o = i(949),
          a = i(1132);
        function l(t, e) {
          if (!(t instanceof o.h)) {
            let i = e ? a.S.INDEX : a.S.VERTEX;
            t instanceof Array &&
              (e
                ? ((t = new Uint32Array(t)), (i = a.S.INDEX | a.S.COPY_DST))
                : ((t = new Float32Array(t)), (i = a.S.VERTEX | a.S.COPY_DST))),
              (t = new o.h({
                data: t,
                label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
                usage: i,
              }));
          }
          return t;
        }
        function u(t) {
          return (
            (t instanceof o.h || Array.isArray(t) || t.BYTES_PER_ELEMENT) &&
              (t = { buffer: t }),
            (t.buffer = l(t.buffer, !1)),
            t
          );
        }
        class h extends n.A {
          constructor(t) {
            const { attributes: e, indexBuffer: i, topology: n } = t;
            super(),
              (this.uid = (0, r.L)("geometry")),
              (this._layoutKey = 0),
              (this.instanceCount = 1),
              (this._bounds = new s.c()),
              (this._boundsDirty = !0),
              (this.attributes = e),
              (this.buffers = []),
              (this.instanceCount = t.instanceCount || 1);
            for (const t in e) {
              const i = (e[t] = u(e[t]));
              -1 === this.buffers.indexOf(i.buffer) &&
                (this.buffers.push(i.buffer),
                i.buffer.on("update", this.onBufferUpdate, this),
                i.buffer.on("change", this.onBufferUpdate, this));
            }
            i &&
              ((this.indexBuffer = l(i, !0)),
              this.buffers.push(this.indexBuffer)),
              (this.topology = n || "triangle-list");
          }
          onBufferUpdate() {
            (this._boundsDirty = !0), this.emit("update", this);
          }
          getAttribute(t) {
            return this.attributes[t];
          }
          getIndex() {
            return this.indexBuffer;
          }
          getBuffer(t) {
            return this.getAttribute(t).buffer;
          }
          getSize() {
            for (const t in this.attributes) {
              const e = this.attributes[t];
              return e.buffer.data.length / (e.stride / 4 || e.size);
            }
            return 0;
          }
          get bounds() {
            return this._boundsDirty
              ? ((this._boundsDirty = !1),
                (function (t, e, i) {
                  const n = t.getAttribute(e);
                  if (!n)
                    return (
                      (i.minX = 0), (i.minY = 0), (i.maxX = 0), (i.maxY = 0), i
                    );
                  const s = n.buffer.data;
                  let r = 1 / 0,
                    o = 1 / 0,
                    a = -1 / 0,
                    l = -1 / 0;
                  const u = s.BYTES_PER_ELEMENT,
                    h = (n.offset || 0) / u,
                    c = (n.stride || 8) / u;
                  for (let t = h; t < s.length; t += c) {
                    const e = s[t],
                      i = s[t + 1];
                    e > a && (a = e),
                      i > l && (l = i),
                      e < r && (r = e),
                      i < o && (o = i);
                  }
                  return (
                    (i.minX = r), (i.minY = o), (i.maxX = a), (i.maxY = l), i
                  );
                })(this, "aPosition", this._bounds))
              : this._bounds;
          }
          destroy(t = !1) {
            this.emit("destroy", this),
              this.removeAllListeners(),
              t && this.buffers.forEach((t) => t.destroy()),
              (this.attributes = null),
              (this.buffers = null),
              (this.indexBuffer = null),
              (this._bounds = null);
          }
        }
      },
      8306: (t, e, i) => {
        "use strict";
        i.d(e, { m: () => s });
        const n = {
          uint8x2: { size: 2, stride: 2, normalised: !1 },
          uint8x4: { size: 4, stride: 4, normalised: !1 },
          sint8x2: { size: 2, stride: 2, normalised: !1 },
          sint8x4: { size: 4, stride: 4, normalised: !1 },
          unorm8x2: { size: 2, stride: 2, normalised: !0 },
          unorm8x4: { size: 4, stride: 4, normalised: !0 },
          snorm8x2: { size: 2, stride: 2, normalised: !0 },
          snorm8x4: { size: 4, stride: 4, normalised: !0 },
          uint16x2: { size: 2, stride: 4, normalised: !1 },
          uint16x4: { size: 4, stride: 8, normalised: !1 },
          sint16x2: { size: 2, stride: 4, normalised: !1 },
          sint16x4: { size: 4, stride: 8, normalised: !1 },
          unorm16x2: { size: 2, stride: 4, normalised: !0 },
          unorm16x4: { size: 4, stride: 8, normalised: !0 },
          snorm16x2: { size: 2, stride: 4, normalised: !0 },
          snorm16x4: { size: 4, stride: 8, normalised: !0 },
          float16x2: { size: 2, stride: 4, normalised: !1 },
          float16x4: { size: 4, stride: 8, normalised: !1 },
          float32: { size: 1, stride: 4, normalised: !1 },
          float32x2: { size: 2, stride: 8, normalised: !1 },
          float32x3: { size: 3, stride: 12, normalised: !1 },
          float32x4: { size: 4, stride: 16, normalised: !1 },
          uint32: { size: 1, stride: 4, normalised: !1 },
          uint32x2: { size: 2, stride: 8, normalised: !1 },
          uint32x3: { size: 3, stride: 12, normalised: !1 },
          uint32x4: { size: 4, stride: 16, normalised: !1 },
          sint32: { size: 1, stride: 4, normalised: !1 },
          sint32x2: { size: 2, stride: 8, normalised: !1 },
          sint32x3: { size: 3, stride: 12, normalised: !1 },
          sint32x4: { size: 4, stride: 16, normalised: !1 },
        };
        function s(t) {
          return n[t] ?? n.float32;
        }
      },
      848: (t, e, i) => {
        "use strict";
        i.d(e, { L: () => s });
        var n = i(133);
        class s {
          constructor() {
            (this.uid = (0, n.L)("instructionSet")),
              (this.instructions = []),
              (this.instructionSize = 0);
          }
          reset() {
            this.instructionSize = 0;
          }
          add(t) {
            this.instructions[this.instructionSize++] = t;
          }
          log() {
            (this.instructions.length = this.instructionSize),
              console.table(this.instructions, ["type", "action"]);
          }
        }
      },
      279: (t, e, i) => {
        "use strict";
        i.d(e, { O: () => a });
        var n = i(133),
          s = i(6932),
          r = i(4492);
        const o = class t {
          constructor(e = {}) {
            if (
              ((this.uid = (0, n.L)("renderTarget")),
              (this.colorTextures = []),
              (this.dirtyId = 0),
              (this.isRoot = !1),
              (this._size = new Float32Array(2)),
              (e = { ...t.defaultOptions, ...e }),
              (this.stencil = e.stencil),
              (this.depth = e.depth),
              (this.isRoot = e.isRoot),
              "number" == typeof e.colorTextures)
            )
              for (let t = 0; t < e.colorTextures; t++)
                this.colorTextures.push(
                  new s.v({
                    width: e.width,
                    height: e.height,
                    resolution: e.resolution,
                    antialias: e.antialias,
                  })
                );
            else {
              this.colorTextures = [...e.colorTextures.map((t) => t.source)];
              const t = this.colorTexture.source;
              this.resize(t.width, t.height, t._resolution);
            }
            this.colorTexture.source.on("resize", this.onSourceResize, this),
              (e.depthStencilTexture || this.stencil) &&
                (e.depthStencilTexture instanceof r.g ||
                e.depthStencilTexture instanceof s.v
                  ? (this.depthStencilTexture = e.depthStencilTexture.source)
                  : this.ensureDepthStencilTexture());
          }
          get size() {
            const t = this._size;
            return (t[0] = this.pixelWidth), (t[1] = this.pixelHeight), t;
          }
          get width() {
            return this.colorTexture.source.width;
          }
          get height() {
            return this.colorTexture.source.height;
          }
          get pixelWidth() {
            return this.colorTexture.source.pixelWidth;
          }
          get pixelHeight() {
            return this.colorTexture.source.pixelHeight;
          }
          get resolution() {
            return this.colorTexture.source._resolution;
          }
          get colorTexture() {
            return this.colorTextures[0];
          }
          onSourceResize(t) {
            this.resize(t.width, t.height, t._resolution, !0);
          }
          ensureDepthStencilTexture() {
            this.depthStencilTexture ||
              (this.depthStencilTexture = new s.v({
                width: this.width,
                height: this.height,
                resolution: this.resolution,
                format: "depth24plus-stencil8",
                autoGenerateMipmaps: !1,
                antialias: !1,
                mipLevelCount: 1,
              }));
          }
          resize(t, e, i = this.resolution, n = !1) {
            this.dirtyId++,
              this.colorTextures.forEach((s, r) => {
                (n && 0 === r) || s.source.resize(t, e, i);
              }),
              this.depthStencilTexture &&
                this.depthStencilTexture.source.resize(t, e, i);
          }
          destroy() {
            this.colorTexture.source.off("resize", this.onSourceResize, this),
              this.depthStencilTexture &&
                (this.depthStencilTexture.destroy(),
                delete this.depthStencilTexture);
          }
        };
        o.defaultOptions = {
          width: 0,
          height: 0,
          resolution: 1,
          colorTextures: 1,
          stencil: !1,
          depth: !1,
          antialias: !1,
          isRoot: !1,
        };
        let a = o;
      },
      7238: (t, e, i) => {
        "use strict";
        i.d(e, { l: () => d });
        var n = i(9313),
          s = i(9252),
          r = i(1257);
        var o = i(7729),
          a = i(4884),
          l = i(6932),
          u = i(4492),
          h = i(8725);
        var c = i(279);
        class d {
          constructor(t) {
            (this.rootViewPort = new s.M()),
              (this.viewport = new s.M()),
              (this.onRenderTargetChange = new o.C("onRenderTargetChange")),
              (this.projectionMatrix = new n.u()),
              (this.defaultClearColor = [0, 0, 0, 0]),
              (this._renderSurfaceToRenderTargetHash = new Map()),
              (this._gpuRenderTargetHash = Object.create(null)),
              (this._renderTargetStack = []),
              (this._renderer = t);
          }
          finishRenderPass() {
            this.adaptor.finishRenderPass(this.renderTarget);
          }
          renderStart({ target: t, clear: e, clearColor: i, frame: n }) {
            (this._renderTargetStack.length = 0),
              this.push(t, e, i, n),
              this.rootViewPort.copyFrom(this.viewport),
              (this.rootRenderTarget = this.renderTarget),
              (this.renderingToScreen = (function (t) {
                const e = t.colorTexture.source.resource;
                return (
                  globalThis.HTMLCanvasElement &&
                  e instanceof HTMLCanvasElement &&
                  document.body.contains(e)
                );
              })(this.rootRenderTarget));
          }
          bind(t, e = !0, i, n) {
            const s = this.getRenderTarget(t),
              r = this.renderTarget !== s;
            (this.renderTarget = s), (this.renderSurface = t);
            const o = this.getGpuRenderTarget(s);
            (s.pixelWidth === o.width && s.pixelHeight === o.height) ||
              (this.adaptor.resizeGpuRenderTarget(s),
              (o.width = s.pixelWidth),
              (o.height = s.pixelHeight));
            const a = s.colorTexture,
              l = this.viewport,
              h = a.pixelWidth,
              c = a.pixelHeight;
            if ((!n && t instanceof u.g && (n = t.frame), n)) {
              const t = a._resolution;
              (l.x = (n.x * t + 0.5) | 0),
                (l.y = (n.y * t + 0.5) | 0),
                (l.width = (n.width * t + 0.5) | 0),
                (l.height = (n.height * t + 0.5) | 0);
            } else (l.x = 0), (l.y = 0), (l.width = h), (l.height = c);
            return (
              (function (t, e, i, n, s, r) {
                const o = r ? 1 : -1;
                t.identity(),
                  (t.a = (1 / n) * 2),
                  (t.d = o * ((1 / s) * 2)),
                  (t.tx = -1 - e * t.a),
                  (t.ty = -o - i * t.d);
              })(
                this.projectionMatrix,
                0,
                0,
                l.width / a.resolution,
                l.height / a.resolution,
                !s.isRoot
              ),
              this.adaptor.startRenderPass(s, e, i, l),
              r && this.onRenderTargetChange.emit(s),
              s
            );
          }
          clear(t, e = r.u.ALL, i) {
            e &&
              (t && (t = this.getRenderTarget(t)),
              this.adaptor.clear(t || this.renderTarget, e, i, this.viewport));
          }
          contextChange() {
            this._gpuRenderTargetHash = Object.create(null);
          }
          push(t, e = r.u.ALL, i, n) {
            const s = this.bind(t, e, i, n);
            return (
              this._renderTargetStack.push({ renderTarget: s, frame: n }), s
            );
          }
          pop() {
            this._renderTargetStack.pop();
            const t =
              this._renderTargetStack[this._renderTargetStack.length - 1];
            this.bind(t.renderTarget, !1, null, t.frame);
          }
          getRenderTarget(t) {
            return (
              t.isTexture && (t = t.source),
              this._renderSurfaceToRenderTargetHash.get(t) ??
                this._initRenderTarget(t)
            );
          }
          copyToTexture(t, e, i, n, s) {
            i.x < 0 && ((n.width += i.x), (s.x -= i.x), (i.x = 0)),
              i.y < 0 && ((n.height += i.y), (s.y -= i.y), (i.y = 0));
            const { pixelWidth: r, pixelHeight: o } = t;
            return (
              (n.width = Math.min(n.width, r - i.x)),
              (n.height = Math.min(n.height, o - i.y)),
              this.adaptor.copyToTexture(t, e, i, n, s)
            );
          }
          ensureDepthStencil() {
            this.renderTarget.stencil ||
              ((this.renderTarget.stencil = !0),
              this.adaptor.startRenderPass(
                this.renderTarget,
                !1,
                null,
                this.viewport
              ));
          }
          destroy() {
            (this._renderer = null),
              this._renderSurfaceToRenderTargetHash.forEach((t, e) => {
                t !== e && t.destroy();
              }),
              this._renderSurfaceToRenderTargetHash.clear(),
              (this._gpuRenderTargetHash = Object.create(null));
          }
          _initRenderTarget(t) {
            let e = null;
            return (
              a.q.test(t) && (t = (0, h.c)(t)),
              t instanceof c.O
                ? (e = t)
                : t instanceof l.v &&
                  ((e = new c.O({ colorTextures: [t] })),
                  a.q.test(t.source.resource) && (e.isRoot = !0),
                  t.on("destroy", () => {
                    e.destroy();
                  })),
              this._renderSurfaceToRenderTargetHash.set(t, e),
              e
            );
          }
          getGpuRenderTarget(t) {
            return (
              this._gpuRenderTargetHash[t.uid] ||
              (this._gpuRenderTargetHash[t.uid] =
                this.adaptor.initGpuRenderTarget(t))
            );
          }
        }
      },
      8475: (t, e, i) => {
        "use strict";
        i.d(e, { M: () => u });
        var n = i(4486),
          s = i(9114),
          r = i(3513),
          o = i(3012),
          a = i(5099),
          l = i(7222);
        class u extends n.A {
          constructor(t) {
            super(),
              (this._uniformBindMap = Object.create(null)),
              (this._ownedBindGroups = []);
            let {
              gpuProgram: e,
              glProgram: i,
              groups: n,
              resources: s,
              compatibleRenderers: o,
              groupMap: u,
            } = t;
            (this.gpuProgram = e),
              (this.glProgram = i),
              void 0 === o &&
                ((o = 0), e && (o |= a.W.WEBGPU), i && (o |= a.W.WEBGL)),
              (this.compatibleRenderers = o);
            const h = {};
            if ((s || n || (s = {}), s && n))
              throw new Error("[Shader] Cannot have both resources and groups");
            if (!e && n && !u)
              throw new Error(
                "[Shader] No group map or WebGPU shader provided - consider using resources instead."
              );
            if (!e && n && u)
              for (const t in u)
                for (const e in u[t]) {
                  const i = u[t][e];
                  h[i] = { group: t, binding: e, name: i };
                }
            else if (e && n && !u) {
              const t = e.structsAndGroups.groups;
              (u = {}),
                t.forEach((t) => {
                  (u[t.group] = u[t.group] || {}),
                    (u[t.group][t.binding] = t.name),
                    (h[t.name] = t);
                });
            } else if (s) {
              if (e) {
                const t = e.structsAndGroups.groups;
                (u = {}),
                  t.forEach((t) => {
                    (u[t.group] = u[t.group] || {}),
                      (u[t.group][t.binding] = t.name),
                      (h[t.name] = t);
                  });
              } else {
                (u = {}),
                  (n = { 99: new r.T() }),
                  this._ownedBindGroups.push(n[99]);
                let t = 0;
                for (const e in s)
                  (h[e] = { group: 99, binding: t, name: e }),
                    (u[99] = u[99] || {}),
                    (u[99][t] = e),
                    t++;
              }
              n = {};
              for (const t in s) {
                const e = t;
                let i = s[t];
                i.source || i._resourceType || (i = new l.k(i));
                const o = h[e];
                o &&
                  (n[o.group] ||
                    ((n[o.group] = new r.T()),
                    this._ownedBindGroups.push(n[o.group])),
                  n[o.group].setResource(i, o.binding));
              }
            }
            (this.groups = n),
              (this._uniformBindMap = u),
              (this.resources = this._buildResourceAccessor(n, h));
          }
          addResource(t, e, i) {
            var n, s;
            (n = this._uniformBindMap)[e] || (n[e] = {}),
              (s = this._uniformBindMap[e])[i] || (s[i] = t),
              this.groups[e] ||
                ((this.groups[e] = new r.T()),
                this._ownedBindGroups.push(this.groups[e]));
          }
          _buildResourceAccessor(t, e) {
            const i = {};
            for (const n in e) {
              const s = e[n];
              Object.defineProperty(i, s.name, {
                get: () => t[s.group].getResource(s.binding),
                set(e) {
                  t[s.group].setResource(e, s.binding);
                },
              });
            }
            return i;
          }
          destroy(t = !1) {
            this.emit("destroy", this),
              t && (this.gpuProgram?.destroy(), this.glProgram?.destroy()),
              (this.gpuProgram = null),
              (this.glProgram = null),
              this.removeAllListeners(),
              (this._uniformBindMap = null),
              this._ownedBindGroups.forEach((t) => {
                t.destroy();
              }),
              (this._ownedBindGroups = null),
              (this.resources = null),
              (this.groups = null);
          }
          static from(t) {
            const { gpu: e, gl: i, ...n } = t;
            let r, a;
            return (
              e && (r = o.B.from(e)),
              i && (a = s.M.from(i)),
              new u({ gpuProgram: r, glProgram: a, ...n })
            );
          }
        }
      },
      7047: (t, e, i) => {
        "use strict";
        i.d(e, { W: () => o });
        var n = i(4577),
          s = i(949),
          r = i(1132);
        class o {
          constructor(t) {
            (this._syncFunctionHash = Object.create(null)),
              (this._adaptor = t),
              this._systemCheck();
          }
          _systemCheck() {
            if (!(0, n.f)())
              throw new Error(
                "Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support."
              );
          }
          ensureUniformGroup(t) {
            const e = this.getUniformGroupData(t);
            t.buffer ||
              (t.buffer = new s.h({
                data: new Float32Array(e.layout.size / 4),
                usage: r.S.UNIFORM | r.S.COPY_DST,
              }));
          }
          getUniformGroupData(t) {
            return (
              this._syncFunctionHash[t._signature] || this._initUniformGroup(t)
            );
          }
          _initUniformGroup(t) {
            const e = t._signature;
            let i = this._syncFunctionHash[e];
            if (!i) {
              const n = Object.keys(t.uniformStructures).map(
                  (e) => t.uniformStructures[e]
                ),
                s = this._adaptor.createUboElements(n),
                r = this._generateUboSync(s.uboElements);
              i = this._syncFunctionHash[e] = { layout: s, syncFunction: r };
            }
            return this._syncFunctionHash[e];
          }
          _generateUboSync(t) {
            return this._adaptor.generateUboSync(t);
          }
          syncUniformGroup(t, e, i) {
            const n = this.getUniformGroupData(t);
            return (
              t.buffer ||
                (t.buffer = new s.h({
                  data: new Float32Array(n.layout.size / 4),
                  usage: r.S.UNIFORM | r.S.COPY_DST,
                })),
              e || (e = t.buffer.data),
              i || (i = 0),
              n.syncFunction(t.uniforms, e, i),
              !0
            );
          }
          updateUniformGroup(t) {
            if (t.isStatic && !t._dirtyId) return !1;
            t._dirtyId = 0;
            const e = this.syncUniformGroup(t);
            return t.buffer.update(), e;
          }
          destroy() {
            this._syncFunctionHash = null;
          }
        }
      },
      7222: (t, e, i) => {
        "use strict";
        i.d(e, { k: () => a });
        var n = i(133),
          s = i(7952);
        function r(t, e) {
          switch (t) {
            case "f32":
              return 0;
            case "vec2<f32>":
              return new Float32Array(2 * e);
            case "vec3<f32>":
              return new Float32Array(3 * e);
            case "vec4<f32>":
              return new Float32Array(4 * e);
            case "mat2x2<f32>":
              return new Float32Array([1, 0, 0, 1]);
            case "mat3x3<f32>":
              return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
            case "mat4x4<f32>":
              return new Float32Array([
                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
              ]);
          }
          return null;
        }
        const o = class t {
          constructor(e, i) {
            (this._touched = 0),
              (this.uid = (0, n.L)("uniform")),
              (this._resourceType = "uniformGroup"),
              (this._resourceId = (0, n.L)("resource")),
              (this.isUniformGroup = !0),
              (this._dirtyId = 0),
              (this.destroyed = !1),
              (i = { ...t.defaultOptions, ...i }),
              (this.uniformStructures = e);
            const o = {};
            for (const t in e) {
              const i = e[t];
              (i.name = t),
                (i.size = i.size ?? 1),
                i.value ?? (i.value = r(i.type, i.size)),
                (o[t] = i.value);
            }
            (this.uniforms = o),
              (this._dirtyId = 1),
              (this.ubo = i.ubo),
              (this.isStatic = i.isStatic),
              (this._signature = (0, s.X)(
                Object.keys(o)
                  .map((t) => `${t}-${e[t].type}`)
                  .join("-"),
                "uniform-group"
              ));
          }
          update() {
            this._dirtyId++;
          }
        };
        o.defaultOptions = { ubo: !1, isStatic: !1 };
        let a = o;
      },
      6423: (t, e, i) => {
        "use strict";
        i.d(e, { E: () => s });
        var n = i(8166);
        function s(t, e, i, s) {
          const r = [
            "\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    ",
          ];
          let o = 0;
          for (let a = 0; a < t.length; a++) {
            const l = t[a],
              u = l.data.name;
            let h = !1,
              c = 0;
            for (let t = 0; t < n.$.length; t++) {
              if (n.$[t].test(l.data)) {
                (c = l.offset / 4),
                  r.push(
                    `name = "${u}";`,
                    `offset += ${c - o};`,
                    n.$[t][e] || n.$[t].ubo
                  ),
                  (h = !0);
                break;
              }
            }
            if (!h)
              if (l.data.size > 1) (c = l.offset / 4), r.push(i(l, c - o));
              else {
                const t = s[l.data.type];
                (c = l.offset / 4),
                  r.push(
                    `\n                    v = uv.${u};\n                    offset += ${
                      c - o
                    };\n                    ${t};\n                `
                  );
              }
            o = c;
          }
          const a = r.join("\n");
          return new Function("uv", "data", "offset", a);
        }
      },
      1266: (t, e, i) => {
        "use strict";
        function n(t, e) {
          return `\n        for (let i = 0; i < ${
            t * e
          }; i++) {\n            data[offset + (((i / ${t})|0) * 4) + (i % ${t})] = v[i];\n        }\n    `;
        }
        i.d(e, { _: () => r, g: () => s });
        const s = {
            f32: "\n        data[offset] = v;",
            i32: "\n        data[offset] = v;",
            "vec2<f32>":
              "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];",
            "vec3<f32>":
              "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];",
            "vec4<f32>":
              "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];",
            "mat2x2<f32>":
              "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];",
            "mat3x3<f32>":
              "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];",
            "mat4x4<f32>":
              "\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }",
            "mat3x2<f32>": n(3, 2),
            "mat4x2<f32>": n(4, 2),
            "mat2x3<f32>": n(2, 3),
            "mat4x3<f32>": n(4, 3),
            "mat2x4<f32>": n(2, 4),
            "mat3x4<f32>": n(3, 4),
          },
          r = {
            ...s,
            "mat2x2<f32>":
              "\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    ",
          };
      },
      8166: (t, e, i) => {
        "use strict";
        i.d(e, { $: () => n });
        const n = [
          {
            type: "mat3x3<f32>",
            test: (t) => void 0 !== t.value.a,
            ubo: "\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        ",
            uniform:
              " \n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        ",
          },
          {
            type: "vec4<f32>",
            test: (t) =>
              "vec4<f32>" === t.type &&
              1 === t.size &&
              void 0 !== t.value.width,
            ubo: "\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        ",
            uniform:
              "\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        ",
          },
          {
            type: "vec2<f32>",
            test: (t) =>
              "vec2<f32>" === t.type && 1 === t.size && void 0 !== t.value.x,
            ubo: "\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        ",
            uniform:
              "\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        ",
          },
          {
            type: "vec4<f32>",
            test: (t) =>
              "vec4<f32>" === t.type && 1 === t.size && void 0 !== t.value.red,
            ubo: "\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        ",
            uniform:
              "\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        ",
          },
          {
            type: "vec3<f32>",
            test: (t) =>
              "vec3<f32>" === t.type && 1 === t.size && void 0 !== t.value.red,
            ubo: "\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        ",
            uniform:
              "\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        ",
          },
        ];
      },
      7547: (t, e, i) => {
        "use strict";
        i.d(e, { U: () => r });
        const n = {
            normal: 0,
            add: 1,
            multiply: 2,
            screen: 3,
            overlay: 4,
            erase: 5,
            "normal-npm": 6,
            "add-npm": 7,
            "screen-npm": 8,
          },
          s = class t {
            constructor() {
              (this.data = 0),
                (this.blendMode = "normal"),
                (this.polygonOffset = 0),
                (this.blend = !0),
                (this.depthMask = !0);
            }
            get blend() {
              return !!(1 & this.data);
            }
            set blend(t) {
              !!(1 & this.data) !== t && (this.data ^= 1);
            }
            get offsets() {
              return !!(2 & this.data);
            }
            set offsets(t) {
              !!(2 & this.data) !== t && (this.data ^= 2);
            }
            set cullMode(t) {
              "none" !== t
                ? ((this.culling = !0),
                  (this.clockwiseFrontFace = "front" === t))
                : (this.culling = !1);
            }
            get cullMode() {
              return this.culling
                ? this.clockwiseFrontFace
                  ? "front"
                  : "back"
                : "none";
            }
            get culling() {
              return !!(4 & this.data);
            }
            set culling(t) {
              !!(4 & this.data) !== t && (this.data ^= 4);
            }
            get depthTest() {
              return !!(8 & this.data);
            }
            set depthTest(t) {
              !!(8 & this.data) !== t && (this.data ^= 8);
            }
            get depthMask() {
              return !!(32 & this.data);
            }
            set depthMask(t) {
              !!(32 & this.data) !== t && (this.data ^= 32);
            }
            get clockwiseFrontFace() {
              return !!(16 & this.data);
            }
            set clockwiseFrontFace(t) {
              !!(16 & this.data) !== t && (this.data ^= 16);
            }
            get blendMode() {
              return this._blendMode;
            }
            set blendMode(t) {
              (this.blend = "none" !== t),
                (this._blendMode = t),
                (this._blendModeId = n[t] || 0);
            }
            get polygonOffset() {
              return this._polygonOffset;
            }
            set polygonOffset(t) {
              (this.offsets = !!t), (this._polygonOffset = t);
            }
            toString() {
              return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;
            }
            static for2d() {
              const e = new t();
              return (e.depthTest = !1), (e.blend = !0), e;
            }
          };
        s.default2d = s.for2d();
        let r = s;
      },
      1957: (t, e, i) => {
        "use strict";
        i.d(e, { K: () => s, Q: () => n });
        const n = {
          normal: "normal-npm",
          add: "add-npm",
          screen: "screen-npm",
        };
        var s = ((t) => (
          (t[(t.DISABLED = 0)] = "DISABLED"),
          (t[(t.RENDERING_MASK_ADD = 1)] = "RENDERING_MASK_ADD"),
          (t[(t.MASK_ACTIVE = 2)] = "MASK_ACTIVE"),
          (t[(t.RENDERING_MASK_REMOVE = 3)] = "RENDERING_MASK_REMOVE"),
          (t[(t.NONE = 4)] = "NONE"),
          t
        ))(s || {});
      },
      2855: (t, e, i) => {
        "use strict";
        i.d(e, { k: () => d });
        var n = i(2577),
          s = i(4263),
          r = i(4577),
          o = i(4670),
          a = i(1257),
          l = i(7729),
          u = i(4486);
        const h = [
            "init",
            "destroy",
            "contextChange",
            "resolutionChange",
            "reset",
            "renderEnd",
            "renderStart",
            "render",
            "update",
            "postrender",
            "prerender",
          ],
          c = class t extends u.A {
            constructor(t) {
              super(),
                (this.runners = Object.create(null)),
                (this.renderPipes = Object.create(null)),
                (this._initOptions = {}),
                (this._systemsHash = Object.create(null)),
                (this.type = t.type),
                (this.name = t.name);
              const e = [...h, ...(t.runners ?? [])];
              this._addRunners(...e),
                this._addSystems(t.systems),
                this._addPipes(t.renderPipes, t.renderPipeAdaptors),
                this._unsafeEvalCheck();
            }
            async init(e = {}) {
              for (const t in this._systemsHash) {
                e = {
                  ...this._systemsHash[t].constructor.defaultOptions,
                  ...e,
                };
              }
              (e = { ...t.defaultOptions, ...e }),
                (this._roundPixels = e.roundPixels ? 1 : 0);
              for (let t = 0; t < this.runners.init.items.length; t++)
                await this.runners.init.items[t].init(e);
              this._initOptions = e;
            }
            render(t, e) {
              let i = t;
              if (
                (i instanceof s.mc &&
                  ((i = { container: i }),
                  e &&
                    ((0, o.t)(
                      o.l,
                      "passing a second argument is deprecated, please use render options instead"
                    ),
                    (i.target = e.renderTexture))),
                i.target || (i.target = this.view.renderTarget),
                i.target === this.view.renderTarget &&
                  ((this._lastObjectRendered = i.container),
                  (i.clearColor = this.background.colorRgba)),
                i.clearColor)
              ) {
                const t =
                  Array.isArray(i.clearColor) && 4 === i.clearColor.length;
                i.clearColor = t
                  ? i.clearColor
                  : n.Q.shared.setValue(i.clearColor).toArray();
              }
              i.transform ||
                (i.container.updateLocalTransform(),
                (i.transform = i.container.localTransform)),
                this.runners.prerender.emit(i),
                this.runners.renderStart.emit(i),
                this.runners.render.emit(i),
                this.runners.renderEnd.emit(i),
                this.runners.postrender.emit(i);
            }
            resize(t, e, i) {
              this.view.resize(t, e, i),
                this.emit(
                  "resize",
                  this.view.screen.width,
                  this.view.screen.height
                );
            }
            clear(t = {}) {
              t.target || (t.target = this.renderTarget.renderTarget),
                t.clearColor || (t.clearColor = this.background.colorRgba),
                t.clear ?? (t.clear = a.u.ALL);
              const { clear: e, clearColor: i, target: s } = t;
              n.Q.shared.setValue(i ?? this.background.colorRgba),
                this.renderTarget.clear(s, e, n.Q.shared.toArray());
            }
            get resolution() {
              return this.view.resolution;
            }
            set resolution(t) {
              (this.view.resolution = t), this.runners.resolutionChange.emit(t);
            }
            get width() {
              return this.view.texture.frame.width;
            }
            get height() {
              return this.view.texture.frame.height;
            }
            get canvas() {
              return this.view.canvas;
            }
            get lastObjectRendered() {
              return this._lastObjectRendered;
            }
            get renderingToScreen() {
              return this.renderTarget.renderingToScreen;
            }
            get screen() {
              return this.view.screen;
            }
            _addRunners(...t) {
              t.forEach((t) => {
                this.runners[t] = new l.C(t);
              });
            }
            _addSystems(t) {
              let e;
              for (e in t) {
                const i = t[e];
                this._addSystem(i.value, i.name);
              }
            }
            _addSystem(t, e) {
              const i = new t(this);
              if (this[e])
                throw new Error(`Whoops! The name "${e}" is already in use`);
              (this[e] = i), (this._systemsHash[e] = i);
              for (const t in this.runners) this.runners[t].add(i);
              return this;
            }
            _addPipes(t, e) {
              const i = e.reduce((t, e) => ((t[e.name] = e.value), t), {});
              t.forEach((t) => {
                const e = t.value,
                  n = t.name,
                  s = i[n];
                this.renderPipes[n] = new e(this, s ? new s() : null);
              });
            }
            destroy(t = !1) {
              this.runners.destroy.items.reverse(),
                this.runners.destroy.emit(t),
                Object.values(this.runners).forEach((t) => {
                  t.destroy();
                }),
                (this._systemsHash = null),
                (this.renderPipes = null);
            }
            generateTexture(t) {
              return this.textureGenerator.generateTexture(t);
            }
            get roundPixels() {
              return !!this._roundPixels;
            }
            _unsafeEvalCheck() {
              if (!(0, r.f)())
                throw new Error(
                  "Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support."
                );
            }
          };
        c.defaultOptions = {
          resolution: 1,
          failIfMajorPerformanceCaveat: !1,
          roundPixels: !1,
        };
        let d = c;
      },
      3864: (t, e, i) => {
        "use strict";
        i.d(e, { f: () => Pt, i: () => wt });
        var n = i(8507);
        class s {
          constructor(t) {
            this._renderer = t;
          }
          addRenderable(t, e) {
            this._renderer.renderPipes.batch.break(e), e.add(t);
          }
          execute(t) {
            t.isRenderable && t.render(this._renderer);
          }
          destroy() {
            this._renderer = null;
          }
        }
        function r(t, e) {
          const i = t.instructionSet,
            n = i.instructions;
          for (let t = 0; t < i.instructionSize; t++) {
            const i = n[t];
            e[i.renderPipeId].execute(i);
          }
        }
        s.extension = {
          type: [n.Ag.WebGLPipes, n.Ag.WebGPUPipes, n.Ag.CanvasPipes],
          name: "customRender",
        };
        class o {
          constructor(t) {
            this._renderer = t;
          }
          addRenderGroup(t, e) {
            this._renderer.renderPipes.batch.break(e), e.add(t);
          }
          execute(t) {
            t.isRenderable &&
              (this._renderer.globalUniforms.push({
                worldTransformMatrix: t.worldTransform,
                worldColor: t.worldColorAlpha,
              }),
              r(t, this._renderer.renderPipes),
              this._renderer.globalUniforms.pop());
          }
          destroy() {
            this._renderer = null;
          }
        }
        o.extension = {
          type: [n.Ag.WebGLPipes, n.Ag.WebGPUPipes, n.Ag.CanvasPipes],
          name: "renderGroup",
        };
        var a = i(9313);
        function l(t, e) {
          const i = t.root,
            n = t.instructionSet;
          n.reset(),
            e.batch.buildStart(n),
            e.blendMode.buildStart(),
            e.colorMask.buildStart(),
            i.sortableChildren && i.sortChildren(),
            h(i, n, e, !0),
            e.batch.buildEnd(n),
            e.blendMode.buildEnd(n);
        }
        function u(t, e, i) {
          t.globalDisplayStatus < 7 ||
            !t.includeInBuild ||
            (t.sortableChildren && t.sortChildren(),
            t.isSimple
              ? (function (t, e, i) {
                  if (t.renderPipeId) {
                    i.blendMode.setBlendMode(t, t.groupBlendMode, e),
                      (t.didViewUpdate = !1);
                    i[t.renderPipeId].addRenderable(t, e);
                  }
                  if (!t.isRenderGroupRoot) {
                    const n = t.children,
                      s = n.length;
                    for (let t = 0; t < s; t++) u(n[t], e, i);
                  }
                })(t, e, i)
              : h(t, e, i, !1));
        }
        function h(t, e, i, n) {
          if (!n && t.isRenderGroupRoot)
            i.renderGroup.addRenderGroup(t.renderGroup, e);
          else {
            for (let n = 0; n < t.effects.length; n++) {
              const s = t.effects[n];
              i[s.pipe].push(s, t, e);
            }
            const n = t.renderPipeId;
            if (n) {
              i.blendMode.setBlendMode(t, t.groupBlendMode, e),
                (t.didViewUpdate = !1);
              i[n].addRenderable(t, e);
            }
            const s = t.children;
            if (s.length) for (let t = 0; t < s.length; t++) u(s[t], e, i);
            for (let n = t.effects.length - 1; n >= 0; n--) {
              const s = t.effects[n];
              i[s.pipe].pop(s, t, e);
            }
          }
        }
        function c(t, e = []) {
          e.push(t);
          for (let i = 0; i < t.renderGroupChildren.length; i++)
            c(t.renderGroupChildren[i], e);
          return e;
        }
        var d = i(4263),
          p = i(1418);
        const f = new d.mc();
        function m(t, e = !1) {
          !(function (t) {
            const e = t.root;
            let i;
            if (t.renderGroupParent) {
              const n = t.renderGroupParent;
              t.worldTransform.appendFrom(
                e.relativeGroupTransform,
                n.worldTransform
              ),
                (t.worldColor = (0, p.L)(e.groupColor, n.worldColor)),
                (i = e.groupAlpha * n.worldAlpha);
            } else
              t.worldTransform.copyFrom(e.localTransform),
                (t.worldColor = e.localColor),
                (i = e.localAlpha);
            (i = i < 0 ? 0 : i > 1 ? 1 : i),
              (t.worldAlpha = i),
              (t.worldColorAlpha = t.worldColor + ((255 * i) << 24));
          })(t);
          const i = t.childrenToUpdate,
            n = t.updateTick;
          t.updateTick++;
          for (const t in i) {
            const e = i[t],
              s = e.list,
              r = e.index;
            for (let t = 0; t < r; t++) g(s[t], n, 0);
            e.index = 0;
          }
          if (e)
            for (let i = 0; i < t.renderGroupChildren.length; i++)
              m(t.renderGroupChildren[i], e);
        }
        function g(t, e, i) {
          if (e === t.updateTick) return;
          (t.updateTick = e), (t.didChange = !1);
          const n = t.localTransform;
          t.updateLocalTransform();
          const s = t.parent;
          if (
            (s && !s.isRenderGroupRoot
              ? ((i |= t._updateFlags),
                t.relativeGroupTransform.appendFrom(
                  n,
                  s.relativeGroupTransform
                ),
                i && v(t, s, i))
              : ((i = t._updateFlags),
                t.relativeGroupTransform.copyFrom(n),
                i && v(t, f, i)),
            !t.isRenderGroupRoot)
          ) {
            const n = t.children,
              s = n.length;
            for (let t = 0; t < s; t++) g(n[t], e, i);
            const r = t.renderGroup;
            t.renderPipeId && !r.structureDidChange && r.updateRenderable(t);
          }
        }
        function v(t, e, i) {
          if (i & d.ig) {
            t.groupColor = (0, p.L)(t.localColor, e.groupColor);
            let i = t.localAlpha * e.groupAlpha;
            (i = i < 0 ? 0 : i > 1 ? 1 : i),
              (t.groupAlpha = i),
              (t.groupColorAlpha = t.groupColor + ((255 * i) << 24));
          }
          i & d.u &&
            (t.groupBlendMode =
              "inherit" === t.localBlendMode
                ? e.groupBlendMode
                : t.localBlendMode),
            i & d.fR &&
              (t.globalDisplayStatus =
                t.localDisplayStatus & e.globalDisplayStatus),
            (t._updateFlags = 0);
        }
        function y(t, e) {
          const { list: i, index: n } = t.childrenRenderablesToUpdate;
          let s = !1;
          for (let t = 0; t < n; t++) {
            const n = i[t];
            if (((s = e[n.renderPipeId].validateRenderable(n)), s)) break;
          }
          return (t.structureDidChange = s), s;
        }
        const x = new a.u();
        class b {
          constructor(t) {
            this._renderer = t;
          }
          render({ container: t, transform: e }) {
            t.isRenderGroup = !0;
            const i = t.parent,
              n = t.renderGroup.renderGroupParent;
            (t.parent = null), (t.renderGroup.renderGroupParent = null);
            const s = this._renderer,
              o = c(t.renderGroup, []);
            let a = x;
            e &&
              ((a = a.copyFrom(t.renderGroup.localTransform)),
              t.renderGroup.localTransform.copyFrom(e));
            const u = s.renderPipes;
            for (let t = 0; t < o.length; t++) {
              const e = o[t];
              e.runOnRender(),
                (e.instructionSet.renderPipes = u),
                e.structureDidChange || y(e, u),
                m(e),
                e.structureDidChange
                  ? ((e.structureDidChange = !1), l(e, u))
                  : S(e),
                (e.childrenRenderablesToUpdate.index = 0),
                s.renderPipes.batch.upload(e.instructionSet);
            }
            s.globalUniforms.start({
              worldTransformMatrix: e
                ? t.renderGroup.localTransform
                : t.renderGroup.worldTransform,
              worldColor: t.renderGroup.worldColorAlpha,
            }),
              r(t.renderGroup, u),
              u.uniformBatch && u.uniformBatch.renderEnd(),
              e && t.renderGroup.localTransform.copyFrom(a),
              (t.parent = i),
              (t.renderGroup.renderGroupParent = n);
          }
          destroy() {
            this._renderer = null;
          }
        }
        function S(t) {
          const { list: e, index: i } = t.childrenRenderablesToUpdate;
          for (let n = 0; n < i; n++) {
            const i = e[n];
            i.didViewUpdate && t.updateRenderable(i);
          }
        }
        b.extension = {
          type: [n.Ag.WebGLSystem, n.Ag.WebGPUSystem, n.Ag.CanvasSystem],
          name: "renderGroup",
        };
        var C = i(8218),
          _ = i(8422);
        class T {
          constructor(t) {
            (this._gpuSpriteHash = Object.create(null)), (this._renderer = t);
          }
          addRenderable(t, e) {
            const i = this._getGpuSprite(t);
            t._didSpriteUpdate && this._updateBatchableSprite(t, i),
              this._renderer.renderPipes.batch.addToBatch(i);
          }
          updateRenderable(t) {
            const e = this._gpuSpriteHash[t.uid];
            t._didSpriteUpdate && this._updateBatchableSprite(t, e),
              e.batcher.updateElement(e);
          }
          validateRenderable(t) {
            const e = t._texture,
              i = this._getGpuSprite(t);
            return (
              i.texture._source !== e._source &&
              !i.batcher.checkAndUpdateTexture(i, e)
            );
          }
          destroyRenderable(t) {
            const e = this._gpuSpriteHash[t.uid];
            C.Z.return(e), (this._gpuSpriteHash[t.uid] = null);
          }
          _updateBatchableSprite(t, e) {
            (t._didSpriteUpdate = !1),
              (e.bounds = t.bounds),
              (e.texture = t._texture);
          }
          _getGpuSprite(t) {
            return this._gpuSpriteHash[t.uid] || this._initGPUSprite(t);
          }
          _initGPUSprite(t) {
            const e = C.Z.get(_.K);
            return (
              (e.renderable = t),
              (e.texture = t._texture),
              (e.bounds = t.bounds),
              (e.roundPixels = this._renderer._roundPixels | t._roundPixels),
              (this._gpuSpriteHash[t.uid] = e),
              (t._didSpriteUpdate = !1),
              t.on("destroyed", () => {
                this.destroyRenderable(t);
              }),
              e
            );
          }
          destroy() {
            for (const t in this._gpuSpriteHash)
              C.Z.return(this._gpuSpriteHash[t]);
            (this._gpuSpriteHash = null), (this._renderer = null);
          }
        }
        T.extension = {
          type: [n.Ag.WebGLPipes, n.Ag.WebGPUPipes, n.Ag.CanvasPipes],
          name: "sprite",
        };
        var w = i(7547),
          P = i(8634),
          A = i(1478);
        class k {
          constructor(t, e) {
            (this.state = w.U.for2d()),
              (this._batches = Object.create(null)),
              (this._geometries = Object.create(null)),
              (this.renderer = t),
              (this._adaptor = e),
              this._adaptor.init(this);
          }
          buildStart(t) {
            if (!this._batches[t.uid]) {
              const e = new A.i();
              (this._batches[t.uid] = e), (this._geometries[e.uid] = new P.J());
            }
            (this._activeBatch = this._batches[t.uid]),
              (this._activeGeometry = this._geometries[this._activeBatch.uid]),
              this._activeBatch.begin();
          }
          addToBatch(t) {
            this._activeBatch.add(t);
          }
          break(t) {
            this._activeBatch.break(t);
          }
          buildEnd(t) {
            const e = this._activeBatch,
              i = this._activeGeometry;
            e.finish(t),
              i.indexBuffer.setDataWithSize(e.indexBuffer, e.indexSize, !0),
              i.buffers[0].setDataWithSize(
                e.attributeBuffer.float32View,
                e.attributeSize,
                !1
              );
          }
          upload(t) {
            const e = this._batches[t.uid],
              i = this._geometries[e.uid];
            e.dirty &&
              ((e.dirty = !1), i.buffers[0].update(4 * e.attributeSize));
          }
          execute(t) {
            if ("startBatch" === t.action) {
              const e = t.batcher,
                i = this._geometries[e.uid];
              this._adaptor.start(this, i);
            }
            this._adaptor.execute(this, t);
          }
          destroy() {
            (this.state = null),
              (this.renderer = null),
              this._adaptor.destroy(),
              (this._adaptor = null);
            for (const t in this._batches) this._batches[t].destroy();
            this._batches = null;
            for (const t in this._geometries) this._geometries[t].destroy();
            this._geometries = null;
          }
        }
        k.extension = {
          type: [n.Ag.WebGLPipes, n.Ag.WebGPUPipes, n.Ag.CanvasPipes],
          name: "batch",
        };
        var M = i(9049),
          E = i(9114),
          I = i(3012),
          D = i(7222),
          R = i(1196),
          B = i(6554),
          F =
            "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,  \n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3<f32>,\n  uMaskClamp:vec4<f32>,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n    @location(1) filterUv : vec2<f32>,\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -> vec2<f32>\n{\n\n  \n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @location(1) filterUv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n\n    var maskClamp = filterUniforms.uMaskClamp;\n\n     var clip = step(3.5,\n        step(maskClamp.x, filterUv.x) +\n        step(maskClamp.y, filterUv.y) +\n        step(filterUv.x, maskClamp.z) +\n        step(filterUv.y, maskClamp.w));\n\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\n    var source = textureSample(uTexture, uSampler, uv);\n    \n    var npmAlpha = 0.0;\n\n    var alphaMul = 1.0 - npmAlpha * (1.0 - mask.a);\n\n    var a = (alphaMul * mask.r) * clip;\n\n    return vec4(source.rgb, source.a) * a;\n}";
        class O extends B.d {
          constructor(t) {
            const { sprite: e, ...i } = t,
              n = new R.N(e.texture),
              s = new D.k({
                uFilterMatrix: { value: new a.u(), type: "mat3x3<f32>" },
                uMaskClamp: { value: n.uClampFrame, type: "vec4<f32>" },
                uAlpha: { value: 1, type: "f32" },
              });
            super({
              ...i,
              gpuProgram: I.B.from({
                vertex: { source: F, entryPoint: "mainVertex" },
                fragment: { source: F, entryPoint: "mainFragment" },
              }),
              glProgram: E.M.from({
                vertex:
                  "in vec2 aPosition;\n\nout vec2 vTextureCoord;\nout vec2 vMaskCoord;\n\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\nuniform mat3 uFilterMatrix;\n\nvec4 filterVertexPosition(  vec2 aPosition )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n       \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord(  vec2 aPosition )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvec2 getFilterCoord( vec2 aPosition )\n{\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}   \n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition(aPosition);\n    vTextureCoord = filterTextureCoord(aPosition);\n    vMaskCoord = getFilterCoord(aPosition);\n}\n",
                fragment:
                  "in vec2 vMaskCoord;\nin vec2 vTextureCoord;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMaskTexture;\n\nuniform float uAlpha;\nuniform vec4 uMaskClamp;\n\nout vec4 finalColor;\n\nvoid main(void)\n{\n    float clip = step(3.5,\n        step(uMaskClamp.x, vMaskCoord.x) +\n        step(uMaskClamp.y, vMaskCoord.y) +\n        step(vMaskCoord.x, uMaskClamp.z) +\n        step(vMaskCoord.y, uMaskClamp.w));\n\n    // TODO look into why this is needed\n    float npmAlpha = uAlpha; \n    vec4 original = texture(uTexture, vTextureCoord);\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\n\n    original *= (alphaMul * masky.r * uAlpha * clip);\n\n    finalColor = original;\n}\n",
                name: "mask-filter",
              }),
              resources: { filterUniforms: s, uMaskTexture: e.texture.source },
            }),
              (this.sprite = e),
              (this._textureMatrix = n);
          }
          apply(t, e, i, n) {
            (this._textureMatrix.texture = this.sprite.texture),
              t
                .calculateSpriteMatrix(
                  this.resources.filterUniforms.uniforms.uFilterMatrix,
                  this.sprite
                )
                .prepend(this._textureMatrix.mapCoord),
              (this.resources.uMaskTexture = this.sprite.texture.source),
              t.applyFilter(this, e, i, n);
          }
        }
        var z = i(9636),
          L = i(9443),
          H = i(6844),
          U = i(4492),
          N = i(2437);
        const G = new z.c();
        class V extends M.a {
          constructor() {
            super({ filters: [new O({ sprite: new H.k(U.g.EMPTY) })] });
          }
          get sprite() {
            return this.filters[0].sprite;
          }
          set sprite(t) {
            this.filters[0].sprite = t;
          }
        }
        class j {
          constructor(t) {
            (this._activeMaskStage = []), (this._renderer = t);
          }
          push(t, e, i) {
            const n = this._renderer;
            if (
              (n.renderPipes.batch.break(i),
              i.add({
                renderPipeId: "alphaMask",
                action: "pushMaskBegin",
                mask: t,
                canBundle: !1,
                maskedContainer: e,
              }),
              t.renderMaskToTexture)
            ) {
              const e = t.mask;
              (e.includeInBuild = !0),
                u(e, i, n.renderPipes),
                (e.includeInBuild = !1);
            }
            n.renderPipes.batch.break(i),
              i.add({
                renderPipeId: "alphaMask",
                action: "pushMaskEnd",
                mask: t,
                maskedContainer: e,
                canBundle: !1,
              });
          }
          pop(t, e, i) {
            this._renderer.renderPipes.batch.break(i),
              i.add({
                renderPipeId: "alphaMask",
                action: "popMaskEnd",
                mask: t,
                canBundle: !1,
              });
          }
          execute(t) {
            const e = this._renderer,
              i = t.mask.renderMaskToTexture;
            if ("pushMaskBegin" === t.action) {
              const n = C.Z.get(V);
              if (i) {
                t.mask.mask.measurable = !0;
                const i = (0, L.fB)(t.mask.mask, !0, G);
                (t.mask.mask.measurable = !1), i.ceil();
                const s = N.W.getOptimalTexture(i.width, i.height, 1, !1);
                e.renderTarget.push(s, !0),
                  e.globalUniforms.push({ offset: i, worldColor: 4294967295 });
                const r = n.sprite;
                (r.texture = s),
                  (r.worldTransform.tx = i.minX),
                  (r.worldTransform.ty = i.minY),
                  this._activeMaskStage.push({
                    filterEffect: n,
                    maskedContainer: t.maskedContainer,
                    filterTexture: s,
                  });
              } else
                (n.sprite = t.mask.mask),
                  this._activeMaskStage.push({
                    filterEffect: n,
                    maskedContainer: t.maskedContainer,
                  });
            } else if ("pushMaskEnd" === t.action) {
              const t = this._activeMaskStage[this._activeMaskStage.length - 1];
              i && (e.renderTarget.pop(), e.globalUniforms.pop()),
                e.filter.push({
                  renderPipeId: "filter",
                  action: "pushFilter",
                  container: t.maskedContainer,
                  filterEffect: t.filterEffect,
                  canBundle: !1,
                });
            } else if ("popMaskEnd" === t.action) {
              e.filter.pop();
              const t = this._activeMaskStage.pop();
              i && N.W.returnTexture(t.filterTexture),
                C.Z.return(t.filterEffect);
            }
          }
          destroy() {
            (this._renderer = null), (this._activeMaskStage = null);
          }
        }
        j.extension = {
          type: [n.Ag.WebGLPipes, n.Ag.WebGPUPipes, n.Ag.CanvasPipes],
          name: "alphaMask",
        };
        class $ {
          constructor(t) {
            (this._colorStack = []),
              (this._colorStackIndex = 0),
              (this._currentColor = 0),
              (this._renderer = t);
          }
          buildStart() {
            (this._colorStack[0] = 15),
              (this._colorStackIndex = 1),
              (this._currentColor = 15);
          }
          push(t, e, i) {
            this._renderer.renderPipes.batch.break(i);
            const n = this._colorStack;
            n[this._colorStackIndex] = n[this._colorStackIndex - 1] & t.mask;
            const s = this._colorStack[this._colorStackIndex];
            s !== this._currentColor &&
              ((this._currentColor = s),
              i.add({
                renderPipeId: "colorMask",
                colorMask: s,
                canBundle: !1,
              })),
              this._colorStackIndex++;
          }
          pop(t, e, i) {
            this._renderer.renderPipes.batch.break(i);
            const n = this._colorStack;
            this._colorStackIndex--;
            const s = n[this._colorStackIndex - 1];
            s !== this._currentColor &&
              ((this._currentColor = s),
              i.add({
                renderPipeId: "colorMask",
                colorMask: s,
                canBundle: !1,
              }));
          }
          execute(t) {
            this._renderer.colorMask.setMask(t.colorMask);
          }
          destroy() {
            this._colorStack = null;
          }
        }
        $.extension = {
          type: [n.Ag.WebGLPipes, n.Ag.WebGPUPipes, n.Ag.CanvasPipes],
          name: "colorMask",
        };
        var q = i(1257),
          W = i(1957);
        class X {
          constructor(t) {
            (this._maskStackHash = {}),
              (this._maskHash = new WeakMap()),
              (this._renderer = t);
          }
          push(t, e, i) {
            var n;
            const s = t,
              r = this._renderer;
            r.renderPipes.batch.break(i),
              r.renderPipes.blendMode.setBlendMode(s.mask, "none", i),
              i.add({
                renderPipeId: "stencilMask",
                action: "pushMaskBegin",
                mask: t,
                canBundle: !1,
              });
            const o = s.mask;
            (o.includeInBuild = !0),
              this._maskHash.has(s) ||
                this._maskHash.set(s, {
                  instructionsStart: 0,
                  instructionsLength: 0,
                });
            const a = this._maskHash.get(s);
            (a.instructionsStart = i.instructionSize),
              u(o, i, r.renderPipes),
              (o.includeInBuild = !1),
              r.renderPipes.batch.break(i),
              i.add({
                renderPipeId: "stencilMask",
                action: "pushMaskEnd",
                mask: t,
                canBundle: !1,
              });
            const l = i.instructionSize - a.instructionsStart - 1;
            a.instructionsLength = l;
            const h = r.renderTarget.renderTarget.uid;
            (n = this._maskStackHash)[h] ?? (n[h] = 0);
          }
          pop(t, e, i) {
            const n = t,
              s = this._renderer;
            s.renderPipes.batch.break(i),
              s.renderPipes.blendMode.setBlendMode(n.mask, "none", i),
              i.add({
                renderPipeId: "stencilMask",
                action: "popMaskBegin",
                canBundle: !1,
              });
            const r = this._maskHash.get(t);
            for (let t = 0; t < r.instructionsLength; t++)
              i.instructions[i.instructionSize++] =
                i.instructions[r.instructionsStart++];
            i.add({
              renderPipeId: "stencilMask",
              action: "popMaskEnd",
              canBundle: !1,
            });
          }
          execute(t) {
            var e;
            const i = this._renderer,
              n = i.renderTarget.renderTarget.uid;
            let s = (e = this._maskStackHash)[n] ?? (e[n] = 0);
            "pushMaskBegin" === t.action
              ? (i.renderTarget.ensureDepthStencil(),
                i.stencil.setStencilMode(W.K.RENDERING_MASK_ADD, s),
                s++,
                i.colorMask.setMask(0))
              : "pushMaskEnd" === t.action
              ? (i.stencil.setStencilMode(W.K.MASK_ACTIVE, s),
                i.colorMask.setMask(15))
              : "popMaskBegin" === t.action
              ? (i.colorMask.setMask(0),
                0 !== s
                  ? i.stencil.setStencilMode(W.K.RENDERING_MASK_REMOVE, s)
                  : (i.renderTarget.clear(null, q.u.STENCIL),
                    i.stencil.setStencilMode(W.K.DISABLED, s)),
                s--)
              : "popMaskEnd" === t.action &&
                (i.stencil.setStencilMode(W.K.MASK_ACTIVE, s),
                i.colorMask.setMask(15)),
              (this._maskStackHash[n] = s);
          }
          destroy() {
            (this._renderer = null),
              (this._maskStackHash = null),
              (this._maskHash = null);
          }
        }
        X.extension = {
          type: [n.Ag.WebGLPipes, n.Ag.WebGPUPipes, n.Ag.CanvasPipes],
          name: "stencilMask",
        };
        var Y = i(2577);
        const K = class t {
          constructor() {
            (this.clearBeforeRender = !0),
              (this._backgroundColor = new Y.Q(0)),
              (this.color = this._backgroundColor),
              (this.alpha = 1);
          }
          init(e) {
            (e = { ...t.defaultOptions, ...e }),
              (this.clearBeforeRender = e.clearBeforeRender),
              (this.color =
                e.background || e.backgroundColor || this._backgroundColor),
              (this.alpha = e.backgroundAlpha),
              this._backgroundColor.setAlpha(e.backgroundAlpha);
          }
          get color() {
            return this._backgroundColor;
          }
          set color(t) {
            this._backgroundColor.setValue(t);
          }
          get alpha() {
            return this._backgroundColor.alpha;
          }
          set alpha(t) {
            this._backgroundColor.setAlpha(t);
          }
          get colorRgba() {
            return this._backgroundColor.toArray();
          }
          destroy() {}
        };
        (K.extension = {
          type: [n.Ag.WebGLSystem, n.Ag.WebGPUSystem, n.Ag.CanvasSystem],
          name: "background",
          priority: 0,
        }),
          (K.defaultOptions = {
            backgroundAlpha: 1,
            backgroundColor: 0,
            clearBeforeRender: !0,
          });
        let Z = K;
        var Q = i(268);
        const J = {};
        n.XO.handle(
          n.Ag.BlendMode,
          (t) => {
            if (!t.name)
              throw new Error("BlendMode extension must have a name property");
            J[t.name] = t.ref;
          },
          (t) => {
            delete J[t.name];
          }
        );
        class tt {
          constructor(t) {
            (this._isAdvanced = !1),
              (this._filterHash = Object.create(null)),
              (this._renderer = t);
          }
          setBlendMode(t, e, i) {
            this._activeBlendMode !== e
              ? ((this._activeBlendMode = e),
                this._isAdvanced && this._endAdvancedBlendMode(i),
                (this._isAdvanced = !!J[e]),
                this._isAdvanced &&
                  (this._beginAdvancedBlendMode(i),
                  this._renderableList.push(t)))
              : this._isAdvanced && this._renderableList.push(t);
          }
          _beginAdvancedBlendMode(t) {
            this._renderer.renderPipes.batch.break(t);
            const e = this._activeBlendMode;
            if (!J[e])
              return void (0, Q.R)(
                `Unable to assign BlendMode: '${e}'. You may want to include: import 'pixi.js/advanced-blend-modes'`
              );
            this._filterHash[e] ||
              (this._filterHash[e] = new M.a({ filters: [new J[e]()] }));
            const i = {
              renderPipeId: "filter",
              action: "pushFilter",
              renderables: [],
              filterEffect: this._filterHash[e],
              canBundle: !1,
            };
            (this._renderableList = i.renderables), t.add(i);
          }
          _endAdvancedBlendMode(t) {
            (this._renderableList = null),
              this._renderer.renderPipes.batch.break(t),
              t.add({
                renderPipeId: "filter",
                action: "popFilter",
                canBundle: !1,
              });
          }
          buildStart() {
            this._isAdvanced = !1;
          }
          buildEnd(t) {
            this._isAdvanced && this._endAdvancedBlendMode(t);
          }
          destroy() {
            (this._renderer = null), (this._renderableList = null);
            for (const t in this._filterHash) this._filterHash[t].destroy();
            this._filterHash = null;
          }
        }
        tt.extension = {
          type: [n.Ag.WebGLPipes, n.Ag.WebGPUPipes, n.Ag.CanvasPipes],
          name: "blendMode",
        };
        const et = { png: "image/png", jpg: "image/jpeg", webp: "image/webp" },
          it = class t {
            constructor(t) {
              this._renderer = t;
            }
            _normalizeOptions(t, e = {}) {
              return t instanceof d.mc || t instanceof U.g
                ? { target: t, ...e }
                : { ...e, ...t };
            }
            async image(t) {
              const e = new Image();
              return (e.src = await this.base64(t)), e;
            }
            async base64(e) {
              e = this._normalizeOptions(e, t.defaultImageOptions);
              const { format: i, quality: n } = e,
                s = this.canvas(e);
              if (void 0 !== s.toBlob)
                return new Promise((t, e) => {
                  s.toBlob(
                    (i) => {
                      if (!i)
                        return void e(new Error("ICanvas.toBlob failed!"));
                      const n = new FileReader();
                      (n.onload = () => t(n.result)),
                        (n.onerror = e),
                        n.readAsDataURL(i);
                    },
                    et[i],
                    n
                  );
                });
              if (void 0 !== s.toDataURL) return s.toDataURL(et[i], n);
              if (void 0 !== s.convertToBlob) {
                const t = await s.convertToBlob({ type: et[i], quality: n });
                return new Promise((e, i) => {
                  const n = new FileReader();
                  (n.onload = () => e(n.result)),
                    (n.onerror = i),
                    n.readAsDataURL(t);
                });
              }
              throw new Error(
                "Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented"
              );
            }
            canvas(t) {
              const e = (t = this._normalizeOptions(t)).target,
                i = this._renderer;
              if (e instanceof U.g) return i.texture.generateCanvas(e);
              const n = i.textureGenerator.generateTexture(t),
                s = i.texture.generateCanvas(n);
              return n.destroy(), s;
            }
            pixels(t) {
              const e = (t = this._normalizeOptions(t)).target,
                i = this._renderer,
                n =
                  e instanceof U.g ? e : i.textureGenerator.generateTexture(t),
                s = i.texture.getPixels(n);
              return e instanceof d.mc && n.destroy(), s;
            }
            texture(t) {
              return (t = this._normalizeOptions(t)).target instanceof U.g
                ? t.target
                : this._renderer.textureGenerator.generateTexture(t);
            }
            download(t) {
              t = this._normalizeOptions(t);
              const e = this.canvas(t),
                i = document.createElement("a");
              (i.download = t.filename ?? "image.png"),
                (i.href = e.toDataURL("image/png")),
                document.body.appendChild(i),
                i.click(),
                document.body.removeChild(i);
            }
            log(t) {
              const e = t.width ?? 200;
              t = this._normalizeOptions(t);
              const i = this.canvas(t),
                n = i.toDataURL();
              console.log(`[Pixi Texture] ${i.width}px ${i.height}px`);
              const s = [
                "font-size: 1px;",
                `padding: ${e}px 300px;`,
                `background: url(${n}) no-repeat;`,
                "background-size: contain;",
              ].join(" ");
              console.log("%c ", s);
            }
            destroy() {
              this._renderer = null;
            }
          };
        (it.extension = {
          type: [n.Ag.WebGLSystem, n.Ag.WebGPUSystem],
          name: "extract",
        }),
          (it.defaultImageOptions = { format: "png", quality: 1 });
        let nt = it;
        var st = i(9252),
          rt = i(7269),
          ot = i(4167);
        const at = new st.M(),
          lt = new z.c(),
          ut = [0, 0, 0, 0];
        class ht {
          constructor(t) {
            this._renderer = t;
          }
          generateTexture(t) {
            t instanceof d.mc &&
              (t = {
                target: t,
                frame: void 0,
                textureSourceOptions: {},
                resolution: void 0,
              });
            const e = t.resolution || this._renderer.resolution,
              i = t.antialias || this._renderer.view.antialias,
              n = t.target;
            let s = t.clearColor;
            if (s) {
              s =
                Array.isArray(s) && 4 === s.length
                  ? s
                  : Y.Q.shared.setValue(s).toArray();
            } else s = ut;
            const r = t.frame?.copyTo(at) || (0, rt.n)(n, lt).rectangle;
            (r.width = 0 | Math.max(r.width, 1 / e)),
              (r.height = 0 | Math.max(r.height, 1 / e));
            const o = ot.Y.create({
                ...t.textureSourceOptions,
                width: r.width,
                height: r.height,
                resolution: e,
                antialias: i,
              }),
              l = a.u.shared.translate(-r.x, -r.y);
            return (
              this._renderer.render({
                container: n,
                transform: l,
                target: o,
                clearColor: s,
              }),
              o
            );
          }
          destroy() {
            this._renderer = null;
          }
        }
        ht.extension = {
          type: [n.Ag.WebGLSystem, n.Ag.WebGPUSystem],
          name: "textureGenerator",
        };
        var ct = i(5101),
          dt = i(2760),
          pt = i(3513),
          ft = i(5099);
        class mt {
          constructor(t) {
            (this._stackIndex = 0),
              (this._globalUniformDataStack = []),
              (this._uniformsPool = []),
              (this._activeUniforms = []),
              (this._bindGroupPool = []),
              (this._activeBindGroups = []),
              (this._renderer = t);
          }
          reset() {
            this._stackIndex = 0;
            for (let t = 0; t < this._activeUniforms.length; t++)
              this._uniformsPool.push(this._activeUniforms[t]);
            for (let t = 0; t < this._activeBindGroups.length; t++)
              this._bindGroupPool.push(this._activeBindGroups[t]);
            (this._activeUniforms.length = 0),
              (this._activeBindGroups.length = 0);
          }
          start(t) {
            this.reset(), this.push(t);
          }
          bind({
            size: t,
            projectionMatrix: e,
            worldTransformMatrix: i,
            worldColor: n,
            offset: s,
          }) {
            const r = this._renderer.renderTarget.renderTarget,
              o = this._stackIndex
                ? this._globalUniformDataStack[this._stackIndex - 1]
                : {
                    projectionData: r,
                    worldTransformMatrix: new a.u(),
                    worldColor: 4294967295,
                    offset: new ct.b(),
                  },
              l = {
                projectionMatrix:
                  e || this._renderer.renderTarget.projectionMatrix,
                resolution: t || r.size,
                worldTransformMatrix: i || o.worldTransformMatrix,
                worldColor: n || o.worldColor,
                offset: s || o.offset,
                bindGroup: null,
              },
              u = this._uniformsPool.pop() || this._createUniforms();
            this._activeUniforms.push(u);
            const h = u.uniforms;
            let c;
            (h.uProjectionMatrix = l.projectionMatrix),
              (h.uResolution = l.resolution),
              h.uWorldTransformMatrix.copyFrom(l.worldTransformMatrix),
              (h.uWorldTransformMatrix.tx -= l.offset.x),
              (h.uWorldTransformMatrix.ty -= l.offset.y),
              (0, dt.V)(l.worldColor, h.uWorldColorAlpha, 0),
              u.update(),
              this._renderer.renderPipes.uniformBatch
                ? (c =
                    this._renderer.renderPipes.uniformBatch.getUniformBindGroup(
                      u,
                      !1
                    ))
                : ((c = this._bindGroupPool.pop() || new pt.T()),
                  this._activeBindGroups.push(c),
                  c.setResource(u, 0)),
              (l.bindGroup = c),
              (this._currentGlobalUniformData = l);
          }
          push(t) {
            this.bind(t),
              (this._globalUniformDataStack[this._stackIndex++] =
                this._currentGlobalUniformData);
          }
          pop() {
            (this._currentGlobalUniformData =
              this._globalUniformDataStack[--this._stackIndex - 1]),
              this._renderer.type === ft.W.WEBGL &&
                this._currentGlobalUniformData.bindGroup.resources[0].update();
          }
          get bindGroup() {
            return this._currentGlobalUniformData.bindGroup;
          }
          get uniformGroup() {
            return this._currentGlobalUniformData.bindGroup.resources[0];
          }
          _createUniforms() {
            return new D.k(
              {
                uProjectionMatrix: { value: new a.u(), type: "mat3x3<f32>" },
                uWorldTransformMatrix: {
                  value: new a.u(),
                  type: "mat3x3<f32>",
                },
                uWorldColorAlpha: {
                  value: new Float32Array(4),
                  type: "vec4<f32>",
                },
                uResolution: { value: [0, 0], type: "vec2<f32>" },
              },
              { isStatic: !0 }
            );
          }
          destroy() {
            this._renderer = null;
          }
        }
        mt.extension = {
          type: [n.Ag.WebGLSystem, n.Ag.WebGPUSystem, n.Ag.CanvasSystem],
          name: "globalUniforms",
        };
        var gt = i(1761);
        let vt = !1;
        const yt = "8.1.0";
        class xt {
          constructor(t) {
            this._renderer = t;
          }
          init(t) {
            if (t.hello) {
              let t = this._renderer.name;
              this._renderer.type === ft.W.WEBGL &&
                (t += ` ${this._renderer.context.webGLVersion}`),
                (function (t) {
                  if (!vt) {
                    if (
                      gt.e
                        .get()
                        .getNavigator()
                        .userAgent.toLowerCase()
                        .indexOf("chrome") > -1
                    ) {
                      const e = [
                        `%c  %c  %c  %c  %c PixiJS %c v${yt} (${t}) http://www.pixijs.com/\n\n`,
                        "background: #E72264; padding:5px 0;",
                        "background: #6CA2EA; padding:5px 0;",
                        "background: #B5D33D; padding:5px 0;",
                        "background: #FED23F; padding:5px 0;",
                        "color: #FFFFFF; background: #E72264; padding:5px 0;",
                        "color: #E72264; background: #FFFFFF; padding:5px 0;",
                      ];
                      globalThis.console.log(...e);
                    } else
                      globalThis.console &&
                        globalThis.console.log(
                          `PixiJS ${yt} - ${t} - http://www.pixijs.com/`
                        );
                    vt = !0;
                  }
                })(t);
            }
          }
        }
        (xt.extension = {
          type: [n.Ag.WebGLSystem, n.Ag.WebGPUSystem, n.Ag.CanvasSystem],
          name: "hello",
          priority: -2,
        }),
          (xt.defaultOptions = { hello: !1 });
        var bt = i(3818),
          St = i(4670),
          Ct = i(279),
          _t = i(8725);
        const Tt = class t {
          get resolution() {
            return this.texture.source._resolution;
          }
          set resolution(t) {
            this.texture.source.resize(
              this.texture.source.width,
              this.texture.source.height,
              t
            );
          }
          init(e) {
            (e = { ...t.defaultOptions, ...e }).view &&
              ((0, St.t)(
                St.l,
                "ViewSystem.view has been renamed to ViewSystem.canvas"
              ),
              (e.canvas = e.view)),
              (this.screen = new st.M(0, 0, e.width, e.height)),
              (this.canvas = e.canvas || gt.e.get().createCanvas()),
              (this.antialias = !!e.antialias),
              (this.texture = (0, _t.c)(this.canvas, e)),
              (this.renderTarget = new Ct.O({
                colorTextures: [this.texture],
                depth: !!e.depth,
                isRoot: !0,
              })),
              (this.texture.source.transparent = e.backgroundAlpha < 1),
              (this.multiView = !!e.multiView),
              this.autoDensity &&
                ((this.canvas.style.width = `${this.texture.width}px`),
                (this.canvas.style.height = `${this.texture.height}px`)),
              (this.resolution = e.resolution);
          }
          resize(t, e, i) {
            this.texture.source.resize(t, e, i),
              (this.screen.width = this.texture.frame.width),
              (this.screen.height = this.texture.frame.height),
              this.autoDensity &&
                ((this.canvas.style.width = `${t}px`),
                (this.canvas.style.height = `${e}px`));
          }
          destroy(t = !1) {
            ("boolean" == typeof t ? t : !!t?.removeView) &&
              this.canvas.parentNode &&
              this.canvas.parentNode.removeChild(this.canvas);
          }
        };
        (Tt.extension = {
          type: [n.Ag.WebGLSystem, n.Ag.WebGPUSystem, n.Ag.CanvasSystem],
          name: "view",
          priority: 0,
        }),
          (Tt.defaultOptions = {
            width: 800,
            height: 600,
            autoDensity: !1,
            antialias: !1,
          });
        const wt = [Z, mt, xt, Tt, b, bt.l, ht, nt],
          Pt = [tt, k, T, o, j, X, $, s];
      },
      7729: (t, e, i) => {
        "use strict";
        i.d(e, { C: () => n });
        class n {
          constructor(t) {
            (this.items = []), (this._name = t);
          }
          emit(t, e, i, n, s, r, o, a) {
            const { name: l, items: u } = this;
            for (let h = 0, c = u.length; h < c; h++)
              u[h][l](t, e, i, n, s, r, o, a);
            return this;
          }
          add(t) {
            return t[this._name] && (this.remove(t), this.items.push(t)), this;
          }
          remove(t) {
            const e = this.items.indexOf(t);
            return -1 !== e && this.items.splice(e, 1), this;
          }
          contains(t) {
            return -1 !== this.items.indexOf(t);
          }
          removeAll() {
            return (this.items.length = 0), this;
          }
          destroy() {
            this.removeAll(), (this.items = null), (this._name = null);
          }
          get empty() {
            return 0 === this.items.length;
          }
          get name() {
            return this._name;
          }
        }
      },
      4167: (t, e, i) => {
        "use strict";
        i.d(e, { Y: () => r });
        var n = i(6932),
          s = i(4492);
        class r extends s.g {
          static create(t) {
            return new s.g({ source: new n.v(t) });
          }
          resize(t, e, i) {
            return this.source.resize(t, e, i), this;
          }
        }
      },
      4492: (t, e, i) => {
        "use strict";
        i.d(e, { g: () => b });
        var n = i(4486),
          s = i(9313);
        const r = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
          o = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
          a = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
          l = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
          u = [],
          h = [],
          c = Math.sign;
        !(function () {
          for (let t = 0; t < 16; t++) {
            const e = [];
            u.push(e);
            for (let i = 0; i < 16; i++) {
              const n = c(r[t] * r[i] + a[t] * o[i]),
                s = c(o[t] * r[i] + l[t] * o[i]),
                u = c(r[t] * a[i] + a[t] * l[i]),
                h = c(o[t] * a[i] + l[t] * l[i]);
              for (let t = 0; t < 16; t++)
                if (r[t] === n && o[t] === s && a[t] === u && l[t] === h) {
                  e.push(t);
                  break;
                }
            }
          }
          for (let t = 0; t < 16; t++) {
            const e = new s.u();
            e.set(r[t], o[t], a[t], l[t], 0, 0), h.push(e);
          }
        })();
        const d = {
          E: 0,
          SE: 1,
          S: 2,
          SW: 3,
          W: 4,
          NW: 5,
          N: 6,
          NE: 7,
          MIRROR_VERTICAL: 8,
          MAIN_DIAGONAL: 10,
          MIRROR_HORIZONTAL: 12,
          REVERSE_DIAGONAL: 14,
          uX: (t) => r[t],
          uY: (t) => o[t],
          vX: (t) => a[t],
          vY: (t) => l[t],
          inv: (t) => (8 & t ? 15 & t : 7 & -t),
          add: (t, e) => u[t][e],
          sub: (t, e) => u[t][d.inv(e)],
          rotate180: (t) => 4 ^ t,
          isVertical: (t) => 2 == (3 & t),
          byDirection: (t, e) =>
            2 * Math.abs(t) <= Math.abs(e)
              ? e >= 0
                ? d.S
                : d.N
              : 2 * Math.abs(e) <= Math.abs(t)
              ? t > 0
                ? d.E
                : d.W
              : e > 0
              ? t > 0
                ? d.SE
                : d.SW
              : t > 0
              ? d.NE
              : d.NW,
          matrixAppendRotationInv: (t, e, i = 0, n = 0) => {
            const s = h[d.inv(e)];
            (s.tx = i), (s.ty = n), t.append(s);
          },
        };
        var p = i(9252),
          f = i(133),
          m = i(4670);
        const g = () => {};
        var v = i(2518),
          y = i(6932),
          x = i(1196);
        class b extends n.A {
          constructor({
            source: t,
            label: e,
            frame: i,
            orig: n,
            trim: s,
            defaultAnchor: r,
            defaultBorders: o,
            rotate: a,
            dynamic: l,
          } = {}) {
            if (
              (super(),
              (this.uid = (0, f.L)("texture")),
              (this.uvs = {
                x0: 0,
                y0: 0,
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                x3: 0,
                y3: 0,
              }),
              (this.frame = new p.M()),
              (this.noFrame = !1),
              (this.dynamic = !1),
              (this.isTexture = !0),
              (this.label = e),
              (this.source = t?.source ?? new y.v()),
              (this.noFrame = !i),
              i)
            )
              this.frame.copyFrom(i);
            else {
              const { width: t, height: e } = this._source;
              (this.frame.width = t), (this.frame.height = e);
            }
            (this.orig = n || this.frame),
              (this.trim = s),
              (this.rotate = a ?? 0),
              (this.defaultAnchor = r),
              (this.defaultBorders = o),
              (this.destroyed = !1),
              (this.dynamic = l || !1),
              this.updateUvs();
          }
          set source(t) {
            this._source && this._source.off("resize", this.update, this),
              (this._source = t),
              t.on("resize", this.update, this),
              this.emit("update", this);
          }
          get source() {
            return this._source;
          }
          get textureMatrix() {
            return (
              this._textureMatrix || (this._textureMatrix = new x.N(this)),
              this._textureMatrix
            );
          }
          get width() {
            return this.orig.width;
          }
          get height() {
            return this.orig.height;
          }
          updateUvs() {
            const { uvs: t, frame: e } = this,
              { width: i, height: n } = this._source,
              s = e.x / i,
              r = e.y / n,
              o = e.width / i,
              a = e.height / n;
            let l = this.rotate;
            if (l) {
              const e = o / 2,
                i = a / 2,
                n = s + e,
                u = r + i;
              (l = d.add(l, d.NW)),
                (t.x0 = n + e * d.uX(l)),
                (t.y0 = u + i * d.uY(l)),
                (l = d.add(l, 2)),
                (t.x1 = n + e * d.uX(l)),
                (t.y1 = u + i * d.uY(l)),
                (l = d.add(l, 2)),
                (t.x2 = n + e * d.uX(l)),
                (t.y2 = u + i * d.uY(l)),
                (l = d.add(l, 2)),
                (t.x3 = n + e * d.uX(l)),
                (t.y3 = u + i * d.uY(l));
            } else
              (t.x0 = s),
                (t.y0 = r),
                (t.x1 = s + o),
                (t.y1 = r),
                (t.x2 = s + o),
                (t.y2 = r + a),
                (t.x3 = s),
                (t.y3 = r + a);
          }
          destroy(t = !1) {
            this._source &&
              t &&
              (this._source.destroy(), (this._source = null)),
              (this._textureMatrix = null),
              (this.destroyed = !0),
              this.emit("destroy", this),
              this.removeAllListeners();
          }
          update() {
            this.noFrame &&
              ((this.frame.width = this._source.width),
              (this.frame.height = this._source.height)),
              this.updateUvs(),
              this.emit("update", this);
          }
          get baseTexture() {
            return (
              (0, m.t)(m.l, "Texture.baseTexture is now Texture.source"),
              this._source
            );
          }
        }
        (b.EMPTY = new b({
          label: "EMPTY",
          source: new y.v({ label: "EMPTY" }),
        })),
          (b.EMPTY.destroy = g),
          (b.WHITE = new b({
            source: new v.P({
              resource: new Uint8Array([255, 255, 255, 255]),
              width: 1,
              height: 1,
              alphaMode: "premultiply-alpha-on-upload",
              label: "WHITE",
            }),
            label: "WHITE",
          })),
          (b.WHITE.destroy = g);
      },
      3818: (t, e, i) => {
        "use strict";
        i.d(e, { l: () => r });
        var n = i(8507);
        const s = class t {
          constructor(t) {
            (this._renderer = t), (this.count = 0), (this.checkCount = 0);
          }
          init(e) {
            (e = { ...t.defaultOptions, ...e }),
              (this.checkCountMax = e.textureGCCheckCountMax),
              (this.maxIdle = e.textureGCAMaxIdle),
              (this.active = e.textureGCActive);
          }
          postrender() {
            this._renderer.renderingToScreen &&
              (this.count++,
              this.active &&
                (this.checkCount++,
                this.checkCount > this.checkCountMax &&
                  ((this.checkCount = 0), this.run())));
          }
          run() {
            const t = this._renderer.texture.managedTextures;
            for (let e = 0; e < t.length; e++) {
              const i = t[e];
              i.autoGarbageCollect &&
                i.resource &&
                i._touched > -1 &&
                this.count - i._touched > this.maxIdle &&
                ((i._touched = -1), i.unload());
            }
          }
          destroy() {
            this._renderer = null;
          }
        };
        (s.extension = {
          type: [n.Ag.WebGLSystem, n.Ag.WebGPUSystem],
          name: "textureGC",
        }),
          (s.defaultOptions = {
            textureGCActive: !0,
            textureGCAMaxIdle: 3600,
            textureGCCheckCountMax: 600,
          });
        let r = s;
        n.XO.add(r);
      },
      1196: (t, e, i) => {
        "use strict";
        i.d(e, { N: () => r });
        var n = i(9313);
        const s = new n.u();
        class r {
          constructor(t, e) {
            (this.mapCoord = new n.u()),
              (this.uClampFrame = new Float32Array(4)),
              (this.uClampOffset = new Float32Array(2)),
              (this._textureID = -1),
              (this._updateID = 0),
              (this.clampOffset = 0),
              (this.clampMargin = void 0 === e ? (t.width < 10 ? 0 : 0.5) : e),
              (this.isSimple = !1),
              (this.texture = t);
          }
          get texture() {
            return this._texture;
          }
          set texture(t) {
            this.texture !== t &&
              (this._texture?.removeListener("update", this.update, this),
              (this._texture = t),
              this._texture.addListener("update", this.update, this),
              this.update());
          }
          multiplyUvs(t, e) {
            void 0 === e && (e = t);
            const i = this.mapCoord;
            for (let n = 0; n < t.length; n += 2) {
              const s = t[n],
                r = t[n + 1];
              (e[n] = s * i.a + r * i.c + i.tx),
                (e[n + 1] = s * i.b + r * i.d + i.ty);
            }
            return e;
          }
          update() {
            const t = this._texture;
            this._updateID++;
            const e = t.uvs;
            this.mapCoord.set(
              e.x1 - e.x0,
              e.y1 - e.y0,
              e.x3 - e.x0,
              e.y3 - e.y0,
              e.x0,
              e.y0
            );
            const i = t.orig,
              n = t.trim;
            n &&
              (s.set(
                i.width / n.width,
                0,
                0,
                i.height / n.height,
                -n.x / n.width,
                -n.y / n.height
              ),
              this.mapCoord.append(s));
            const r = t.source,
              o = this.uClampFrame,
              a = this.clampMargin / r._resolution,
              l = this.clampOffset;
            return (
              (o[0] = (t.frame.x + a + l) / r.width),
              (o[1] = (t.frame.y + a + l) / r.height),
              (o[2] = (t.frame.x + t.frame.width - a + l) / r.width),
              (o[3] = (t.frame.y + t.frame.height - a + l) / r.height),
              (this.uClampOffset[0] = l / r.pixelWidth),
              (this.uClampOffset[1] = l / r.pixelHeight),
              (this.isSimple =
                t.frame.width === r.width &&
                t.frame.height === r.height &&
                0 === t.rotate),
              !0
            );
          }
        }
      },
      2437: (t, e, i) => {
        "use strict";
        i.d(e, { W: () => a });
        var n = i(9939),
          s = i(6932),
          r = i(4492);
        let o = 0;
        const a = new (class {
          constructor(t) {
            (this._poolKeyHash = Object.create(null)),
              (this._texturePool = {}),
              (this.textureOptions = t || {}),
              (this.enableFullScreen = !1);
          }
          createTexture(t, e, i) {
            const n = new s.v({
              ...this.textureOptions,
              width: t,
              height: e,
              resolution: 1,
              antialias: i,
              autoGarbageCollect: !0,
            });
            return new r.g({ source: n, label: "texturePool_" + o++ });
          }
          getOptimalTexture(t, e, i = 1, s) {
            let r = Math.ceil(t * i - 1e-6),
              o = Math.ceil(e * i - 1e-6);
            (r = (0, n.U5)(r)), (o = (0, n.U5)(o));
            const a = (r << 17) + (o << 1) + (s ? 1 : 0);
            this._texturePool[a] || (this._texturePool[a] = []);
            let l = this._texturePool[a].pop();
            return (
              l || (l = this.createTexture(r, o, s)),
              (l.source._resolution = i),
              (l.source.width = r / i),
              (l.source.height = o / i),
              (l.source.pixelWidth = r),
              (l.source.pixelHeight = o),
              (l.frame.x = 0),
              (l.frame.y = 0),
              (l.frame.width = t),
              (l.frame.height = e),
              l.updateUvs(),
              (this._poolKeyHash[l.uid] = a),
              l
            );
          }
          getSameSizeTexture(t, e = !1) {
            const i = t.source;
            return this.getOptimalTexture(t.width, t.height, i._resolution, e);
          }
          returnTexture(t) {
            const e = this._poolKeyHash[t.uid];
            this._texturePool[e].push(t);
          }
          clear(t) {
            if ((t = !1 !== t))
              for (const t in this._texturePool) {
                const e = this._texturePool[t];
                if (e) for (let t = 0; t < e.length; t++) e[t].destroy(!0);
              }
            this._texturePool = {};
          }
        })();
      },
      2518: (t, e, i) => {
        "use strict";
        i.d(e, { P: () => r });
        var n = i(8507),
          s = i(6932);
        class r extends s.v {
          constructor(t) {
            const e = t.resource || new Float32Array(t.width * t.height * 4);
            let i = t.format;
            i ||
              (i =
                e instanceof Float32Array
                  ? "rgba32float"
                  : e instanceof Int32Array || e instanceof Uint32Array
                  ? "rgba32uint"
                  : e instanceof Int16Array || e instanceof Uint16Array
                  ? "rgba16uint"
                  : (Int8Array, "bgra8unorm")),
              super({ ...t, resource: e, format: i }),
              (this.uploadMethodId = "buffer");
          }
          static test(t) {
            return (
              t instanceof Int8Array ||
              t instanceof Uint8Array ||
              t instanceof Uint8ClampedArray ||
              t instanceof Int16Array ||
              t instanceof Uint16Array ||
              t instanceof Int32Array ||
              t instanceof Uint32Array ||
              t instanceof Float32Array
            );
          }
        }
        r.extension = n.Ag.TextureSource;
      },
      4884: (t, e, i) => {
        "use strict";
        i.d(e, { q: () => o });
        var n = i(1761),
          s = i(8507),
          r = i(6932);
        class o extends r.v {
          constructor(t) {
            t.resource || (t.resource = n.e.get().createCanvas()),
              t.width ||
                ((t.width = t.resource.width),
                t.autoDensity || (t.width /= t.resolution)),
              t.height ||
                ((t.height = t.resource.height),
                t.autoDensity || (t.height /= t.resolution)),
              super(t),
              (this.uploadMethodId = "image"),
              (this.autoDensity = t.autoDensity);
            const e = t.resource;
            (this.pixelWidth === e.width && this.pixelWidth === e.height) ||
              this.resizeCanvas(),
              (this.transparent = !!t.transparent);
          }
          resizeCanvas() {
            this.autoDensity &&
              ((this.resource.style.width = `${this.width}px`),
              (this.resource.style.height = `${this.height}px`)),
              (this.resource.width === this.pixelWidth &&
                this.resource.height === this.pixelHeight) ||
                ((this.resource.width = this.pixelWidth),
                (this.resource.height = this.pixelHeight));
          }
          resize(t = this.width, e = this.height, i = this._resolution) {
            const n = super.resize(t, e, i);
            return n && this.resizeCanvas(), n;
          }
          static test(t) {
            return (
              (globalThis.HTMLCanvasElement &&
                t instanceof HTMLCanvasElement) ||
              (globalThis.OffscreenCanvas && t instanceof OffscreenCanvas)
            );
          }
        }
        o.extension = s.Ag.TextureSource;
      },
      8293: (t, e, i) => {
        "use strict";
        i.d(e, { b: () => a });
        var n = i(1761),
          s = i(8507),
          r = i(268),
          o = i(6932);
        class a extends o.v {
          constructor(t) {
            if (
              t.resource &&
              globalThis.HTMLImageElement &&
              t.resource instanceof HTMLImageElement
            ) {
              const e = n.e
                .get()
                .createCanvas(t.resource.width, t.resource.height);
              e.getContext("2d").drawImage(t.resource, 0, 0),
                (t.resource = e),
                (0, r.R)(
                  "ImageSource: Image element passed, converting to canvas. Use CanvasSource instead."
                );
            }
            super(t),
              (this.uploadMethodId = "image"),
              (this.autoGarbageCollect = !0);
          }
          static test(t) {
            return (
              (globalThis.HTMLImageElement && t instanceof HTMLImageElement) ||
              ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            );
          }
        }
        a.extension = s.Ag.TextureSource;
      },
      6932: (t, e, i) => {
        "use strict";
        i.d(e, { v: () => c });
        var n = i(4486),
          s = i(9939);
        var r = i(133),
          o = i(4670);
        const a = Object.create(null);
        const l = class t extends n.A {
          constructor(e = {}) {
            super(),
              (this._resourceType = "textureSampler"),
              (this._touched = 0),
              (this._maxAnisotropy = 1),
              (this.destroyed = !1),
              (e = { ...t.defaultOptions, ...e }),
              (this.addressMode = e.addressMode),
              (this.addressModeU = e.addressModeU ?? this.addressModeU),
              (this.addressModeV = e.addressModeV ?? this.addressModeV),
              (this.addressModeW = e.addressModeW ?? this.addressModeW),
              (this.scaleMode = e.scaleMode),
              (this.magFilter = e.magFilter ?? this.magFilter),
              (this.minFilter = e.minFilter ?? this.minFilter),
              (this.mipmapFilter = e.mipmapFilter ?? this.mipmapFilter),
              (this.lodMinClamp = e.lodMinClamp),
              (this.lodMaxClamp = e.lodMaxClamp),
              (this.compare = e.compare),
              (this.maxAnisotropy = e.maxAnisotropy ?? 1);
          }
          set addressMode(t) {
            (this.addressModeU = t),
              (this.addressModeV = t),
              (this.addressModeW = t);
          }
          get addressMode() {
            return this.addressModeU;
          }
          set wrapMode(t) {
            (0, o.t)(
              o.l,
              "TextureStyle.wrapMode is now TextureStyle.addressMode"
            ),
              (this.addressMode = t);
          }
          get wrapMode() {
            return this.addressMode;
          }
          set scaleMode(t) {
            (this.magFilter = t), (this.minFilter = t), (this.mipmapFilter = t);
          }
          get scaleMode() {
            return this.magFilter;
          }
          set maxAnisotropy(t) {
            (this._maxAnisotropy = Math.min(t, 16)),
              this._maxAnisotropy > 1 && (this.scaleMode = "linear");
          }
          get maxAnisotropy() {
            return this._maxAnisotropy;
          }
          get _resourceId() {
            return this._sharedResourceId || this._generateResourceId();
          }
          update() {
            this.emit("change", this), (this._sharedResourceId = null);
          }
          _generateResourceId() {
            const t = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
            return (
              (this._sharedResourceId = (function (t) {
                const e = a[t];
                return void 0 === e && (a[t] = (0, r.L)("resource")), e;
              })(t)),
              this._resourceId
            );
          }
          destroy() {
            (this.destroyed = !0),
              this.emit("destroy", this),
              this.emit("change", this),
              this.removeAllListeners();
          }
        };
        l.defaultOptions = {
          addressMode: "clamp-to-edge",
          scaleMode: "linear",
        };
        let u = l;
        const h = class t extends n.A {
          constructor(e = {}) {
            super(),
              (this.options = e),
              (this.uid = (0, r.L)("textureSource")),
              (this._resourceType = "textureSource"),
              (this._resourceId = (0, r.L)("resource")),
              (this.uploadMethodId = "unknown"),
              (this._resolution = 1),
              (this.pixelWidth = 1),
              (this.pixelHeight = 1),
              (this.width = 1),
              (this.height = 1),
              (this.sampleCount = 1),
              (this.mipLevelCount = 1),
              (this.autoGenerateMipmaps = !1),
              (this.format = "rgba8unorm"),
              (this.dimension = "2d"),
              (this.antialias = !1),
              (this._touched = 0),
              (this._batchTick = -1),
              (this._textureBindLocation = -1),
              (e = { ...t.defaultOptions, ...e }),
              (this.label = e.label ?? ""),
              (this.resource = e.resource),
              (this.autoGarbageCollect = e.autoGarbageCollect),
              (this._resolution = e.resolution),
              e.width
                ? (this.pixelWidth = e.width * this._resolution)
                : (this.pixelWidth = this.resource
                    ? this.resourceWidth ?? 1
                    : 1),
              e.height
                ? (this.pixelHeight = e.height * this._resolution)
                : (this.pixelHeight = this.resource
                    ? this.resourceHeight ?? 1
                    : 1),
              (this.width = this.pixelWidth / this._resolution),
              (this.height = this.pixelHeight / this._resolution),
              (this.format = e.format),
              (this.dimension = e.dimensions),
              (this.mipLevelCount = e.mipLevelCount),
              (this.autoGenerateMipmaps = e.autoGenerateMipmaps),
              (this.sampleCount = e.sampleCount),
              (this.antialias = e.antialias),
              (this.alphaMode = e.alphaMode),
              (this.style = new u(
                (function (t) {
                  const e = {};
                  for (const i in t) void 0 !== t[i] && (e[i] = t[i]);
                  return e;
                })(e)
              )),
              (this.destroyed = !1),
              this._refreshPOT();
          }
          get source() {
            return this;
          }
          get style() {
            return this._style;
          }
          set style(t) {
            this.style !== t &&
              (this._style?.off("change", this._onStyleChange, this),
              (this._style = t),
              this._style?.on("change", this._onStyleChange, this),
              this._onStyleChange());
          }
          get addressMode() {
            return this._style.addressMode;
          }
          set addressMode(t) {
            this._style.addressMode = t;
          }
          get repeatMode() {
            return this._style.addressMode;
          }
          set repeatMode(t) {
            this._style.addressMode = t;
          }
          get magFilter() {
            return this._style.magFilter;
          }
          set magFilter(t) {
            this._style.magFilter = t;
          }
          get minFilter() {
            return this._style.minFilter;
          }
          set minFilter(t) {
            this._style.minFilter = t;
          }
          get mipmapFilter() {
            return this._style.mipmapFilter;
          }
          set mipmapFilter(t) {
            this._style.mipmapFilter = t;
          }
          get lodMinClamp() {
            return this._style.lodMinClamp;
          }
          set lodMinClamp(t) {
            this._style.lodMinClamp = t;
          }
          get lodMaxClamp() {
            return this._style.lodMaxClamp;
          }
          set lodMaxClamp(t) {
            this._style.lodMaxClamp = t;
          }
          _onStyleChange() {
            this.emit("styleChange", this);
          }
          update() {
            if (this.resource) {
              const t = this._resolution;
              if (this.resize(this.resourceWidth / t, this.resourceHeight / t))
                return;
            }
            this.emit("update", this);
          }
          destroy() {
            (this.destroyed = !0),
              this.emit("destroy", this),
              this.emit("change", this),
              this._style && (this._style.destroy(), (this._style = null)),
              (this.uploadMethodId = null),
              (this.resource = null),
              this.removeAllListeners();
          }
          unload() {
            (this._resourceId = (0, r.L)("resource")),
              this.emit("change", this),
              this.emit("unload", this);
          }
          get resourceWidth() {
            const { resource: t } = this;
            return t.naturalWidth || t.videoWidth || t.displayWidth || t.width;
          }
          get resourceHeight() {
            const { resource: t } = this;
            return (
              t.naturalHeight || t.videoHeight || t.displayHeight || t.height
            );
          }
          get resolution() {
            return this._resolution;
          }
          set resolution(t) {
            this._resolution !== t &&
              ((this._resolution = t),
              (this.width = this.pixelWidth / t),
              (this.height = this.pixelHeight / t));
          }
          resize(t, e, i) {
            (i = i || this._resolution),
              (t = t || this.width),
              (e = e || this.height);
            const n = Math.round(t * i),
              s = Math.round(e * i);
            return (
              (this.width = n / i),
              (this.height = s / i),
              (this._resolution = i),
              (this.pixelWidth !== n || this.pixelHeight !== s) &&
                (this._refreshPOT(),
                (this.pixelWidth = n),
                (this.pixelHeight = s),
                this.emit("resize", this),
                (this._resourceId = (0, r.L)("resource")),
                this.emit("change", this),
                !0)
            );
          }
          updateMipmaps() {
            this.autoGenerateMipmaps &&
              this.mipLevelCount > 1 &&
              this.emit("updateMipmaps", this);
          }
          set wrapMode(t) {
            this._style.wrapMode = t;
          }
          get wrapMode() {
            return this._style.wrapMode;
          }
          set scaleMode(t) {
            this._style.scaleMode = t;
          }
          get scaleMode() {
            return this._style.scaleMode;
          }
          _refreshPOT() {
            this.isPowerOfTwo =
              (0, s.f3)(this.pixelWidth) && (0, s.f3)(this.pixelHeight);
          }
          static test(t) {
            throw new Error("Unimplemented");
          }
        };
        h.defaultOptions = {
          resolution: 1,
          format: "bgra8unorm",
          alphaMode: "premultiply-alpha-on-upload",
          dimensions: "2d",
          mipLevelCount: 1,
          autoGenerateMipmaps: !1,
          sampleCount: 1,
          antialias: !1,
          autoGarbageCollect: !1,
        };
        let c = h;
      },
      6139: (t, e, i) => {
        "use strict";
        i.d(e, { $: () => l });
        var n = i(8507),
          s = i(7309),
          r = i(6858),
          o = i(6932);
        const a = class t extends o.v {
          constructor(e) {
            super(e),
              (this.isReady = !1),
              (this.uploadMethodId = "video"),
              (e = { ...t.defaultOptions, ...e }),
              (this._autoUpdate = !0),
              (this._isConnectedToTicker = !1),
              (this._updateFPS = e.updateFPS || 0),
              (this._msToNextUpdate = 0),
              (this.autoPlay = !1 !== e.autoPlay),
              (this.alphaMode = e.alphaMode ?? "premultiply-alpha-on-upload"),
              (this._videoFrameRequestCallback =
                this._videoFrameRequestCallback.bind(this)),
              (this._videoFrameRequestCallbackHandle = null),
              (this._load = null),
              (this._resolve = null),
              (this._reject = null),
              (this._onCanPlay = this._onCanPlay.bind(this)),
              (this._onCanPlayThrough = this._onCanPlayThrough.bind(this)),
              (this._onError = this._onError.bind(this)),
              (this._onPlayStart = this._onPlayStart.bind(this)),
              (this._onPlayStop = this._onPlayStop.bind(this)),
              (this._onSeeked = this._onSeeked.bind(this)),
              !1 !== e.autoLoad && this.load();
          }
          updateFrame() {
            if (!this.destroyed) {
              if (this._updateFPS) {
                const t = s.R.shared.elapsedMS * this.resource.playbackRate;
                this._msToNextUpdate = Math.floor(this._msToNextUpdate - t);
              }
              (!this._updateFPS || this._msToNextUpdate <= 0) &&
                (this._msToNextUpdate = this._updateFPS
                  ? Math.floor(1e3 / this._updateFPS)
                  : 0),
                this.isValid && this.update();
            }
          }
          _videoFrameRequestCallback() {
            this.updateFrame(),
              this.destroyed
                ? (this._videoFrameRequestCallbackHandle = null)
                : (this._videoFrameRequestCallbackHandle =
                    this.resource.requestVideoFrameCallback(
                      this._videoFrameRequestCallback
                    ));
          }
          get isValid() {
            return !!this.resource.videoWidth && !!this.resource.videoHeight;
          }
          async load() {
            if (this._load) return this._load;
            const t = this.resource,
              e = this.options;
            return (
              (t.readyState === t.HAVE_ENOUGH_DATA ||
                t.readyState === t.HAVE_FUTURE_DATA) &&
                t.width &&
                t.height &&
                (t.complete = !0),
              t.addEventListener("play", this._onPlayStart),
              t.addEventListener("pause", this._onPlayStop),
              t.addEventListener("seeked", this._onSeeked),
              this._isSourceReady()
                ? this._mediaReady()
                : (e.preload || t.addEventListener("canplay", this._onCanPlay),
                  t.addEventListener("canplaythrough", this._onCanPlayThrough),
                  t.addEventListener("error", this._onError, !0)),
              (this.alphaMode = await (0, r.C)()),
              (this._load = new Promise((i, n) => {
                this.isValid
                  ? i(this)
                  : ((this._resolve = i),
                    (this._reject = n),
                    void 0 !== e.preloadTimeoutMs &&
                      (this._preloadTimeout = setTimeout(() => {
                        this._onError(
                          new ErrorEvent(
                            `Preload exceeded timeout of ${e.preloadTimeoutMs}ms`
                          )
                        );
                      })),
                    t.load());
              })),
              this._load
            );
          }
          _onError(t) {
            this.resource.removeEventListener("error", this._onError, !0),
              this.emit("error", t),
              this._reject &&
                (this._reject(t),
                (this._reject = null),
                (this._resolve = null));
          }
          _isSourcePlaying() {
            const t = this.resource;
            return !t.paused && !t.ended;
          }
          _isSourceReady() {
            return this.resource.readyState > 2;
          }
          _onPlayStart() {
            this.isValid || this._mediaReady(), this._configureAutoUpdate();
          }
          _onPlayStop() {
            this._configureAutoUpdate();
          }
          _onSeeked() {
            this._autoUpdate &&
              !this._isSourcePlaying() &&
              ((this._msToNextUpdate = 0),
              this.updateFrame(),
              (this._msToNextUpdate = 0));
          }
          _onCanPlay() {
            this.resource.removeEventListener("canplay", this._onCanPlay),
              this._mediaReady();
          }
          _onCanPlayThrough() {
            this.resource.removeEventListener(
              "canplaythrough",
              this._onCanPlay
            ),
              this._preloadTimeout &&
                (clearTimeout(this._preloadTimeout),
                (this._preloadTimeout = void 0)),
              this._mediaReady();
          }
          _mediaReady() {
            const t = this.resource;
            this.isValid &&
              ((this.isReady = !0), this.resize(t.videoWidth, t.videoHeight)),
              (this._msToNextUpdate = 0),
              this.updateFrame(),
              (this._msToNextUpdate = 0),
              this._resolve &&
                (this._resolve(this),
                (this._resolve = null),
                (this._reject = null)),
              this._isSourcePlaying()
                ? this._onPlayStart()
                : this.autoPlay && this.resource.play();
          }
          destroy() {
            this._configureAutoUpdate();
            const t = this.resource;
            t &&
              (t.removeEventListener("play", this._onPlayStart),
              t.removeEventListener("pause", this._onPlayStop),
              t.removeEventListener("seeked", this._onSeeked),
              t.removeEventListener("canplay", this._onCanPlay),
              t.removeEventListener("canplaythrough", this._onCanPlayThrough),
              t.removeEventListener("error", this._onError, !0),
              t.pause(),
              (t.src = ""),
              t.load()),
              super.destroy();
          }
          get autoUpdate() {
            return this._autoUpdate;
          }
          set autoUpdate(t) {
            t !== this._autoUpdate &&
              ((this._autoUpdate = t), this._configureAutoUpdate());
          }
          get updateFPS() {
            return this._updateFPS;
          }
          set updateFPS(t) {
            t !== this._updateFPS &&
              ((this._updateFPS = t), this._configureAutoUpdate());
          }
          _configureAutoUpdate() {
            this._autoUpdate && this._isSourcePlaying()
              ? !this._updateFPS && this.resource.requestVideoFrameCallback
                ? (this._isConnectedToTicker &&
                    (s.R.shared.remove(this.updateFrame, this),
                    (this._isConnectedToTicker = !1),
                    (this._msToNextUpdate = 0)),
                  null === this._videoFrameRequestCallbackHandle &&
                    (this._videoFrameRequestCallbackHandle =
                      this.resource.requestVideoFrameCallback(
                        this._videoFrameRequestCallback
                      )))
                : (null !== this._videoFrameRequestCallbackHandle &&
                    (this.resource.cancelVideoFrameCallback(
                      this._videoFrameRequestCallbackHandle
                    ),
                    (this._videoFrameRequestCallbackHandle = null)),
                  this._isConnectedToTicker ||
                    (s.R.shared.add(this.updateFrame, this),
                    (this._isConnectedToTicker = !0),
                    (this._msToNextUpdate = 0)))
              : (null !== this._videoFrameRequestCallbackHandle &&
                  (this.resource.cancelVideoFrameCallback(
                    this._videoFrameRequestCallbackHandle
                  ),
                  (this._videoFrameRequestCallbackHandle = null)),
                this._isConnectedToTicker &&
                  (s.R.shared.remove(this.updateFrame, this),
                  (this._isConnectedToTicker = !1),
                  (this._msToNextUpdate = 0)));
          }
          static test(t) {
            return (
              (globalThis.HTMLVideoElement && t instanceof HTMLVideoElement) ||
              (globalThis.VideoFrame && t instanceof VideoFrame)
            );
          }
        };
        (a.extension = n.Ag.TextureSource),
          (a.defaultOptions = {
            ...o.v.defaultOptions,
            autoLoad: !0,
            autoPlay: !0,
            updateFPS: 0,
            crossorigin: !0,
            loop: !1,
            muted: !0,
            playsinline: !0,
            preload: !1,
          }),
          (a.MIME_TYPES = {
            ogv: "video/ogg",
            mov: "video/quicktime",
            m4v: "video/mp4",
          });
        let l = a;
      },
      8725: (t, e, i) => {
        "use strict";
        i.d(e, { c: () => o });
        var n = i(4884),
          s = i(4492);
        const r = new Map();
        function o(t, e) {
          if (!r.has(t)) {
            const i = new s.g({ source: new n.q({ resource: t, ...e }) }),
              o = () => {
                r.get(t) === i && r.delete(t);
              };
            i.once("destroy", o), i.source.once("destroy", o), r.set(t, i);
          }
          return r.get(t);
        }
      },
      6557: (t, e, i) => {
        "use strict";
        var n = i(1979),
          s = i(8507),
          r = i(6932),
          o = i(4492);
        const a = [];
        function l(t = {}) {
          const e = t && t.resource,
            i = e ? t.resource : t,
            n = e ? t : { resource: t };
          for (let t = 0; t < a.length; t++) {
            const e = a[t];
            if (e.test(i)) return new e(n);
          }
          throw new Error(
            `Could not find a source type for resource: ${n.resource}`
          );
        }
        s.XO.handleByList(s.Ag.TextureSource, a),
          (o.g.from = function (t, e = !1) {
            return "string" == typeof t
              ? n.l.get(t)
              : t instanceof r.v
              ? new o.g({ source: t })
              : (function (t = {}, e = !1) {
                  const i = t && t.resource,
                    s = i ? t.resource : t,
                    r = i ? t : { resource: t };
                  if (!e && n.l.has(s)) return n.l.get(s);
                  const a = new o.g({ source: l(r) });
                  return (
                    a.on("destroy", () => {
                      n.l.has(s) && n.l.remove(s);
                    }),
                    e || n.l.set(s, a),
                    a
                  );
                })(t, e);
          });
      },
      7952: (t, e, i) => {
        "use strict";
        i.d(e, { X: () => r });
        const n = Object.create(null),
          s = Object.create(null);
        function r(t, e) {
          let i = s[t];
          return (
            void 0 === i &&
              (void 0 === n[e] && (n[e] = 1), (s[t] = i = n[e]++)),
            i
          );
        }
      },
      5099: (t, e, i) => {
        "use strict";
        i.d(e, { W: () => n });
        var n = ((t) => (
          (t[(t.WEBGL = 1)] = "WEBGL"),
          (t[(t.WEBGPU = 2)] = "WEBGPU"),
          (t[(t.BOTH = 3)] = "BOTH"),
          t
        ))(n || {});
      },
      4263: (t, e, i) => {
        "use strict";
        i.d(e, { mc: () => z, u: () => F, ig: () => B, fR: () => O });
        var n = i(4486),
          s = i(2577);
        var r = i(9313),
          o = i(1652),
          a = i(2812),
          l = i(133),
          u = i(4670),
          h = i(9903);
        const c = {
          allowChildren: !0,
          removeChildren(t = 0, e) {
            const i = e ?? this.children.length,
              n = i - t,
              s = [];
            if (n > 0 && n <= i) {
              for (let e = i - 1; e >= t; e--) {
                const t = this.children[e];
                t &&
                  (this.renderGroup && this.renderGroup.removeChild(t),
                  s.push(t),
                  (t.parent = null));
              }
              (0, h.d)(this.children, t, i);
              for (let t = 0; t < s.length; ++t)
                this.emit("childRemoved", s[t], this, t),
                  s[t].emit("removed", this);
              return s;
            }
            if (0 === n && 0 === this.children.length) return s;
            throw new RangeError(
              "removeChildren: numeric values are outside the acceptable range."
            );
          },
          removeChildAt(t) {
            const e = this.getChildAt(t);
            return this.removeChild(e);
          },
          getChildAt(t) {
            if (t < 0 || t >= this.children.length)
              throw new Error(`getChildAt: Index (${t}) does not exist.`);
            return this.children[t];
          },
          setChildIndex(t, e) {
            if (e < 0 || e >= this.children.length)
              throw new Error(
                `The index ${e} supplied is out of bounds ${this.children.length}`
              );
            this.getChildIndex(t), this.addChildAt(t, e);
          },
          getChildIndex(t) {
            const e = this.children.indexOf(t);
            if (-1 === e)
              throw new Error(
                "The supplied Container must be a child of the caller"
              );
            return e;
          },
          addChildAt(t, e) {
            this.allowChildren ||
              (0, u.t)(
                u.l,
                "addChildAt: Only Containers will be allowed to add children in v8.0.0"
              );
            const { children: i } = this;
            if (e < 0 || e > i.length)
              throw new Error(
                `${t}addChildAt: The index ${e} supplied is out of bounds ${i.length}`
              );
            if (t.parent) {
              const i = t.parent.children.indexOf(t);
              if (t.parent === this && i === e) return t;
              -1 !== i && t.parent.children.splice(i, 1);
            }
            return (
              e === i.length ? i.push(t) : i.splice(e, 0, t),
              (t.parent = this),
              (t.didChange = !0),
              (t.didViewUpdate = !1),
              (t._updateFlags = 15),
              this.renderGroup && this.renderGroup.addChild(t),
              this.sortableChildren && (this.sortDirty = !0),
              this.emit("childAdded", t, this, e),
              t.emit("added", this),
              t
            );
          },
          swapChildren(t, e) {
            if (t === e) return;
            const i = this.getChildIndex(t),
              n = this.getChildIndex(e);
            (this.children[i] = e), (this.children[n] = t);
          },
          removeFromParent() {
            this.parent?.removeChild(this);
          },
        };
        var d = i(9049),
          p = i(8507),
          f = i(8218);
        const m = new (class {
          constructor() {
            (this._effectClasses = []),
              (this._tests = []),
              (this._initialized = !1);
          }
          init() {
            this._initialized ||
              ((this._initialized = !0),
              this._effectClasses.forEach((t) => {
                this.add({ test: t.test, maskClass: t });
              }));
          }
          add(t) {
            this._tests.push(t);
          }
          getMaskEffect(t) {
            this._initialized || this.init();
            for (let e = 0; e < this._tests.length; e++) {
              const i = this._tests[e];
              if (i.test(t)) return f.Z.get(i.maskClass, t);
            }
            return t;
          }
          returnMaskEffect(t) {
            f.Z.return(t);
          }
        })();
        p.XO.handleByList(p.Ag.MaskEffect, m._effectClasses);
        const g = {
            _mask: null,
            _filters: null,
            effects: [],
            addEffect(t) {
              -1 === this.effects.indexOf(t) &&
                (this.effects.push(t),
                this.effects.sort((t, e) => t.priority - e.priority),
                this.renderGroup && (this.renderGroup.structureDidChange = !0),
                this._updateIsSimple());
            },
            removeEffect(t) {
              const e = this.effects.indexOf(t);
              -1 !== e &&
                (this.effects.splice(e, 1),
                !this.isRenderGroupRoot &&
                  this.renderGroup &&
                  (this.renderGroup.structureDidChange = !0),
                this._updateIsSimple());
            },
            set mask(t) {
              if (
                (this._mask || (this._mask = { mask: null, effect: null }),
                this._mask.mask === t)
              )
                return;
              if (
                (this._mask.effect &&
                  (this.removeEffect(this._mask.effect),
                  m.returnMaskEffect(this._mask.effect),
                  (this._mask.effect = null)),
                (this._mask.mask = t),
                null == t)
              )
                return;
              const e = m.getMaskEffect(t);
              (this._mask.effect = e), this.addEffect(e);
            },
            get mask() {
              return this._mask?.mask;
            },
            set filters(t) {
              !Array.isArray(t) && t && (t = [t]),
                this._filters ||
                  (this._filters = {
                    filters: null,
                    effect: null,
                    filterArea: null,
                  });
              const e = t?.length > 0,
                i =
                  (this._filters.effect && !e) || (!this._filters.effect && e);
              if (
                ((t = Array.isArray(t) ? t.slice(0) : t),
                (this._filters.filters = Object.freeze(t)),
                i)
              )
                if (e) {
                  const t = f.Z.get(d.a);
                  (this._filters.effect = t), this.addEffect(t);
                } else {
                  const t = this._filters.effect;
                  this.removeEffect(t),
                    (t.filterArea = null),
                    (t.filters = null),
                    (this._filters.effect = null),
                    f.Z.return(t);
                }
              e &&
                ((this._filters.effect.filters = t),
                (this._filters.effect.filterArea = this.filterArea));
            },
            get filters() {
              return this._filters?.filters;
            },
            set filterArea(t) {
              this._filters ||
                (this._filters = {
                  filters: null,
                  effect: null,
                  filterArea: null,
                }),
                (this._filters.filterArea = t);
            },
            get filterArea() {
              return this._filters?.filterArea;
            },
          },
          v = {
            label: null,
            get name() {
              return (
                (0, u.t)(
                  u.l,
                  "Container.name property has been removed, use Container.label instead"
                ),
                this.label
              );
            },
            set name(t) {
              (0, u.t)(
                u.l,
                "Container.name property has been removed, use Container.label instead"
              ),
                (this.label = t);
            },
            getChildByName(t, e = !1) {
              return this.getChildByLabel(t, e);
            },
            getChildByLabel(t, e = !1) {
              const i = this.children;
              for (let e = 0; e < i.length; e++) {
                const n = i[e];
                if (n.label === t || (t instanceof RegExp && t.test(n.label)))
                  return n;
              }
              if (e)
                for (let e = 0; e < i.length; e++) {
                  const n = i[e].getChildByLabel(t, !0);
                  if (n) return n;
                }
              return null;
            },
            getChildrenByLabel(t, e = !1, i = []) {
              const n = this.children;
              for (let e = 0; e < n.length; e++) {
                const s = n[e];
                (s.label === t || (t instanceof RegExp && t.test(s.label))) &&
                  i.push(s);
              }
              if (e)
                for (let e = 0; e < n.length; e++)
                  n[e].getChildrenByLabel(t, !0, i);
              return i;
            },
          };
        var y = i(9636),
          x = i(9443),
          b = i(7269);
        function S(t, e) {
          const i = t.children;
          for (let t = 0; t < i.length; t++) {
            const n = i[t],
              s = ((255 & n.uid) << 24) | (16777215 & n._didChangeId);
            e.data[e.index] !== s &&
              ((e.data[e.index] = s), (e.didChange = !0)),
              e.index++,
              n.children.length && S(n, e);
          }
          return e.didChange;
        }
        const C = new r.u(),
          _ = {
            _localBoundsCacheId: -1,
            _localBoundsCacheData: null,
            _setWidth(t, e) {
              const i = Math.sign(this.scale.x) || 1;
              this.scale.x = 0 !== e ? (t / e) * i : i;
            },
            _setHeight(t, e) {
              const i = Math.sign(this.scale.y) || 1;
              this.scale.y = 0 !== e ? (t / e) * i : i;
            },
            getLocalBounds() {
              this._localBoundsCacheData ||
                (this._localBoundsCacheData = {
                  data: [],
                  index: 1,
                  didChange: !1,
                  localBounds: new y.c(),
                });
              const t = this._localBoundsCacheData;
              return (
                (t.index = 1),
                (t.didChange = !1),
                t.data[0] !== this._didChangeId >> 12 &&
                  ((t.didChange = !0), (t.data[0] = this._didChangeId >> 12)),
                S(this, t),
                t.didChange && (0, b.n)(this, t.localBounds, C),
                t.localBounds
              );
            },
            getBounds(t, e) {
              return (0, x.fB)(this, t, e || new y.c());
            },
          },
          T = {
            _onRender: null,
            set onRender(t) {
              const e = this.renderGroup;
              if (!t)
                return (
                  this._onRender && e?.removeOnRender(this),
                  void (this._onRender = null)
                );
              this._onRender || e?.addOnRender(this), (this._onRender = t);
            },
            get onRender() {
              return this._onRender;
            },
          },
          w = {
            _zIndex: 0,
            sortDirty: !1,
            sortableChildren: !1,
            get zIndex() {
              return this._zIndex;
            },
            set zIndex(t) {
              this._zIndex !== t &&
                ((this._zIndex = t), this.depthOfChildModified());
            },
            depthOfChildModified() {
              this.parent &&
                ((this.parent.sortableChildren = !0),
                (this.parent.sortDirty = !0)),
                this.renderGroup &&
                  !this.isRenderGroupRoot &&
                  (this.renderGroup.structureDidChange = !0);
            },
            sortChildren() {
              this.sortDirty && ((this.sortDirty = !1), this.children.sort(P));
            },
          };
        function P(t, e) {
          return t._zIndex - e._zIndex;
        }
        var A = i(5101);
        const k = {
          getGlobalPosition(t = new A.b(), e = !1) {
            return (
              this.parent
                ? this.parent.toGlobal(this._position, t, e)
                : ((t.x = this._position.x), (t.y = this._position.y)),
              t
            );
          },
          toGlobal(t, e, i = !1) {
            if (!i) {
              this.updateLocalTransform();
              const i = (0, x.Ek)(this, new r.u());
              return i.append(this.localTransform), i.apply(t, e);
            }
            return this.worldTransform.apply(t, e);
          },
          toLocal(t, e, i, n) {
            if ((e && (t = e.toGlobal(t, i, n)), !n)) {
              this.updateLocalTransform();
              const e = (0, x.Ek)(this, new r.u());
              return e.append(this.localTransform), e.applyInverse(t, i);
            }
            return this.worldTransform.applyInverse(t, i);
          },
        };
        var M = i(848);
        class E {
          constructor(t) {
            (this.renderPipeId = "renderGroup"),
              (this.root = null),
              (this.canBundle = !1),
              (this.renderGroupParent = null),
              (this.renderGroupChildren = []),
              (this._children = []),
              (this.worldTransform = new r.u()),
              (this.worldColorAlpha = 4294967295),
              (this.worldColor = 16777215),
              (this.worldAlpha = 1),
              (this.childrenToUpdate = Object.create(null)),
              (this.updateTick = 0),
              (this.childrenRenderablesToUpdate = { list: [], index: 0 }),
              (this.structureDidChange = !0),
              (this.instructionSet = new M.L()),
              (this._onRenderContainers = []),
              (this.root = t),
              this.addChild(t);
          }
          get localTransform() {
            return this.root.localTransform;
          }
          addRenderGroupChild(t) {
            t.renderGroupParent &&
              t.renderGroupParent._removeRenderGroupChild(t),
              (t.renderGroupParent = this),
              this.onChildUpdate(t.root),
              this.renderGroupChildren.push(t);
          }
          _removeRenderGroupChild(t) {
            t.root.didChange && this._removeChildFromUpdate(t.root);
            const e = this.renderGroupChildren.indexOf(t);
            e > -1 && this.renderGroupChildren.splice(e, 1),
              (t.renderGroupParent = null);
          }
          addChild(t) {
            if (
              ((this.structureDidChange = !0),
              t !== this.root &&
                (this._children.push(t),
                (t.updateTick = -1),
                t.parent === this.root
                  ? (t.relativeRenderGroupDepth = 1)
                  : (t.relativeRenderGroupDepth =
                      t.parent.relativeRenderGroupDepth + 1),
                t._onRender && this.addOnRender(t)),
              t.renderGroup)
            ) {
              if (t.renderGroup.root === t)
                return void this.addRenderGroupChild(t.renderGroup);
            } else (t.renderGroup = this), (t.didChange = !0);
            const e = t.children;
            t.isRenderGroupRoot || this.onChildUpdate(t);
            for (let t = 0; t < e.length; t++) this.addChild(e[t]);
          }
          removeChild(t) {
            if (
              ((this.structureDidChange = !0),
              t._onRender && this.removeOnRender(t),
              t.renderGroup.root !== t)
            ) {
              const e = t.children;
              for (let t = 0; t < e.length; t++) this.removeChild(e[t]);
              t.didChange && t.renderGroup._removeChildFromUpdate(t),
                (t.renderGroup = null);
            } else this._removeRenderGroupChild(t.renderGroup);
            const e = this._children.indexOf(t);
            e > -1 && this._children.splice(e, 1);
          }
          onChildUpdate(t) {
            let e = this.childrenToUpdate[t.relativeRenderGroupDepth];
            e ||
              (e = this.childrenToUpdate[t.relativeRenderGroupDepth] =
                { index: 0, list: [] }),
              (e.list[e.index++] = t);
          }
          updateRenderable(t) {
            t.globalDisplayStatus < 7 ||
              ((t.didViewUpdate = !1),
              this.instructionSet.renderPipes[t.renderPipeId].updateRenderable(
                t
              ));
          }
          onChildViewUpdate(t) {
            this.childrenRenderablesToUpdate.list[
              this.childrenRenderablesToUpdate.index++
            ] = t;
          }
          _removeChildFromUpdate(t) {
            const e = this.childrenToUpdate[t.relativeRenderGroupDepth];
            if (!e) return;
            const i = e.list.indexOf(t);
            i > -1 && e.list.splice(i, 1), e.index--;
          }
          get isRenderable() {
            return 7 === this.root.localDisplayStatus && this.worldAlpha > 0;
          }
          addOnRender(t) {
            this._onRenderContainers.push(t);
          }
          removeOnRender(t) {
            this._onRenderContainers.splice(
              this._onRenderContainers.indexOf(t),
              1
            );
          }
          runOnRender() {
            for (let t = 0; t < this._onRenderContainers.length; t++)
              this._onRenderContainers[t]._onRender();
          }
        }
        const I = new a.o(null),
          D = new a.o(null),
          R = new a.o(null, 1, 1),
          B = 1,
          F = 2,
          O = 4;
        class z extends n.A {
          constructor(t = {}) {
            super(),
              (this.uid = (0, l.L)("renderable")),
              (this._updateFlags = 15),
              (this.isRenderGroupRoot = !1),
              (this.renderGroup = null),
              (this.didChange = !1),
              (this.didViewUpdate = !1),
              (this.relativeRenderGroupDepth = 0),
              (this.children = []),
              (this.parent = null),
              (this.includeInBuild = !0),
              (this.measurable = !0),
              (this.isSimple = !0),
              (this.updateTick = -1),
              (this.localTransform = new r.u()),
              (this.relativeGroupTransform = new r.u()),
              (this.groupTransform = this.relativeGroupTransform),
              (this.destroyed = !1),
              (this._position = new a.o(this, 0, 0)),
              (this._scale = R),
              (this._pivot = D),
              (this._skew = I),
              (this._cx = 1),
              (this._sx = 0),
              (this._cy = 0),
              (this._sy = 1),
              (this._rotation = 0),
              (this.localColor = 16777215),
              (this.localAlpha = 1),
              (this.groupAlpha = 1),
              (this.groupColor = 16777215),
              (this.groupColorAlpha = 4294967295),
              (this.localBlendMode = "inherit"),
              (this.groupBlendMode = "normal"),
              (this.localDisplayStatus = 7),
              (this.globalDisplayStatus = 7),
              (this._didChangeId = 0),
              (this._didLocalTransformChangeId = -1),
              (function (t, e, i = {}) {
                for (const n in e) i[n] || void 0 === e[n] || (t[n] = e[n]);
              })(this, t, { children: !0, parent: !0, effects: !0 }),
              t.children?.forEach((t) => this.addChild(t)),
              (this.effects = []),
              t.parent?.addChild(this);
          }
          static mixin(t) {
            Object.defineProperties(
              z.prototype,
              Object.getOwnPropertyDescriptors(t)
            );
          }
          addChild(...t) {
            if (
              (this.allowChildren ||
                (0, u.t)(
                  u.l,
                  "addChild: Only Containers will be allowed to add children in v8.0.0"
                ),
              t.length > 1)
            ) {
              for (let e = 0; e < t.length; e++) this.addChild(t[e]);
              return t[0];
            }
            const e = t[0];
            return e.parent === this
              ? (this.children.splice(this.children.indexOf(e), 1),
                this.children.push(e),
                this.renderGroup &&
                  !this.isRenderGroupRoot &&
                  (this.renderGroup.structureDidChange = !0),
                e)
              : (e.parent && e.parent.removeChild(e),
                this.children.push(e),
                this.sortableChildren && (this.sortDirty = !0),
                (e.parent = this),
                (e.didChange = !0),
                (e.didViewUpdate = !1),
                (e._updateFlags = 15),
                this.renderGroup && this.renderGroup.addChild(e),
                this.emit("childAdded", e, this, this.children.length - 1),
                e.emit("added", this),
                0 !== e._zIndex && e.depthOfChildModified(),
                e);
          }
          removeChild(...t) {
            if (t.length > 1) {
              for (let e = 0; e < t.length; e++) this.removeChild(t[e]);
              return t[0];
            }
            const e = t[0],
              i = this.children.indexOf(e);
            return (
              i > -1 &&
                (this.children.splice(i, 1),
                this.renderGroup && this.renderGroup.removeChild(e),
                (e.parent = null),
                this.emit("childRemoved", e, this, i),
                e.emit("removed", this)),
              e
            );
          }
          _onUpdate(t) {
            if (
              (t && t === this._skew && this._updateSkew(),
              this._didChangeId++,
              !this.didChange)
            )
              if (((this.didChange = !0), this.isRenderGroupRoot)) {
                const t = this.renderGroup.renderGroupParent;
                t && t.onChildUpdate(this);
              } else this.renderGroup && this.renderGroup.onChildUpdate(this);
          }
          set isRenderGroup(t) {
            if (this.isRenderGroupRoot && !1 === t)
              throw new Error("[Pixi] cannot undo a render group just yet");
            t && this.enableRenderGroup();
          }
          get isRenderGroup() {
            return this.isRenderGroupRoot;
          }
          enableRenderGroup() {
            if (this.renderGroup && this.renderGroup.root === this) return;
            this.isRenderGroupRoot = !0;
            const t = this.renderGroup;
            if (
              (t && t.removeChild(this), (this.renderGroup = new E(this)), t)
            ) {
              for (let e = 0; e < t.renderGroupChildren.length; e++) {
                const i = t.renderGroupChildren[e];
                let n = i.root;
                for (; n; ) {
                  if (n === this) {
                    this.renderGroup.addRenderGroupChild(i);
                    break;
                  }
                  n = n.parent;
                }
              }
              t.addRenderGroupChild(this.renderGroup);
            }
            this._updateIsSimple(), (this.groupTransform = r.u.IDENTITY);
          }
          _updateIsSimple() {
            this.isSimple =
              !this.isRenderGroupRoot && 0 === this.effects.length;
          }
          get worldTransform() {
            return (
              this._worldTransform || (this._worldTransform = new r.u()),
              this.renderGroup &&
                (this.isRenderGroupRoot
                  ? this._worldTransform.copyFrom(
                      this.renderGroup.worldTransform
                    )
                  : this._worldTransform.appendFrom(
                      this.relativeGroupTransform,
                      this.renderGroup.worldTransform
                    )),
              this._worldTransform
            );
          }
          get x() {
            return this._position.x;
          }
          set x(t) {
            this._position.x = t;
          }
          get y() {
            return this._position.y;
          }
          set y(t) {
            this._position.y = t;
          }
          get position() {
            return this._position;
          }
          set position(t) {
            this._position.copyFrom(t);
          }
          get rotation() {
            return this._rotation;
          }
          set rotation(t) {
            this._rotation !== t &&
              ((this._rotation = t), this._onUpdate(this._skew));
          }
          get angle() {
            return this.rotation * o.bO;
          }
          set angle(t) {
            this.rotation = t * o.Td;
          }
          get pivot() {
            return (
              this._pivot === D && (this._pivot = new a.o(this, 0, 0)),
              this._pivot
            );
          }
          set pivot(t) {
            this._pivot === D && (this._pivot = new a.o(this, 0, 0)),
              "number" == typeof t
                ? this._pivot.set(t)
                : this._pivot.copyFrom(t);
          }
          get skew() {
            return (
              this._skew === I && (this._skew = new a.o(this, 0, 0)), this._skew
            );
          }
          set skew(t) {
            this._skew === I && (this._skew = new a.o(this, 0, 0)),
              this._skew.copyFrom(t);
          }
          get scale() {
            return (
              this._scale === R && (this._scale = new a.o(this, 1, 1)),
              this._scale
            );
          }
          set scale(t) {
            this._scale === R && (this._scale = new a.o(this, 0, 0)),
              "number" == typeof t
                ? this._scale.set(t)
                : this._scale.copyFrom(t);
          }
          get width() {
            return Math.abs(this.scale.x * this.getLocalBounds().width);
          }
          set width(t) {
            const e = this.getLocalBounds().width;
            this._setWidth(t, e);
          }
          get height() {
            return Math.abs(this.scale.y * this.getLocalBounds().height);
          }
          set height(t) {
            const e = this.getLocalBounds().height;
            this._setHeight(t, e);
          }
          getSize(t) {
            t || (t = {});
            const e = this.getLocalBounds();
            return (
              (t.width = Math.abs(this.scale.x * e.width)),
              (t.height = Math.abs(this.scale.y * e.height)),
              t
            );
          }
          setSize(t, e) {
            const i = this.getLocalBounds();
            let n, s;
            "object" != typeof t
              ? ((n = t), (s = e ?? t))
              : ((n = t.width), (s = t.height ?? t.width)),
              void 0 !== n && this._setWidth(n, i.width),
              void 0 !== s && this._setHeight(s, i.height);
          }
          _updateSkew() {
            const t = this._rotation,
              e = this._skew;
            (this._cx = Math.cos(t + e._y)),
              (this._sx = Math.sin(t + e._y)),
              (this._cy = -Math.sin(t - e._x)),
              (this._sy = Math.cos(t - e._x));
          }
          updateTransform(t) {
            return (
              this.position.set(
                "number" == typeof t.x ? t.x : this.position.x,
                "number" == typeof t.y ? t.y : this.position.y
              ),
              this.scale.set(
                "number" == typeof t.scaleX ? t.scaleX || 1 : this.scale.x,
                "number" == typeof t.scaleY ? t.scaleY || 1 : this.scale.y
              ),
              (this.rotation =
                "number" == typeof t.rotation ? t.rotation : this.rotation),
              this.skew.set(
                "number" == typeof t.skewX ? t.skewX : this.skew.x,
                "number" == typeof t.skewY ? t.skewY : this.skew.y
              ),
              this.pivot.set(
                "number" == typeof t.pivotX ? t.pivotX : this.pivot.x,
                "number" == typeof t.pivotY ? t.pivotY : this.pivot.y
              ),
              this
            );
          }
          setFromMatrix(t) {
            t.decompose(this);
          }
          updateLocalTransform() {
            if ((15 & this._didLocalTransformChangeId) === this._didChangeId)
              return;
            this._didLocalTransformChangeId = this._didChangeId;
            const t = this.localTransform,
              e = this._scale,
              i = this._pivot,
              n = this._position,
              s = e._x,
              r = e._y,
              o = i._x,
              a = i._y;
            (t.a = this._cx * s),
              (t.b = this._sx * s),
              (t.c = this._cy * r),
              (t.d = this._sy * r),
              (t.tx = n._x - (o * t.a + a * t.c)),
              (t.ty = n._y - (o * t.b + a * t.d));
          }
          set alpha(t) {
            t !== this.localAlpha &&
              ((this.localAlpha = t),
              (this._updateFlags |= B),
              this._onUpdate());
          }
          get alpha() {
            return this.localAlpha;
          }
          set tint(t) {
            const e = s.Q.shared.setValue(t ?? 16777215).toBgrNumber();
            e !== this.localColor &&
              ((this.localColor = e),
              (this._updateFlags |= B),
              this._onUpdate());
          }
          get tint() {
            const t = this.localColor;
            return ((255 & t) << 16) + (65280 & t) + ((t >> 16) & 255);
          }
          set blendMode(t) {
            this.localBlendMode !== t &&
              (this.renderGroup &&
                !this.isRenderGroupRoot &&
                (this.renderGroup.structureDidChange = !0),
              (this._updateFlags |= F),
              (this.localBlendMode = t),
              this._onUpdate());
          }
          get blendMode() {
            return this.localBlendMode;
          }
          get visible() {
            return !!(2 & this.localDisplayStatus);
          }
          set visible(t) {
            const e = t ? 1 : 0;
            (2 & this.localDisplayStatus) >> 1 !== e &&
              (this.renderGroup &&
                !this.isRenderGroupRoot &&
                (this.renderGroup.structureDidChange = !0),
              (this._updateFlags |= O),
              (this.localDisplayStatus ^= 2),
              this._onUpdate());
          }
          get culled() {
            return !(4 & this.localDisplayStatus);
          }
          set culled(t) {
            const e = t ? 1 : 0;
            (4 & this.localDisplayStatus) >> 2 !== e &&
              (this.renderGroup &&
                !this.isRenderGroupRoot &&
                (this.renderGroup.structureDidChange = !0),
              (this._updateFlags |= O),
              (this.localDisplayStatus ^= 4),
              this._onUpdate());
          }
          get renderable() {
            return !!(1 & this.localDisplayStatus);
          }
          set renderable(t) {
            const e = t ? 1 : 0;
            (1 & this.localDisplayStatus) !== e &&
              ((this._updateFlags |= O),
              (this.localDisplayStatus ^= 1),
              this.renderGroup &&
                !this.isRenderGroupRoot &&
                (this.renderGroup.structureDidChange = !0),
              this._onUpdate());
          }
          get isRenderable() {
            return 7 === this.localDisplayStatus && this.groupAlpha > 0;
          }
          destroy(t = !1) {
            if (this.destroyed) return;
            (this.destroyed = !0),
              this.removeFromParent(),
              (this.parent = null),
              (this._mask = null),
              (this._filters = null),
              (this.effects = null),
              (this._position = null),
              (this._scale = null),
              (this._pivot = null),
              (this._skew = null),
              this.emit("destroyed", this),
              this.removeAllListeners();
            const e = "boolean" == typeof t ? t : t?.children,
              i = this.removeChildren(0, this.children.length);
            if (e) for (let e = 0; e < i.length; ++e) i[e].destroy(t);
          }
        }
        z.mixin(c),
          z.mixin(k),
          z.mixin(T),
          z.mixin(_),
          z.mixin(g),
          z.mixin(v),
          z.mixin(w),
          z.mixin({ cullArea: null, cullable: !1, cullableChildren: !0 });
      },
      9636: (t, e, i) => {
        "use strict";
        i.d(e, { c: () => o });
        var n = i(9313),
          s = i(9252);
        const r = new n.u();
        class o {
          constructor(t = 1 / 0, e = 1 / 0, i = -1 / 0, n = -1 / 0) {
            (this.minX = 1 / 0),
              (this.minY = 1 / 0),
              (this.maxX = -1 / 0),
              (this.maxY = -1 / 0),
              (this.matrix = r),
              (this.minX = t),
              (this.minY = e),
              (this.maxX = i),
              (this.maxY = n);
          }
          isEmpty() {
            return this.minX > this.maxX || this.minY > this.maxY;
          }
          get rectangle() {
            this._rectangle || (this._rectangle = new s.M());
            const t = this._rectangle;
            return (
              this.minX > this.maxX || this.minY > this.maxY
                ? ((t.x = 0), (t.y = 0), (t.width = 0), (t.height = 0))
                : t.copyFromBounds(this),
              t
            );
          }
          clear() {
            return (
              (this.minX = 1 / 0),
              (this.minY = 1 / 0),
              (this.maxX = -1 / 0),
              (this.maxY = -1 / 0),
              (this.matrix = r),
              this
            );
          }
          set(t, e, i, n) {
            (this.minX = t), (this.minY = e), (this.maxX = i), (this.maxY = n);
          }
          addFrame(t, e, i, n, s) {
            s || (s = this.matrix);
            const r = s.a,
              o = s.b,
              a = s.c,
              l = s.d,
              u = s.tx,
              h = s.ty;
            let c = this.minX,
              d = this.minY,
              p = this.maxX,
              f = this.maxY,
              m = r * t + a * e + u,
              g = o * t + l * e + h;
            m < c && (c = m),
              g < d && (d = g),
              m > p && (p = m),
              g > f && (f = g),
              (m = r * i + a * e + u),
              (g = o * i + l * e + h),
              m < c && (c = m),
              g < d && (d = g),
              m > p && (p = m),
              g > f && (f = g),
              (m = r * t + a * n + u),
              (g = o * t + l * n + h),
              m < c && (c = m),
              g < d && (d = g),
              m > p && (p = m),
              g > f && (f = g),
              (m = r * i + a * n + u),
              (g = o * i + l * n + h),
              m < c && (c = m),
              g < d && (d = g),
              m > p && (p = m),
              g > f && (f = g),
              (this.minX = c),
              (this.minY = d),
              (this.maxX = p),
              (this.maxY = f);
          }
          addRect(t, e) {
            this.addFrame(t.x, t.y, t.x + t.width, t.y + t.height, e);
          }
          addBounds(t, e) {
            this.addFrame(t.minX, t.minY, t.maxX, t.maxY, e);
          }
          addBoundsMask(t) {
            (this.minX = this.minX > t.minX ? this.minX : t.minX),
              (this.minY = this.minY > t.minY ? this.minY : t.minY),
              (this.maxX = this.maxX < t.maxX ? this.maxX : t.maxX),
              (this.maxY = this.maxY < t.maxY ? this.maxY : t.maxY);
          }
          applyMatrix(t) {
            const e = this.minX,
              i = this.minY,
              n = this.maxX,
              s = this.maxY,
              { a: r, b: o, c: a, d: l, tx: u, ty: h } = t;
            let c = r * e + a * i + u,
              d = o * e + l * i + h;
            (this.minX = c),
              (this.minY = d),
              (this.maxX = c),
              (this.maxY = d),
              (c = r * n + a * i + u),
              (d = o * n + l * i + h),
              (this.minX = c < this.minX ? c : this.minX),
              (this.minY = d < this.minY ? d : this.minY),
              (this.maxX = c > this.maxX ? c : this.maxX),
              (this.maxY = d > this.maxY ? d : this.maxY),
              (c = r * e + a * s + u),
              (d = o * e + l * s + h),
              (this.minX = c < this.minX ? c : this.minX),
              (this.minY = d < this.minY ? d : this.minY),
              (this.maxX = c > this.maxX ? c : this.maxX),
              (this.maxY = d > this.maxY ? d : this.maxY),
              (c = r * n + a * s + u),
              (d = o * n + l * s + h),
              (this.minX = c < this.minX ? c : this.minX),
              (this.minY = d < this.minY ? d : this.minY),
              (this.maxX = c > this.maxX ? c : this.maxX),
              (this.maxY = d > this.maxY ? d : this.maxY);
          }
          fit(t) {
            return (
              this.minX < t.left && (this.minX = t.left),
              this.maxX > t.right && (this.maxX = t.right),
              this.minY < t.top && (this.minY = t.top),
              this.maxY > t.bottom && (this.maxY = t.bottom),
              this
            );
          }
          fitBounds(t, e, i, n) {
            return (
              this.minX < t && (this.minX = t),
              this.maxX > e && (this.maxX = e),
              this.minY < i && (this.minY = i),
              this.maxY > n && (this.maxY = n),
              this
            );
          }
          pad(t, e = t) {
            return (
              (this.minX -= t),
              (this.maxX += t),
              (this.minY -= e),
              (this.maxY += e),
              this
            );
          }
          ceil() {
            return (
              (this.minX = Math.floor(this.minX)),
              (this.minY = Math.floor(this.minY)),
              (this.maxX = Math.ceil(this.maxX)),
              (this.maxY = Math.ceil(this.maxY)),
              this
            );
          }
          clone() {
            return new o(this.minX, this.minY, this.maxX, this.maxY);
          }
          scale(t, e = t) {
            return (
              (this.minX *= t),
              (this.minY *= e),
              (this.maxX *= t),
              (this.maxY *= e),
              this
            );
          }
          get x() {
            return this.minX;
          }
          set x(t) {
            const e = this.maxX - this.minX;
            (this.minX = t), (this.maxX = t + e);
          }
          get y() {
            return this.minY;
          }
          set y(t) {
            const e = this.maxY - this.minY;
            (this.minY = t), (this.maxY = t + e);
          }
          get width() {
            return this.maxX - this.minX;
          }
          set width(t) {
            this.maxX = this.minX + t;
          }
          get height() {
            return this.maxY - this.minY;
          }
          set height(t) {
            this.maxY = this.minY + t;
          }
          get left() {
            return this.minX;
          }
          get right() {
            return this.maxX;
          }
          get top() {
            return this.minY;
          }
          get bottom() {
            return this.maxY;
          }
          get isPositive() {
            return this.maxX - this.minX > 0 && this.maxY - this.minY > 0;
          }
          get isValid() {
            return this.minX + this.minY !== 1 / 0;
          }
          addVertexData(t, e, i, n) {
            let s = this.minX,
              r = this.minY,
              o = this.maxX,
              a = this.maxY;
            n || (n = this.matrix);
            const l = n.a,
              u = n.b,
              h = n.c,
              c = n.d,
              d = n.tx,
              p = n.ty;
            for (let n = e; n < i; n += 2) {
              const e = t[n],
                i = t[n + 1],
                f = l * e + h * i + d,
                m = u * e + c * i + p;
              (s = f < s ? f : s),
                (r = m < r ? m : r),
                (o = f > o ? f : o),
                (a = m > a ? m : a);
            }
            (this.minX = s), (this.minY = r), (this.maxX = o), (this.maxY = a);
          }
          containsPoint(t, e) {
            return (
              this.minX <= t &&
              this.minY <= e &&
              this.maxX >= t &&
              this.maxY >= e
            );
          }
          toString() {
            return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
          }
        }
      },
      9443: (t, e, i) => {
        "use strict";
        i.d(e, { Ek: () => a, fB: () => r });
        var n = i(9313),
          s = i(2208);
        function r(t, e, i) {
          let r, l;
          return (
            i.clear(),
            t.parent
              ? e
                ? (r = t.parent.worldTransform)
                : ((l = s.u.get().identity()), (r = a(t, l)))
              : (r = n.u.IDENTITY),
            o(t, i, r, e),
            l && s.u.return(l),
            i.isValid || i.set(0, 0, 0, 0),
            i
          );
        }
        function o(t, e, i, r) {
          if (!t.visible || !t.measurable) return;
          let a;
          r
            ? (a = t.worldTransform)
            : (t.updateLocalTransform(),
              (a = s.u.get()),
              a.appendFrom(t.localTransform, i));
          const l = e,
            u = !!t.effects.length;
          if ((u && (e = s.o.get().clear()), t.boundsArea))
            e.addRect(t.boundsArea, a);
          else {
            t.addBounds && ((e.matrix = a), t.addBounds(e));
            for (let i = 0; i < t.children.length; i++)
              o(t.children[i], e, a, r);
          }
          if (u) {
            for (let i = 0; i < t.effects.length; i++)
              t.effects[i].addBounds?.(e);
            l.addBounds(e, n.u.IDENTITY), s.o.return(e);
          }
          r || s.u.return(a);
        }
        function a(t, e) {
          const i = t.parent;
          return (
            i &&
              (a(i, e), i.updateLocalTransform(), e.append(i.localTransform)),
            e
          );
        }
      },
      7269: (t, e, i) => {
        "use strict";
        i.d(e, { n: () => r });
        var n = i(9313),
          s = i(2208);
        function r(t, e, i) {
          return (
            e.clear(),
            i || (i = n.u.IDENTITY),
            o(t, e, i, t, !0),
            e.isValid || e.set(0, 0, 0, 0),
            e
          );
        }
        function o(t, e, i, r, a) {
          let l;
          if (a) (l = s.u.get()), (l = i.copyTo(l));
          else {
            if (!t.visible || !t.measurable) return;
            t.updateLocalTransform();
            const e = t.localTransform;
            (l = s.u.get()), l.appendFrom(e, i);
          }
          const u = e,
            h = !!t.effects.length;
          if ((h && (e = s.o.get().clear()), t.boundsArea))
            e.addRect(t.boundsArea, l);
          else {
            t.renderPipeId && ((e.matrix = l), t.addBounds(e));
            const i = t.children;
            for (let t = 0; t < i.length; t++) o(i[t], e, l, r, !1);
          }
          if (h) {
            for (let i = 0; i < t.effects.length; i++)
              t.effects[i].addLocalBounds?.(e, r);
            u.addBounds(e, n.u.IDENTITY), s.o.return(e);
          }
          s.u.return(l);
        }
      },
      2208: (t, e, i) => {
        "use strict";
        i.d(e, { o: () => a, u: () => o });
        var n = i(9313),
          s = i(8425),
          r = i(9636);
        const o = new s.b(n.u),
          a = new s.b(r.c);
      },
      1418: (t, e, i) => {
        "use strict";
        i.d(e, { L: () => s });
        const n = 16777215;
        function s(t, e) {
          return t === n || e === n
            ? t + e - n
            : (function (t, e, i) {
                const n = (t >> 16) & 255,
                  s = (t >> 8) & 255,
                  r = 255 & t;
                return (
                  ((n + (((e >> 16) & 255) - n) * i) << 16) +
                  ((s + (((e >> 8) & 255) - s) * i) << 8) +
                  (r + ((255 & e) - r) * i)
                );
              })(t, e, 0.5);
        }
      },
      2760: (t, e, i) => {
        "use strict";
        function n(t, e, i) {
          const n = ((t >> 24) & 255) / 255;
          (e[i++] = ((255 & t) / 255) * n),
            (e[i++] = (((t >> 8) & 255) / 255) * n),
            (e[i++] = (((t >> 16) & 255) / 255) * n),
            (e[i++] = n);
        }
        i.d(e, { V: () => n });
      },
      6954: (t, e, i) => {
        "use strict";
        i.d(e, { G: () => s });
        var n = i(1418);
        class s {
          constructor() {
            (this.batcher = null),
              (this.batch = null),
              (this.applyTransform = !0),
              (this.roundPixels = 0);
          }
          get blendMode() {
            return this.applyTransform
              ? this.renderable.groupBlendMode
              : "normal";
          }
          packIndex(t, e, i) {
            const n = this.geometryData.indices;
            for (let s = 0; s < this.indexSize; s++)
              t[e++] = n[s + this.indexOffset] + i - this.vertexOffset;
          }
          packAttributes(t, e, i, s) {
            const r = this.geometryData,
              o = this.renderable,
              a = r.vertices,
              l = r.uvs,
              u = 2 * this.vertexOffset,
              h = 2 * (this.vertexOffset + this.vertexSize),
              c = this.color,
              d = (c >> 16) | (65280 & c) | ((255 & c) << 16);
            if (this.applyTransform) {
              const r =
                  (0, n.L)(d, o.groupColor) +
                  ((this.alpha * o.groupAlpha * 255) << 24),
                c = o.groupTransform,
                p = (s << 16) | (65535 & this.roundPixels),
                f = c.a,
                m = c.b,
                g = c.c,
                v = c.d,
                y = c.tx,
                x = c.ty;
              for (let n = u; n < h; n += 2) {
                const s = a[n],
                  o = a[n + 1];
                (t[i] = f * s + g * o + y),
                  (t[i + 1] = m * s + v * o + x),
                  (t[i + 2] = l[n]),
                  (t[i + 3] = l[n + 1]),
                  (e[i + 4] = r),
                  (e[i + 5] = p),
                  (i += 6);
              }
            } else {
              const n = d + ((255 * this.alpha) << 24);
              for (let r = u; r < h; r += 2)
                (t[i] = a[r]),
                  (t[i + 1] = a[r + 1]),
                  (t[i + 2] = l[r]),
                  (t[i + 3] = l[r + 1]),
                  (e[i + 4] = n),
                  (e[i + 5] = s << 16),
                  (i += 6);
            }
          }
          get vertSize() {
            return this.vertexSize;
          }
          copyTo(t) {
            (t.indexOffset = this.indexOffset),
              (t.indexSize = this.indexSize),
              (t.vertexOffset = this.vertexOffset),
              (t.vertexSize = this.vertexSize),
              (t.color = this.color),
              (t.alpha = this.alpha),
              (t.texture = this.texture),
              (t.geometryData = this.geometryData);
          }
          reset() {
            this.applyTransform = !0;
          }
        }
      },
      9408: (t, e, i) => {
        "use strict";
        i.d(e, { A: () => o });
        var n = i(4670),
          s = i(4263),
          r = i(4835);
        class o extends s.mc {
          constructor(t) {
            t instanceof r.T && (t = { context: t });
            const { context: e, roundPixels: i, ...n } = t || {};
            super({ label: "Graphics", ...n }),
              (this.canBundle = !0),
              (this.renderPipeId = "graphics"),
              (this._roundPixels = 0),
              (this._context = e || (this._ownedContext = new r.T())),
              this._context.on("update", this.onViewUpdate, this),
              (this.allowChildren = !1),
              (this.roundPixels = i ?? !1);
          }
          set context(t) {
            t !== this._context &&
              (this._context.off("update", this.onViewUpdate, this),
              (this._context = t),
              this._context.on("update", this.onViewUpdate, this),
              this.onViewUpdate());
          }
          get context() {
            return this._context;
          }
          get bounds() {
            return this._context.bounds;
          }
          addBounds(t) {
            t.addBounds(this._context.bounds);
          }
          containsPoint(t) {
            return this._context.containsPoint(t);
          }
          get roundPixels() {
            return !!this._roundPixels;
          }
          set roundPixels(t) {
            this._roundPixels = t ? 1 : 0;
          }
          onViewUpdate() {
            (this._didChangeId += 4096),
              (this._didGraphicsUpdate = !0),
              this.didViewUpdate ||
                ((this.didViewUpdate = !0),
                this.renderGroup && this.renderGroup.onChildViewUpdate(this));
          }
          destroy(t) {
            this._ownedContext && !t
              ? this._ownedContext.destroy(t)
              : (!0 !== t && !0 !== t?.context) || this._context.destroy(t),
              (this._ownedContext = null),
              (this._context = null),
              super.destroy(t);
          }
          _callContextMethod(t, e) {
            return this.context[t](...e), this;
          }
          setFillStyle(...t) {
            return this._callContextMethod("setFillStyle", t);
          }
          setStrokeStyle(...t) {
            return this._callContextMethod("setStrokeStyle", t);
          }
          fill(...t) {
            return this._callContextMethod("fill", t);
          }
          stroke(...t) {
            return this._callContextMethod("stroke", t);
          }
          texture(...t) {
            return this._callContextMethod("texture", t);
          }
          beginPath() {
            return this._callContextMethod("beginPath", []);
          }
          cut() {
            return this._callContextMethod("cut", []);
          }
          arc(...t) {
            return this._callContextMethod("arc", t);
          }
          arcTo(...t) {
            return this._callContextMethod("arcTo", t);
          }
          arcToSvg(...t) {
            return this._callContextMethod("arcToSvg", t);
          }
          bezierCurveTo(...t) {
            return this._callContextMethod("bezierCurveTo", t);
          }
          closePath() {
            return this._callContextMethod("closePath", []);
          }
          ellipse(...t) {
            return this._callContextMethod("ellipse", t);
          }
          circle(...t) {
            return this._callContextMethod("circle", t);
          }
          path(...t) {
            return this._callContextMethod("path", t);
          }
          lineTo(...t) {
            return this._callContextMethod("lineTo", t);
          }
          moveTo(...t) {
            return this._callContextMethod("moveTo", t);
          }
          quadraticCurveTo(...t) {
            return this._callContextMethod("quadraticCurveTo", t);
          }
          rect(...t) {
            return this._callContextMethod("rect", t);
          }
          roundRect(...t) {
            return this._callContextMethod("roundRect", t);
          }
          poly(...t) {
            return this._callContextMethod("poly", t);
          }
          regularPoly(...t) {
            return this._callContextMethod("regularPoly", t);
          }
          roundPoly(...t) {
            return this._callContextMethod("roundPoly", t);
          }
          roundShape(...t) {
            return this._callContextMethod("roundShape", t);
          }
          filletRect(...t) {
            return this._callContextMethod("filletRect", t);
          }
          chamferRect(...t) {
            return this._callContextMethod("chamferRect", t);
          }
          star(...t) {
            return this._callContextMethod("star", t);
          }
          svg(...t) {
            return this._callContextMethod("svg", t);
          }
          restore(...t) {
            return this._callContextMethod("restore", t);
          }
          save() {
            return this._callContextMethod("save", []);
          }
          getTransform() {
            return this.context.getTransform();
          }
          resetTransform() {
            return this._callContextMethod("resetTransform", []);
          }
          rotateTransform(...t) {
            return this._callContextMethod("rotate", t);
          }
          scaleTransform(...t) {
            return this._callContextMethod("scale", t);
          }
          setTransform(...t) {
            return this._callContextMethod("setTransform", t);
          }
          transform(...t) {
            return this._callContextMethod("transform", t);
          }
          translateTransform(...t) {
            return this._callContextMethod("translate", t);
          }
          clear() {
            return this._callContextMethod("clear", []);
          }
          get fillStyle() {
            return this._context.fillStyle;
          }
          set fillStyle(t) {
            this._context.fillStyle = t;
          }
          get strokeStyle() {
            return this._context.strokeStyle;
          }
          set strokeStyle(t) {
            this._context.strokeStyle = t;
          }
          clone(t = !1) {
            if (t) return new o(this._context.clone());
            this._ownedContext = null;
            return new o(this._context);
          }
          lineStyle(t, e, i) {
            (0, n.t)(
              n.l,
              "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style."
            );
            const s = {};
            return (
              t && (s.width = t),
              e && (s.color = e),
              i && (s.alpha = i),
              (this.context.strokeStyle = s),
              this
            );
          }
          beginFill(t, e) {
            (0, n.t)(
              n.l,
              "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."
            );
            const i = {};
            return (
              t && (i.color = t),
              e && (i.alpha = e),
              (this.context.fillStyle = i),
              this
            );
          }
          endFill() {
            (0, n.t)(
              n.l,
              "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."
            ),
              this.context.fill();
            const t = this.context.strokeStyle;
            return (
              (t.width === r.T.defaultStrokeStyle.width &&
                t.color === r.T.defaultStrokeStyle.color &&
                t.alpha === r.T.defaultStrokeStyle.alpha) ||
                this.context.stroke(),
              this
            );
          }
          drawCircle(...t) {
            return (
              (0, n.t)(
                n.l,
                "Graphics#drawCircle has been renamed to Graphics#circle"
              ),
              this._callContextMethod("circle", t)
            );
          }
          drawEllipse(...t) {
            return (
              (0, n.t)(
                n.l,
                "Graphics#drawEllipse has been renamed to Graphics#ellipse"
              ),
              this._callContextMethod("ellipse", t)
            );
          }
          drawPolygon(...t) {
            return (
              (0, n.t)(
                n.l,
                "Graphics#drawPolygon has been renamed to Graphics#poly"
              ),
              this._callContextMethod("poly", t)
            );
          }
          drawRect(...t) {
            return (
              (0, n.t)(
                n.l,
                "Graphics#drawRect has been renamed to Graphics#rect"
              ),
              this._callContextMethod("rect", t)
            );
          }
          drawRoundedRect(...t) {
            return (
              (0, n.t)(
                n.l,
                "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"
              ),
              this._callContextMethod("roundRect", t)
            );
          }
          drawStar(...t) {
            return (
              (0, n.t)(
                n.l,
                "Graphics#drawStar has been renamed to Graphics#star"
              ),
              this._callContextMethod("star", t)
            );
          }
        }
      },
      4835: (t, e, i) => {
        "use strict";
        i.d(e, { T: () => J });
        var n = i(4486),
          s = i(2577),
          r = i(9313),
          o = i(5101),
          a = i(4492),
          l = i(133),
          u = i(4670),
          h = i(9636),
          c = i(268),
          d = i(8133);
        var p = i(9252);
        class f {
          constructor(t = 0, e = 0, i = 0) {
            (this.type = "circle"),
              (this.x = t),
              (this.y = e),
              (this.radius = i);
          }
          clone() {
            return new f(this.x, this.y, this.radius);
          }
          contains(t, e) {
            if (this.radius <= 0) return !1;
            const i = this.radius * this.radius;
            let n = this.x - t,
              s = this.y - e;
            return (n *= n), (s *= s), n + s <= i;
          }
          strokeContains(t, e, i) {
            if (0 === this.radius) return !1;
            const n = this.x - t,
              s = this.y - e,
              r = this.radius,
              o = i / 2,
              a = Math.sqrt(n * n + s * s);
            return a < r + o && a > r - o;
          }
          getBounds(t) {
            return (
              ((t = t || new p.M()).x = this.x - this.radius),
              (t.y = this.y - this.radius),
              (t.width = 2 * this.radius),
              (t.height = 2 * this.radius),
              t
            );
          }
          copyFrom(t) {
            return (
              (this.x = t.x), (this.y = t.y), (this.radius = t.radius), this
            );
          }
          copyTo(t) {
            return t.copyFrom(this), t;
          }
          toString() {
            return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`;
          }
        }
        class m {
          constructor(t = 0, e = 0, i = 0, n = 0) {
            (this.type = "ellipse"),
              (this.x = t),
              (this.y = e),
              (this.halfWidth = i),
              (this.halfHeight = n);
          }
          clone() {
            return new m(this.x, this.y, this.halfWidth, this.halfHeight);
          }
          contains(t, e) {
            if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1;
            let i = (t - this.x) / this.halfWidth,
              n = (e - this.y) / this.halfHeight;
            return (i *= i), (n *= n), i + n <= 1;
          }
          strokeContains(t, e, i) {
            const { halfWidth: n, halfHeight: s } = this;
            if (n <= 0 || s <= 0) return !1;
            const r = i / 2,
              o = n - r,
              a = s - r,
              l = n + r,
              u = s + r,
              h = t - this.x,
              c = e - this.y;
            return (
              (h * h) / (o * o) + (c * c) / (a * a) > 1 &&
              (h * h) / (l * l) + (c * c) / (u * u) <= 1
            );
          }
          getBounds() {
            return new p.M(
              this.x - this.halfWidth,
              this.y - this.halfHeight,
              2 * this.halfWidth,
              2 * this.halfHeight
            );
          }
          copyFrom(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.halfWidth = t.halfWidth),
              (this.halfHeight = t.halfHeight),
              this
            );
          }
          copyTo(t) {
            return t.copyFrom(this), t;
          }
          toString() {
            return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`;
          }
        }
        function g(t, e, i, n, s, r) {
          const o = s - i,
            a = r - n,
            l = o * o + a * a;
          let u,
            h,
            c = -1;
          0 !== l && (c = ((t - i) * o + (e - n) * a) / l),
            c < 0
              ? ((u = i), (h = n))
              : c > 1
              ? ((u = s), (h = r))
              : ((u = i + c * o), (h = n + c * a));
          const d = t - u,
            p = e - h;
          return d * d + p * p;
        }
        class v {
          constructor(...t) {
            this.type = "polygon";
            let e = Array.isArray(t[0]) ? t[0] : t;
            if ("number" != typeof e[0]) {
              const t = [];
              for (let i = 0, n = e.length; i < n; i++) t.push(e[i].x, e[i].y);
              e = t;
            }
            (this.points = e), (this.closePath = !0);
          }
          clone() {
            const t = this.points.slice(),
              e = new v(t);
            return (e.closePath = this.closePath), e;
          }
          contains(t, e) {
            let i = !1;
            const n = this.points.length / 2;
            for (let s = 0, r = n - 1; s < n; r = s++) {
              const n = this.points[2 * s],
                o = this.points[2 * s + 1],
                a = this.points[2 * r],
                l = this.points[2 * r + 1];
              o > e != l > e &&
                t < ((e - o) / (l - o)) * (a - n) + n &&
                (i = !i);
            }
            return i;
          }
          strokeContains(t, e, i) {
            const n = i / 2,
              s = n * n,
              { points: r } = this,
              o = r.length - (this.closePath ? 0 : 2);
            for (let i = 0; i < o; i += 2) {
              if (
                g(
                  t,
                  e,
                  r[i],
                  r[i + 1],
                  r[(i + 2) % r.length],
                  r[(i + 3) % r.length]
                ) <= s
              )
                return !0;
            }
            return !1;
          }
          getBounds(t) {
            t = t || new p.M();
            const e = this.points;
            let i = 1 / 0,
              n = -1 / 0,
              s = 1 / 0,
              r = -1 / 0;
            for (let t = 0, o = e.length; t < o; t += 2) {
              const o = e[t],
                a = e[t + 1];
              (i = o < i ? o : i),
                (n = o > n ? o : n),
                (s = a < s ? a : s),
                (r = a > r ? a : r);
            }
            return (
              (t.x = i), (t.width = n - i), (t.y = s), (t.height = r - s), t
            );
          }
          copyFrom(t) {
            return (
              (this.points = t.points.slice()),
              (this.closePath = t.closePath),
              this
            );
          }
          copyTo(t) {
            return t.copyFrom(this), t;
          }
          toString() {
            return `[pixi.js/math:PolygoncloseStroke=${
              this.closePath
            }points=${this.points.reduce((t, e) => `${t}, ${e}`, "")}]`;
          }
          get lastX() {
            return this.points[this.points.length - 2];
          }
          get lastY() {
            return this.points[this.points.length - 1];
          }
          get x() {
            return this.points[this.points.length - 2];
          }
          get y() {
            return this.points[this.points.length - 1];
          }
        }
        const y = (t, e, i, n, s, r) => {
          const o = t - i,
            a = e - n,
            l = Math.sqrt(o * o + a * a);
          return l >= s - r && l <= s + r;
        };
        class x {
          constructor(t = 0, e = 0, i = 0, n = 0, s = 20) {
            (this.type = "roundedRectangle"),
              (this.x = t),
              (this.y = e),
              (this.width = i),
              (this.height = n),
              (this.radius = s);
          }
          getBounds(t) {
            return (
              ((t = t || new p.M()).x = this.x),
              (t.y = this.y),
              (t.width = this.width),
              (t.height = this.height),
              t
            );
          }
          clone() {
            return new x(this.x, this.y, this.width, this.height, this.radius);
          }
          copyFrom(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.width = t.width),
              (this.height = t.height),
              this
            );
          }
          copyTo(t) {
            return t.copyFrom(this), t;
          }
          contains(t, e) {
            if (this.width <= 0 || this.height <= 0) return !1;
            if (
              t >= this.x &&
              t <= this.x + this.width &&
              e >= this.y &&
              e <= this.y + this.height
            ) {
              const i = Math.max(
                0,
                Math.min(this.radius, Math.min(this.width, this.height) / 2)
              );
              if (
                (e >= this.y + i && e <= this.y + this.height - i) ||
                (t >= this.x + i && t <= this.x + this.width - i)
              )
                return !0;
              let n = t - (this.x + i),
                s = e - (this.y + i);
              const r = i * i;
              if (n * n + s * s <= r) return !0;
              if (((n = t - (this.x + this.width - i)), n * n + s * s <= r))
                return !0;
              if (((s = e - (this.y + this.height - i)), n * n + s * s <= r))
                return !0;
              if (((n = t - (this.x + i)), n * n + s * s <= r)) return !0;
            }
            return !1;
          }
          strokeContains(t, e, i) {
            const { x: n, y: s, width: r, height: o, radius: a } = this,
              l = i / 2,
              u = n + a,
              h = s + a,
              c = n + r,
              d = s + o;
            return (
              (((t >= n - l && t <= n + l) || (t >= c - l && t <= c + l)) &&
                e >= h &&
                e <= h + (o - 2 * a)) ||
              (((e >= s - l && e <= s + l) || (e >= d - l && e <= d + l)) &&
                t >= u &&
                t <= u + (r - 2 * a)) ||
              (t < u && e < h && y(t, e, u, h, a, l)) ||
              (t > c - a && e < h && y(t, e, c - a, h, a, l)) ||
              (t > c - a && e > d - a && y(t, e, c - a, d - a, a, l)) ||
              (t < u && e > d - a && y(t, e, u, d - a, a, l))
            );
          }
          toString() {
            return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
          }
        }
        var b = i(3428);
        const S = 8,
          C = 1.1920929e-7,
          _ = 1,
          T = 0.01,
          w = 0,
          P = 0;
        function A(t, e, i, n, s, r, o, a, l, u) {
          const h = Math.min(
            0.99,
            Math.max(0, u ?? b.GH.defaultOptions.bezierSmoothness)
          );
          let c = (_ - h) / 1;
          return (
            (c *= c),
            (function (t, e, i, n, s, r, o, a, l, u) {
              k(t, e, i, n, s, r, o, a, l, u, 0), l.push(o, a);
            })(e, i, n, s, r, o, a, l, t, c),
            t
          );
        }
        function k(t, e, i, n, s, r, o, a, l, u, h) {
          if (h > S) return;
          const c = Math.PI,
            d = (t + i) / 2,
            p = (e + n) / 2,
            f = (i + s) / 2,
            m = (n + r) / 2,
            g = (s + o) / 2,
            v = (r + a) / 2,
            y = (d + f) / 2,
            x = (p + m) / 2,
            b = (f + g) / 2,
            _ = (m + v) / 2,
            A = (y + b) / 2,
            M = (x + _) / 2;
          if (h > 0) {
            let h = o - t,
              d = a - e;
            const p = Math.abs((i - o) * d - (n - a) * h),
              f = Math.abs((s - o) * d - (r - a) * h);
            let m, g;
            if (p > C && f > C) {
              if ((p + f) * (p + f) <= u * (h * h + d * d)) {
                if (w < T) return void l.push(A, M);
                const u = Math.atan2(r - n, s - i);
                if (
                  ((m = Math.abs(u - Math.atan2(n - e, i - t))),
                  (g = Math.abs(Math.atan2(a - r, o - s) - u)),
                  m >= c && (m = 2 * c - m),
                  g >= c && (g = 2 * c - g),
                  m + g < w)
                )
                  return void l.push(A, M);
                if (0 !== P) {
                  if (m > P) return void l.push(i, n);
                  if (g > P) return void l.push(s, r);
                }
              }
            } else if (p > C) {
              if (p * p <= u * (h * h + d * d)) {
                if (w < T) return void l.push(A, M);
                if (
                  ((m = Math.abs(
                    Math.atan2(r - n, s - i) - Math.atan2(n - e, i - t)
                  )),
                  m >= c && (m = 2 * c - m),
                  m < w)
                )
                  return l.push(i, n), void l.push(s, r);
                if (0 !== P && m > P) return void l.push(i, n);
              }
            } else if (f > C) {
              if (f * f <= u * (h * h + d * d)) {
                if (w < T) return void l.push(A, M);
                if (
                  ((m = Math.abs(
                    Math.atan2(a - r, o - s) - Math.atan2(r - n, s - i)
                  )),
                  m >= c && (m = 2 * c - m),
                  m < w)
                )
                  return l.push(i, n), void l.push(s, r);
                if (0 !== P && m > P) return void l.push(s, r);
              }
            } else if (
              ((h = A - (t + o) / 2), (d = M - (e + a) / 2), h * h + d * d <= u)
            )
              return void l.push(A, M);
          }
          k(t, e, d, p, y, x, A, M, l, u, h + 1),
            k(A, M, b, _, g, v, o, a, l, u, h + 1);
        }
        const M = 8,
          E = 1.1920929e-7,
          I = 0.01,
          D = 0;
        function R(t, e, i, n, s, r, o, a) {
          let l =
            (1 -
              Math.min(
                0.99,
                Math.max(0, a ?? b.GH.defaultOptions.bezierSmoothness)
              )) /
            1;
          return (
            (l *= l),
            (function (t, e, i, n, s, r, o, a) {
              B(o, t, e, i, n, s, r, a, 0), o.push(s, r);
            })(e, i, n, s, r, o, t, l),
            t
          );
        }
        function B(t, e, i, n, s, r, o, a, l) {
          if (l > M) return;
          const u = Math.PI,
            h = (e + n) / 2,
            c = (i + s) / 2,
            d = (n + r) / 2,
            p = (s + o) / 2,
            f = (h + d) / 2,
            m = (c + p) / 2;
          let g = r - e,
            v = o - i;
          const y = Math.abs((n - r) * v - (s - o) * g);
          if (y > E) {
            if (y * y <= a * (g * g + v * v)) {
              if (D < I) return void t.push(f, m);
              let a = Math.abs(
                Math.atan2(o - s, r - n) - Math.atan2(s - i, n - e)
              );
              if ((a >= u && (a = 2 * u - a), a < D)) return void t.push(f, m);
            }
          } else if (
            ((g = f - (e + r) / 2), (v = m - (i + o) / 2), g * g + v * v <= a)
          )
            return void t.push(f, m);
          B(t, e, i, h, c, f, m, a, l + 1), B(t, f, m, d, p, r, o, a, l + 1);
        }
        function F(t, e, i, n, s, r, o, a) {
          let l = Math.abs(s - r);
          ((!o && s > r) || (o && r > s)) && (l = 2 * Math.PI - l),
            (a =
              a ||
              Math.max(6, Math.floor(6 * Math.pow(n, 1 / 3) * (l / Math.PI))));
          let u = l / (a = Math.max(a, 3)),
            h = s;
          u *= o ? -1 : 1;
          for (let s = 0; s < a + 1; s++) {
            const s = e + Math.cos(h) * n,
              r = i + Math.sin(h) * n;
            t.push(s, r), (h += u);
          }
        }
        const O = 2 * Math.PI,
          z = { centerX: 0, centerY: 0, ang1: 0, ang2: 0 },
          L = ({ x: t, y: e }, i, n, s, r, o, a, l) => {
            const u = s * (t *= i) - r * (e *= n),
              h = r * t + s * e;
            return (l.x = u + o), (l.y = h + a), l;
          };
        function H(t, e) {
          const i =
              -1.5707963267948966 === e
                ? -0.551915024494
                : (4 / 3) * Math.tan(e / 4),
            n = 1.5707963267948966 === e ? 0.551915024494 : i,
            s = Math.cos(t),
            r = Math.sin(t),
            o = Math.cos(t + e),
            a = Math.sin(t + e);
          return [
            { x: s - r * n, y: r + s * n },
            { x: o + a * n, y: a - o * n },
            { x: o, y: a },
          ];
        }
        const U = (t, e, i, n) => {
          let s = t * i + e * n;
          return (
            s > 1 && (s = 1),
            s < -1 && (s = -1),
            (t * n - e * i < 0 ? -1 : 1) * Math.acos(s)
          );
        };
        function N(t, e, i, n, s, r, o, a = 0, l = 0, u = 0) {
          if (0 === r || 0 === o) return;
          const h = Math.sin((a * O) / 360),
            c = Math.cos((a * O) / 360),
            d = (c * (e - n)) / 2 + (h * (i - s)) / 2,
            p = (-h * (e - n)) / 2 + (c * (i - s)) / 2;
          if (0 === d && 0 === p) return;
          (r = Math.abs(r)), (o = Math.abs(o));
          const f =
            Math.pow(d, 2) / Math.pow(r, 2) + Math.pow(p, 2) / Math.pow(o, 2);
          f > 1 && ((r *= Math.sqrt(f)), (o *= Math.sqrt(f))),
            ((t, e, i, n, s, r, o, a, l, u, h, c, d) => {
              const p = Math.pow(s, 2),
                f = Math.pow(r, 2),
                m = Math.pow(h, 2),
                g = Math.pow(c, 2);
              let v = p * f - p * g - f * m;
              v < 0 && (v = 0),
                (v /= p * g + f * m),
                (v = Math.sqrt(v) * (o === a ? -1 : 1));
              const y = ((v * s) / r) * c,
                x = ((v * -r) / s) * h,
                b = u * y - l * x + (t + i) / 2,
                S = l * y + u * x + (e + n) / 2,
                C = (h - y) / s,
                _ = (c - x) / r,
                T = (-h - y) / s,
                w = (-c - x) / r,
                P = U(1, 0, C, _);
              let A = U(C, _, T, w);
              0 === a && A > 0 && (A -= O),
                1 === a && A < 0 && (A += O),
                (d.centerX = b),
                (d.centerY = S),
                (d.ang1 = P),
                (d.ang2 = A);
            })(e, i, n, s, r, o, l, u, h, c, d, p, z);
          let { ang1: m, ang2: g } = z;
          const { centerX: v, centerY: y } = z;
          let x = Math.abs(g) / (O / 4);
          Math.abs(1 - x) < 1e-7 && (x = 1);
          const b = Math.max(Math.ceil(x), 1);
          g /= b;
          let S = t[t.length - 2],
            C = t[t.length - 1];
          const _ = { x: 0, y: 0 };
          for (let e = 0; e < b; e++) {
            const e = H(m, g),
              { x: i, y: n } = L(e[0], r, o, c, h, v, y, _),
              { x: s, y: a } = L(e[1], r, o, c, h, v, y, _),
              { x: l, y: u } = L(e[2], r, o, c, h, v, y, _);
            A(t, S, C, i, n, s, a, l, u), (S = l), (C = u), (m += g);
          }
        }
        const G = new p.M();
        class V {
          constructor(t) {
            (this.shapePrimitives = []),
              (this._currentPoly = null),
              (this._bounds = new h.c()),
              (this._graphicsPath2D = t);
          }
          moveTo(t, e) {
            return this.startPoly(t, e), this;
          }
          lineTo(t, e) {
            this._ensurePoly();
            const i = this._currentPoly.points,
              n = i[i.length - 2],
              s = i[i.length - 1];
            return (n === t && s === e) || i.push(t, e), this;
          }
          arc(t, e, i, n, s, r) {
            this._ensurePoly(!1);
            return F(this._currentPoly.points, t, e, i, n, s, r), this;
          }
          arcTo(t, e, i, n, s) {
            this._ensurePoly();
            return (
              (function (t, e, i, n, s, r) {
                const o = t[t.length - 2],
                  a = t[t.length - 1] - i,
                  l = o - e,
                  u = s - i,
                  h = n - e,
                  c = Math.abs(a * h - l * u);
                if (c < 1e-8 || 0 === r)
                  return void (
                    (t[t.length - 2] === e && t[t.length - 1] === i) ||
                    t.push(e, i)
                  );
                const d = a * a + l * l,
                  p = u * u + h * h,
                  f = a * u + l * h,
                  m = (r * Math.sqrt(d)) / c,
                  g = (r * Math.sqrt(p)) / c,
                  v = (m * f) / d,
                  y = (g * f) / p,
                  x = m * h + g * l,
                  b = m * u + g * a,
                  S = l * (g + v),
                  C = a * (g + v),
                  _ = h * (m + y),
                  T = u * (m + y);
                F(
                  t,
                  x + e,
                  b + i,
                  r,
                  Math.atan2(C - b, S - x),
                  Math.atan2(T - b, _ - x),
                  l * u > h * a
                );
              })(this._currentPoly.points, t, e, i, n, s),
              this
            );
          }
          arcToSvg(t, e, i, n, s, r, o) {
            return (
              N(
                this._currentPoly.points,
                this._currentPoly.lastX,
                this._currentPoly.lastY,
                r,
                o,
                t,
                e,
                i,
                n,
                s
              ),
              this
            );
          }
          bezierCurveTo(t, e, i, n, s, r, o) {
            this._ensurePoly();
            const a = this._currentPoly;
            return (
              A(
                this._currentPoly.points,
                a.lastX,
                a.lastY,
                t,
                e,
                i,
                n,
                s,
                r,
                o
              ),
              this
            );
          }
          quadraticCurveTo(t, e, i, n, s) {
            this._ensurePoly();
            const r = this._currentPoly;
            return (
              R(this._currentPoly.points, r.lastX, r.lastY, t, e, i, n, s), this
            );
          }
          closePath() {
            return this.endPoly(!0), this;
          }
          addPath(t, e) {
            this.endPoly(),
              e && !e.isIdentity() && (t = t.clone(!0)).transform(e);
            for (let e = 0; e < t.instructions.length; e++) {
              const i = t.instructions[e];
              this[i.action](...i.data);
            }
            return this;
          }
          finish(t = !1) {
            this.endPoly(t);
          }
          rect(t, e, i, n, s) {
            return this.drawShape(new p.M(t, e, i, n), s), this;
          }
          circle(t, e, i, n) {
            return this.drawShape(new f(t, e, i), n), this;
          }
          poly(t, e, i) {
            const n = new v(t);
            return (n.closePath = e), this.drawShape(n, i), this;
          }
          regularPoly(t, e, i, n, s = 0, r) {
            n = Math.max(0 | n, 3);
            const o = (-1 * Math.PI) / 2 + s,
              a = (2 * Math.PI) / n,
              l = [];
            for (let s = 0; s < n; s++) {
              const n = s * a + o;
              l.push(t + i * Math.cos(n), e + i * Math.sin(n));
            }
            return this.poly(l, !0, r), this;
          }
          roundPoly(t, e, i, n, s, r = 0, o) {
            if (((n = Math.max(0 | n, 3)), s <= 0))
              return this.regularPoly(t, e, i, n, r);
            const a = i * Math.sin(Math.PI / n) - 0.001;
            s = Math.min(s, a);
            const l = (-1 * Math.PI) / 2 + r,
              u = (2 * Math.PI) / n,
              h = ((n - 2) * Math.PI) / n / 2;
            for (let r = 0; r < n; r++) {
              const n = r * u + l,
                a = t + i * Math.cos(n),
                c = e + i * Math.sin(n),
                d = n + Math.PI + h,
                p = n - Math.PI - h,
                f = a + s * Math.cos(d),
                m = c + s * Math.sin(d),
                g = a + s * Math.cos(p),
                v = c + s * Math.sin(p);
              0 === r ? this.moveTo(f, m) : this.lineTo(f, m),
                this.quadraticCurveTo(a, c, g, v, o);
            }
            return this.closePath();
          }
          roundShape(t, e, i = !1, n) {
            return t.length < 3
              ? this
              : (i
                  ? (function (t, e, i, n) {
                      const s = (t, e) =>
                          Math.sqrt((t.x - e.x) ** 2 + (t.y - e.y) ** 2),
                        r = (t, e, i) => ({
                          x: t.x + (e.x - t.x) * i,
                          y: t.y + (e.y - t.y) * i,
                        }),
                        o = e.length;
                      for (let a = 0; a < o; a++) {
                        const l = e[(a + 1) % o],
                          u = l.radius ?? i;
                        if (u <= 0) {
                          0 === a ? t.moveTo(l.x, l.y) : t.lineTo(l.x, l.y);
                          continue;
                        }
                        const h = e[a],
                          c = e[(a + 2) % o],
                          d = s(h, l);
                        let p;
                        p = d < 1e-4 ? l : r(l, h, Math.min(d / 2, u) / d);
                        const f = s(c, l);
                        let m;
                        (m = f < 1e-4 ? l : r(l, c, Math.min(f / 2, u) / f)),
                          0 === a ? t.moveTo(p.x, p.y) : t.lineTo(p.x, p.y),
                          t.quadraticCurveTo(l.x, l.y, m.x, m.y, n);
                      }
                    })(this, t, e, n)
                  : (function (t, e, i) {
                      const n = (t, e) => {
                          const i = e.x - t.x,
                            n = e.y - t.y,
                            s = Math.sqrt(i * i + n * n);
                          return { len: s, nx: i / s, ny: n / s };
                        },
                        s = (e, i) => {
                          0 === e ? t.moveTo(i.x, i.y) : t.lineTo(i.x, i.y);
                        };
                      let r = e[e.length - 1];
                      for (let o = 0; o < e.length; o++) {
                        const a = e[o % e.length],
                          l = a.radius ?? i;
                        if (l <= 0) {
                          s(o, a), (r = a);
                          continue;
                        }
                        const u = e[(o + 1) % e.length],
                          h = n(a, r),
                          c = n(a, u);
                        if (h.len < 1e-4 || c.len < 1e-4) {
                          s(o, a), (r = a);
                          continue;
                        }
                        let d = Math.asin(h.nx * c.ny - h.ny * c.nx),
                          p = 1,
                          f = !1;
                        h.nx * c.nx - h.ny * -c.ny < 0
                          ? d < 0
                            ? (d = Math.PI + d)
                            : ((d = Math.PI - d), (p = -1), (f = !0))
                          : d > 0 && ((p = -1), (f = !0));
                        const m = d / 2;
                        let g,
                          v = Math.abs((Math.cos(m) * l) / Math.sin(m));
                        v > Math.min(h.len / 2, c.len / 2)
                          ? ((v = Math.min(h.len / 2, c.len / 2)),
                            (g = Math.abs((v * Math.sin(m)) / Math.cos(m))))
                          : (g = l);
                        const y = a.x + c.nx * v + -c.ny * g * p,
                          x = a.y + c.ny * v + c.nx * g * p,
                          b = Math.atan2(h.ny, h.nx) + (Math.PI / 2) * p,
                          S = Math.atan2(c.ny, c.nx) - (Math.PI / 2) * p;
                        0 === o &&
                          t.moveTo(y + Math.cos(b) * g, x + Math.sin(b) * g),
                          t.arc(y, x, g, b, S, f),
                          (r = a);
                      }
                    })(this, t, e),
                this.closePath());
          }
          filletRect(t, e, i, n, s) {
            if (0 === s) return this.rect(t, e, i, n);
            const r = Math.min(i, n) / 2,
              o = Math.min(r, Math.max(-r, s)),
              a = t + i,
              l = e + n,
              u = o < 0 ? -o : 0,
              h = Math.abs(o);
            return this.moveTo(t, e + h)
              .arcTo(t + u, e + u, t + h, e, h)
              .lineTo(a - h, e)
              .arcTo(a - u, e + u, a, e + h, h)
              .lineTo(a, l - h)
              .arcTo(a - u, l - u, t + i - h, l, h)
              .lineTo(t + h, l)
              .arcTo(t + u, l - u, t, l - h, h)
              .closePath();
          }
          chamferRect(t, e, i, n, s, r) {
            if (s <= 0) return this.rect(t, e, i, n);
            const o = Math.min(s, Math.min(i, n) / 2),
              a = t + i,
              l = e + n,
              u = [
                t + o,
                e,
                a - o,
                e,
                a,
                e + o,
                a,
                l - o,
                a - o,
                l,
                t + o,
                l,
                t,
                l - o,
                t,
                e + o,
              ];
            for (let t = u.length - 1; t >= 2; t -= 2)
              u[t] === u[t - 2] && u[t - 1] === u[t - 3] && u.splice(t - 1, 2);
            return this.poly(u, !0, r);
          }
          ellipse(t, e, i, n, s) {
            return this.drawShape(new m(t, e, i, n), s), this;
          }
          roundRect(t, e, i, n, s, r) {
            return this.drawShape(new x(t, e, i, n, s), r), this;
          }
          drawShape(t, e) {
            return (
              this.endPoly(),
              this.shapePrimitives.push({ shape: t, transform: e }),
              this
            );
          }
          startPoly(t, e) {
            let i = this._currentPoly;
            return (
              i && this.endPoly(),
              (i = new v()),
              i.points.push(t, e),
              (this._currentPoly = i),
              this
            );
          }
          endPoly(t = !1) {
            const e = this._currentPoly;
            return (
              e &&
                e.points.length > 2 &&
                ((e.closePath = t), this.shapePrimitives.push({ shape: e })),
              (this._currentPoly = null),
              this
            );
          }
          _ensurePoly(t = !0) {
            if (!this._currentPoly && ((this._currentPoly = new v()), t)) {
              const t = this.shapePrimitives[this.shapePrimitives.length - 1];
              if (t) {
                let e = t.shape.x,
                  i = t.shape.y;
                if (!t.transform.isIdentity()) {
                  const n = t.transform,
                    s = e;
                  (e = n.a * e + n.c * i + n.tx),
                    (i = n.b * s + n.d * i + n.ty);
                }
                this._currentPoly.points.push(e, i);
              } else this._currentPoly.points.push(0, 0);
            }
          }
          buildPath() {
            const t = this._graphicsPath2D;
            (this.shapePrimitives.length = 0), (this._currentPoly = null);
            for (let e = 0; e < t.instructions.length; e++) {
              const i = t.instructions[e];
              this[i.action](...i.data);
            }
            this.finish();
          }
          get bounds() {
            const t = this._bounds;
            t.clear();
            const e = this.shapePrimitives;
            for (let i = 0; i < e.length; i++) {
              const n = e[i],
                s = n.shape.getBounds(G);
              n.transform ? t.addRect(s, n.transform) : t.addRect(s);
            }
            return t;
          }
        }
        class j {
          constructor(t) {
            (this.instructions = []),
              (this.uid = (0, l.L)("graphicsPath")),
              (this._dirty = !0),
              "string" == typeof t
                ? (function (t, e) {
                    const i = d(t),
                      n = [];
                    let s = null,
                      r = 0,
                      o = 0;
                    for (let t = 0; t < i.length; t++) {
                      const a = i[t],
                        l = a[0],
                        u = a;
                      switch (l) {
                        case "M":
                          (r = u[1]), (o = u[2]), e.moveTo(r, o);
                          break;
                        case "m":
                          (r += u[1]), (o += u[2]), e.moveTo(r, o);
                          break;
                        case "H":
                          (r = u[1]), e.lineTo(r, o);
                          break;
                        case "h":
                          (r += u[1]), e.lineTo(r, o);
                          break;
                        case "V":
                          (o = u[1]), e.lineTo(r, o);
                          break;
                        case "v":
                          (o += u[1]), e.lineTo(r, o);
                          break;
                        case "L":
                          (r = u[1]), (o = u[2]), e.lineTo(r, o);
                          break;
                        case "l":
                          (r += u[1]), (o += u[2]), e.lineTo(r, o);
                          break;
                        case "C":
                          (r = u[5]),
                            (o = u[6]),
                            e.bezierCurveTo(u[1], u[2], u[3], u[4], r, o);
                          break;
                        case "c":
                          e.bezierCurveTo(
                            r + u[1],
                            o + u[2],
                            r + u[3],
                            o + u[4],
                            r + u[5],
                            o + u[6]
                          ),
                            (r += u[5]),
                            (o += u[6]);
                          break;
                        case "S":
                          (r = u[3]),
                            (o = u[4]),
                            e.bezierCurveToShort(u[1], u[2], r, o);
                          break;
                        case "s":
                          e.bezierCurveToShort(
                            r + u[1],
                            o + u[2],
                            r + u[3],
                            o + u[4]
                          ),
                            (r += u[3]),
                            (o += u[4]);
                          break;
                        case "Q":
                          (r = u[3]),
                            (o = u[4]),
                            e.quadraticCurveTo(u[1], u[2], r, o);
                          break;
                        case "q":
                          e.quadraticCurveTo(
                            r + u[1],
                            o + u[2],
                            r + u[3],
                            o + u[4]
                          ),
                            (r += u[3]),
                            (o += u[4]);
                          break;
                        case "T":
                          (r = u[1]), (o = u[2]), e.quadraticCurveToShort(r, o);
                          break;
                        case "t":
                          (r += u[1]),
                            (o += u[2]),
                            e.quadraticCurveToShort(r, o);
                          break;
                        case "A":
                          (r = u[6]),
                            (o = u[7]),
                            e.arcToSvg(u[1], u[2], u[3], u[4], u[5], r, o);
                          break;
                        case "a":
                          (r += u[6]),
                            (o += u[7]),
                            e.arcToSvg(u[1], u[2], u[3], u[4], u[5], r, o);
                          break;
                        case "Z":
                        case "z":
                          e.closePath(),
                            n.length > 0 &&
                              ((s = n.pop()),
                              s
                                ? ((r = s.startX), (o = s.startY))
                                : ((r = 0), (o = 0))),
                            (s = null);
                          break;
                        default:
                          (0, c.R)(`Unknown SVG path command: ${l}`);
                      }
                      "Z" !== l &&
                        "z" !== l &&
                        null === s &&
                        ((s = { startX: r, startY: o }), n.push(s));
                    }
                  })(t, this)
                : (this.instructions = t?.slice() ?? []);
          }
          get shapePath() {
            return (
              this._shapePath || (this._shapePath = new V(this)),
              this._dirty && ((this._dirty = !1), this._shapePath.buildPath()),
              this._shapePath
            );
          }
          addPath(t, e) {
            return (
              (t = t.clone()),
              this.instructions.push({ action: "addPath", data: [t, e] }),
              (this._dirty = !0),
              this
            );
          }
          arc(...t) {
            return (
              this.instructions.push({ action: "arc", data: t }),
              (this._dirty = !0),
              this
            );
          }
          arcTo(...t) {
            return (
              this.instructions.push({ action: "arcTo", data: t }),
              (this._dirty = !0),
              this
            );
          }
          arcToSvg(...t) {
            return (
              this.instructions.push({ action: "arcToSvg", data: t }),
              (this._dirty = !0),
              this
            );
          }
          bezierCurveTo(...t) {
            return (
              this.instructions.push({ action: "bezierCurveTo", data: t }),
              (this._dirty = !0),
              this
            );
          }
          bezierCurveToShort(t, e, i, n, s) {
            const r = this.instructions[this.instructions.length - 1],
              a = this.getLastPoint(o.b.shared);
            let l = 0,
              u = 0;
            if (r && "bezierCurveTo" === r.action) {
              (l = r.data[2]), (u = r.data[3]);
              const t = a.x,
                e = a.y;
              (l = t + (t - l)), (u = e + (e - u));
            } else (l = a.x), (u = a.y);
            return (
              this.instructions.push({
                action: "bezierCurveTo",
                data: [l, u, t, e, i, n, s],
              }),
              (this._dirty = !0),
              this
            );
          }
          closePath() {
            return (
              this.instructions.push({ action: "closePath", data: [] }),
              (this._dirty = !0),
              this
            );
          }
          ellipse(...t) {
            return (
              this.instructions.push({ action: "ellipse", data: t }),
              (this._dirty = !0),
              this
            );
          }
          lineTo(...t) {
            return (
              this.instructions.push({ action: "lineTo", data: t }),
              (this._dirty = !0),
              this
            );
          }
          moveTo(...t) {
            return this.instructions.push({ action: "moveTo", data: t }), this;
          }
          quadraticCurveTo(...t) {
            return (
              this.instructions.push({ action: "quadraticCurveTo", data: t }),
              (this._dirty = !0),
              this
            );
          }
          quadraticCurveToShort(t, e, i) {
            const n = this.instructions[this.instructions.length - 1],
              s = this.getLastPoint(o.b.shared);
            let r = 0,
              a = 0;
            if (n && "quadraticCurveTo" === n.action) {
              (r = n.data[0]), (a = n.data[1]);
              const t = s.x,
                e = s.y;
              (r = t + (t - r)), (a = e + (e - a));
            } else (r = s.x), (a = s.y);
            return (
              this.instructions.push({
                action: "quadraticCurveTo",
                data: [r, a, t, e, i],
              }),
              (this._dirty = !0),
              this
            );
          }
          rect(t, e, i, n, s) {
            return (
              this.instructions.push({ action: "rect", data: [t, e, i, n, s] }),
              (this._dirty = !0),
              this
            );
          }
          circle(t, e, i, n) {
            return (
              this.instructions.push({ action: "circle", data: [t, e, i, n] }),
              (this._dirty = !0),
              this
            );
          }
          roundRect(...t) {
            return (
              this.instructions.push({ action: "roundRect", data: t }),
              (this._dirty = !0),
              this
            );
          }
          poly(...t) {
            return (
              this.instructions.push({ action: "poly", data: t }),
              (this._dirty = !0),
              this
            );
          }
          regularPoly(...t) {
            return (
              this.instructions.push({ action: "regularPoly", data: t }),
              (this._dirty = !0),
              this
            );
          }
          roundPoly(...t) {
            return (
              this.instructions.push({ action: "roundPoly", data: t }),
              (this._dirty = !0),
              this
            );
          }
          roundShape(...t) {
            return (
              this.instructions.push({ action: "roundShape", data: t }),
              (this._dirty = !0),
              this
            );
          }
          filletRect(...t) {
            return (
              this.instructions.push({ action: "filletRect", data: t }),
              (this._dirty = !0),
              this
            );
          }
          chamferRect(...t) {
            return (
              this.instructions.push({ action: "chamferRect", data: t }),
              (this._dirty = !0),
              this
            );
          }
          star(t, e, i, n, s, r, o) {
            s = s || n / 2;
            const a = (-1 * Math.PI) / 2 + r,
              l = 2 * i,
              u = (2 * Math.PI) / l,
              h = [];
            for (let i = 0; i < l; i++) {
              const r = i % 2 ? s : n,
                o = i * u + a;
              h.push(t + r * Math.cos(o), e + r * Math.sin(o));
            }
            return this.poly(h, !0, o), this;
          }
          clone(t = !1) {
            const e = new j();
            if (t)
              for (let t = 0; t < this.instructions.length; t++) {
                const i = this.instructions[t];
                e.instructions.push({ action: i.action, data: i.data.slice() });
              }
            else e.instructions = this.instructions.slice();
            return e;
          }
          clear() {
            return (this.instructions.length = 0), (this._dirty = !0), this;
          }
          transform(t) {
            if (t.isIdentity()) return this;
            const e = t.a,
              i = t.b,
              n = t.c,
              s = t.d,
              r = t.tx,
              o = t.ty;
            let a = 0,
              l = 0,
              u = 0,
              h = 0,
              d = 0,
              p = 0,
              f = 0,
              m = 0;
            for (let g = 0; g < this.instructions.length; g++) {
              const v = this.instructions[g],
                y = v.data;
              switch (v.action) {
                case "moveTo":
                case "lineTo":
                  (a = y[0]),
                    (l = y[1]),
                    (y[0] = e * a + n * l + r),
                    (y[1] = i * a + s * l + o);
                  break;
                case "bezierCurveTo":
                  (u = y[0]),
                    (h = y[1]),
                    (d = y[2]),
                    (p = y[3]),
                    (a = y[4]),
                    (l = y[5]),
                    (y[0] = e * u + n * h + r),
                    (y[1] = i * u + s * h + o),
                    (y[2] = e * d + n * p + r),
                    (y[3] = i * d + s * p + o),
                    (y[4] = e * a + n * l + r),
                    (y[5] = i * a + s * l + o);
                  break;
                case "quadraticCurveTo":
                  (u = y[0]),
                    (h = y[1]),
                    (a = y[2]),
                    (l = y[3]),
                    (y[0] = e * u + n * h + r),
                    (y[1] = i * u + s * h + o),
                    (y[2] = e * a + n * l + r),
                    (y[3] = i * a + s * l + o);
                  break;
                case "arcToSvg":
                  (a = y[5]),
                    (l = y[6]),
                    (f = y[0]),
                    (m = y[1]),
                    (y[0] = e * f + n * m),
                    (y[1] = i * f + s * m),
                    (y[5] = e * a + n * l + r),
                    (y[6] = i * a + s * l + o);
                  break;
                case "circle":
                  y[4] = $(y[3], t);
                  break;
                case "rect":
                  y[4] = $(y[4], t);
                  break;
                case "ellipse":
                  y[8] = $(y[8], t);
                  break;
                case "roundRect":
                  y[5] = $(y[5], t);
                  break;
                case "addPath":
                  y[0].transform(t);
                  break;
                case "poly":
                  y[2] = $(y[2], t);
                  break;
                default:
                  (0, c.R)("unknown transform action", v.action);
              }
            }
            return (this._dirty = !0), this;
          }
          get bounds() {
            return this.shapePath.bounds;
          }
          getLastPoint(t) {
            let e = this.instructions.length - 1,
              i = this.instructions[e];
            if (!i) return (t.x = 0), (t.y = 0), t;
            for (; "closePath" === i.action; ) {
              if ((e--, e < 0)) return (t.x = 0), (t.y = 0), t;
              i = this.instructions[e];
            }
            switch (i.action) {
              case "moveTo":
              case "lineTo":
                (t.x = i.data[0]), (t.y = i.data[1]);
                break;
              case "quadraticCurveTo":
                (t.x = i.data[2]), (t.y = i.data[3]);
                break;
              case "bezierCurveTo":
                (t.x = i.data[4]), (t.y = i.data[5]);
                break;
              case "arc":
              case "arcToSvg":
                (t.x = i.data[5]), (t.y = i.data[6]);
                break;
              case "addPath":
                i.data[0].getLastPoint(t);
            }
            return t;
          }
        }
        function $(t, e) {
          return t ? t.prepend(e) : e.clone();
        }
        function q(t, e) {
          if ("string" == typeof t) {
            const e = document.createElement("div");
            (e.innerHTML = t.trim()), (t = e.querySelector("svg"));
          }
          return W(t, { context: e, path: new j() }, null, null), e;
        }
        function W(t, e, i, n) {
          const r = t.children,
            { fillStyle: o, strokeStyle: a } = (function (t) {
              const e = t.getAttribute("style"),
                i = {},
                n = {};
              let r = !1,
                o = !1;
              if (e) {
                const t = e.split(";");
                for (let e = 0; e < t.length; e++) {
                  const a = t[e],
                    [l, u] = a.split(":");
                  switch (l) {
                    case "stroke":
                      "none" !== u &&
                        ((i.color = s.Q.shared.setValue(u).toNumber()),
                        (o = !0));
                      break;
                    case "stroke-width":
                      i.width = Number(u);
                      break;
                    case "fill":
                      "none" !== u &&
                        ((r = !0),
                        (n.color = s.Q.shared.setValue(u).toNumber()));
                      break;
                    case "fill-opacity":
                      n.alpha = Number(u);
                      break;
                    case "stroke-opacity":
                      i.alpha = Number(u);
                      break;
                    case "opacity":
                      (n.alpha = Number(u)), (i.alpha = Number(u));
                  }
                }
              } else {
                const e = t.getAttribute("stroke");
                e &&
                  "none" !== e &&
                  ((o = !0),
                  (i.color = s.Q.shared.setValue(e).toNumber()),
                  (i.width = X(t, "stroke-width", 1)));
                const a = t.getAttribute("fill");
                a &&
                  "none" !== a &&
                  ((r = !0), (n.color = s.Q.shared.setValue(a).toNumber()));
              }
              return { strokeStyle: o ? i : null, fillStyle: r ? n : null };
            })(t);
          let l, u, h, c, d, p, f, m, g, v, y, x, b, S, C, _, T;
          switch (
            (o && i ? (i = { ...i, ...o }) : o && (i = o),
            a && n ? (n = { ...n, ...a }) : a && (n = a),
            (e.context.fillStyle = i),
            (e.context.strokeStyle = n),
            t.nodeName.toLowerCase())
          ) {
            case "path":
              (S = t.getAttribute("d")),
                (C = new j(S)),
                e.context.path(C),
                i && e.context.fill(),
                n && e.context.stroke();
              break;
            case "circle":
              (f = X(t, "cx", 0)),
                (m = X(t, "cy", 0)),
                (g = X(t, "r", 0)),
                e.context.ellipse(f, m, g, g),
                i && e.context.fill(),
                n && e.context.stroke();
              break;
            case "rect":
              (l = X(t, "x", 0)),
                (u = X(t, "y", 0)),
                (_ = X(t, "width", 0)),
                (T = X(t, "height", 0)),
                (v = X(t, "rx", 0)),
                (y = X(t, "ry", 0)),
                v || y
                  ? e.context.roundRect(l, u, _, T, v || y)
                  : e.context.rect(l, u, _, T),
                i && e.context.fill(),
                n && e.context.stroke();
              break;
            case "ellipse":
              (f = X(t, "cx", 0)),
                (m = X(t, "cy", 0)),
                (v = X(t, "rx", 0)),
                (y = X(t, "ry", 0)),
                e.context.beginPath(),
                e.context.ellipse(f, m, v, y),
                i && e.context.fill(),
                n && e.context.stroke();
              break;
            case "line":
              (h = X(t, "x1", 0)),
                (c = X(t, "y1", 0)),
                (d = X(t, "x2", 0)),
                (p = X(t, "y2", 0)),
                e.context.beginPath(),
                e.context.moveTo(h, c),
                e.context.lineTo(d, p),
                n && e.context.stroke();
              break;
            case "polygon":
              (b = t.getAttribute("points")),
                (x = b.match(/\d+/g).map((t) => parseInt(t, 10))),
                e.context.poly(x, !0),
                i && e.context.fill(),
                n && e.context.stroke();
              break;
            case "polyline":
              (b = t.getAttribute("points")),
                (x = b.match(/\d+/g).map((t) => parseInt(t, 10))),
                e.context.poly(x, !1),
                n && e.context.stroke();
              break;
            case "g":
            case "svg":
              break;
            default:
              console.info(`[SVG parser] <${t.nodeName}> elements unsupported`);
          }
          for (let t = 0; t < r.length; t++) W(r[t], e, i, n);
        }
        function X(t, e, i) {
          const n = t.getAttribute(e);
          return n ? Number(n) : i;
        }
        var Y = i(990);
        const K = new o.b(),
          Z = new r.u(),
          Q = class t extends n.A {
            constructor() {
              super(...arguments),
                (this.uid = (0, l.L)("graphicsContext")),
                (this.dirty = !0),
                (this.batchMode = "auto"),
                (this.instructions = []),
                (this._activePath = new j()),
                (this._transform = new r.u()),
                (this._fillStyle = { ...t.defaultFillStyle }),
                (this._strokeStyle = { ...t.defaultStrokeStyle }),
                (this._stateStack = []),
                (this._tick = 0),
                (this._bounds = new h.c()),
                (this._boundsDirty = !0);
            }
            clone() {
              const e = new t();
              return (
                (e.batchMode = this.batchMode),
                (e.instructions = this.instructions.slice()),
                (e._activePath = this._activePath.clone()),
                (e._transform = this._transform.clone()),
                (e._fillStyle = { ...this._fillStyle }),
                (e._strokeStyle = { ...this._strokeStyle }),
                (e._stateStack = this._stateStack.slice()),
                (e._bounds = this._bounds.clone()),
                (e._boundsDirty = !0),
                e
              );
            }
            get fillStyle() {
              return this._fillStyle;
            }
            set fillStyle(e) {
              this._fillStyle = (0, Y.M)(e, t.defaultFillStyle);
            }
            get strokeStyle() {
              return this._strokeStyle;
            }
            set strokeStyle(e) {
              this._strokeStyle = (0, Y.M)(e, t.defaultStrokeStyle);
            }
            setFillStyle(e) {
              return (this._fillStyle = (0, Y.M)(e, t.defaultFillStyle)), this;
            }
            setStrokeStyle(e) {
              return (
                (this._strokeStyle = (0, Y.M)(e, t.defaultStrokeStyle)), this
              );
            }
            texture(t, e, i, n, r, o) {
              return (
                this.instructions.push({
                  action: "texture",
                  data: {
                    image: t,
                    dx: i || 0,
                    dy: n || 0,
                    dw: r || t.frame.width,
                    dh: o || t.frame.height,
                    transform: this._transform.clone(),
                    alpha: this._fillStyle.alpha,
                    style: e ? s.Q.shared.setValue(e).toNumber() : 16777215,
                  },
                }),
                this.onUpdate(),
                this
              );
            }
            beginPath() {
              return (this._activePath = new j()), this;
            }
            fill(e, i) {
              let n;
              const s = this.instructions[this.instructions.length - 1];
              return (
                (n =
                  0 === this._tick && s && "stroke" === s.action
                    ? s.data.path
                    : this._activePath.clone()),
                n
                  ? (null != e &&
                      (void 0 !== i &&
                        "number" == typeof e &&
                        ((0, u.t)(
                          u.l,
                          "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"
                        ),
                        (e = { color: e, alpha: i })),
                      (this._fillStyle = (0, Y.M)(e, t.defaultFillStyle))),
                    this.instructions.push({
                      action: "fill",
                      data: { style: this.fillStyle, path: n },
                    }),
                    this.onUpdate(),
                    this._initNextPathLocation(),
                    (this._tick = 0),
                    this)
                  : this
              );
            }
            _initNextPathLocation() {
              const { x: t, y: e } = this._activePath.getLastPoint(o.b.shared);
              this._activePath.clear(), this._activePath.moveTo(t, e);
            }
            stroke(e) {
              let i;
              const n = this.instructions[this.instructions.length - 1];
              return (
                (i =
                  0 === this._tick && n && "fill" === n.action
                    ? n.data.path
                    : this._activePath.clone()),
                i
                  ? (null != e &&
                      (this._strokeStyle = (0, Y.M)(e, t.defaultStrokeStyle)),
                    this.instructions.push({
                      action: "stroke",
                      data: { style: this.strokeStyle, path: i },
                    }),
                    this.onUpdate(),
                    this._initNextPathLocation(),
                    (this._tick = 0),
                    this)
                  : this
              );
            }
            cut() {
              for (let t = 0; t < 2; t++) {
                const e = this.instructions[this.instructions.length - 1 - t],
                  i = this._activePath.clone();
                if (e && ("stroke" === e.action || "fill" === e.action)) {
                  if (!e.data.hole) {
                    e.data.hole = i;
                    break;
                  }
                  e.data.hole.addPath(i);
                }
              }
              return this._initNextPathLocation(), this;
            }
            arc(t, e, i, n, s, r) {
              this._tick++;
              const o = this._transform;
              return (
                this._activePath.arc(
                  o.a * t + o.c * e + o.tx,
                  o.b * t + o.d * e + o.ty,
                  i,
                  n,
                  s,
                  r
                ),
                this
              );
            }
            arcTo(t, e, i, n, s) {
              this._tick++;
              const r = this._transform;
              return (
                this._activePath.arcTo(
                  r.a * t + r.c * e + r.tx,
                  r.b * t + r.d * e + r.ty,
                  r.a * i + r.c * n + r.tx,
                  r.b * i + r.d * n + r.ty,
                  s
                ),
                this
              );
            }
            arcToSvg(t, e, i, n, s, r, o) {
              this._tick++;
              const a = this._transform;
              return (
                this._activePath.arcToSvg(
                  t,
                  e,
                  i,
                  n,
                  s,
                  a.a * r + a.c * o + a.tx,
                  a.b * r + a.d * o + a.ty
                ),
                this
              );
            }
            bezierCurveTo(t, e, i, n, s, r, o) {
              this._tick++;
              const a = this._transform;
              return (
                this._activePath.bezierCurveTo(
                  a.a * t + a.c * e + a.tx,
                  a.b * t + a.d * e + a.ty,
                  a.a * i + a.c * n + a.tx,
                  a.b * i + a.d * n + a.ty,
                  a.a * s + a.c * r + a.tx,
                  a.b * s + a.d * r + a.ty,
                  o
                ),
                this
              );
            }
            closePath() {
              return this._tick++, this._activePath?.closePath(), this;
            }
            ellipse(t, e, i, n) {
              return (
                this._tick++,
                this._activePath.ellipse(t, e, i, n, this._transform.clone()),
                this
              );
            }
            circle(t, e, i) {
              return (
                this._tick++,
                this._activePath.circle(t, e, i, this._transform.clone()),
                this
              );
            }
            path(t) {
              return (
                this._tick++,
                this._activePath.addPath(t, this._transform.clone()),
                this
              );
            }
            lineTo(t, e) {
              this._tick++;
              const i = this._transform;
              return (
                this._activePath.lineTo(
                  i.a * t + i.c * e + i.tx,
                  i.b * t + i.d * e + i.ty
                ),
                this
              );
            }
            moveTo(t, e) {
              this._tick++;
              const i = this._transform,
                n = this._activePath.instructions,
                s = i.a * t + i.c * e + i.tx,
                r = i.b * t + i.d * e + i.ty;
              return 1 === n.length && "moveTo" === n[0].action
                ? ((n[0].data[0] = s), (n[0].data[1] = r), this)
                : (this._activePath.moveTo(s, r), this);
            }
            quadraticCurveTo(t, e, i, n, s) {
              this._tick++;
              const r = this._transform;
              return (
                this._activePath.quadraticCurveTo(
                  r.a * t + r.c * e + r.tx,
                  r.b * t + r.d * e + r.ty,
                  r.a * i + r.c * n + r.tx,
                  r.b * i + r.d * n + r.ty,
                  s
                ),
                this
              );
            }
            rect(t, e, i, n) {
              return (
                this._tick++,
                this._activePath.rect(t, e, i, n, this._transform.clone()),
                this
              );
            }
            roundRect(t, e, i, n, s) {
              return (
                this._tick++,
                this._activePath.roundRect(
                  t,
                  e,
                  i,
                  n,
                  s,
                  this._transform.clone()
                ),
                this
              );
            }
            poly(t, e) {
              return (
                this._tick++,
                this._activePath.poly(t, e, this._transform.clone()),
                this
              );
            }
            regularPoly(t, e, i, n, s = 0, r) {
              return (
                this._tick++,
                this._activePath.regularPoly(t, e, i, n, s, r),
                this
              );
            }
            roundPoly(t, e, i, n, s, r) {
              return (
                this._tick++, this._activePath.roundPoly(t, e, i, n, s, r), this
              );
            }
            roundShape(t, e, i, n) {
              return (
                this._tick++, this._activePath.roundShape(t, e, i, n), this
              );
            }
            filletRect(t, e, i, n, s) {
              return (
                this._tick++, this._activePath.filletRect(t, e, i, n, s), this
              );
            }
            chamferRect(t, e, i, n, s, r) {
              return (
                this._tick++,
                this._activePath.chamferRect(t, e, i, n, s, r),
                this
              );
            }
            star(t, e, i, n, s = 0, r = 0) {
              return (
                this._tick++,
                this._activePath.star(
                  t,
                  e,
                  i,
                  n,
                  s,
                  r,
                  this._transform.clone()
                ),
                this
              );
            }
            svg(t) {
              return this._tick++, q(t, this), this;
            }
            restore() {
              const t = this._stateStack.pop();
              return (
                t &&
                  ((this._transform = t.transform),
                  (this._fillStyle = t.fillStyle),
                  (this._strokeStyle = t.strokeStyle)),
                this
              );
            }
            save() {
              return (
                this._stateStack.push({
                  transform: this._transform.clone(),
                  fillStyle: { ...this._fillStyle },
                  strokeStyle: { ...this._strokeStyle },
                }),
                this
              );
            }
            getTransform() {
              return this._transform;
            }
            resetTransform() {
              return this._transform.identity(), this;
            }
            rotate(t) {
              return this._transform.rotate(t), this;
            }
            scale(t, e = t) {
              return this._transform.scale(t, e), this;
            }
            setTransform(t, e, i, n, s, o) {
              return t instanceof r.u
                ? (this._transform.set(t.a, t.b, t.c, t.d, t.tx, t.ty), this)
                : (this._transform.set(t, e, i, n, s, o), this);
            }
            transform(t, e, i, n, s, o) {
              return t instanceof r.u
                ? (this._transform.append(t), this)
                : (Z.set(t, e, i, n, s, o), this._transform.append(Z), this);
            }
            translate(t, e = t) {
              return this._transform.translate(t, e), this;
            }
            clear() {
              return (
                (this.instructions.length = 0),
                this.resetTransform(),
                this.onUpdate(),
                this
              );
            }
            onUpdate() {
              this.dirty ||
                (this.emit("update", this, 16),
                (this.dirty = !0),
                (this._boundsDirty = !0));
            }
            get bounds() {
              if (!this._boundsDirty) return this._bounds;
              const t = this._bounds;
              t.clear();
              for (let e = 0; e < this.instructions.length; e++) {
                const i = this.instructions[e],
                  n = i.action;
                if ("fill" === n) {
                  const e = i.data;
                  t.addBounds(e.path.bounds);
                } else if ("texture" === n) {
                  const e = i.data;
                  t.addFrame(e.dx, e.dy, e.dx + e.dw, e.dy + e.dh, e.transform);
                }
                if ("stroke" === n) {
                  const e = i.data,
                    n = e.style.width / 2,
                    s = e.path.bounds;
                  t.addFrame(s.minX - n, s.minY - n, s.maxX + n, s.maxY + n);
                }
              }
              return t;
            }
            containsPoint(t) {
              if (!this.bounds.containsPoint(t.x, t.y)) return !1;
              const e = this.instructions;
              let i = !1;
              for (let n = 0; n < e.length; n++) {
                const s = e[n],
                  r = s.data,
                  o = r.path;
                if (!s.action || !o) continue;
                const a = r.style,
                  l = o.shapePath.shapePrimitives;
                for (let e = 0; e < l.length; e++) {
                  const n = l[e].shape;
                  if (!a || !n) continue;
                  const o = l[e].transform,
                    u = o ? o.applyInverse(t, K) : t;
                  i =
                    "fill" === s.action
                      ? n.contains(u.x, u.y)
                      : n.strokeContains(u.x, u.y, a.width);
                  const h = r.hole;
                  if (h) {
                    const t = h.shapePath?.shapePrimitives;
                    if (t)
                      for (let e = 0; e < t.length; e++)
                        t[e].shape.contains(u.x, u.y) && (i = !1);
                  }
                  if (i) return !0;
                }
              }
              return i;
            }
            destroy(t = !1) {
              (this._stateStack.length = 0),
                (this._transform = null),
                this.emit("destroy", this),
                this.removeAllListeners();
              if ("boolean" == typeof t ? t : t?.texture) {
                const e = "boolean" == typeof t ? t : t?.textureSource;
                this._fillStyle.texture && this._fillStyle.texture.destroy(e),
                  this._strokeStyle.texture &&
                    this._strokeStyle.texture.destroy(e);
              }
              (this._fillStyle = null),
                (this._strokeStyle = null),
                (this.instructions = null),
                (this._activePath = null),
                (this._bounds = null),
                (this._stateStack = null),
                (this.customShader = null),
                (this._transform = null);
            }
          };
        (Q.defaultFillStyle = {
          color: 16777215,
          alpha: 1,
          texture: a.g.WHITE,
          matrix: null,
          fill: null,
        }),
          (Q.defaultStrokeStyle = {
            width: 1,
            color: 16777215,
            alpha: 1,
            alignment: 0.5,
            miterLimit: 10,
            cap: "butt",
            join: "miter",
            texture: a.g.WHITE,
            matrix: null,
            fill: null,
          });
        let J = Q;
      },
      3428: (t, e, i) => {
        "use strict";
        i.d(e, { GH: () => M });
        var n = i(8507),
          s = i(8634),
          r = i(341),
          o = i(1478),
          a = i(848),
          l = i(8218),
          u = i(9252);
        function h(t, e, i, n, s) {
          const r = e.a,
            o = e.b,
            a = e.c,
            l = e.d,
            u = e.tx,
            h = e.ty;
          (i = i || 0), (n = n || 2), (s = s || t.length / n - i);
          let c = i * n;
          for (let e = 0; e < s; e++) {
            const e = t[c],
              i = t[c + 1];
            (t[c] = r * e + a * i + u),
              (t[c + 1] = o * e + l * i + h),
              (c += n);
          }
        }
        var c = i(4492),
          d = i(6954);
        const p = {
          build(t, e) {
            let i, n, s, r, o, a;
            if ("circle" === t.type) {
              const e = t;
              (i = e.x), (n = e.y), (o = a = e.radius), (s = r = 0);
            } else if ("ellipse" === t.type) {
              const e = t;
              (i = e.x),
                (n = e.y),
                (o = e.halfWidth),
                (a = e.halfHeight),
                (s = r = 0);
            } else {
              const e = t,
                l = e.width / 2,
                u = e.height / 2;
              (i = e.x + l),
                (n = e.y + u),
                (o = a = Math.max(0, Math.min(e.radius, Math.min(l, u)))),
                (s = l - o),
                (r = u - a);
            }
            if (!(o >= 0 && a >= 0 && s >= 0 && r >= 0)) return e;
            const l = Math.ceil(2.3 * Math.sqrt(o + a)),
              u = 8 * l + (s ? 4 : 0) + (r ? 4 : 0);
            if (0 === u) return e;
            if (0 === l)
              return (
                (e[0] = e[6] = i + s),
                (e[1] = e[3] = n + r),
                (e[2] = e[4] = i - s),
                (e[5] = e[7] = n - r),
                e
              );
            let h = 0,
              c = 4 * l + (s ? 2 : 0) + 2,
              d = c,
              p = u,
              f = s + o,
              m = r,
              g = i + f,
              v = i - f,
              y = n + m;
            if (((e[h++] = g), (e[h++] = y), (e[--c] = y), (e[--c] = v), r)) {
              const t = n - m;
              (e[d++] = v), (e[d++] = t), (e[--p] = t), (e[--p] = g);
            }
            for (let t = 1; t < l; t++) {
              const u = (Math.PI / 2) * (t / l),
                f = s + Math.cos(u) * o,
                m = r + Math.sin(u) * a,
                g = i + f,
                v = i - f,
                y = n + m,
                x = n - m;
              (e[h++] = g),
                (e[h++] = y),
                (e[--c] = y),
                (e[--c] = v),
                (e[d++] = v),
                (e[d++] = x),
                (e[--p] = x),
                (e[--p] = g);
            }
            (f = s), (m = r + a), (g = i + f), (v = i - f), (y = n + m);
            const x = n - m;
            return (
              (e[h++] = g),
              (e[h++] = y),
              (e[--p] = x),
              (e[--p] = g),
              s && ((e[h++] = v), (e[h++] = y), (e[--p] = x), (e[--p] = v)),
              e
            );
          },
          triangulate(t, e, i, n, s, r) {
            if (0 === t.length) return;
            let o = 0,
              a = 0;
            for (let e = 0; e < t.length; e += 2) (o += t[e]), (a += t[e + 1]);
            (o /= t.length / 2), (a /= t.length / 2);
            let l = n;
            (e[l * i] = o), (e[l * i + 1] = a);
            const u = l++;
            for (let n = 0; n < t.length; n += 2)
              (e[l * i] = t[n]),
                (e[l * i + 1] = t[n + 1]),
                n > 0 && ((s[r++] = l), (s[r++] = u), (s[r++] = l - 1)),
                l++;
            (s[r++] = u + 1), (s[r++] = u), (s[r++] = l - 1);
          },
        };
        var f = i(5101);
        const m = 1e-4,
          g = 1e-4;
        function v(t, e, i, n, s, r, o, a) {
          let l, u;
          o ? ((l = n), (u = -i)) : ((l = -n), (u = i));
          const h = t - i * s + l,
            c = e - n * s + u,
            d = t + i * r + l,
            p = e + n * r + u;
          return a.push(h, c), a.push(d, p), 2;
        }
        function y(t, e, i, n, s, r, o, a) {
          const l = i - t,
            u = n - e;
          let h = Math.atan2(l, u),
            c = Math.atan2(s - t, r - e);
          a && h < c ? (h += 2 * Math.PI) : !a && h > c && (c += 2 * Math.PI);
          let d = h;
          const p = c - h,
            f = Math.abs(p),
            m = Math.sqrt(l * l + u * u),
            g = 1 + (((15 * f * Math.sqrt(m)) / Math.PI) | 0),
            v = p / g;
          if (((d += v), a)) {
            o.push(t, e), o.push(i, n);
            for (let i = 1, n = d; i < g; i++, n += v)
              o.push(t, e), o.push(t + Math.sin(n) * m, e + Math.cos(n) * m);
            o.push(t, e), o.push(s, r);
          } else {
            o.push(i, n), o.push(t, e);
            for (let i = 1, n = d; i < g; i++, n += v)
              o.push(t + Math.sin(n) * m, e + Math.cos(n) * m), o.push(t, e);
            o.push(s, r), o.push(t, e);
          }
          return 2 * g;
        }
        var x = i(6570);
        function b(t, e, i, n, s, r, o) {
          const a = x(t, e, 2);
          if (!a) return;
          for (let t = 0; t < a.length; t += 3)
            (r[o++] = a[t] + s),
              (r[o++] = a[t + 1] + s),
              (r[o++] = a[t + 2] + s);
          let l = s * n;
          for (let e = 0; e < t.length; e += 2)
            (i[l] = t[e]), (i[l + 1] = t[e + 1]), (l += n);
        }
        const S = [],
          C = {
            rectangle: {
              build(t, e) {
                const i = t,
                  n = i.x,
                  s = i.y,
                  r = i.width,
                  o = i.height;
                return r >= 0 && o >= 0
                  ? ((e[0] = n),
                    (e[1] = s),
                    (e[2] = n + r),
                    (e[3] = s),
                    (e[4] = n + r),
                    (e[5] = s + o),
                    (e[6] = n),
                    (e[7] = s + o),
                    e)
                  : e;
              },
              triangulate(t, e, i, n, s, r) {
                let o = 0;
                (e[(n *= i) + o] = t[0]),
                  (e[n + o + 1] = t[1]),
                  (o += i),
                  (e[n + o] = t[2]),
                  (e[n + o + 1] = t[3]),
                  (o += i),
                  (e[n + o] = t[6]),
                  (e[n + o + 1] = t[7]),
                  (o += i),
                  (e[n + o] = t[4]),
                  (e[n + o + 1] = t[5]),
                  (o += i);
                const a = n / i;
                (s[r++] = a),
                  (s[r++] = a + 1),
                  (s[r++] = a + 2),
                  (s[r++] = a + 1),
                  (s[r++] = a + 3),
                  (s[r++] = a + 2);
              },
            },
            polygon: {
              build(t, e) {
                for (let i = 0; i < t.points.length; i++) e[i] = t.points[i];
                return e;
              },
              triangulate(t, e, i, n, s, r) {
                b(t, S, e, i, n, s, r);
              },
            },
            triangle: {
              build: (t, e) => (
                (e[0] = t.x),
                (e[1] = t.y),
                (e[2] = t.x2),
                (e[3] = t.y2),
                (e[4] = t.x3),
                (e[5] = t.y3),
                e
              ),
              triangulate(t, e, i, n, s, r) {
                let o = 0;
                (e[(n *= i) + o] = t[0]),
                  (e[n + o + 1] = t[1]),
                  (o += i),
                  (e[n + o] = t[2]),
                  (e[n + o + 1] = t[3]),
                  (o += i),
                  (e[n + o] = t[4]),
                  (e[n + o + 1] = t[5]);
                const a = n / i;
                (s[r++] = a), (s[r++] = a + 1), (s[r++] = a + 2);
              },
            },
            circle: p,
            ellipse: p,
            roundedRectangle: p,
          },
          _ = new u.M();
        function T(t, e, i) {
          const { vertices: n, uvs: s, indices: r } = i,
            o = r.length,
            a = n.length / 2,
            u = [],
            c = C.rectangle,
            p = _,
            f = t.image;
          (p.x = t.dx), (p.y = t.dy), (p.width = t.dw), (p.height = t.dh);
          const m = t.transform;
          c.build(p, u), m && h(u, m), c.triangulate(u, n, 2, a, r, o);
          const g = f.uvs;
          s.push(g.x0, g.y0, g.x1, g.y1, g.x3, g.y3, g.x2, g.y2);
          const v = l.Z.get(d.G);
          (v.indexOffset = o),
            (v.indexSize = r.length - o),
            (v.vertexOffset = a),
            (v.vertexSize = n.length / 2 - a),
            (v.color = t.style),
            (v.alpha = t.alpha),
            (v.texture = f),
            (v.geometryData = i),
            e.push(v);
        }
        function w(t, e, i, n, s, r) {
          const { vertices: o, uvs: a, indices: u } = r,
            p = t.shapePrimitives.length - 1;
          t.shapePrimitives.forEach(({ shape: t, transform: x }, S) => {
            const _ = u.length,
              T = o.length / 2,
              w = [],
              P = C[t.type];
            if ((P.build(t, w), x && h(w, x), n)) {
              const i = t.closePath ?? !0;
              !(function (t, e, i, n, s, r, o, a, l) {
                const u = m;
                if (0 === t.length) return;
                const h = e;
                let c = h.alignment;
                if (0.5 !== e.alignment) {
                  let e = (function (t) {
                    const e = t.length;
                    if (e < 6) return 1;
                    let i = 0;
                    for (let n = 0, s = t[e - 2], r = t[e - 1]; n < e; n += 2) {
                      const e = t[n],
                        o = t[n + 1];
                      (i += (e - s) * (o + r)), (s = e), (r = o);
                    }
                    return i < 0 ? -1 : 1;
                  })(t);
                  i && (e *= -1), (c = (c - 0.5) * e + 0.5);
                }
                const d = new f.b(t[0], t[1]),
                  p = new f.b(t[t.length - 2], t[t.length - 1]),
                  x = n,
                  b = Math.abs(d.x - p.x) < u && Math.abs(d.y - p.y) < u;
                if (x) {
                  (t = t.slice()),
                    b &&
                      (t.pop(),
                      t.pop(),
                      p.set(t[t.length - 2], t[t.length - 1]));
                  const e = 0.5 * (d.x + p.x),
                    i = 0.5 * (p.y + d.y);
                  t.unshift(e, i), t.push(e, i);
                }
                const S = s,
                  C = t.length / 2;
                let _ = t.length;
                const T = S.length / 2,
                  w = h.width / 2,
                  P = w * w,
                  A = h.miterLimit * h.miterLimit;
                let k = t[0],
                  M = t[1],
                  E = t[2],
                  I = t[3],
                  D = 0,
                  R = 0,
                  B = -(M - I),
                  F = k - E,
                  O = 0,
                  z = 0,
                  L = Math.sqrt(B * B + F * F);
                (B /= L), (F /= L), (B *= w), (F *= w);
                const H = 2 * (1 - c),
                  U = 2 * c;
                x ||
                  ("round" === h.cap
                    ? (_ +=
                        y(
                          k - B * (H - U) * 0.5,
                          M - F * (H - U) * 0.5,
                          k - B * H,
                          M - F * H,
                          k + B * U,
                          M + F * U,
                          S,
                          !0
                        ) + 2)
                    : "square" === h.cap && (_ += v(k, M, B, F, H, U, !0, S))),
                  S.push(k - B * H, M - F * H),
                  S.push(k + B * U, M + F * U);
                for (let e = 1; e < C - 1; ++e) {
                  (k = t[2 * (e - 1)]),
                    (M = t[2 * (e - 1) + 1]),
                    (E = t[2 * e]),
                    (I = t[2 * e + 1]),
                    (D = t[2 * (e + 1)]),
                    (R = t[2 * (e + 1) + 1]),
                    (B = -(M - I)),
                    (F = k - E),
                    (L = Math.sqrt(B * B + F * F)),
                    (B /= L),
                    (F /= L),
                    (B *= w),
                    (F *= w),
                    (O = -(I - R)),
                    (z = E - D),
                    (L = Math.sqrt(O * O + z * z)),
                    (O /= L),
                    (z /= L),
                    (O *= w),
                    (z *= w);
                  const i = E - k,
                    n = M - I,
                    s = E - D,
                    r = R - I,
                    o = i * s + n * r,
                    a = n * s - r * i,
                    l = a < 0;
                  if (Math.abs(a) < 0.001 * Math.abs(o)) {
                    S.push(E - B * H, I - F * H),
                      S.push(E + B * U, I + F * U),
                      o >= 0 &&
                        ("round" === h.join
                          ? (_ +=
                              y(
                                E,
                                I,
                                E - B * H,
                                I - F * H,
                                E - O * H,
                                I - z * H,
                                S,
                                !1
                              ) + 4)
                          : (_ += 2),
                        S.push(E - O * U, I - z * U),
                        S.push(E + O * H, I + z * H));
                    continue;
                  }
                  const u = (-B + k) * (-F + I) - (-B + E) * (-F + M),
                    c = (-O + D) * (-z + I) - (-O + E) * (-z + R),
                    d = (i * c - s * u) / a,
                    p = (r * u - n * c) / a,
                    f = (d - E) * (d - E) + (p - I) * (p - I),
                    m = E + (d - E) * H,
                    g = I + (p - I) * H,
                    v = E - (d - E) * U,
                    x = I - (p - I) * U,
                    b = l ? H : U;
                  f <= Math.min(i * i + n * n, s * s + r * r) + b * b * P
                    ? "bevel" === h.join || f / P > A
                      ? (l
                          ? (S.push(m, g),
                            S.push(E + B * U, I + F * U),
                            S.push(m, g),
                            S.push(E + O * U, I + z * U))
                          : (S.push(E - B * H, I - F * H),
                            S.push(v, x),
                            S.push(E - O * H, I - z * H),
                            S.push(v, x)),
                        (_ += 2))
                      : "round" === h.join
                      ? l
                        ? (S.push(m, g),
                          S.push(E + B * U, I + F * U),
                          (_ +=
                            y(
                              E,
                              I,
                              E + B * U,
                              I + F * U,
                              E + O * U,
                              I + z * U,
                              S,
                              !0
                            ) + 4),
                          S.push(m, g),
                          S.push(E + O * U, I + z * U))
                        : (S.push(E - B * H, I - F * H),
                          S.push(v, x),
                          (_ +=
                            y(
                              E,
                              I,
                              E - B * H,
                              I - F * H,
                              E - O * H,
                              I - z * H,
                              S,
                              !1
                            ) + 4),
                          S.push(E - O * H, I - z * H),
                          S.push(v, x))
                      : (S.push(m, g), S.push(v, x))
                    : (S.push(E - B * H, I - F * H),
                      S.push(E + B * U, I + F * U),
                      "round" === h.join
                        ? (_ += l
                            ? y(
                                E,
                                I,
                                E + B * U,
                                I + F * U,
                                E + O * U,
                                I + z * U,
                                S,
                                !0
                              ) + 2
                            : y(
                                E,
                                I,
                                E - B * H,
                                I - F * H,
                                E - O * H,
                                I - z * H,
                                S,
                                !1
                              ) + 2)
                        : "miter" === h.join &&
                          f / P <= A &&
                          (l
                            ? (S.push(v, x), S.push(v, x))
                            : (S.push(m, g), S.push(m, g)),
                          (_ += 2)),
                      S.push(E - O * H, I - z * H),
                      S.push(E + O * U, I + z * U),
                      (_ += 2));
                }
                (k = t[2 * (C - 2)]),
                  (M = t[2 * (C - 2) + 1]),
                  (E = t[2 * (C - 1)]),
                  (I = t[2 * (C - 1) + 1]),
                  (B = -(M - I)),
                  (F = k - E),
                  (L = Math.sqrt(B * B + F * F)),
                  (B /= L),
                  (F /= L),
                  (B *= w),
                  (F *= w),
                  S.push(E - B * H, I - F * H),
                  S.push(E + B * U, I + F * U),
                  x ||
                    ("round" === h.cap
                      ? (_ +=
                          y(
                            E - B * (H - U) * 0.5,
                            I - F * (H - U) * 0.5,
                            E - B * H,
                            I - F * H,
                            E + B * U,
                            I + F * U,
                            S,
                            !1
                          ) + 2)
                      : "square" === h.cap &&
                        (_ += v(E, I, B, F, H, U, !1, S)));
                const N = g * g;
                for (let t = T; t < _ + T - 2; ++t)
                  (k = S[2 * t]),
                    (M = S[2 * t + 1]),
                    (E = S[2 * (t + 1)]),
                    (I = S[2 * (t + 1) + 1]),
                    (D = S[2 * (t + 2)]),
                    (R = S[2 * (t + 2) + 1]),
                    Math.abs(k * (I - R) + E * (R - M) + D * (M - I)) < N ||
                      a.push(t, t + 1, t + 2);
              })(w, e, !1, i, o, 0, 0, u);
            } else if (i && p === S) {
              0 !== p &&
                console.warn(
                  "[Pixi Graphics] only the last shape have be cut out"
                );
              const t = [],
                e = w.slice(),
                n = (function (t) {
                  if (!t) return [];
                  const e = t.shapePrimitives,
                    i = [];
                  for (let t = 0; t < e.length; t++) {
                    const n = e[t].shape,
                      s = [];
                    C[n.type].build(n, s), i.push(s);
                  }
                  return i;
                })(i.shapePath);
              n.forEach((i) => {
                t.push(e.length / 2), e.push(...i);
              }),
                b(e, t, o, 2, T, u, _);
            } else P.triangulate(w, o, 2, T, u, _);
            const A = a.length / 2,
              k = e.texture;
            if (k !== c.g.WHITE) {
              const t = e.matrix;
              x && t.append(x.clone().invert()),
                (function (t, e, i, n, s, r, o, a = null) {
                  let l = 0;
                  (i *= e), (s *= r);
                  const u = a.a,
                    h = a.b,
                    c = a.c,
                    d = a.d,
                    p = a.tx,
                    f = a.ty;
                  for (; l < o; ) {
                    const o = t[i],
                      a = t[i + 1];
                    (n[s] = u * o + c * a + p),
                      (n[s + 1] = h * o + d * a + f),
                      (s += r),
                      (i += e),
                      l++;
                  }
                })(o, 2, T, a, A, 2, o.length / 2 - T, t);
            } else
              !(function (t, e, i, n) {
                let s = 0;
                for (e *= i; s < n; ) (t[e] = 0), (t[e + 1] = 0), (e += i), s++;
              })(a, A, 2, o.length / 2 - T);
            const M = l.Z.get(d.G);
            (M.indexOffset = _),
              (M.indexSize = u.length - _),
              (M.vertexOffset = T),
              (M.vertexSize = o.length / 2 - T),
              (M.color = e.color),
              (M.alpha = e.alpha),
              (M.texture = k),
              (M.geometryData = r),
              s.push(M);
          });
        }
        class P {
          constructor() {
            (this.batches = []),
              (this.geometryData = { vertices: [], uvs: [], indices: [] });
          }
        }
        class A {
          constructor() {
            (this.geometry = new s.J()), (this.instructions = new a.L());
          }
          init() {
            this.instructions.reset();
          }
        }
        const k = class t {
          constructor() {
            (this._activeBatchers = []),
              (this._gpuContextHash = {}),
              (this._graphicsDataContextHash = Object.create(null)),
              (this._needsContextNeedsRebuild = []);
          }
          init(e) {
            t.defaultOptions.bezierSmoothness =
              e?.bezierSmoothness ?? t.defaultOptions.bezierSmoothness;
          }
          prerender() {
            this._returnActiveBatchers();
          }
          getContextRenderData(t) {
            return (
              this._graphicsDataContextHash[t.uid] ||
              this._initContextRenderData(t)
            );
          }
          updateGpuContext(t) {
            let e = this._gpuContextHash[t.uid] || this._initContext(t);
            if (t.dirty) {
              e
                ? this._cleanGraphicsContextData(t)
                : (e = this._initContext(t)),
                (function (t, e) {
                  const { geometryData: i, batches: n } = e;
                  (n.length = 0),
                    (i.indices.length = 0),
                    (i.vertices.length = 0),
                    (i.uvs.length = 0);
                  for (let e = 0; e < t.instructions.length; e++) {
                    const s = t.instructions[e];
                    if ("texture" === s.action) T(s.data, n, i);
                    else if ("fill" === s.action || "stroke" === s.action) {
                      const t = "stroke" === s.action,
                        e = s.data.path.shapePath,
                        r = s.data.style,
                        o = s.data.hole;
                      t && o && w(o.shapePath, r, null, !0, n, i),
                        w(e, r, o, t, n, i);
                    }
                  }
                })(t, e);
              const i = t.batchMode;
              t.customShader || "no-batch" === i
                ? (e.isBatchable = !1)
                : "auto" === i &&
                  (e.isBatchable = e.geometryData.vertices.length < 400),
                (t.dirty = !1);
            }
            return e;
          }
          getGpuContext(t) {
            return this._gpuContextHash[t.uid] || this._initContext(t);
          }
          _returnActiveBatchers() {
            for (let t = 0; t < this._activeBatchers.length; t++)
              l.Z.return(this._activeBatchers[t]);
            this._activeBatchers.length = 0;
          }
          _initContextRenderData(t) {
            const e = l.Z.get(A),
              { batches: i, geometryData: n } = this._gpuContextHash[t.uid],
              s = n.vertices.length,
              a = n.indices.length;
            for (let t = 0; t < i.length; t++) i[t].applyTransform = !1;
            const u = l.Z.get(o.i);
            this._activeBatchers.push(u),
              u.ensureAttributeBuffer(s),
              u.ensureIndexBuffer(a),
              u.begin();
            for (let t = 0; t < i.length; t++) {
              const e = i[t];
              u.add(e);
            }
            u.finish(e.instructions);
            const h = e.geometry;
            h.indexBuffer.setDataWithSize(u.indexBuffer, u.indexSize, !0),
              h.buffers[0].setDataWithSize(
                u.attributeBuffer.float32View,
                u.attributeSize,
                !0
              );
            const c = u.batches;
            for (let t = 0; t < c.length; t++) {
              const e = c[t];
              e.bindGroup = (0, r.w)(e.textures.textures, e.textures.count);
            }
            return (this._graphicsDataContextHash[t.uid] = e), e;
          }
          _initContext(t) {
            const e = new P();
            return (
              (this._gpuContextHash[t.uid] = e),
              t.on("update", this.onGraphicsContextUpdate, this),
              t.on("destroy", this.onGraphicsContextDestroy, this),
              this._gpuContextHash[t.uid]
            );
          }
          onGraphicsContextUpdate(t) {
            this._needsContextNeedsRebuild.push(t);
          }
          onGraphicsContextDestroy(t) {
            this._cleanGraphicsContextData(t),
              t.off("update", this.onGraphicsContextUpdate, this),
              t.off("destroy", this.onGraphicsContextDestroy, this),
              (this._gpuContextHash[t.uid] = null);
          }
          _cleanGraphicsContextData(t) {
            const e = this._gpuContextHash[t.uid];
            e.isBatchable ||
              (this._graphicsDataContextHash[t.uid] &&
                (l.Z.return(this.getContextRenderData(t)),
                (this._graphicsDataContextHash[t.uid] = null))),
              e.batches &&
                e.batches.forEach((t) => {
                  l.Z.return(t);
                });
          }
          destroy() {
            for (const t of this._needsContextNeedsRebuild)
              this._gpuContextHash[t.uid] && this.onGraphicsContextDestroy(t);
            this._needsContextNeedsRebuild.length = 0;
          }
        };
        (k.extension = {
          type: [n.Ag.WebGLSystem, n.Ag.WebGPUSystem, n.Ag.CanvasSystem],
          name: "graphicsContext",
        }),
          (k.defaultOptions = { bezierSmoothness: 0.5 });
        let M = k;
      },
      7276: (t, e, i) => {
        "use strict";
        i.d(e, { _: () => h });
        var n = i(2577),
          s = i(1761),
          r = i(9313),
          o = i(8293),
          a = i(4492),
          l = i(133);
        const u = class t {
          constructor(t, e, i, n) {
            (this.uid = (0, l.L)("fillGradient")),
              (this.type = "linear"),
              (this.gradientStops = []),
              (this.x0 = t),
              (this.y0 = e),
              (this.x1 = i),
              (this.y1 = n);
          }
          addColorStop(t, e) {
            return (
              this.gradientStops.push({
                offset: t,
                color: n.Q.shared.setValue(e).toHex(),
              }),
              this
            );
          }
          buildLinearGradient() {
            const e = t.defaultTextureSize,
              { gradientStops: i } = this,
              n = s.e.get().createCanvas();
            (n.width = e), (n.height = e);
            const l = n.getContext("2d"),
              u = l.createLinearGradient(0, 0, t.defaultTextureSize, 1);
            for (let t = 0; t < i.length; t++) {
              const e = i[t];
              u.addColorStop(e.offset, e.color);
            }
            (l.fillStyle = u),
              l.fillRect(0, 0, e, e),
              (this.texture = new a.g({
                source: new o.b({
                  resource: n,
                  addressModeU: "clamp-to-edge",
                  addressModeV: "repeat",
                }),
              }));
            const { x0: h, y0: c, x1: d, y1: p } = this,
              f = new r.u(),
              m = d - h,
              g = p - c,
              v = Math.sqrt(m * m + g * g),
              y = Math.atan2(g, m);
            f.translate(-h, -c),
              f.scale(1 / e, 1 / e),
              f.rotate(-y),
              f.scale(256 / v, 1),
              (this.transform = f);
          }
        };
        u.defaultTextureSize = 256;
        let h = u;
      },
      2806: (t, e, i) => {
        "use strict";
        i.d(e, { m: () => o });
        var n = i(9313),
          s = i(133);
        const r = {
          repeat: { addressModeU: "repeat", addressModeV: "repeat" },
          "repeat-x": { addressModeU: "repeat", addressModeV: "clamp-to-edge" },
          "repeat-y": { addressModeU: "clamp-to-edge", addressModeV: "repeat" },
          "no-repeat": {
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge",
          },
        };
        class o {
          constructor(t, e) {
            (this.uid = (0, s.L)("fillPattern")),
              (this.transform = new n.u()),
              (this.texture = t),
              this.transform.scale(1 / t.frame.width, 1 / t.frame.height),
              e &&
                ((t.source.style.addressModeU = r[e].addressModeU),
                (t.source.style.addressModeV = r[e].addressModeV));
          }
          setTransform(t) {
            const e = this.texture;
            this.transform.copyFrom(t),
              this.transform.invert(),
              this.transform.scale(1 / e.frame.width, 1 / e.frame.height);
          }
        }
      },
      990: (t, e, i) => {
        "use strict";
        i.d(e, { M: () => l });
        var n = i(2577),
          s = i(9313),
          r = i(4492),
          o = i(7276),
          a = i(2806);
        function l(t, e) {
          if (null == t) return null;
          let i, l;
          if (
            (t?.fill
              ? ((l = t.fill), (i = { ...e, ...t }))
              : ((l = t), (i = e)),
            n.Q.isColorLike(l))
          ) {
            const t = n.Q.shared.setValue(l ?? 0);
            return {
              ...i,
              color: t.toNumber(),
              alpha: 1 === t.alpha ? i.alpha : t.alpha,
              texture: r.g.WHITE,
            };
          }
          if (l instanceof a.m) {
            const t = l;
            return {
              ...i,
              color: 16777215,
              texture: t.texture,
              matrix: t.transform,
              fill: i.fill ?? null,
            };
          }
          if (l instanceof o._) {
            const t = l;
            return (
              t.buildLinearGradient(),
              { ...i, color: 16777215, texture: t.texture, matrix: t.transform }
            );
          }
          const u = { ...e, ...t };
          if (u.texture) {
            if (u.texture !== r.g.WHITE) {
              const t = u.matrix?.invert() || new s.u();
              t.scale(1 / u.texture.frame.width, 1 / u.texture.frame.height),
                (u.matrix = t);
            }
            const t = u.texture.source.style;
            "clamp-to-edge" === t.addressMode && (t.addressMode = "repeat");
          }
          const h = n.Q.shared.setValue(u.color);
          return (
            (u.alpha *= h.alpha),
            (u.color = h.toNumber()),
            (u.matrix = u.matrix ? u.matrix.clone() : null),
            u
          );
        }
      },
      8422: (t, e, i) => {
        "use strict";
        i.d(e, { K: () => n });
        class n {
          constructor() {
            (this.vertexSize = 4),
              (this.indexSize = 6),
              (this.location = 0),
              (this.batcher = null),
              (this.batch = null),
              (this.roundPixels = 0);
          }
          get blendMode() {
            return this.renderable.groupBlendMode;
          }
          packAttributes(t, e, i, n) {
            const s = this.renderable,
              r = this.texture,
              o = s.groupTransform,
              a = o.a,
              l = o.b,
              u = o.c,
              h = o.d,
              c = o.tx,
              d = o.ty,
              p = this.bounds,
              f = p.maxX,
              m = p.minX,
              g = p.maxY,
              v = p.minY,
              y = r.uvs,
              x = s.groupColorAlpha,
              b = (n << 16) | (65535 & this.roundPixels);
            (t[i + 0] = a * m + u * v + c),
              (t[i + 1] = h * v + l * m + d),
              (t[i + 2] = y.x0),
              (t[i + 3] = y.y0),
              (e[i + 4] = x),
              (e[i + 5] = b),
              (t[i + 6] = a * f + u * v + c),
              (t[i + 7] = h * v + l * f + d),
              (t[i + 8] = y.x1),
              (t[i + 9] = y.y1),
              (e[i + 10] = x),
              (e[i + 11] = b),
              (t[i + 12] = a * f + u * g + c),
              (t[i + 13] = h * g + l * f + d),
              (t[i + 14] = y.x2),
              (t[i + 15] = y.y2),
              (e[i + 16] = x),
              (e[i + 17] = b),
              (t[i + 18] = a * m + u * g + c),
              (t[i + 19] = h * g + l * m + d),
              (t[i + 20] = y.x3),
              (t[i + 21] = y.y3),
              (e[i + 22] = x),
              (e[i + 23] = b);
          }
          packIndex(t, e, i) {
            (t[e] = i + 0),
              (t[e + 1] = i + 1),
              (t[e + 2] = i + 2),
              (t[e + 3] = i + 0),
              (t[e + 4] = i + 2),
              (t[e + 5] = i + 3);
          }
          reset() {
            (this.renderable = null),
              (this.texture = null),
              (this.batcher = null),
              (this.batch = null),
              (this.bounds = null);
          }
        }
      },
      6844: (t, e, i) => {
        "use strict";
        i.d(e, { k: () => a });
        var n = i(2812),
          s = i(4492),
          r = i(2048),
          o = i(4263);
        class a extends o.mc {
          constructor(t = s.g.EMPTY) {
            t instanceof s.g && (t = { texture: t });
            const {
              texture: e,
              anchor: i,
              roundPixels: r,
              width: o,
              height: a,
              ...l
            } = t;
            super({ label: "Sprite", ...l }),
              (this.renderPipeId = "sprite"),
              (this.batched = !0),
              (this._didSpriteUpdate = !1),
              (this._bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
              (this._sourceBounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
              (this._boundsDirty = !0),
              (this._sourceBoundsDirty = !0),
              (this._roundPixels = 0),
              (this._anchor = new n.o({
                _onUpdate: () => {
                  this.onViewUpdate();
                },
              })),
              i
                ? (this.anchor = i)
                : e.defaultAnchor && (this.anchor = e.defaultAnchor),
              (this.texture = e),
              (this.allowChildren = !1),
              (this.roundPixels = r ?? !1),
              o && (this.width = o),
              a && (this.height = a);
          }
          static from(t, e = !1) {
            return t instanceof s.g ? new a(t) : new a(s.g.from(t, e));
          }
          set texture(t) {
            t || (t = s.g.EMPTY);
            const e = this._texture;
            e !== t &&
              (e && e.dynamic && e.off("update", this.onViewUpdate, this),
              t.dynamic && t.on("update", this.onViewUpdate, this),
              (this._texture = t),
              this.onViewUpdate());
          }
          get texture() {
            return this._texture;
          }
          get bounds() {
            return (
              this._boundsDirty &&
                (this._updateBounds(), (this._boundsDirty = !1)),
              this._bounds
            );
          }
          get sourceBounds() {
            return (
              this._sourceBoundsDirty &&
                (this._updateSourceBounds(), (this._sourceBoundsDirty = !1)),
              this._sourceBounds
            );
          }
          containsPoint(t) {
            const e = this.sourceBounds;
            return (
              t.x >= e.maxX && t.x <= e.minX && t.y >= e.maxY && t.y <= e.minY
            );
          }
          addBounds(t) {
            const e = this._texture.trim ? this.sourceBounds : this.bounds;
            t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
          }
          onViewUpdate() {
            (this._didChangeId += 4096),
              (this._didSpriteUpdate = !0),
              (this._sourceBoundsDirty = this._boundsDirty = !0),
              this.didViewUpdate ||
                ((this.didViewUpdate = !0),
                this.renderGroup && this.renderGroup.onChildViewUpdate(this));
          }
          _updateBounds() {
            (0, r.y)(this._bounds, this._anchor, this._texture, 0);
          }
          _updateSourceBounds() {
            const t = this._anchor,
              e = this._texture,
              i = this._sourceBounds,
              { width: n, height: s } = e.orig;
            (i.maxX = -t._x * n),
              (i.minX = i.maxX + n),
              (i.maxY = -t._y * s),
              (i.minY = i.maxY + s);
          }
          destroy(t = !1) {
            super.destroy(t);
            if ("boolean" == typeof t ? t : t?.texture) {
              const e = "boolean" == typeof t ? t : t?.textureSource;
              this._texture.destroy(e);
            }
            (this._texture = null),
              (this._bounds = null),
              (this._sourceBounds = null),
              (this._anchor = null);
          }
          get anchor() {
            return this._anchor;
          }
          set anchor(t) {
            "number" == typeof t
              ? this._anchor.set(t)
              : this._anchor.copyFrom(t);
          }
          get roundPixels() {
            return !!this._roundPixels;
          }
          set roundPixels(t) {
            this._roundPixels = t ? 1 : 0;
          }
          get width() {
            return Math.abs(this.scale.x) * this._texture.orig.width;
          }
          set width(t) {
            this._setWidth(t, this._texture.orig.width);
          }
          get height() {
            return Math.abs(this.scale.y) * this._texture.orig.height;
          }
          set height(t) {
            this._setHeight(t, this._texture.orig.height);
          }
          getSize(t) {
            return (
              t || (t = {}),
              (t.width = Math.abs(this.scale.x) * this._texture.orig.width),
              (t.height = Math.abs(this.scale.y) * this._texture.orig.height),
              t
            );
          }
          setSize(t, e) {
            let i, n;
            "object" != typeof t
              ? ((i = t), (n = e ?? t))
              : ((i = t.width), (n = t.height ?? t.width)),
              void 0 !== i && this._setWidth(i, this._texture.orig.width),
              void 0 !== n && this._setHeight(n, this._texture.orig.height);
          }
        }
      },
      8291: (t, e, i) => {
        "use strict";
        i.d(e, { x: () => c });
        var n = i(4486),
          s = i(2577),
          r = i(4670),
          o = i(7276),
          a = i(4835),
          l = i(990),
          u = i(8011);
        const h = class t extends n.A {
          constructor(e = {}) {
            super(),
              (function (t) {
                const e = t;
                if ("boolean" == typeof e.dropShadow && e.dropShadow) {
                  const i = c.defaultDropShadow;
                  t.dropShadow = {
                    alpha: e.dropShadowAlpha ?? i.alpha,
                    angle: e.dropShadowAngle ?? i.angle,
                    blur: e.dropShadowBlur ?? i.blur,
                    color: e.dropShadowColor ?? i.color,
                    distance: e.dropShadowDistance ?? i.distance,
                  };
                }
                if (e.strokeThickness) {
                  (0, r.t)(r.l, "strokeThickness is now a part of stroke");
                  const i = e.stroke;
                  t.stroke = { color: i, width: e.strokeThickness };
                }
                if (Array.isArray(e.fill)) {
                  (0, r.t)(
                    r.l,
                    "gradient fill is now a fill pattern: `new FillGradient(...)`"
                  );
                  const i = new o._(0, 0, 0, 1.7 * t.fontSize),
                    n = e.fill.map((t) => s.Q.shared.setValue(t).toNumber());
                  n.forEach((t, s) => {
                    const r = e.fillGradientStops[s] ?? s / n.length;
                    i.addColorStop(r, t);
                  }),
                    (t.fill = { fill: i });
                }
              })(e);
            const i = { ...t.defaultTextStyle, ...e };
            for (const t in i) {
              this[t] = i[t];
            }
            this.update();
          }
          get align() {
            return this._align;
          }
          set align(t) {
            (this._align = t), this.update();
          }
          get breakWords() {
            return this._breakWords;
          }
          set breakWords(t) {
            (this._breakWords = t), this.update();
          }
          get dropShadow() {
            return this._dropShadow;
          }
          set dropShadow(e) {
            (this._dropShadow =
              null !== e && "object" == typeof e
                ? { ...t.defaultDropShadow, ...e }
                : e
                ? { ...t.defaultDropShadow }
                : null),
              this.update();
          }
          get fontFamily() {
            return this._fontFamily;
          }
          set fontFamily(t) {
            (this._fontFamily = t), this.update();
          }
          get fontSize() {
            return this._fontSize;
          }
          set fontSize(t) {
            (this._fontSize = "string" == typeof t ? parseInt(t, 10) : t),
              this.update();
          }
          get fontStyle() {
            return this._fontStyle;
          }
          set fontStyle(t) {
            (this._fontStyle = t), this.update();
          }
          get fontVariant() {
            return this._fontVariant;
          }
          set fontVariant(t) {
            (this._fontVariant = t), this.update();
          }
          get fontWeight() {
            return this._fontWeight;
          }
          set fontWeight(t) {
            (this._fontWeight = t), this.update();
          }
          get leading() {
            return this._leading;
          }
          set leading(t) {
            (this._leading = t), this.update();
          }
          get letterSpacing() {
            return this._letterSpacing;
          }
          set letterSpacing(t) {
            (this._letterSpacing = t), this.update();
          }
          get lineHeight() {
            return this._lineHeight;
          }
          set lineHeight(t) {
            (this._lineHeight = t), this.update();
          }
          get padding() {
            return this._padding;
          }
          set padding(t) {
            (this._padding = t), this.update();
          }
          get trim() {
            return this._trim;
          }
          set trim(t) {
            (this._trim = t), this.update();
          }
          get textBaseline() {
            return this._textBaseline;
          }
          set textBaseline(t) {
            (this._textBaseline = t), this.update();
          }
          get whiteSpace() {
            return this._whiteSpace;
          }
          set whiteSpace(t) {
            (this._whiteSpace = t), this.update();
          }
          get wordWrap() {
            return this._wordWrap;
          }
          set wordWrap(t) {
            (this._wordWrap = t), this.update();
          }
          get wordWrapWidth() {
            return this._wordWrapWidth;
          }
          set wordWrapWidth(t) {
            (this._wordWrapWidth = t), this.update();
          }
          get fill() {
            return this._originalFill;
          }
          set fill(t) {
            t !== this._originalFill &&
              ((this._originalFill = t),
              (this._fill = (0, l.M)(
                0 === t ? "black" : t,
                a.T.defaultFillStyle
              )),
              this.update());
          }
          get stroke() {
            return this._originalStroke;
          }
          set stroke(t) {
            t !== this._originalStroke &&
              ((this._originalStroke = t),
              (this._stroke = (0, l.M)(t, a.T.defaultStrokeStyle)),
              this.update());
          }
          _generateKey() {
            return (this._styleKey = (0, u.V)(this)), this._styleKey;
          }
          update() {
            (this._styleKey = null), this.emit("update", this);
          }
          reset() {
            const e = t.defaultTextStyle;
            for (const t in e) this[t] = e[t];
          }
          get styleKey() {
            return this._styleKey || this._generateKey();
          }
          clone() {
            return new t({
              align: this.align,
              breakWords: this.breakWords,
              dropShadow: this.dropShadow,
              fill: this._fill,
              fontFamily: this.fontFamily,
              fontSize: this.fontSize,
              fontStyle: this.fontStyle,
              fontVariant: this.fontVariant,
              fontWeight: this.fontWeight,
              leading: this.leading,
              letterSpacing: this.letterSpacing,
              lineHeight: this.lineHeight,
              padding: this.padding,
              stroke: this._stroke,
              textBaseline: this.textBaseline,
              whiteSpace: this.whiteSpace,
              wordWrap: this.wordWrap,
              wordWrapWidth: this.wordWrapWidth,
            });
          }
          destroy(t = !1) {
            this.removeAllListeners();
            if ("boolean" == typeof t ? t : t?.texture) {
              const e = "boolean" == typeof t ? t : t?.textureSource;
              this._fill?.texture && this._fill.texture.destroy(e),
                this._originalFill?.texture &&
                  this._originalFill.texture.destroy(e),
                this._stroke?.texture && this._stroke.texture.destroy(e),
                this._originalStroke?.texture &&
                  this._originalStroke.texture.destroy(e);
            }
            (this._fill = null),
              (this._stroke = null),
              (this.dropShadow = null),
              (this._originalStroke = null),
              (this._originalFill = null);
          }
        };
        (h.defaultDropShadow = {
          alpha: 1,
          angle: Math.PI / 6,
          blur: 0,
          color: "black",
          distance: 5,
        }),
          (h.defaultTextStyle = {
            align: "left",
            breakWords: !1,
            dropShadow: null,
            fill: "black",
            fontFamily: "Arial",
            fontSize: 26,
            fontStyle: "normal",
            fontVariant: "normal",
            fontWeight: "normal",
            leading: 0,
            letterSpacing: 0,
            lineHeight: 0,
            padding: 0,
            stroke: null,
            textBaseline: "alphabetic",
            trim: !1,
            whiteSpace: "pre",
            wordWrap: !1,
            wordWrapWidth: 100,
          });
        let c = h;
      },
      4016: (t, e, i) => {
        "use strict";
        i.d(e, { P: () => a });
        var n = i(1761),
          s = i(1242);
        const r = { willReadFrequently: !0 },
          o = class t {
            static get experimentalLetterSpacingSupported() {
              let e = t._experimentalLetterSpacingSupported;
              if (void 0 !== e) {
                const i = n.e.get().getCanvasRenderingContext2D().prototype;
                e = t._experimentalLetterSpacingSupported =
                  "letterSpacing" in i || "textLetterSpacing" in i;
              }
              return e;
            }
            constructor(t, e, i, n, s, r, o, a, l) {
              (this.text = t),
                (this.style = e),
                (this.width = i),
                (this.height = n),
                (this.lines = s),
                (this.lineWidths = r),
                (this.lineHeight = o),
                (this.maxLineWidth = a),
                (this.fontProperties = l);
            }
            static measureText(e = " ", i, n = t._canvas, r = i.wordWrap) {
              const o = `${e}:${i.styleKey}`;
              if (t._measurementCache[o]) return t._measurementCache[o];
              const a = (0, s.Z)(i),
                l = t.measureFont(a);
              0 === l.fontSize &&
                ((l.fontSize = i.fontSize), (l.ascent = i.fontSize));
              const u = t.__context;
              u.font = a;
              const h = (r ? t._wordWrap(e, i, n) : e).split(/(?:\r\n|\r|\n)/),
                c = new Array(h.length);
              let d = 0;
              for (let e = 0; e < h.length; e++) {
                const n = t._measureText(h[e], i.letterSpacing, u);
                (c[e] = n), (d = Math.max(d, n));
              }
              const p = i._stroke?.width || 0;
              let f = d + p;
              i.dropShadow && (f += i.dropShadow.distance);
              const m = i.lineHeight || l.fontSize + p;
              let g =
                Math.max(m, l.fontSize + 2 * p) +
                (h.length - 1) * (m + i.leading);
              i.dropShadow && (g += i.dropShadow.distance);
              return new t(e, i, f, g, h, c, m + i.leading, d, l);
            }
            static _measureText(e, i, n) {
              let s = !1;
              t.experimentalLetterSpacingSupported &&
                (t.experimentalLetterSpacing
                  ? ((n.letterSpacing = `${i}px`),
                    (n.textLetterSpacing = `${i}px`),
                    (s = !0))
                  : ((n.letterSpacing = "0px"), (n.textLetterSpacing = "0px")));
              let r = n.measureText(e).width;
              return (
                r > 0 &&
                  (s
                    ? (r -= i)
                    : (r += (t.graphemeSegmenter(e).length - 1) * i)),
                r
              );
            }
            static _wordWrap(e, i, n = t._canvas) {
              const s = n.getContext("2d", r);
              let o = 0,
                a = "",
                l = "";
              const u = Object.create(null),
                { letterSpacing: h, whiteSpace: c } = i,
                d = t._collapseSpaces(c),
                p = t._collapseNewlines(c);
              let f = !d;
              const m = i.wordWrapWidth + h,
                g = t._tokenize(e);
              for (let e = 0; e < g.length; e++) {
                let n = g[e];
                if (t._isNewline(n)) {
                  if (!p) {
                    (l += t._addLine(a)), (f = !d), (a = ""), (o = 0);
                    continue;
                  }
                  n = " ";
                }
                if (d) {
                  const e = t.isBreakingSpace(n),
                    i = t.isBreakingSpace(a[a.length - 1]);
                  if (e && i) continue;
                }
                const r = t._getFromCache(n, h, u, s);
                if (r > m)
                  if (
                    ("" !== a && ((l += t._addLine(a)), (a = ""), (o = 0)),
                    t.canBreakWords(n, i.breakWords))
                  ) {
                    const e = t.wordWrapSplit(n);
                    for (let r = 0; r < e.length; r++) {
                      let c = e[r],
                        d = c,
                        p = 1;
                      for (; e[r + p]; ) {
                        const s = e[r + p];
                        if (t.canBreakChars(d, s, n, r, i.breakWords)) break;
                        (c += s), (d = s), p++;
                      }
                      r += p - 1;
                      const g = t._getFromCache(c, h, u, s);
                      g + o > m &&
                        ((l += t._addLine(a)), (f = !1), (a = ""), (o = 0)),
                        (a += c),
                        (o += g);
                    }
                  } else {
                    a.length > 0 && ((l += t._addLine(a)), (a = ""), (o = 0));
                    const i = e === g.length - 1;
                    (l += t._addLine(n, !i)), (f = !1), (a = ""), (o = 0);
                  }
                else
                  r + o > m &&
                    ((f = !1), (l += t._addLine(a)), (a = ""), (o = 0)),
                    (a.length > 0 || !t.isBreakingSpace(n) || f) &&
                      ((a += n), (o += r));
              }
              return (l += t._addLine(a, !1)), l;
            }
            static _addLine(e, i = !0) {
              return (e = t._trimRight(e)), (e = i ? `${e}\n` : e);
            }
            static _getFromCache(e, i, n, s) {
              let r = n[e];
              return (
                "number" != typeof r &&
                  ((r = t._measureText(e, i, s) + i), (n[e] = r)),
                r
              );
            }
            static _collapseSpaces(t) {
              return "normal" === t || "pre-line" === t;
            }
            static _collapseNewlines(t) {
              return "normal" === t;
            }
            static _trimRight(e) {
              if ("string" != typeof e) return "";
              for (let i = e.length - 1; i >= 0; i--) {
                const n = e[i];
                if (!t.isBreakingSpace(n)) break;
                e = e.slice(0, -1);
              }
              return e;
            }
            static _isNewline(e) {
              return (
                "string" == typeof e && t._newlines.includes(e.charCodeAt(0))
              );
            }
            static isBreakingSpace(e, i) {
              return (
                "string" == typeof e &&
                t._breakingSpaces.includes(e.charCodeAt(0))
              );
            }
            static _tokenize(e) {
              const i = [];
              let n = "";
              if ("string" != typeof e) return i;
              for (let s = 0; s < e.length; s++) {
                const r = e[s],
                  o = e[s + 1];
                t.isBreakingSpace(r, o) || t._isNewline(r)
                  ? ("" !== n && (i.push(n), (n = "")), i.push(r))
                  : (n += r);
              }
              return "" !== n && i.push(n), i;
            }
            static canBreakWords(t, e) {
              return e;
            }
            static canBreakChars(t, e, i, n, s) {
              return !0;
            }
            static wordWrapSplit(e) {
              return t.graphemeSegmenter(e);
            }
            static measureFont(e) {
              if (t._fonts[e]) return t._fonts[e];
              const i = t._context;
              i.font = e;
              const n = i.measureText(t.METRICS_STRING + t.BASELINE_SYMBOL),
                s = {
                  ascent: n.actualBoundingBoxAscent,
                  descent: n.actualBoundingBoxDescent,
                  fontSize:
                    n.actualBoundingBoxAscent + n.actualBoundingBoxDescent,
                };
              return (t._fonts[e] = s), s;
            }
            static clearMetrics(e = "") {
              e ? delete t._fonts[e] : (t._fonts = {});
            }
            static get _canvas() {
              if (!t.__canvas) {
                let e;
                try {
                  const i = new OffscreenCanvas(0, 0),
                    s = i.getContext("2d", r);
                  if (s?.measureText) return (t.__canvas = i), i;
                  e = n.e.get().createCanvas();
                } catch (t) {
                  e = n.e.get().createCanvas();
                }
                (e.width = e.height = 10), (t.__canvas = e);
              }
              return t.__canvas;
            }
            static get _context() {
              return (
                t.__context || (t.__context = t._canvas.getContext("2d", r)),
                t.__context
              );
            }
          };
        (o.METRICS_STRING = "|ÉqÅ"),
          (o.BASELINE_SYMBOL = "M"),
          (o.BASELINE_MULTIPLIER = 1.4),
          (o.HEIGHT_MULTIPLIER = 2),
          (o.graphemeSegmenter = (() => {
            if ("function" == typeof Intl?.Segmenter) {
              const t = new Intl.Segmenter();
              return (e) => [...t.segment(e)].map((t) => t.segment);
            }
            return (t) => [...t];
          })()),
          (o.experimentalLetterSpacing = !1),
          (o._fonts = {}),
          (o._newlines = [10, 13]),
          (o._breakingSpaces = [
            9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202,
            8287, 12288,
          ]),
          (o._measurementCache = {});
        let a = o;
      },
      1242: (t, e, i) => {
        "use strict";
        i.d(e, { Z: () => s });
        const n = [
          "serif",
          "sans-serif",
          "monospace",
          "cursive",
          "fantasy",
          "system-ui",
        ];
        function s(t) {
          const e =
            "number" == typeof t.fontSize ? `${t.fontSize}px` : t.fontSize;
          let i = t.fontFamily;
          Array.isArray(t.fontFamily) || (i = t.fontFamily.split(","));
          for (let t = i.length - 1; t >= 0; t--) {
            let e = i[t].trim();
            /([\"\'])[^\'\"]+\1/.test(e) || n.includes(e) || (e = `"${e}"`),
              (i[t] = e);
          }
          return `${t.fontStyle} ${t.fontVariant} ${t.fontWeight} ${e} ${i.join(
            ","
          )}`;
        }
      },
      8011: (t, e, i) => {
        "use strict";
        i.d(e, { V: () => s });
        const n = [
          "_fontFamily",
          "_fontStyle",
          "_fontSize",
          "_fontVariant",
          "_fontWeight",
          "_breakWords",
          "_align",
          "_leading",
          "_letterSpacing",
          "_lineHeight",
          "_textBaseline",
          "_whiteSpace",
          "_wordWrap",
          "_wordWrapWidth",
          "_padding",
          "_cssOverrides",
          "_trim",
        ];
        function s(t) {
          const e = [];
          let i = 0;
          for (let s = 0; s < n.length; s++) {
            const r = n[s];
            e[i++] = t[r];
          }
          return (
            (i = r(t._fill, e, i)),
            (i = (function (t, e, i) {
              return t
                ? ((i = r(t, e, i)),
                  (e[i++] = t.width),
                  (e[i++] = t.alignment),
                  (e[i++] = t.cap),
                  (e[i++] = t.join),
                  (e[i++] = t.miterLimit),
                  i)
                : i;
            })(t._stroke, e, i)),
            e.join("-")
          );
        }
        function r(t, e, i) {
          return t
            ? ((e[i++] = t.color),
              (e[i++] = t.alpha),
              (e[i++] = t.fill?.uid),
              i)
            : i;
        }
      },
      9010: (t, e, i) => {
        "use strict";
        var n = i(8507),
          s = i(4589),
          r = i(1173),
          o = i(2233),
          a = i(4492),
          l = i(2927),
          u = i(9252);
        const h = class t {
          constructor(t, e) {
            (this.linkedSheets = []),
              (this._texture = t instanceof a.g ? t : null),
              (this.textureSource = t.source),
              (this.textures = {}),
              (this.animations = {}),
              (this.data = e);
            const i = parseFloat(e.meta.scale);
            i
              ? ((this.resolution = i), (t.source.resolution = this.resolution))
              : (this.resolution = t.source._resolution),
              (this._frames = this.data.frames),
              (this._frameKeys = Object.keys(this._frames)),
              (this._batchIndex = 0),
              (this._callback = null);
          }
          parse() {
            return new Promise((e) => {
              (this._callback = e),
                (this._batchIndex = 0),
                this._frameKeys.length <= t.BATCH_SIZE
                  ? (this._processFrames(0),
                    this._processAnimations(),
                    this._parseComplete())
                  : this._nextBatch();
            });
          }
          _processFrames(e) {
            let i = e;
            const n = t.BATCH_SIZE;
            for (; i - e < n && i < this._frameKeys.length; ) {
              const t = this._frameKeys[i],
                e = this._frames[t],
                n = e.frame;
              if (n) {
                let i = null,
                  s = null;
                const r =
                    !1 !== e.trimmed && e.sourceSize ? e.sourceSize : e.frame,
                  o = new u.M(
                    0,
                    0,
                    Math.floor(r.w) / this.resolution,
                    Math.floor(r.h) / this.resolution
                  );
                (i = e.rotated
                  ? new u.M(
                      Math.floor(n.x) / this.resolution,
                      Math.floor(n.y) / this.resolution,
                      Math.floor(n.h) / this.resolution,
                      Math.floor(n.w) / this.resolution
                    )
                  : new u.M(
                      Math.floor(n.x) / this.resolution,
                      Math.floor(n.y) / this.resolution,
                      Math.floor(n.w) / this.resolution,
                      Math.floor(n.h) / this.resolution
                    )),
                  !1 !== e.trimmed &&
                    e.spriteSourceSize &&
                    (s = new u.M(
                      Math.floor(e.spriteSourceSize.x) / this.resolution,
                      Math.floor(e.spriteSourceSize.y) / this.resolution,
                      Math.floor(n.w) / this.resolution,
                      Math.floor(n.h) / this.resolution
                    )),
                  (this.textures[t] = new a.g({
                    source: this.textureSource,
                    frame: i,
                    orig: o,
                    trim: s,
                    rotate: e.rotated ? 2 : 0,
                    defaultAnchor: e.anchor,
                    defaultBorders: e.borders,
                    label: t.toString(),
                  }));
              }
              i++;
            }
          }
          _processAnimations() {
            const t = this.data.animations || {};
            for (const e in t) {
              this.animations[e] = [];
              for (let i = 0; i < t[e].length; i++) {
                const n = t[e][i];
                this.animations[e].push(this.textures[n]);
              }
            }
          }
          _parseComplete() {
            const t = this._callback;
            (this._callback = null),
              (this._batchIndex = 0),
              t.call(this, this.textures);
          }
          _nextBatch() {
            this._processFrames(this._batchIndex * t.BATCH_SIZE),
              this._batchIndex++,
              setTimeout(() => {
                this._batchIndex * t.BATCH_SIZE < this._frameKeys.length
                  ? this._nextBatch()
                  : (this._processAnimations(), this._parseComplete());
              }, 0);
          }
          destroy(t = !1) {
            for (const t in this.textures) this.textures[t].destroy();
            (this._frames = null),
              (this._frameKeys = null),
              (this.data = null),
              (this.textures = null),
              t && (this._texture?.destroy(), this.textureSource.destroy()),
              (this._texture = null),
              (this.textureSource = null),
              (this.linkedSheets = []);
          }
        };
        h.BATCH_SIZE = 1e3;
        let c = h;
        const d = [
          "jpg",
          "png",
          "jpeg",
          "avif",
          "webp",
          "basis",
          "etc2",
          "bc7",
          "bc6h",
          "bc5",
          "bc4",
          "bc3",
          "bc2",
          "bc1",
          "eac",
          "astc",
        ];
        function p(t, e, i) {
          const n = {};
          if (
            (t.forEach((t) => {
              n[t] = e;
            }),
            Object.keys(e.textures).forEach((t) => {
              n[t] = e.textures[t];
            }),
            !i)
          ) {
            const i = l.A.dirname(t[0]);
            e.linkedSheets.forEach((t, s) => {
              const r = p(
                [`${i}/${e.data.meta.related_multi_packs[s]}`],
                t,
                !0
              );
              Object.assign(n, r);
            });
          }
          return n;
        }
        const f = {
          extension: n.Ag.Asset,
          cache: {
            test: (t) => t instanceof c,
            getCacheableAssets: (t, e) => p(t, e, !1),
          },
          resolver: {
            test: (t) => {
              const e = t.split("?")[0].split("."),
                i = e.pop(),
                n = e.pop();
              return "json" === i && d.includes(n);
            },
            parse: (t) => {
              const e = t.split(".");
              return {
                resolution: parseFloat(r.x.RETINA_PREFIX.exec(t)?.[1] ?? "1"),
                format: e[e.length - 2],
                src: t,
              };
            },
          },
          loader: {
            name: "spritesheetLoader",
            extension: { type: n.Ag.LoadParser, priority: s.T.Normal },
            testParse: async (t, e) =>
              ".json" === l.A.extname(e.src).toLowerCase() && !!t.frames,
            async parse(t, e, i) {
              const { texture: n, imageFilename: s } = e?.data ?? {};
              let r,
                u = l.A.dirname(e.src);
              if (
                (u && u.lastIndexOf("/") !== u.length - 1 && (u += "/"),
                n instanceof a.g)
              )
                r = n;
              else {
                const n = (0, o.Y)(u + (s ?? t.meta.image), e.src);
                r = (await i.load([n]))[n];
              }
              const h = new c(r.source, t);
              await h.parse();
              const d = t?.meta?.related_multi_packs;
              if (Array.isArray(d)) {
                const t = [];
                for (const n of d) {
                  if ("string" != typeof n) continue;
                  let s = u + n;
                  e.data?.ignoreMultiPack ||
                    ((s = (0, o.Y)(s, e.src)),
                    t.push(i.load({ src: s, data: { ignoreMultiPack: !0 } })));
                }
                const n = await Promise.all(t);
                (h.linkedSheets = n),
                  n.forEach((t) => {
                    t.linkedSheets = [h].concat(
                      h.linkedSheets.filter((e) => e !== t)
                    );
                  });
              }
              return h;
            },
            async unload(t, e, i) {
              await i.unload(t.textureSource._sourceOrigin), t.destroy(!1);
            },
          },
        };
        n.XO.add(f);
      },
      7309: (t, e, i) => {
        "use strict";
        i.d(e, { R: () => o });
        var n = i(4458);
        class s {
          constructor(t, e = null, i = 0, n = !1) {
            (this.next = null),
              (this.previous = null),
              (this._destroyed = !1),
              (this._fn = t),
              (this._context = e),
              (this.priority = i),
              (this._once = n);
          }
          match(t, e = null) {
            return this._fn === t && this._context === e;
          }
          emit(t) {
            this._fn &&
              (this._context ? this._fn.call(this._context, t) : this._fn(t));
            const e = this.next;
            return (
              this._once && this.destroy(!0),
              this._destroyed && (this.next = null),
              e
            );
          }
          connect(t) {
            (this.previous = t),
              t.next && (t.next.previous = this),
              (this.next = t.next),
              (t.next = this);
          }
          destroy(t = !1) {
            (this._destroyed = !0),
              (this._fn = null),
              (this._context = null),
              this.previous && (this.previous.next = this.next),
              this.next && (this.next.previous = this.previous);
            const e = this.next;
            return (this.next = t ? null : e), (this.previous = null), e;
          }
        }
        const r = class t {
          constructor() {
            (this.autoStart = !1),
              (this.deltaTime = 1),
              (this.lastTime = -1),
              (this.speed = 1),
              (this.started = !1),
              (this._requestId = null),
              (this._maxElapsedMS = 100),
              (this._minElapsedMS = 0),
              (this._protected = !1),
              (this._lastFrame = -1),
              (this._head = new s(null, null, 1 / 0)),
              (this.deltaMS = 1 / t.targetFPMS),
              (this.elapsedMS = 1 / t.targetFPMS),
              (this._tick = (t) => {
                (this._requestId = null),
                  this.started &&
                    (this.update(t),
                    this.started &&
                      null === this._requestId &&
                      this._head.next &&
                      (this._requestId = requestAnimationFrame(this._tick)));
              });
          }
          _requestIfNeeded() {
            null === this._requestId &&
              this._head.next &&
              ((this.lastTime = performance.now()),
              (this._lastFrame = this.lastTime),
              (this._requestId = requestAnimationFrame(this._tick)));
          }
          _cancelIfNeeded() {
            null !== this._requestId &&
              (cancelAnimationFrame(this._requestId), (this._requestId = null));
          }
          _startIfPossible() {
            this.started
              ? this._requestIfNeeded()
              : this.autoStart && this.start();
          }
          add(t, e, i = n.d.NORMAL) {
            return this._addListener(new s(t, e, i));
          }
          addOnce(t, e, i = n.d.NORMAL) {
            return this._addListener(new s(t, e, i, !0));
          }
          _addListener(t) {
            let e = this._head.next,
              i = this._head;
            if (e) {
              for (; e; ) {
                if (t.priority > e.priority) {
                  t.connect(i);
                  break;
                }
                (i = e), (e = e.next);
              }
              t.previous || t.connect(i);
            } else t.connect(i);
            return this._startIfPossible(), this;
          }
          remove(t, e) {
            let i = this._head.next;
            for (; i; ) i = i.match(t, e) ? i.destroy() : i.next;
            return this._head.next || this._cancelIfNeeded(), this;
          }
          get count() {
            if (!this._head) return 0;
            let t = 0,
              e = this._head;
            for (; (e = e.next); ) t++;
            return t;
          }
          start() {
            this.started || ((this.started = !0), this._requestIfNeeded());
          }
          stop() {
            this.started && ((this.started = !1), this._cancelIfNeeded());
          }
          destroy() {
            if (!this._protected) {
              this.stop();
              let t = this._head.next;
              for (; t; ) t = t.destroy(!0);
              this._head.destroy(), (this._head = null);
            }
          }
          update(e = performance.now()) {
            let i;
            if (e > this.lastTime) {
              if (
                ((i = this.elapsedMS = e - this.lastTime),
                i > this._maxElapsedMS && (i = this._maxElapsedMS),
                (i *= this.speed),
                this._minElapsedMS)
              ) {
                const t = (e - this._lastFrame) | 0;
                if (t < this._minElapsedMS) return;
                this._lastFrame = e - (t % this._minElapsedMS);
              }
              (this.deltaMS = i),
                (this.deltaTime = this.deltaMS * t.targetFPMS);
              const n = this._head;
              let s = n.next;
              for (; s; ) s = s.emit(this);
              n.next || this._cancelIfNeeded();
            } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
            this.lastTime = e;
          }
          get FPS() {
            return 1e3 / this.elapsedMS;
          }
          get minFPS() {
            return 1e3 / this._maxElapsedMS;
          }
          set minFPS(e) {
            const i = Math.min(this.maxFPS, e),
              n = Math.min(Math.max(0, i) / 1e3, t.targetFPMS);
            this._maxElapsedMS = 1 / n;
          }
          get maxFPS() {
            return this._minElapsedMS
              ? Math.round(1e3 / this._minElapsedMS)
              : 0;
          }
          set maxFPS(t) {
            if (0 === t) this._minElapsedMS = 0;
            else {
              const e = Math.max(this.minFPS, t);
              this._minElapsedMS = 1 / (e / 1e3);
            }
          }
          static get shared() {
            if (!t._shared) {
              const e = (t._shared = new t());
              (e.autoStart = !0), (e._protected = !0);
            }
            return t._shared;
          }
          static get system() {
            if (!t._system) {
              const e = (t._system = new t());
              (e.autoStart = !0), (e._protected = !0);
            }
            return t._system;
          }
        };
        r.targetFPMS = 0.06;
        let o = r;
      },
      4458: (t, e, i) => {
        "use strict";
        i.d(e, { d: () => n });
        var n = ((t) => (
          (t[(t.INTERACTION = 50)] = "INTERACTION"),
          (t[(t.HIGH = 25)] = "HIGH"),
          (t[(t.NORMAL = 0)] = "NORMAL"),
          (t[(t.LOW = -25)] = "LOW"),
          (t[(t.UTILITY = -50)] = "UTILITY"),
          t
        ))(n || {});
      },
      6858: (t, e, i) => {
        "use strict";
        let n;
        async function s() {
          return (
            n ??
              (n = (async () => {
                const t = document.createElement("canvas").getContext("webgl");
                if (!t) return "premultiply-alpha-on-upload";
                const e = await new Promise((t) => {
                  const e = document.createElement("video");
                  (e.onloadeddata = () => t(e)),
                    (e.onerror = () => t(null)),
                    (e.autoplay = !1),
                    (e.crossOrigin = "anonymous"),
                    (e.preload = "auto"),
                    (e.src =
                      "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM="),
                    e.load();
                });
                if (!e) return "premultiply-alpha-on-upload";
                const i = t.createTexture();
                t.bindTexture(t.TEXTURE_2D, i);
                const n = t.createFramebuffer();
                t.bindFramebuffer(t.FRAMEBUFFER, n),
                  t.framebufferTexture2D(
                    t.FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0,
                    t.TEXTURE_2D,
                    i,
                    0
                  ),
                  t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                  t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE),
                  t.texImage2D(
                    t.TEXTURE_2D,
                    0,
                    t.RGBA,
                    t.RGBA,
                    t.UNSIGNED_BYTE,
                    e
                  );
                const s = new Uint8Array(4);
                return (
                  t.readPixels(0, 0, 1, 1, t.RGBA, t.UNSIGNED_BYTE, s),
                  t.deleteFramebuffer(n),
                  t.deleteTexture(i),
                  t.getExtension("WEBGL_lose_context")?.loseContext(),
                  s[0] <= s[3]
                    ? "premultiplied-alpha"
                    : "premultiply-alpha-on-upload"
                );
              })()),
            n
          );
        }
        i.d(e, { C: () => s });
      },
      7218: (t, e, i) => {
        "use strict";
        i.d(e, { F: () => b });
        var n = /iPhone/i,
          s = /iPod/i,
          r = /iPad/i,
          o = /\biOS-universal(?:.+)Mac\b/i,
          a = /\bAndroid(?:.+)Mobile\b/i,
          l = /Android/i,
          u = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
          h = /Silk/i,
          c = /Windows Phone/i,
          d = /\bWindows(?:.+)ARM\b/i,
          p = /BlackBerry/i,
          f = /BB10/i,
          m = /Opera Mini/i,
          g = /\b(CriOS|Chrome)(?:.+)Mobile/i,
          v = /Mobile(?:.+)Firefox\b/i,
          y = function (t) {
            return (
              void 0 !== t &&
              "MacIntel" === t.platform &&
              "number" == typeof t.maxTouchPoints &&
              t.maxTouchPoints > 1 &&
              "undefined" == typeof MSStream
            );
          };
        function x(t) {
          var e = { userAgent: "", platform: "", maxTouchPoints: 0 };
          t || "undefined" == typeof navigator
            ? "string" == typeof t
              ? (e.userAgent = t)
              : t &&
                t.userAgent &&
                (e = {
                  userAgent: t.userAgent,
                  platform: t.platform,
                  maxTouchPoints: t.maxTouchPoints || 0,
                })
            : (e = {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                maxTouchPoints: navigator.maxTouchPoints || 0,
              });
          var i = e.userAgent,
            x = i.split("[FBAN");
          void 0 !== x[1] && (i = x[0]),
            void 0 !== (x = i.split("Twitter"))[1] && (i = x[0]);
          var b = (function (t) {
              return function (e) {
                return e.test(t);
              };
            })(i),
            S = {
              apple: {
                phone: b(n) && !b(c),
                ipod: b(s),
                tablet: !b(n) && (b(r) || y(e)) && !b(c),
                universal: b(o),
                device: (b(n) || b(s) || b(r) || b(o) || y(e)) && !b(c),
              },
              amazon: {
                phone: b(u),
                tablet: !b(u) && b(h),
                device: b(u) || b(h),
              },
              android: {
                phone: (!b(c) && b(u)) || (!b(c) && b(a)),
                tablet: !b(c) && !b(u) && !b(a) && (b(h) || b(l)),
                device:
                  (!b(c) && (b(u) || b(h) || b(a) || b(l))) || b(/\bokhttp\b/i),
              },
              windows: { phone: b(c), tablet: b(d), device: b(c) || b(d) },
              other: {
                blackberry: b(p),
                blackberry10: b(f),
                opera: b(m),
                firefox: b(v),
                chrome: b(g),
                device: b(p) || b(f) || b(m) || b(v) || b(g),
              },
              any: !1,
              phone: !1,
              tablet: !1,
            };
          return (
            (S.any =
              S.apple.device ||
              S.android.device ||
              S.windows.device ||
              S.other.device),
            (S.phone = S.apple.phone || S.android.phone || S.windows.phone),
            (S.tablet = S.apple.tablet || S.android.tablet || S.windows.tablet),
            S
          );
        }
        const b = (x.default ?? x)(globalThis.navigator);
      },
      4577: (t, e, i) => {
        "use strict";
        let n;
        function s() {
          if ("boolean" == typeof n) return n;
          try {
            const t = new Function(
              "param1",
              "param2",
              "param3",
              "return param1[param2] === param3;"
            );
            n = !0 === t({ a: "b" }, "a", "b");
          } catch (t) {
            n = !1;
          }
          return n;
        }
        i.d(e, { f: () => s });
      },
      9903: (t, e, i) => {
        "use strict";
        function n(t, e, i) {
          const n = t.length;
          let s;
          if (e >= n || 0 === i) return;
          const r = n - (i = e + i > n ? n - e : i);
          for (s = e; s < r; ++s) t[s] = t[s + i];
          t.length = r;
        }
        i.d(e, { d: () => n });
      },
      133: (t, e, i) => {
        "use strict";
        i.d(e, { L: () => s });
        const n = { default: -1 };
        function s(t = "default") {
          return void 0 === n[t] && (n[t] = -1), ++n[t];
        }
      },
      2048: (t, e, i) => {
        "use strict";
        function n(t, e, i, n) {
          const { width: s, height: r } = i.orig,
            o = i.trim;
          if (o) {
            const i = o.width,
              a = o.height;
            (t.minX = o.x - e._x * s - n),
              (t.maxX = t.minX + i),
              (t.minY = o.y - e._y * r - n),
              (t.maxY = t.minY + a);
          } else
            (t.minX = -e._x * s - n),
              (t.maxX = t.minX + s),
              (t.minY = -e._y * r - n),
              (t.maxY = t.minY + r);
        }
        i.d(e, { y: () => n });
      },
      4670: (t, e, i) => {
        "use strict";
        i.d(e, { l: () => s, t: () => r });
        const n = {},
          s = "8.0.0";
        function r(t, e, i = 3) {
          if (n[e]) return;
          let s = new Error().stack;
          void 0 === s
            ? console.warn(
                "PixiJS Deprecation Warning: ",
                `${e}\nDeprecated since v${t}`
              )
            : ((s = s.split("\n").splice(i).join("\n")),
              console.groupCollapsed
                ? (console.groupCollapsed(
                    "%cPixiJS Deprecation Warning: %c%s",
                    "color:#614108;background:#fffbe6",
                    "font-weight:normal;color:#614108;background:#fffbe6",
                    `${e}\nDeprecated since v${t}`
                  ),
                  console.warn(s),
                  console.groupEnd())
                : (console.warn(
                    "PixiJS Deprecation Warning: ",
                    `${e}\nDeprecated since v${t}`
                  ),
                  console.warn(s))),
            (n[e] = !0);
        }
      },
      268: (t, e, i) => {
        "use strict";
        i.d(e, { R: () => r });
        let n = 0;
        const s = 500;
        function r(...t) {
          n !== s &&
            (n++,
            n === s
              ? console.warn(
                  "PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS."
                )
              : console.warn("PixiJS Warning: ", ...t));
        }
      },
      2927: (t, e, i) => {
        "use strict";
        i.d(e, { A: () => o });
        var n = i(1761);
        function s(t) {
          if ("string" != typeof t)
            throw new TypeError(
              `Path must be a string. Received ${JSON.stringify(t)}`
            );
        }
        function r(t) {
          return t.split("?")[0].split("#")[0];
        }
        const o = {
          toPosix(t) {
            return (
              (e = "\\"),
              (i = "/"),
              t.replace(
                new RegExp(e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "g"),
                i
              )
            );
            var e, i;
          },
          isUrl(t) {
            return /^https?:/.test(this.toPosix(t));
          },
          isDataUrl: (t) =>
            /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(
              t
            ),
          isBlobUrl: (t) => t.startsWith("blob:"),
          hasProtocol(t) {
            return /^[^/:]+:/.test(this.toPosix(t));
          },
          getProtocol(t) {
            s(t), (t = this.toPosix(t));
            const e = /^file:\/\/\//.exec(t);
            if (e) return e[0];
            const i = /^[^/:]+:\/{0,2}/.exec(t);
            return i ? i[0] : "";
          },
          toAbsolute(t, e, i) {
            if ((s(t), this.isDataUrl(t) || this.isBlobUrl(t))) return t;
            const a = r(this.toPosix(e ?? n.e.get().getBaseUrl())),
              l = r(this.toPosix(i ?? this.rootname(a)));
            if ((t = this.toPosix(t)).startsWith("/"))
              return o.join(l, t.slice(1));
            return this.isAbsolute(t) ? t : this.join(a, t);
          },
          normalize(t) {
            if ((s(t), 0 === t.length)) return ".";
            if (this.isDataUrl(t) || this.isBlobUrl(t)) return t;
            let e = "";
            const i = (t = this.toPosix(t)).startsWith("/");
            this.hasProtocol(t) &&
              ((e = this.rootname(t)), (t = t.slice(e.length)));
            const n = t.endsWith("/");
            return (
              (t = (function (t, e) {
                let i = "",
                  n = 0,
                  s = -1,
                  r = 0,
                  o = -1;
                for (let a = 0; a <= t.length; ++a) {
                  if (a < t.length) o = t.charCodeAt(a);
                  else {
                    if (47 === o) break;
                    o = 47;
                  }
                  if (47 === o) {
                    if (s === a - 1 || 1 === r);
                    else if (s !== a - 1 && 2 === r) {
                      if (
                        i.length < 2 ||
                        2 !== n ||
                        46 !== i.charCodeAt(i.length - 1) ||
                        46 !== i.charCodeAt(i.length - 2)
                      )
                        if (i.length > 2) {
                          const t = i.lastIndexOf("/");
                          if (t !== i.length - 1) {
                            -1 === t
                              ? ((i = ""), (n = 0))
                              : ((i = i.slice(0, t)),
                                (n = i.length - 1 - i.lastIndexOf("/"))),
                              (s = a),
                              (r = 0);
                            continue;
                          }
                        } else if (2 === i.length || 1 === i.length) {
                          (i = ""), (n = 0), (s = a), (r = 0);
                          continue;
                        }
                      e && (i.length > 0 ? (i += "/..") : (i = ".."), (n = 2));
                    } else
                      i.length > 0
                        ? (i += `/${t.slice(s + 1, a)}`)
                        : (i = t.slice(s + 1, a)),
                        (n = a - s - 1);
                    (s = a), (r = 0);
                  } else 46 === o && -1 !== r ? ++r : (r = -1);
                }
                return i;
              })(t, !1)).length > 0 &&
                n &&
                (t += "/"),
              i ? `/${t}` : e + t
            );
          },
          isAbsolute(t) {
            return (
              s(t),
              (t = this.toPosix(t)),
              !!this.hasProtocol(t) || t.startsWith("/")
            );
          },
          join(...t) {
            if (0 === t.length) return ".";
            let e;
            for (let i = 0; i < t.length; ++i) {
              const n = t[i];
              if ((s(n), n.length > 0))
                if (void 0 === e) e = n;
                else {
                  const s = t[i - 1] ?? "";
                  this.joinExtensions.includes(this.extname(s).toLowerCase())
                    ? (e += `/../${n}`)
                    : (e += `/${n}`);
                }
            }
            return void 0 === e ? "." : this.normalize(e);
          },
          dirname(t) {
            if ((s(t), 0 === t.length)) return ".";
            let e = (t = this.toPosix(t)).charCodeAt(0);
            const i = 47 === e;
            let n = -1,
              r = !0;
            const o = this.getProtocol(t),
              a = t;
            for (let i = (t = t.slice(o.length)).length - 1; i >= 1; --i)
              if (((e = t.charCodeAt(i)), 47 === e)) {
                if (!r) {
                  n = i;
                  break;
                }
              } else r = !1;
            return -1 === n
              ? i
                ? "/"
                : this.isUrl(a)
                ? o + t
                : o
              : i && 1 === n
              ? "//"
              : o + t.slice(0, n);
          },
          rootname(t) {
            s(t);
            let e = "";
            if (
              ((e = (t = this.toPosix(t)).startsWith("/")
                ? "/"
                : this.getProtocol(t)),
              this.isUrl(t))
            ) {
              const i = t.indexOf("/", e.length);
              (e = -1 !== i ? t.slice(0, i) : t), e.endsWith("/") || (e += "/");
            }
            return e;
          },
          basename(t, e) {
            s(t), e && s(e), (t = r(this.toPosix(t)));
            let i,
              n = 0,
              o = -1,
              a = !0;
            if (void 0 !== e && e.length > 0 && e.length <= t.length) {
              if (e.length === t.length && e === t) return "";
              let s = e.length - 1,
                r = -1;
              for (i = t.length - 1; i >= 0; --i) {
                const l = t.charCodeAt(i);
                if (47 === l) {
                  if (!a) {
                    n = i + 1;
                    break;
                  }
                } else
                  -1 === r && ((a = !1), (r = i + 1)),
                    s >= 0 &&
                      (l === e.charCodeAt(s)
                        ? -1 == --s && (o = i)
                        : ((s = -1), (o = r)));
              }
              return (
                n === o ? (o = r) : -1 === o && (o = t.length), t.slice(n, o)
              );
            }
            for (i = t.length - 1; i >= 0; --i)
              if (47 === t.charCodeAt(i)) {
                if (!a) {
                  n = i + 1;
                  break;
                }
              } else -1 === o && ((a = !1), (o = i + 1));
            return -1 === o ? "" : t.slice(n, o);
          },
          extname(t) {
            s(t);
            let e = -1,
              i = 0,
              n = -1,
              o = !0,
              a = 0;
            for (let s = (t = r(this.toPosix(t))).length - 1; s >= 0; --s) {
              const r = t.charCodeAt(s);
              if (47 !== r)
                -1 === n && ((o = !1), (n = s + 1)),
                  46 === r
                    ? -1 === e
                      ? (e = s)
                      : 1 !== a && (a = 1)
                    : -1 !== e && (a = -1);
              else if (!o) {
                i = s + 1;
                break;
              }
            }
            return -1 === e ||
              -1 === n ||
              0 === a ||
              (1 === a && e === n - 1 && e === i + 1)
              ? ""
              : t.slice(e, n);
          },
          parse(t) {
            s(t);
            const e = { root: "", dir: "", base: "", ext: "", name: "" };
            if (0 === t.length) return e;
            let i = (t = r(this.toPosix(t))).charCodeAt(0);
            const n = this.isAbsolute(t);
            let o;
            (e.root = this.rootname(t)), (o = n || this.hasProtocol(t) ? 1 : 0);
            let a = -1,
              l = 0,
              u = -1,
              h = !0,
              c = t.length - 1,
              d = 0;
            for (; c >= o; --c)
              if (((i = t.charCodeAt(c)), 47 !== i))
                -1 === u && ((h = !1), (u = c + 1)),
                  46 === i
                    ? -1 === a
                      ? (a = c)
                      : 1 !== d && (d = 1)
                    : -1 !== a && (d = -1);
              else if (!h) {
                l = c + 1;
                break;
              }
            return (
              -1 === a ||
              -1 === u ||
              0 === d ||
              (1 === d && a === u - 1 && a === l + 1)
                ? -1 !== u &&
                  (e.base = e.name =
                    0 === l && n ? t.slice(1, u) : t.slice(l, u))
                : (0 === l && n
                    ? ((e.name = t.slice(1, a)), (e.base = t.slice(1, u)))
                    : ((e.name = t.slice(l, a)), (e.base = t.slice(l, u))),
                  (e.ext = t.slice(a, u))),
              (e.dir = this.dirname(t)),
              e
            );
          },
          sep: "/",
          delimiter: ":",
          joinExtensions: [".html"],
        };
      },
      8425: (t, e, i) => {
        "use strict";
        i.d(e, { b: () => n });
        class n {
          constructor(t, e) {
            (this._pool = []),
              (this._count = 0),
              (this._index = 0),
              (this._classType = t),
              e && this.prepopulate(e);
          }
          prepopulate(t) {
            for (let e = 0; e < t; e++)
              this._pool[this._index++] = new this._classType();
            this._count += t;
          }
          get(t) {
            let e;
            return (
              (e =
                this._index > 0
                  ? this._pool[--this._index]
                  : new this._classType()),
              e.init?.(t),
              e
            );
          }
          return(t) {
            t.reset?.(), (this._pool[this._index++] = t);
          }
          get totalSize() {
            return this._count;
          }
          get totalFree() {
            return this._index;
          }
          get totalUsed() {
            return this._count - this._index;
          }
        }
      },
      8218: (t, e, i) => {
        "use strict";
        i.d(e, { Z: () => s });
        var n = i(8425);
        const s = new (class {
          constructor() {
            this._poolsByClass = new Map();
          }
          prepopulate(t, e) {
            this.getPool(t).prepopulate(e);
          }
          get(t, e) {
            return this.getPool(t).get(e);
          }
          return(t) {
            this.getPool(t.constructor).return(t);
          }
          getPool(t) {
            return (
              this._poolsByClass.has(t) ||
                this._poolsByClass.set(t, new n.b(t)),
              this._poolsByClass.get(t)
            );
          }
          stats() {
            const t = {};
            return (
              this._poolsByClass.forEach((e) => {
                const i = t[e._classType.name]
                  ? e._classType.name + e._classType.ID
                  : e._classType.name;
                t[i] = {
                  free: e.totalFree,
                  used: e.totalUsed,
                  size: e.totalSize,
                };
              }),
              t
            );
          }
        })();
      },
    },
    i = {};
  function n(t) {
    var s = i[t];
    if (void 0 !== s) return s.exports;
    var r = (i[t] = { id: t, loaded: !1, exports: {} });
    return e[t].call(r.exports, r, r.exports, n), (r.loaded = !0), r.exports;
  }
  (n.m = e),
    (n.n = (t) => {
      var e = t && t.__esModule ? () => t.default : () => t;
      return n.d(e, { a: e }), e;
    }),
    (n.d = (t, e) => {
      for (var i in e)
        n.o(e, i) &&
          !n.o(t, i) &&
          Object.defineProperty(t, i, { enumerable: !0, get: e[i] });
    }),
    (n.f = {}),
    (n.e = (t) =>
      Promise.all(Object.keys(n.f).reduce((e, i) => (n.f[i](t, e), e), []))),
    (n.u = (t) => t + ".script.js"),
    (n.g = (function () {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (t) {
        if ("object" == typeof window) return window;
      }
    })()),
    (n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
    (t = {}),
    (n.l = (e, i, s, r) => {
      if (t[e]) t[e].push(i);
      else {
        var o, a;
        if (void 0 !== s)
          for (
            var l = document.getElementsByTagName("script"), u = 0;
            u < l.length;
            u++
          ) {
            var h = l[u];
            if (h.getAttribute("src") == e) {
              o = h;
              break;
            }
          }
        o ||
          ((a = !0),
          ((o = document.createElement("script")).charset = "utf-8"),
          (o.timeout = 120),
          n.nc && o.setAttribute("nonce", n.nc),
          (o.src = e)),
          (t[e] = [i]);
        var c = (i, n) => {
            (o.onerror = o.onload = null), clearTimeout(d);
            var s = t[e];
            if (
              (delete t[e],
              o.parentNode && o.parentNode.removeChild(o),
              s && s.forEach((t) => t(n)),
              i)
            )
              return i(n);
          },
          d = setTimeout(
            c.bind(null, void 0, { type: "timeout", target: o }),
            12e4
          );
        (o.onerror = c.bind(null, o.onerror)),
          (o.onload = c.bind(null, o.onload)),
          a && document.head.appendChild(o);
      }
    }),
    (n.r = (t) => {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(t, "__esModule", { value: !0 });
    }),
    (n.nmd = (t) => ((t.paths = []), t.children || (t.children = []), t)),
    (() => {
      var t;
      n.g.importScripts && (t = n.g.location + "");
      var e = n.g.document;
      if (!t && e && (e.currentScript && (t = e.currentScript.src), !t)) {
        var i = e.getElementsByTagName("script");
        if (i.length)
          for (var s = i.length - 1; s > -1 && (!t || !/^http(s?):/.test(t)); )
            t = i[s--].src;
      }
      if (!t)
        throw new Error(
          "Automatic publicPath is not supported in this browser"
        );
      (t = t
        .replace(/#.*$/, "")
        .replace(/\?.*$/, "")
        .replace(/\/[^\/]+$/, "/")),
        (n.p = t);
    })(),
    (() => {
      var t = { 792: 0 };
      n.f.j = (e, i) => {
        var s = n.o(t, e) ? t[e] : void 0;
        if (0 !== s)
          if (s) i.push(s[2]);
          else {
            var r = new Promise((i, n) => (s = t[e] = [i, n]));
            i.push((s[2] = r));
            var o = n.p + n.u(e),
              a = new Error();
            n.l(
              o,
              (i) => {
                if (n.o(t, e) && (0 !== (s = t[e]) && (t[e] = void 0), s)) {
                  var r = i && ("load" === i.type ? "missing" : i.type),
                    o = i && i.target && i.target.src;
                  (a.message =
                    "Loading chunk " + e + " failed.\n(" + r + ": " + o + ")"),
                    (a.name = "ChunkLoadError"),
                    (a.type = r),
                    (a.request = o),
                    s[1](a);
                }
              },
              "chunk-" + e,
              e
            );
          }
      };
      var e = (e, i) => {
          var s,
            r,
            [o, a, l] = i,
            u = 0;
          if (o.some((e) => 0 !== t[e])) {
            for (s in a) n.o(a, s) && (n.m[s] = a[s]);
            if (l) l(n);
          }
          for (e && e(i); u < o.length; u++)
            (r = o[u]), n.o(t, r) && t[r] && t[r][0](), (t[r] = 0);
        },
        i = (self.webpackChunk = self.webpackChunk || []);
      i.forEach(e.bind(null, 0)), (i.push = e.bind(null, i.push.bind(i)));
    })(),
    (() => {
      "use strict";
      var t = n(8507);
      const e = {
          extension: { type: t.Ag.Environment, name: "browser", priority: -1 },
          test: () => !0,
          load: async () => {
            await Promise.all([n.e(72), n.e(376)]).then(n.bind(n, 376));
          },
        },
        i = {
          extension: { type: t.Ag.Environment, name: "webworker", priority: 0 },
          test: () =>
            "undefined" != typeof self && void 0 !== self.WorkerGlobalScope,
          load: async () => {
            await Promise.all([n.e(72), n.e(162)]).then(n.bind(n, 2162));
          },
        };
      n(8480), n(9010);
      var s = n(268);
      class r {
        constructor(t, e = !1) {
          (this._loader = t),
            (this._assetList = []),
            (this._isLoading = !1),
            (this._maxConcurrent = 1),
            (this.verbose = e);
        }
        add(t) {
          t.forEach((t) => {
            this._assetList.push(t);
          }),
            this.verbose &&
              console.log("[BackgroundLoader] assets: ", this._assetList),
            this._isActive && !this._isLoading && this._next();
        }
        async _next() {
          if (this._assetList.length && this._isActive) {
            this._isLoading = !0;
            const t = [],
              e = Math.min(this._assetList.length, this._maxConcurrent);
            for (let i = 0; i < e; i++) t.push(this._assetList.pop());
            await this._loader.load(t), (this._isLoading = !1), this._next();
          }
        }
        get active() {
          return this._isActive;
        }
        set active(t) {
          this._isActive !== t &&
            ((this._isActive = t), t && !this._isLoading && this._next());
        }
      }
      var o = n(1979),
        a = n(4492);
      const l = {
        extension: t.Ag.CacheParser,
        test: (t) => Array.isArray(t) && t.every((t) => t instanceof a.g),
        getCacheableAssets: (t, e) => {
          const i = {};
          return (
            t.forEach((t) => {
              e.forEach((e, n) => {
                i[t + (0 === n ? "" : n + 1)] = e;
              });
            }),
            i
          );
        },
      };
      async function u(t) {
        if ("Image" in globalThis)
          return new Promise((e) => {
            const i = new Image();
            (i.onload = () => {
              e(!0);
            }),
              (i.onerror = () => {
                e(!1);
              }),
              (i.src = t);
          });
        if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
          try {
            const e = await (await fetch(t)).blob();
            await createImageBitmap(e);
          } catch (t) {
            return !1;
          }
          return !0;
        }
        return !1;
      }
      const h = {
          extension: { type: t.Ag.DetectionParser, priority: 1 },
          test: async () =>
            u(
              "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
            ),
          add: async (t) => [...t, "avif"],
          remove: async (t) => t.filter((t) => "avif" !== t),
        },
        c = ["png", "jpg", "jpeg"],
        d = {
          extension: { type: t.Ag.DetectionParser, priority: -1 },
          test: () => Promise.resolve(!0),
          add: async (t) => [...t, ...c],
          remove: async (t) => t.filter((t) => !c.includes(t)),
        },
        p =
          "WorkerGlobalScope" in globalThis &&
          globalThis instanceof globalThis.WorkerGlobalScope;
      function f(t) {
        if (p) return !1;
        return "" !== document.createElement("video").canPlayType(t);
      }
      const m = {
          extension: { type: t.Ag.DetectionParser, priority: 0 },
          test: async () => f("video/mp4"),
          add: async (t) => [...t, "mp4", "m4v"],
          remove: async (t) => t.filter((t) => "mp4" !== t && "m4v" !== t),
        },
        g = {
          extension: { type: t.Ag.DetectionParser, priority: 0 },
          test: async () => f("video/ogg"),
          add: async (t) => [...t, "ogv"],
          remove: async (t) => t.filter((t) => "ogv" !== t),
        },
        v = {
          extension: { type: t.Ag.DetectionParser, priority: 0 },
          test: async () => f("video/webm"),
          add: async (t) => [...t, "webm"],
          remove: async (t) => t.filter((t) => "webm" !== t),
        },
        y = {
          extension: { type: t.Ag.DetectionParser, priority: 0 },
          test: async () =>
            u(
              "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
            ),
          add: async (t) => [...t, "webp"],
          remove: async (t) => t.filter((t) => "webp" !== t),
        };
      var x = n(2927),
        b = n(2406),
        S = n(2217);
      class C {
        constructor() {
          (this._parsers = []),
            (this._parsersValidated = !1),
            (this.parsers = new Proxy(this._parsers, {
              set: (t, e, i) => ((this._parsersValidated = !1), (t[e] = i), !0),
            })),
            (this.promiseCache = {});
        }
        reset() {
          (this._parsersValidated = !1), (this.promiseCache = {});
        }
        _getLoadPromiseAndParser(t, e) {
          const i = { promise: null, parser: null };
          return (
            (i.promise = (async () => {
              let n = null,
                r = null;
              if (
                (e.loadParser &&
                  ((r = this._parserHash[e.loadParser]),
                  r ||
                    (0, s.R)(
                      `[Assets] specified load parser "${e.loadParser}" not found while loading ${t}`
                    )),
                !r)
              ) {
                for (let i = 0; i < this.parsers.length; i++) {
                  const n = this.parsers[i];
                  if (n.load && n.test?.(t, e, this)) {
                    r = n;
                    break;
                  }
                }
                if (!r)
                  return (
                    (0, s.R)(
                      `[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`
                    ),
                    null
                  );
              }
              (n = await r.load(t, e, this)), (i.parser = r);
              for (let t = 0; t < this.parsers.length; t++) {
                const s = this.parsers[t];
                s.parse &&
                  s.parse &&
                  (await s.testParse?.(n, e, this)) &&
                  ((n = (await s.parse(n, e, this)) || n), (i.parser = s));
              }
              return n;
            })()),
            i
          );
        }
        async load(t, e) {
          this._parsersValidated || this._validateParsers();
          let i = 0;
          const n = {},
            s = (0, S.a)(t),
            r = (0, b.z)(t, (t) => ({ alias: [t], src: t })),
            o = r.length,
            a = r.map(async (t) => {
              const s = x.A.toAbsolute(t.src);
              if (!n[t.src])
                try {
                  this.promiseCache[s] ||
                    (this.promiseCache[s] = this._getLoadPromiseAndParser(
                      s,
                      t
                    )),
                    (n[t.src] = await this.promiseCache[s].promise),
                    e && e(++i / o);
                } catch (e) {
                  throw (
                    (delete this.promiseCache[s],
                    delete n[t.src],
                    new Error(`[Loader.load] Failed to load ${s}.\n${e}`))
                  );
                }
            });
          return await Promise.all(a), s ? n[r[0].src] : n;
        }
        async unload(t) {
          const e = (0, b.z)(t, (t) => ({ alias: [t], src: t })).map(
            async (t) => {
              const e = x.A.toAbsolute(t.src),
                i = this.promiseCache[e];
              if (i) {
                const n = await i.promise;
                delete this.promiseCache[e],
                  await i.parser?.unload?.(n, t, this);
              }
            }
          );
          await Promise.all(e);
        }
        _validateParsers() {
          (this._parsersValidated = !0),
            (this._parserHash = this._parsers
              .filter((t) => t.name)
              .reduce(
                (t, e) => (
                  e.name
                    ? t[e.name] &&
                      (0, s.R)(`[Assets] loadParser name conflict "${e.name}"`)
                    : (0, s.R)("[Assets] loadParser should have a name"),
                  { ...t, [e.name]: e }
                ),
                {}
              ));
        }
      }
      var _ = n(1761);
      function T(t, e) {
        if (Array.isArray(e)) {
          for (const i of e) if (t.startsWith(`data:${i}`)) return !0;
          return !1;
        }
        return t.startsWith(`data:${e}`);
      }
      function w(t, e) {
        const i = t.split("?")[0],
          n = x.A.extname(i).toLowerCase();
        return Array.isArray(e) ? e.includes(n) : n === e;
      }
      var P = n(4589);
      const A = {
          extension: { type: t.Ag.LoadParser, priority: P.T.Low },
          name: "loadJson",
          test: (t) => T(t, "application/json") || w(t, ".json"),
          async load(t) {
            const e = await _.e.get().fetch(t);
            return await e.json();
          },
        },
        k = {
          name: "loadTxt",
          extension: { type: t.Ag.LoadParser, priority: P.T.Low },
          test: (t) => T(t, "text/plain") || w(t, ".txt"),
          async load(t) {
            const e = await _.e.get().fetch(t);
            return await e.text();
          },
        },
        M = [
          "normal",
          "bold",
          "100",
          "200",
          "300",
          "400",
          "500",
          "600",
          "700",
          "800",
          "900",
        ],
        E = [".ttf", ".otf", ".woff", ".woff2"],
        I = ["font/ttf", "font/otf", "font/woff", "font/woff2"],
        D = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;
      const R = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
      const B = {
        extension: { type: t.Ag.LoadParser, priority: P.T.Low },
        name: "loadWebFont",
        test: (t) => T(t, I) || w(t, E),
        async load(t, e) {
          const i = _.e.get().getFontFaceSet();
          if (i) {
            const s = [],
              r =
                e.data?.family ??
                (function (t) {
                  const e = x.A.extname(t),
                    i = x.A.basename(t, e)
                      .replace(/(-|_)/g, " ")
                      .toLowerCase()
                      .split(" ")
                      .map((t) => t.charAt(0).toUpperCase() + t.slice(1));
                  let n = i.length > 0;
                  for (const t of i)
                    if (!t.match(D)) {
                      n = !1;
                      break;
                    }
                  let s = i.join(" ");
                  return n || (s = `"${s.replace(/[\\"]/g, "\\$&")}"`), s;
                })(t),
              a = e.data?.weights?.filter((t) => M.includes(t)) ?? ["normal"],
              l = e.data ?? {};
            for (let e = 0; e < a.length; e++) {
              const o = a[e],
                u = new FontFace(
                  r,
                  `url(${((n = t), R.test(n) ? n : encodeURI(n))})`,
                  { ...l, weight: o }
                );
              await u.load(), i.add(u), s.push(u);
            }
            return (
              o.l.set(`${r}-and-url`, { url: t, fontFaces: s }),
              1 === s.length ? s[0] : s
            );
          }
          var n;
          return (
            (0, s.R)(
              "[loadWebFont] FontFace API is not supported. Skipping loading font"
            ),
            null
          );
        },
        unload(t) {
          (Array.isArray(t) ? t : [t]).forEach((t) => {
            o.l.remove(t.family), _.e.get().getFontFaceSet().delete(t);
          });
        },
      };
      var F = n(8293),
        O = n(4835),
        z = n(1173);
      function L(t, e = 1) {
        const i = z.x.RETINA_PREFIX?.exec(t);
        return i ? parseFloat(i[1]) : e;
      }
      function H(t, e, i) {
        (t.label = i), (t._sourceOrigin = i);
        const n = new a.g({ source: t, label: i }),
          r = () => {
            delete e.promiseCache[i], o.l.has(i) && o.l.remove(i);
          };
        return (
          n.source.once("destroy", () => {
            e.promiseCache[i] &&
              ((0, s.R)(
                "[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."
              ),
              r());
          }),
          n.once("destroy", () => {
            t.destroyed ||
              ((0, s.R)(
                "[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."
              ),
              r());
          }),
          n
        );
      }
      const U = {
        extension: { type: t.Ag.LoadParser, priority: P.T.Low },
        name: "loadSVG",
        config: { crossOrigin: "anonymous", parseAsGraphicsContext: !1 },
        test: (t) => T(t, "image/svg+xml") || w(t, ".svg"),
        async load(t, e, i) {
          return e.data.parseAsGraphicsContext ??
            this.config.parseAsGraphicsContext
            ? (async function (t) {
                const e = await _.e.get().fetch(t),
                  i = await e.text(),
                  n = new O.T();
                return n.svg(i), n;
              })(t)
            : (async function (t, e, i, n) {
                const s = await _.e.get().fetch(t),
                  r = await s.blob(),
                  o = URL.createObjectURL(r),
                  a = new Image();
                (a.src = o),
                  (a.crossOrigin = n),
                  await a.decode(),
                  URL.revokeObjectURL(o);
                const l = document.createElement("canvas"),
                  u = l.getContext("2d"),
                  h = e.data?.resolution || L(t),
                  c = e.data?.width ?? a.width,
                  d = e.data?.height ?? a.height;
                (l.width = c * h),
                  (l.height = d * h),
                  u.drawImage(a, 0, 0, c * h, d * h);
                const { parseAsGraphicsContext: p, ...f } = e.data;
                return H(
                  new F.b({
                    resource: l,
                    alphaMode: "premultiply-alpha-on-upload",
                    resolution: h,
                    ...f,
                  }),
                  i,
                  t
                );
              })(t, e, i, this.config.crossOrigin);
        },
        unload(t) {
          t.destroy(!0);
        },
      };
      let N = null;
      class G {
        constructor() {
          N ||
            (N = URL.createObjectURL(
              new Blob(
                [
                  '(function () {\n    \'use strict\';\n\n    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";\n    async function checkImageBitmap() {\n      try {\n        if (typeof createImageBitmap !== "function")\n          return false;\n        const response = await fetch(WHITE_PNG);\n        const imageBlob = await response.blob();\n        const imageBitmap = await createImageBitmap(imageBlob);\n        return imageBitmap.width === 1 && imageBitmap.height === 1;\n      } catch (e) {\n        return false;\n      }\n    }\n    void checkImageBitmap().then((result) => {\n      self.postMessage(result);\n    });\n\n})();\n',
                ],
                { type: "application/javascript" }
              )
            )),
            (this.worker = new Worker(N));
        }
      }
      G.revokeObjectURL = function () {
        N && (URL.revokeObjectURL(N), (N = null));
      };
      let V = null;
      class j {
        constructor() {
          V ||
            (V = URL.createObjectURL(
              new Blob(
                [
                  "(function () {\n    'use strict';\n\n    async function loadImageBitmap(url) {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`[WorkerManager.loadImageBitmap] Failed to fetch ${url}: ${response.status} ${response.statusText}`);\n      }\n      const imageBlob = await response.blob();\n      const imageBitmap = await createImageBitmap(imageBlob);\n      return imageBitmap;\n    }\n    self.onmessage = async (event) => {\n      try {\n        const imageBitmap = await loadImageBitmap(event.data.data[0]);\n        self.postMessage({\n          data: imageBitmap,\n          uuid: event.data.uuid,\n          id: event.data.id\n        }, [imageBitmap]);\n      } catch (e) {\n        self.postMessage({\n          error: e,\n          uuid: event.data.uuid,\n          id: event.data.id\n        });\n      }\n    };\n\n})();\n",
                ],
                { type: "application/javascript" }
              )
            )),
            (this.worker = new Worker(V));
        }
      }
      j.revokeObjectURL = function () {
        V && (URL.revokeObjectURL(V), (V = null));
      };
      let $,
        q = 0;
      const W = new (class {
          constructor() {
            (this._initialized = !1),
              (this._createdWorkers = 0),
              (this._workerPool = []),
              (this._queue = []),
              (this._resolveHash = {});
          }
          isImageBitmapSupported() {
            return (
              void 0 !== this._isImageBitmapSupported ||
                (this._isImageBitmapSupported = new Promise((t) => {
                  const { worker: e } = new G();
                  e.addEventListener("message", (i) => {
                    e.terminate(), G.revokeObjectURL(), t(i.data);
                  });
                })),
              this._isImageBitmapSupported
            );
          }
          loadImageBitmap(t) {
            return this._run("loadImageBitmap", [t]);
          }
          async _initWorkers() {
            this._initialized || (this._initialized = !0);
          }
          _getWorker() {
            void 0 === $ && ($ = navigator.hardwareConcurrency || 4);
            let t = this._workerPool.pop();
            return (
              !t &&
                this._createdWorkers < $ &&
                (this._createdWorkers++,
                (t = new j().worker),
                t.addEventListener("message", (t) => {
                  this._complete(t.data),
                    this._returnWorker(t.target),
                    this._next();
                })),
              t
            );
          }
          _returnWorker(t) {
            this._workerPool.push(t);
          }
          _complete(t) {
            void 0 !== t.error
              ? this._resolveHash[t.uuid].reject(t.error)
              : this._resolveHash[t.uuid].resolve(t.data),
              (this._resolveHash[t.uuid] = null);
          }
          async _run(t, e) {
            await this._initWorkers();
            const i = new Promise((i, n) => {
              this._queue.push({ id: t, arguments: e, resolve: i, reject: n });
            });
            return this._next(), i;
          }
          _next() {
            if (!this._queue.length) return;
            const t = this._getWorker();
            if (!t) return;
            const e = this._queue.pop(),
              i = e.id;
            (this._resolveHash[q] = { resolve: e.resolve, reject: e.reject }),
              t.postMessage({ data: e.arguments, uuid: q++, id: i });
          }
        })(),
        X = [".jpeg", ".jpg", ".png", ".webp", ".avif"],
        Y = ["image/jpeg", "image/png", "image/webp", "image/avif"];
      const K = {
        name: "loadTextures",
        extension: { type: t.Ag.LoadParser, priority: P.T.High },
        config: {
          preferWorkers: !0,
          preferCreateImageBitmap: !0,
          crossOrigin: "anonymous",
        },
        test: (t) => T(t, Y) || w(t, X),
        async load(t, e, i) {
          let n = null;
          n =
            globalThis.createImageBitmap && this.config.preferCreateImageBitmap
              ? this.config.preferWorkers && (await W.isImageBitmapSupported())
                ? await W.loadImageBitmap(t)
                : await (async function (t) {
                    const e = await _.e.get().fetch(t);
                    if (!e.ok)
                      throw new Error(
                        `[loadImageBitmap] Failed to fetch ${t}: ${e.status} ${e.statusText}`
                      );
                    const i = await e.blob();
                    return await createImageBitmap(i);
                  })(t)
              : await new Promise((e) => {
                  (n = new Image()),
                    (n.crossOrigin = this.config.crossOrigin),
                    (n.src = t),
                    n.complete
                      ? e(n)
                      : (n.onload = () => {
                          e(n);
                        });
                });
          return H(
            new F.b({
              resource: n,
              alphaMode: "premultiply-alpha-on-upload",
              resolution: e.data?.resolution || L(t),
              ...e.data,
            }),
            i,
            t
          );
        },
        unload(t) {
          t.destroy(!0);
        },
      };
      var Z = n(6139),
        Q = n(6858);
      const J = [
          ".mp4",
          ".m4v",
          ".webm",
          ".ogg",
          ".ogv",
          ".h264",
          ".avi",
          ".mov",
        ],
        tt = J.map((t) => `video/${t.substring(1)}`);
      function et(t, e, i) {
        void 0 !== i || e.startsWith("data:")
          ? !1 !== i && (t.crossOrigin = "string" == typeof i ? i : "anonymous")
          : (t.crossOrigin = (function (t, e = globalThis.location) {
              if (t.startsWith("data:")) return "";
              e = e || globalThis.location;
              const i = new URL(t, document.baseURI);
              if (
                i.hostname !== e.hostname ||
                i.port !== e.port ||
                i.protocol !== e.protocol
              )
                return "anonymous";
              return "";
            })(e));
      }
      const it = {
          name: "loadVideo",
          extension: { type: t.Ag.LoadParser },
          config: null,
          test(t) {
            const e = T(t, tt),
              i = w(t, J);
            return e || i;
          },
          async load(t, e, i) {
            const n = {
                ...Z.$.defaultOptions,
                resolution: e.data?.resolution || L(t),
                alphaMode: e.data?.alphaMode || (await (0, Q.C)()),
                ...e.data,
              },
              s = document.createElement("video"),
              r = {
                preload: !1 !== n.autoLoad ? "auto" : void 0,
                "webkit-playsinline": !1 !== n.playsinline ? "" : void 0,
                playsinline: !1 !== n.playsinline ? "" : void 0,
                muted: !0 === n.muted ? "" : void 0,
                loop: !0 === n.loop ? "" : void 0,
                autoplay: !1 !== n.autoPlay ? "" : void 0,
              };
            Object.keys(r).forEach((t) => {
              const e = r[t];
              void 0 !== e && s.setAttribute(t, e);
            }),
              !0 === n.muted && (s.muted = !0),
              et(s, t, n.crossorigin);
            const o = document.createElement("source");
            let a;
            if (t.startsWith("data:")) a = t.slice(5, t.indexOf(";"));
            else if (!t.startsWith("blob:")) {
              const e = t
                .split("?")[0]
                .slice(t.lastIndexOf(".") + 1)
                .toLowerCase();
              a = Z.$.MIME_TYPES[e] || `video/${e}`;
            }
            return (
              (o.src = t),
              a && (o.type = a),
              new Promise((r) => {
                const a = async () => {
                  const o = new Z.$({ ...n, resource: s });
                  var l;
                  s.removeEventListener("canplay", a),
                    e.data.preload &&
                      (await ((l = s),
                      new Promise((t, e) => {
                        function i() {
                          s(), t();
                        }
                        function n(t) {
                          s(), e(t);
                        }
                        function s() {
                          l.removeEventListener("canplaythrough", i),
                            l.removeEventListener("error", n);
                        }
                        l.addEventListener("canplaythrough", i),
                          l.addEventListener("error", n),
                          l.load();
                      }))),
                    r(H(o, i, t));
                };
                s.addEventListener("canplay", a), s.appendChild(o);
              })
            );
          },
          unload(t) {
            t.destroy(!0);
          },
        },
        nt = {
          extension: t.Ag.ResolveParser,
          test: K.test,
          parse: (t) => ({
            resolution: parseFloat(z.x.RETINA_PREFIX.exec(t)?.[1] ?? "1"),
            format: t.split(".").pop(),
            src: t,
          }),
        },
        st = {
          extension: t.Ag.ResolveParser,
          test: (t) => z.x.RETINA_PREFIX.test(t) && t.endsWith(".json"),
          parse: nt.parse,
        };
      const rt = new (class {
        constructor() {
          (this._detections = []),
            (this._initialized = !1),
            (this.resolver = new z.x()),
            (this.loader = new C()),
            (this.cache = o.l),
            (this._backgroundLoader = new r(this.loader)),
            (this._backgroundLoader.active = !0),
            this.reset();
        }
        async init(t = {}) {
          if (this._initialized)
            return void (0, s.R)(
              "[Assets]AssetManager already initialized, did you load before calling this Assets.init()?"
            );
          if (
            ((this._initialized = !0),
            t.defaultSearchParams &&
              this.resolver.setDefaultSearchParams(t.defaultSearchParams),
            t.basePath && (this.resolver.basePath = t.basePath),
            t.bundleIdentifier &&
              this.resolver.setBundleIdentifier(t.bundleIdentifier),
            t.manifest)
          ) {
            let e = t.manifest;
            "string" == typeof e && (e = await this.load(e)),
              this.resolver.addManifest(e);
          }
          const e = t.texturePreference?.resolution ?? 1,
            i = "number" == typeof e ? [e] : e,
            n = await this._detectFormats({
              preferredFormats: t.texturePreference?.format,
              skipDetections: t.skipDetections,
              detections: this._detections,
            });
          this.resolver.prefer({ params: { format: n, resolution: i } }),
            t.preferences && this.setPreferences(t.preferences);
        }
        add(t) {
          this.resolver.add(t);
        }
        async load(t, e) {
          this._initialized || (await this.init());
          const i = (0, S.a)(t),
            n = (0, b.z)(t).map((t) => {
              if ("string" != typeof t) {
                const e = this.resolver.getAlias(t);
                return (
                  e.some((t) => !this.resolver.hasKey(t)) && this.add(t),
                  Array.isArray(e) ? e[0] : e
                );
              }
              return (
                this.resolver.hasKey(t) || this.add({ alias: t, src: t }), t
              );
            }),
            s = this.resolver.resolve(n),
            r = await this._mapLoadToResolve(s, e);
          return i ? r[n[0]] : r;
        }
        addBundle(t, e) {
          this.resolver.addBundle(t, e);
        }
        async loadBundle(t, e) {
          this._initialized || (await this.init());
          let i = !1;
          "string" == typeof t && ((i = !0), (t = [t]));
          const n = this.resolver.resolveBundle(t),
            s = {},
            r = Object.keys(n);
          let o = 0,
            a = 0;
          const l = () => {
              e?.(++o / a);
            },
            u = r.map((t) => {
              const e = n[t];
              return (
                (a += Object.keys(e).length),
                this._mapLoadToResolve(e, l).then((e) => {
                  s[t] = e;
                })
              );
            });
          return await Promise.all(u), i ? s[t[0]] : s;
        }
        async backgroundLoad(t) {
          this._initialized || (await this.init()),
            "string" == typeof t && (t = [t]);
          const e = this.resolver.resolve(t);
          this._backgroundLoader.add(Object.values(e));
        }
        async backgroundLoadBundle(t) {
          this._initialized || (await this.init()),
            "string" == typeof t && (t = [t]);
          const e = this.resolver.resolveBundle(t);
          Object.values(e).forEach((t) => {
            this._backgroundLoader.add(Object.values(t));
          });
        }
        reset() {
          this.resolver.reset(),
            this.loader.reset(),
            this.cache.reset(),
            (this._initialized = !1);
        }
        get(t) {
          if ("string" == typeof t) return o.l.get(t);
          const e = {};
          for (let i = 0; i < t.length; i++) e[i] = o.l.get(t[i]);
          return e;
        }
        async _mapLoadToResolve(t, e) {
          const i = [...new Set(Object.values(t))];
          this._backgroundLoader.active = !1;
          const n = await this.loader.load(i, e);
          this._backgroundLoader.active = !0;
          const s = {};
          return (
            i.forEach((t) => {
              const e = n[t.src],
                i = [t.src];
              t.alias && i.push(...t.alias),
                i.forEach((t) => {
                  s[t] = e;
                }),
                o.l.set(i, e);
            }),
            s
          );
        }
        async unload(t) {
          this._initialized || (await this.init());
          const e = (0, b.z)(t).map((t) => ("string" != typeof t ? t.src : t)),
            i = this.resolver.resolve(e);
          await this._unloadFromResolved(i);
        }
        async unloadBundle(t) {
          this._initialized || (await this.init()), (t = (0, b.z)(t));
          const e = this.resolver.resolveBundle(t),
            i = Object.keys(e).map((t) => this._unloadFromResolved(e[t]));
          await Promise.all(i);
        }
        async _unloadFromResolved(t) {
          const e = Object.values(t);
          e.forEach((t) => {
            o.l.remove(t.src);
          }),
            await this.loader.unload(e);
        }
        async _detectFormats(t) {
          let e = [];
          t.preferredFormats &&
            (e = Array.isArray(t.preferredFormats)
              ? t.preferredFormats
              : [t.preferredFormats]);
          for (const i of t.detections)
            t.skipDetections || (await i.test())
              ? (e = await i.add(e))
              : t.skipDetections || (e = await i.remove(e));
          return (e = e.filter((t, i) => e.indexOf(t) === i)), e;
        }
        get detections() {
          return this._detections;
        }
        setPreferences(t) {
          this.loader.parsers.forEach((e) => {
            e.config &&
              Object.keys(e.config)
                .filter((e) => e in t)
                .forEach((i) => {
                  e.config[i] = t[i];
                });
          });
        }
      })();
      t.XO.handleByList(t.Ag.LoadParser, rt.loader.parsers)
        .handleByList(t.Ag.ResolveParser, rt.resolver.parsers)
        .handleByList(t.Ag.CacheParser, rt.cache.parsers)
        .handleByList(t.Ag.DetectionParser, rt.detections),
        t.XO.add(l, d, h, y, m, g, v, A, k, B, U, K, it, nt, st);
      const ot = {
        loader: t.Ag.LoadParser,
        resolver: t.Ag.ResolveParser,
        cache: t.Ag.CacheParser,
        detection: t.Ag.DetectionParser,
      };
      t.XO.handle(
        t.Ag.Asset,
        (e) => {
          const i = e.ref;
          Object.entries(ot)
            .filter(([t]) => !!i[t])
            .forEach(([e, n]) =>
              t.XO.add(Object.assign(i[e], { extension: i[e].extension ?? n }))
            );
        },
        (e) => {
          const i = e.ref;
          Object.keys(ot)
            .filter((t) => !!i[t])
            .forEach((e) => t.XO.remove(i[e]));
        }
      );
      var at = n(2577),
        lt = n(9114),
        ut = n(3012),
        ht = n(7222),
        ct = n(6554),
        dt =
          "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",
        pt =
          "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct AlphaUniforms {\n  uAlpha:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> alphaUniforms : AlphaUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n \n    var sample = textureSample(uTexture, uSampler, uv);\n    \n    return sample * alphaUniforms.uAlpha;\n}";
      const ft = class t extends ct.d {
        constructor(e) {
          e = { ...t.defaultOptions, ...e };
          const i = ut.B.from({
              vertex: { source: pt, entryPoint: "mainVertex" },
              fragment: { source: pt, entryPoint: "mainFragment" },
            }),
            n = lt.M.from({
              vertex: dt,
              fragment:
                "\nin vec2 vTextureCoord;\n\nout vec4 finalColor;\n\nuniform float uAlpha;\nuniform sampler2D uTexture;\n\nvoid main()\n{\n    finalColor =  texture(uTexture, vTextureCoord) * uAlpha;\n}\n",
              name: "alpha-filter",
            }),
            { alpha: s, ...r } = e;
          super({
            ...r,
            gpuProgram: i,
            glProgram: n,
            resources: {
              alphaUniforms: new ht.k({ uAlpha: { value: s, type: "f32" } }),
            },
          });
        }
        get alpha() {
          return this.resources.alphaUniforms.uniforms.uAlpha;
        }
        set alpha(t) {
          this.resources.alphaUniforms.uniforms.uAlpha = t;
        }
      };
      ft.defaultOptions = { alpha: 1 };
      let mt = ft;
      var gt = n(2437),
        vt = n(5099),
        yt = n(4670);
      const xt = {
          5: [0.153388, 0.221461, 0.250301],
          7: [0.071303, 0.131514, 0.189879, 0.214607],
          9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
          11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
          13: [
            0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868,
            0.197641,
          ],
          15: [
            489e-6, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697,
            0.197448,
          ],
        },
        bt = [
          "in vec2 vBlurTexCoords[%size%];",
          "uniform sampler2D uTexture;",
          "out vec4 finalColor;",
          "void main(void)",
          "{",
          "    finalColor = vec4(0.0);",
          "    %blur%",
          "}",
        ].join("\n");
      const St =
        "\n    in vec2 aPosition;\n\n    uniform float uStrength;\n\n    out vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 uInputSize;\n    uniform vec4 uOutputFrame;\n    uniform vec4 uOutputTexture;\n\n    vec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\n    vec2 filterTextureCoord( void )\n    {\n        return aPosition * (uOutputFrame.zw * uInputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        float pixelStrength = uInputSize.%dimension% * uStrength;\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
      function Ct(t, e) {
        const i = (function (t, e) {
            const i = Math.ceil(t / 2);
            let n,
              s = St,
              r = "";
            n = e
              ? "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);"
              : "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
            for (let e = 0; e < t; e++) {
              let t = n.replace("%index%", e.toString());
              (t = t.replace("%sampleIndex%", e - (i - 1) + ".0")),
                (r += t),
                (r += "\n");
            }
            return (
              (s = s.replace("%blur%", r)),
              (s = s.replace("%size%", t.toString())),
              (s = s.replace("%dimension%", e ? "z" : "w")),
              s
            );
          })(e, t),
          n = (function (t) {
            const e = xt[t],
              i = e.length;
            let n,
              s = bt,
              r = "";
            for (let s = 0; s < t; s++) {
              let o =
                "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;".replace(
                  "%index%",
                  s.toString()
                );
              (n = s),
                s >= i && (n = t - s - 1),
                (o = o.replace("%value%", e[n].toString())),
                (r += o),
                (r += "\n");
            }
            return (
              (s = s.replace("%blur%", r)),
              (s = s.replace("%size%", t.toString())),
              s
            );
          })(e);
        return lt.M.from({
          vertex: i,
          fragment: n,
          name: `blur-${t ? "horizontal" : "vertical"}-pass-filter`,
        });
      }
      const _t = class t extends ct.d {
        constructor(e) {
          super({
            glProgram: Ct(
              (e = { ...t.defaultOptions, ...e }).horizontal,
              e.kernelSize
            ),
            gpuProgram: (function (t, e) {
              const i = xt[e],
                n = i.length,
                s = [],
                r = [],
                o = [];
              for (let a = 0; a < e; a++) {
                (s[a] = `@location(${a}) offset${a}: vec2<f32>,`),
                  (r[a] = t
                    ? `filteredCord + vec2(${a - n + 1} * strength, 0.0),`
                    : `filteredCord + vec2(0.0, ${a - n + 1} * strength),`);
                const l = i[a < n ? a : e - a - 1].toString();
                o[
                  a
                ] = `finalColor += textureSample(uTexture, uSampler, offset${a}) * ${l};`;
              }
              const a = s.join("\n"),
                l = r.join("\n"),
                u = o.join("\n"),
                h =
                  "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct BlurUniforms {\n  uStrength:f32,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    %blur-struct%\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n\n  let filteredCord = filterTextureCoord(aPosition);\n\n  let strength = gfu.uInputSize.w * blurUniforms.uStrength;\n\n  return VSOutput(\n   filterVertexPosition(aPosition),\n    %blur-vertex-out%\n  );\n}\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  %blur-fragment-in%\n) -> @location(0) vec4<f32> {\n\n    var   finalColor = vec4(0.0);\n\n    %blur-sampling%\n\n    return finalColor;\n}"
                    .replace("%blur-struct%", a)
                    .replace("%blur-vertex-out%", l)
                    .replace("%blur-fragment-in%", a)
                    .replace("%blur-sampling%", u);
              return ut.B.from({
                vertex: { source: h, entryPoint: "mainVertex" },
                fragment: { source: h, entryPoint: "mainFragment" },
              });
            })(e.horizontal, e.kernelSize),
            resources: {
              blurUniforms: { uStrength: { value: 0, type: "f32" } },
            },
            ...e,
          }),
            (this.horizontal = e.horizontal),
            (this._quality = 0),
            (this.quality = e.quality),
            (this.blur = e.strength),
            (this._uniforms = this.resources.blurUniforms.uniforms);
        }
        apply(t, e, i, n) {
          if (
            ((this._uniforms.uStrength = this.strength / this.passes),
            1 === this.passes)
          )
            t.applyFilter(this, e, i, n);
          else {
            const s = gt.W.getSameSizeTexture(e);
            let r = e,
              o = s;
            this._state.blend = !1;
            for (let e = 0; e < this.passes - 1; e++) {
              t.applyFilter(this, r, o, t.renderer.type === vt.W.WEBGPU);
              const e = o;
              (o = r), (r = e);
            }
            (this._state.blend = !0),
              t.applyFilter(this, r, i, n),
              gt.W.returnTexture(s);
          }
        }
        get blur() {
          return this.strength;
        }
        set blur(t) {
          (this.padding = 1 + 2 * Math.abs(t)), (this.strength = t);
        }
        get quality() {
          return this._quality;
        }
        set quality(t) {
          (this._quality = t), (this.passes = t);
        }
      };
      _t.defaultOptions = { strength: 8, quality: 4, kernelSize: 5 };
      let Tt = _t;
      class wt extends ct.d {
        constructor(...t) {
          let e = t[0] ?? {};
          "number" == typeof e &&
            ((0, yt.t)(
              yt.l,
              "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"
            ),
            (e = { strength: e }),
            t[1] && (e.quality = t[1]),
            t[2] && (e.resolution = t[2]),
            t[3] && (e.kernelSize = t[3])),
            (e = { ...Tt.defaultOptions, ...e });
          const { strength: i, quality: n, ...s } = e;
          super({ ...s, compatibleRenderers: vt.W.BOTH, resources: {} }),
            (this._repeatEdgePixels = !1),
            (this.blurXFilter = new Tt({ horizontal: !1, ...e })),
            (this.blurYFilter = new Tt({ horizontal: !0, ...e })),
            (this.quality = n),
            (this.blur = i),
            (this.repeatEdgePixels = !1);
        }
        apply(t, e, i, n) {
          const s = Math.abs(this.blurXFilter.strength),
            r = Math.abs(this.blurYFilter.strength);
          if (s && r) {
            const s = gt.W.getSameSizeTexture(e);
            this.blurXFilter.apply(t, e, s, !0),
              this.blurYFilter.apply(t, s, i, n),
              gt.W.returnTexture(s);
          } else
            r
              ? this.blurYFilter.apply(t, e, i, n)
              : this.blurXFilter.apply(t, e, i, n);
        }
        updatePadding() {
          this._repeatEdgePixels
            ? (this.padding = 0)
            : (this.padding =
                2 *
                Math.max(
                  Math.abs(this.blurXFilter.blur),
                  Math.abs(this.blurYFilter.blur)
                ));
        }
        get blur() {
          return this.blurXFilter.blur;
        }
        set blur(t) {
          (this.blurXFilter.blur = this.blurYFilter.blur = t),
            this.updatePadding();
        }
        get quality() {
          return this.blurXFilter.quality;
        }
        set quality(t) {
          this.blurXFilter.quality = this.blurYFilter.quality = t;
        }
        get blurX() {
          return this.blurXFilter.blur;
        }
        set blurX(t) {
          (this.blurXFilter.blur = t), this.updatePadding();
        }
        get blurY() {
          return this.blurYFilter.blur;
        }
        set blurY(t) {
          (this.blurYFilter.blur = t), this.updatePadding();
        }
        get blendMode() {
          return this.blurYFilter.blendMode;
        }
        set blendMode(t) {
          this.blurYFilter.blendMode = t;
        }
        get repeatEdgePixels() {
          return this._repeatEdgePixels;
        }
        set repeatEdgePixels(t) {
          (this._repeatEdgePixels = t), this.updatePadding();
        }
      }
      wt.defaultOptions = { strength: 8, quality: 4, kernelSize: 5 };
      var Pt =
        "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\nstruct ColorMatrixUniforms {\n  uColorMatrix:array<vec4<f32>, 5>,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\n@group(0) @binding(2) var uSampler : sampler;\n@group(1) @binding(0) var<uniform> colorMatrixUniforms : ColorMatrixUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>,\n  };\n  \nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n  );\n}\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n) -> @location(0) vec4<f32> {\n\n\n  var c = textureSample(uTexture, uSampler, uv);\n  \n  if (colorMatrixUniforms.uAlpha == 0.0) {\n    return c;\n  }\n\n \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.r /= c.a;\n      c.g /= c.a;\n      c.b /= c.a;\n    }\n\n    var cm = colorMatrixUniforms.uColorMatrix;\n\n\n    var result = vec4<f32>(0.);\n\n    result.r = (cm[0][0] * c.r);\n    result.r += (cm[0][1] * c.g);\n    result.r += (cm[0][2] * c.b);\n    result.r += (cm[0][3] * c.a);\n    result.r += cm[1][0];\n\n    result.g = (cm[1][1] * c.r);\n    result.g += (cm[1][2] * c.g);\n    result.g += (cm[1][3] * c.b);\n    result.g += (cm[2][0] * c.a);\n    result.g += cm[2][1];\n\n    result.b = (cm[2][2] * c.r);\n    result.b += (cm[2][3] * c.g);\n    result.b += (cm[3][0] * c.b);\n    result.b += (cm[3][1] * c.a);\n    result.b += cm[3][2];\n\n    result.a = (cm[3][3] * c.r);\n    result.a += (cm[4][0] * c.g);\n    result.a += (cm[4][1] * c.b);\n    result.a += (cm[4][2] * c.a);\n    result.a += cm[4][3];\n\n    var rgb = mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);\n\n    rgb.r *= result.a;\n    rgb.g *= result.a;\n    rgb.b *= result.a;\n\n    return vec4(rgb, result.a);\n}";
      class At extends ct.d {
        constructor(t = {}) {
          const e = new ht.k({
            uColorMatrix: {
              value: [
                1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,
              ],
              type: "f32",
              size: 20,
            },
            uAlpha: { value: 1, type: "f32" },
          });
          super({
            ...t,
            gpuProgram: ut.B.from({
              vertex: { source: Pt, entryPoint: "mainVertex" },
              fragment: { source: Pt, entryPoint: "mainFragment" },
            }),
            glProgram: lt.M.from({
              vertex: dt,
              fragment:
                "\nin vec2 vTextureCoord;\nin vec4 vColor;\n\nout vec4 finalColor;\n\nuniform float uColorMatrix[20];\nuniform float uAlpha;\n\nuniform sampler2D uTexture;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * 0.2);\n    float diff = (randomValue - 0.5) *  0.5;\n\n    if (uAlpha == 0.0) {\n        finalColor = color;\n        return;\n    }\n\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    vec4 result;\n\n    result.r = (uColorMatrix[0] * color.r);\n        result.r += (uColorMatrix[1] * color.g);\n        result.r += (uColorMatrix[2] * color.b);\n        result.r += (uColorMatrix[3] * color.a);\n        result.r += uColorMatrix[4];\n\n    result.g = (uColorMatrix[5] * color.r);\n        result.g += (uColorMatrix[6] * color.g);\n        result.g += (uColorMatrix[7] * color.b);\n        result.g += (uColorMatrix[8] * color.a);\n        result.g += uColorMatrix[9];\n\n    result.b = (uColorMatrix[10] * color.r);\n       result.b += (uColorMatrix[11] * color.g);\n       result.b += (uColorMatrix[12] * color.b);\n       result.b += (uColorMatrix[13] * color.a);\n       result.b += uColorMatrix[14];\n\n    result.a = (uColorMatrix[15] * color.r);\n       result.a += (uColorMatrix[16] * color.g);\n       result.a += (uColorMatrix[17] * color.b);\n       result.a += (uColorMatrix[18] * color.a);\n       result.a += uColorMatrix[19];\n\n    vec3 rgb = mix(color.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    finalColor = vec4(rgb, result.a);\n}\n",
              name: "color-matrix-filter",
            }),
            resources: { colorMatrixUniforms: e },
          }),
            (this.alpha = 1);
        }
        _loadMatrix(t, e = !1) {
          let i = t;
          e && (this._multiply(i, this.matrix, t), (i = this._colorMatrix(i))),
            (this.resources.colorMatrixUniforms.uniforms.uColorMatrix = i),
            this.resources.colorMatrixUniforms.update();
        }
        _multiply(t, e, i) {
          return (
            (t[0] = e[0] * i[0] + e[1] * i[5] + e[2] * i[10] + e[3] * i[15]),
            (t[1] = e[0] * i[1] + e[1] * i[6] + e[2] * i[11] + e[3] * i[16]),
            (t[2] = e[0] * i[2] + e[1] * i[7] + e[2] * i[12] + e[3] * i[17]),
            (t[3] = e[0] * i[3] + e[1] * i[8] + e[2] * i[13] + e[3] * i[18]),
            (t[4] =
              e[0] * i[4] + e[1] * i[9] + e[2] * i[14] + e[3] * i[19] + e[4]),
            (t[5] = e[5] * i[0] + e[6] * i[5] + e[7] * i[10] + e[8] * i[15]),
            (t[6] = e[5] * i[1] + e[6] * i[6] + e[7] * i[11] + e[8] * i[16]),
            (t[7] = e[5] * i[2] + e[6] * i[7] + e[7] * i[12] + e[8] * i[17]),
            (t[8] = e[5] * i[3] + e[6] * i[8] + e[7] * i[13] + e[8] * i[18]),
            (t[9] =
              e[5] * i[4] + e[6] * i[9] + e[7] * i[14] + e[8] * i[19] + e[9]),
            (t[10] =
              e[10] * i[0] + e[11] * i[5] + e[12] * i[10] + e[13] * i[15]),
            (t[11] =
              e[10] * i[1] + e[11] * i[6] + e[12] * i[11] + e[13] * i[16]),
            (t[12] =
              e[10] * i[2] + e[11] * i[7] + e[12] * i[12] + e[13] * i[17]),
            (t[13] =
              e[10] * i[3] + e[11] * i[8] + e[12] * i[13] + e[13] * i[18]),
            (t[14] =
              e[10] * i[4] +
              e[11] * i[9] +
              e[12] * i[14] +
              e[13] * i[19] +
              e[14]),
            (t[15] =
              e[15] * i[0] + e[16] * i[5] + e[17] * i[10] + e[18] * i[15]),
            (t[16] =
              e[15] * i[1] + e[16] * i[6] + e[17] * i[11] + e[18] * i[16]),
            (t[17] =
              e[15] * i[2] + e[16] * i[7] + e[17] * i[12] + e[18] * i[17]),
            (t[18] =
              e[15] * i[3] + e[16] * i[8] + e[17] * i[13] + e[18] * i[18]),
            (t[19] =
              e[15] * i[4] +
              e[16] * i[9] +
              e[17] * i[14] +
              e[18] * i[19] +
              e[19]),
            t
          );
        }
        _colorMatrix(t) {
          const e = new Float32Array(t);
          return (
            (e[4] /= 255), (e[9] /= 255), (e[14] /= 255), (e[19] /= 255), e
          );
        }
        brightness(t, e) {
          const i = [
            t,
            0,
            0,
            0,
            0,
            0,
            t,
            0,
            0,
            0,
            0,
            0,
            t,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
          ];
          this._loadMatrix(i, e);
        }
        tint(t, e) {
          const [i, n, s] = at.Q.shared.setValue(t).toArray(),
            r = [i, 0, 0, 0, 0, 0, n, 0, 0, 0, 0, 0, s, 0, 0, 0, 0, 0, 1, 0];
          this._loadMatrix(r, e);
        }
        greyscale(t, e) {
          const i = [
            t,
            t,
            t,
            0,
            0,
            t,
            t,
            t,
            0,
            0,
            t,
            t,
            t,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
          ];
          this._loadMatrix(i, e);
        }
        grayscale(t, e) {
          this.greyscale(t, e);
        }
        blackAndWhite(t) {
          this._loadMatrix(
            [
              0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0,
              0, 0, 1, 0,
            ],
            t
          );
        }
        hue(t, e) {
          t = ((t || 0) / 180) * Math.PI;
          const i = Math.cos(t),
            n = Math.sin(t),
            s = 1 / 3,
            r = (0, Math.sqrt)(s),
            o = [
              i + (1 - i) * s,
              s * (1 - i) - r * n,
              s * (1 - i) + r * n,
              0,
              0,
              s * (1 - i) + r * n,
              i + s * (1 - i),
              s * (1 - i) - r * n,
              0,
              0,
              s * (1 - i) - r * n,
              s * (1 - i) + r * n,
              i + s * (1 - i),
              0,
              0,
              0,
              0,
              0,
              1,
              0,
            ];
          this._loadMatrix(o, e);
        }
        contrast(t, e) {
          const i = (t || 0) + 1,
            n = -0.5 * (i - 1),
            s = [i, 0, 0, 0, n, 0, i, 0, 0, n, 0, 0, i, 0, n, 0, 0, 0, 1, 0];
          this._loadMatrix(s, e);
        }
        saturate(t = 0, e) {
          const i = (2 * t) / 3 + 1,
            n = -0.5 * (i - 1),
            s = [i, n, n, 0, 0, n, i, n, 0, 0, n, n, i, 0, 0, 0, 0, 0, 1, 0];
          this._loadMatrix(s, e);
        }
        desaturate() {
          this.saturate(-1);
        }
        negative(t) {
          this._loadMatrix(
            [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0],
            t
          );
        }
        sepia(t) {
          this._loadMatrix(
            [
              0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999,
              0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0,
            ],
            t
          );
        }
        technicolor(t) {
          this._loadMatrix(
            [
              1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0,
              11.793603434377337, -0.3087833385928097, 1.7658908555458428,
              -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616,
              -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0,
              0, 0, 1, 0,
            ],
            t
          );
        }
        polaroid(t) {
          this._loadMatrix(
            [
              1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016,
              -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0,
            ],
            t
          );
        }
        toBGR(t) {
          this._loadMatrix(
            [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0],
            t
          );
        }
        kodachrome(t) {
          this._loadMatrix(
            [
              1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0,
              63.72958762196502, -0.16404339962244616, 1.0835251566291304,
              -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763,
              -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0,
              0, 0, 1, 0,
            ],
            t
          );
        }
        browni(t) {
          this._loadMatrix(
            [
              0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0,
              47.43192855600873, -0.037703249837783157, 0.8609577587992641,
              0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335,
              -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,
              0, 0, 0, 1, 0,
            ],
            t
          );
        }
        vintage(t) {
          this._loadMatrix(
            [
              0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0,
              9.651285835294123, 0.02578397704808868, 0.6441188644374771,
              0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719,
              -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0,
              0, 0, 1, 0,
            ],
            t
          );
        }
        colorTone(t, e, i, n, s) {
          (t = t || 0.2),
            (e = e || 0.15),
            (i = i || 16770432),
            (n = n || 3375104);
          const r = at.Q.shared,
            [o, a, l] = r.setValue(i).toArray(),
            [u, h, c] = r.setValue(n).toArray(),
            d = [
              0.3,
              0.59,
              0.11,
              0,
              0,
              o,
              a,
              l,
              t,
              0,
              u,
              h,
              c,
              e,
              0,
              o - u,
              a - h,
              l - c,
              0,
              0,
            ];
          this._loadMatrix(d, s);
        }
        night(t, e) {
          const i = [
            -2 * (t = t || 0.1),
            -t,
            0,
            0,
            0,
            -t,
            0,
            t,
            0,
            0,
            0,
            t,
            2 * t,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
          ];
          this._loadMatrix(i, e);
        }
        predator(t, e) {
          const i = [
            11.224130630493164 * t,
            -4.794486999511719 * t,
            -2.8746118545532227 * t,
            0 * t,
            0.40342438220977783 * t,
            -3.6330697536468506 * t,
            9.193157196044922 * t,
            -2.951810836791992 * t,
            0 * t,
            -1.316135048866272 * t,
            -3.2184197902679443 * t,
            -4.2375030517578125 * t,
            7.476448059082031 * t,
            0 * t,
            0.8044459223747253 * t,
            0,
            0,
            0,
            1,
            0,
          ];
          this._loadMatrix(i, e);
        }
        lsd(t) {
          this._loadMatrix(
            [
              2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0,
              0, 0, 1, 0,
            ],
            t
          );
        }
        reset() {
          this._loadMatrix(
            [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
            !1
          );
        }
        get matrix() {
          return this.resources.colorMatrixUniforms.uniforms.uColorMatrix;
        }
        set matrix(t) {
          this.resources.colorMatrixUniforms.uniforms.uColorMatrix = t;
        }
        get alpha() {
          return this.resources.colorMatrixUniforms.uniforms.uAlpha;
        }
        set alpha(t) {
          this.resources.colorMatrixUniforms.uniforms.uAlpha = t;
        }
      }
      var kt = n(1652),
        Mt = n(2812),
        Et = n(5101);
      const It = [];
      t.XO.handleByNamedList(t.Ag.Environment, It);
      var Dt = n(2855);
      let Rt, Bt;
      async function Ft(t = {}) {
        return (
          void 0 !== Bt ||
            (Bt = await (async () => {
              if (!_.e.get().getNavigator().gpu) return !1;
              try {
                const e = await navigator.gpu.requestAdapter(t);
                return await e.requestDevice(), !0;
              } catch (t) {
                return !1;
              }
            })()),
          Bt
        );
      }
      const Ot = ["webgl", "webgpu", "canvas"];
      async function zt(t) {
        let e,
          i = [];
        t.preference
          ? (i.push(t.preference),
            Ot.forEach((e) => {
              e !== t.preference && i.push(e);
            }))
          : (i = Ot.slice()),
          await (async function (t) {
            if (t)
              for (let t = 0; t < It.length; t++) {
                const e = It[t];
                if (e.value.test()) return void (await e.value.load());
              }
          })(t.manageImports ?? !0);
        let s = {};
        for (let o = 0; o < i.length; o++) {
          const a = i[o];
          if ("webgpu" === a && (await Ft())) {
            const { WebGPURenderer: i } = await n.e(751).then(n.bind(n, 4751));
            (e = i), (s = { ...t, ...t.webgpu });
            break;
          }
          if (
            "webgl" === a &&
            ((r =
              t.failIfMajorPerformanceCaveat ??
              Dt.k.defaultOptions.failIfMajorPerformanceCaveat),
            void 0 !== Rt ||
              (Rt = (() => {
                const t = {
                  stencil: !0,
                  failIfMajorPerformanceCaveat:
                    r ?? Dt.k.defaultOptions.failIfMajorPerformanceCaveat,
                };
                try {
                  if (!_.e.get().getWebGLRenderingContext()) return !1;
                  let e = _.e.get().createCanvas().getContext("webgl", t);
                  const i = !!e?.getContextAttributes()?.stencil;
                  if (e) {
                    const t = e.getExtension("WEBGL_lose_context");
                    t && t.loseContext();
                  }
                  return (e = null), i;
                } catch (t) {
                  return !1;
                }
              })()),
            Rt)
          ) {
            const { WebGLRenderer: i } = await Promise.resolve().then(
              n.bind(n, 3151)
            );
            (e = i), (s = { ...t, ...t.webgl });
            break;
          }
          if ("canvas" === a) {
            s = { ...t };
            break;
          }
        }
        var r;
        delete s.webgpu, delete s.webgl;
        const o = new e();
        return await o.init(s), o;
      }
      var Lt = n(3151),
        Ht = n(4167),
        Ut = n(6932),
        Nt = n(3818),
        Gt = (n(6557), n(4263)),
        Vt = n(9408),
        jt = n(9313);
      class $t {
        constructor({ matrix: t, observer: e } = {}) {
          (this.dirty = !0),
            (this._matrix = t ?? new jt.u()),
            (this.observer = e),
            (this.position = new Mt.o(this, 0, 0)),
            (this.scale = new Mt.o(this, 1, 1)),
            (this.pivot = new Mt.o(this, 0, 0)),
            (this.skew = new Mt.o(this, 0, 0)),
            (this._rotation = 0),
            (this._cx = 1),
            (this._sx = 0),
            (this._cy = 0),
            (this._sy = 1);
        }
        get matrix() {
          const t = this._matrix;
          return this.dirty
            ? ((t.a = this._cx * this.scale.x),
              (t.b = this._sx * this.scale.x),
              (t.c = this._cy * this.scale.y),
              (t.d = this._sy * this.scale.y),
              (t.tx =
                this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c)),
              (t.ty =
                this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d)),
              (this.dirty = !1),
              t)
            : t;
        }
        _onUpdate(t) {
          (this.dirty = !0),
            t === this.skew && this.updateSkew(),
            this.observer?._onUpdate(this);
        }
        updateSkew() {
          (this._cx = Math.cos(this._rotation + this.skew.y)),
            (this._sx = Math.sin(this._rotation + this.skew.y)),
            (this._cy = -Math.sin(this._rotation - this.skew.x)),
            (this._sy = Math.cos(this._rotation - this.skew.x)),
            (this.dirty = !0);
        }
        toString() {
          return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`;
        }
        setFromMatrix(t) {
          t.decompose(this), (this.dirty = !0);
        }
        get rotation() {
          return this._rotation;
        }
        set rotation(t) {
          this._rotation !== t &&
            ((this._rotation = t), this._onUpdate(this.skew));
        }
      }
      const qt = class t extends Gt.mc {
        constructor(...e) {
          let i = e[0] || {};
          i instanceof a.g && (i = { texture: i }),
            e.length > 1 &&
              ((0, yt.t)(
                yt.l,
                "use new TilingSprite({ texture, width:100, height:100 }) instead"
              ),
              (i.width = e[1]),
              (i.height = e[2])),
            (i = { ...t.defaultOptions, ...i });
          const {
            texture: n,
            anchor: s,
            tilePosition: r,
            tileScale: o,
            tileRotation: l,
            width: u,
            height: h,
            applyAnchorToTexture: c,
            roundPixels: d,
            ...p
          } = i ?? {};
          super({ label: "TilingSprite", ...p }),
            (this.renderPipeId = "tilingSprite"),
            (this.canBundle = !0),
            (this.batched = !0),
            (this._roundPixels = 0),
            (this._bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 }),
            (this._boundsDirty = !0),
            (this.allowChildren = !1),
            (this._anchor = new Mt.o(this)),
            (this._applyAnchorToTexture = c),
            (this.texture = n),
            (this._width = u ?? n.width),
            (this._height = h ?? n.height),
            (this._tileTransform = new $t({
              observer: { _onUpdate: () => this.onViewUpdate() },
            })),
            s && (this.anchor = s),
            (this.tilePosition = r),
            (this.tileScale = o),
            (this.tileRotation = l),
            (this.roundPixels = d ?? !1);
        }
        static from(e, i = {}) {
          return new t(
            "string" == typeof e
              ? { texture: o.l.get(e), ...i }
              : { texture: e, ...i }
          );
        }
        get clampMargin() {
          return this._texture.textureMatrix.clampMargin;
        }
        set clampMargin(t) {
          this._texture.textureMatrix.clampMargin = t;
        }
        get anchor() {
          return this._anchor;
        }
        set anchor(t) {
          "number" == typeof t ? this._anchor.set(t) : this._anchor.copyFrom(t);
        }
        get tilePosition() {
          return this._tileTransform.position;
        }
        set tilePosition(t) {
          this._tileTransform.position.copyFrom(t);
        }
        get tileScale() {
          return this._tileTransform.scale;
        }
        set tileScale(t) {
          "number" == typeof t
            ? this._tileTransform.scale.set(t)
            : this._tileTransform.scale.copyFrom(t);
        }
        set tileRotation(t) {
          this._tileTransform.rotation = t;
        }
        get tileRotation() {
          return this._tileTransform.rotation;
        }
        get tileTransform() {
          return this._tileTransform;
        }
        get roundPixels() {
          return !!this._roundPixels;
        }
        set roundPixels(t) {
          this._roundPixels = t ? 1 : 0;
        }
        get bounds() {
          return (
            this._boundsDirty &&
              (this._updateBounds(), (this._boundsDirty = !1)),
            this._bounds
          );
        }
        set texture(t) {
          t || (t = a.g.EMPTY);
          const e = this._texture;
          e !== t &&
            (e && e.dynamic && e.off("update", this.onViewUpdate, this),
            t.dynamic && t.on("update", this.onViewUpdate, this),
            (this._texture = t),
            this.onViewUpdate());
        }
        get texture() {
          return this._texture;
        }
        set width(t) {
          (this._width = t), this.onViewUpdate();
        }
        get width() {
          return this._width;
        }
        set height(t) {
          (this._height = t), this.onViewUpdate();
        }
        get height() {
          return this._height;
        }
        _updateBounds() {
          const t = this._bounds,
            e = this._anchor,
            i = this._width,
            n = this._height;
          (t.maxX = -e._x * i),
            (t.minX = t.maxX + i),
            (t.maxY = -e._y * n),
            (t.minY = t.maxY + n);
        }
        addBounds(t) {
          const e = this.bounds;
          t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
        }
        containsPoint(t) {
          const e = this.bounds.minX,
            i = this.bounds.minY,
            n = -e * this._anchor._x;
          let s = 0;
          return (
            t.x >= n &&
            t.x <= n + e &&
            ((s = -i * this._anchor._y), t.y >= s && t.y <= s + i)
          );
        }
        onViewUpdate() {
          (this._boundsDirty = !0),
            (this._didTilingSpriteUpdate = !0),
            (this._didChangeId += 4096),
            this.didViewUpdate ||
              ((this.didViewUpdate = !0),
              this.renderGroup && this.renderGroup.onChildViewUpdate(this));
        }
        destroy(t = !1) {
          super.destroy(t),
            (this._anchor = null),
            (this._tileTransform = null),
            (this._bounds = null);
          if ("boolean" == typeof t ? t : t?.texture) {
            const e = "boolean" == typeof t ? t : t?.textureSource;
            this._texture.destroy(e);
          }
          this._texture = null;
        }
      };
      qt.defaultOptions = {
        texture: a.g.EMPTY,
        anchor: { x: 0, y: 0 },
        tilePosition: { x: 0, y: 0 },
        tileScale: { x: 1, y: 1 },
        tileRotation: 0,
        applyAnchorToTexture: !1,
      };
      let Wt = qt;
      var Xt = n(6844),
        Yt = n(9636);
      class Kt extends Gt.mc {
        constructor(t, e) {
          const {
            text: i,
            resolution: n,
            style: s,
            anchor: r,
            width: o,
            height: a,
            roundPixels: l,
            ...u
          } = t;
          super({ ...u }),
            (this.batched = !0),
            (this.resolution = null),
            (this._didTextUpdate = !0),
            (this._roundPixels = 0),
            (this._bounds = new Yt.c()),
            (this._boundsDirty = !0),
            (this._styleClass = e),
            (this.text = i ?? ""),
            (this.style = s),
            (this.resolution = n ?? null),
            (this.allowChildren = !1),
            (this._anchor = new Mt.o({
              _onUpdate: () => {
                this.onViewUpdate();
              },
            })),
            r && (this.anchor = r),
            (this.roundPixels = l ?? !1),
            o && (this.width = o),
            a && (this.height = a);
        }
        get anchor() {
          return this._anchor;
        }
        set anchor(t) {
          "number" == typeof t ? this._anchor.set(t) : this._anchor.copyFrom(t);
        }
        get roundPixels() {
          return !!this._roundPixels;
        }
        set roundPixels(t) {
          this._roundPixels = t ? 1 : 0;
        }
        set text(t) {
          (t = t.toString()),
            this._text !== t && ((this._text = t), this.onViewUpdate());
        }
        get text() {
          return this._text;
        }
        get style() {
          return this._style;
        }
        set style(t) {
          (t = t || {}),
            this._style?.off("update", this.onViewUpdate, this),
            t instanceof this._styleClass
              ? (this._style = t)
              : (this._style = new this._styleClass(t)),
            this._style.on("update", this.onViewUpdate, this),
            this.onViewUpdate();
        }
        get bounds() {
          return (
            this._boundsDirty &&
              (this._updateBounds(), (this._boundsDirty = !1)),
            this._bounds
          );
        }
        get width() {
          return Math.abs(this.scale.x) * this.bounds.width;
        }
        set width(t) {
          this._setWidth(t, this.bounds.width);
        }
        get height() {
          return Math.abs(this.scale.y) * this.bounds.height;
        }
        set height(t) {
          this._setHeight(t, this.bounds.height);
        }
        getSize(t) {
          return (
            t || (t = {}),
            (t.width = Math.abs(this.scale.x) * this.bounds.width),
            (t.height = Math.abs(this.scale.y) * this.bounds.height),
            t
          );
        }
        setSize(t, e) {
          let i, n;
          "object" != typeof t
            ? ((i = t), (n = e ?? t))
            : ((i = t.width), (n = t.height ?? t.width)),
            void 0 !== i && this._setWidth(i, this.bounds.width),
            void 0 !== n && this._setHeight(n, this.bounds.height);
        }
        addBounds(t) {
          const e = this.bounds;
          t.addFrame(e.minX, e.minY, e.maxX, e.maxY);
        }
        containsPoint(t) {
          const e = this.bounds.maxX,
            i = this.bounds.maxY,
            n = -e * this.anchor.x;
          let s = 0;
          return (
            t.x >= n &&
            t.x <= n + e &&
            ((s = -i * this.anchor.y), t.y >= s && t.y <= s + i)
          );
        }
        onViewUpdate() {
          (this._didChangeId += 4096),
            (this._boundsDirty = !0),
            this.didViewUpdate ||
              ((this.didViewUpdate = !0),
              (this._didTextUpdate = !0),
              this.renderGroup && this.renderGroup.onChildViewUpdate(this));
        }
        _getKey() {
          return `${this.text}:${this._style.styleKey}`;
        }
        destroy(t = !1) {
          super.destroy(t),
            (this.owner = null),
            (this._bounds = null),
            (this._anchor = null),
            ("boolean" == typeof t ? t : t?.style) && this._style.destroy(t),
            (this._style = null),
            (this._text = null);
        }
      }
      var Zt = n(4016),
        Qt = n(8291);
      class Jt extends Kt {
        constructor(...t) {
          const e = (function (t, e) {
            let i = t[0] ?? {};
            return (
              ("string" == typeof i || t[1]) &&
                ((0, yt.t)(
                  yt.l,
                  `use new ${e}({ text: "hi!", style }) instead`
                ),
                (i = { text: i, style: t[1] })),
              i
            );
          })(t, "Text");
          super(e, Qt.x), (this.renderPipeId = "text");
        }
        _updateBounds() {
          const t = this._bounds,
            e = this._style.padding,
            i = this._anchor,
            n = Zt.P.measureText(this._text, this._style),
            { width: s, height: r } = n;
          (t.minX = -i._x * s - e),
            (t.maxX = t.minX + s),
            (t.minY = -i._y * r - e),
            (t.maxY = t.minY + r);
        }
      }
      var te = n(7309),
        ee = n(7218),
        ie = n(4486);
      n(6570);
      let ne;
      function se() {
        return ne;
      }
      t.XO.add(e, i);
      class re {
        constructor(t, e) {
          this.init(t, e);
        }
        init(t, e) {
          (this.destination = t), (this.source = e || t);
        }
        connect(t) {
          this.source?.connect(t);
        }
        disconnect() {
          this.source?.disconnect();
        }
        destroy() {
          this.disconnect(), (this.destination = null), (this.source = null);
        }
      }
      class oe {
        static setParamValue(t, e) {
          if (t.setValueAtTime) {
            const i = se().context;
            t.setValueAtTime(e, i.audioContext.currentTime);
          } else t.value = e;
          return e;
        }
      }
      const ae = class extends re {
        constructor(
          t = 0,
          e = 0,
          i = 0,
          n = 0,
          s = 0,
          r = 0,
          o = 0,
          a = 0,
          l = 0,
          u = 0
        ) {
          let h = [];
          const c = [
            { f: ae.F32, type: "lowshelf", gain: t },
            { f: ae.F64, type: "peaking", gain: e },
            { f: ae.F125, type: "peaking", gain: i },
            { f: ae.F250, type: "peaking", gain: n },
            { f: ae.F500, type: "peaking", gain: s },
            { f: ae.F1K, type: "peaking", gain: r },
            { f: ae.F2K, type: "peaking", gain: o },
            { f: ae.F4K, type: "peaking", gain: a },
            { f: ae.F8K, type: "peaking", gain: l },
            { f: ae.F16K, type: "highshelf", gain: u },
          ];
          se().useLegacy ||
            (h = c.map((t) => {
              const e = se().context.audioContext.createBiquadFilter();
              return (
                (e.type = t.type),
                oe.setParamValue(e.Q, 1),
                (e.frequency.value = t.f),
                oe.setParamValue(e.gain, t.gain),
                e
              );
            })),
            super(h[0], h[h.length - 1]),
            (this.bands = h),
            (this.bandsMap = {});
          for (let t = 0; t < this.bands.length; t++) {
            const e = this.bands[t];
            t > 0 && this.bands[t - 1].connect(e),
              (this.bandsMap[e.frequency.value] = e);
          }
        }
        setGain(t, e = 0) {
          if (!this.bandsMap[t])
            throw new Error(`No band found for frequency ${t}`);
          oe.setParamValue(this.bandsMap[t].gain, e);
        }
        getGain(t) {
          if (!this.bandsMap[t])
            throw new Error(`No band found for frequency ${t}`);
          return this.bandsMap[t].gain.value;
        }
        set f32(t) {
          this.setGain(ae.F32, t);
        }
        get f32() {
          return this.getGain(ae.F32);
        }
        set f64(t) {
          this.setGain(ae.F64, t);
        }
        get f64() {
          return this.getGain(ae.F64);
        }
        set f125(t) {
          this.setGain(ae.F125, t);
        }
        get f125() {
          return this.getGain(ae.F125);
        }
        set f250(t) {
          this.setGain(ae.F250, t);
        }
        get f250() {
          return this.getGain(ae.F250);
        }
        set f500(t) {
          this.setGain(ae.F500, t);
        }
        get f500() {
          return this.getGain(ae.F500);
        }
        set f1k(t) {
          this.setGain(ae.F1K, t);
        }
        get f1k() {
          return this.getGain(ae.F1K);
        }
        set f2k(t) {
          this.setGain(ae.F2K, t);
        }
        get f2k() {
          return this.getGain(ae.F2K);
        }
        set f4k(t) {
          this.setGain(ae.F4K, t);
        }
        get f4k() {
          return this.getGain(ae.F4K);
        }
        set f8k(t) {
          this.setGain(ae.F8K, t);
        }
        get f8k() {
          return this.getGain(ae.F8K);
        }
        set f16k(t) {
          this.setGain(ae.F16K, t);
        }
        get f16k() {
          return this.getGain(ae.F16K);
        }
        reset() {
          this.bands.forEach((t) => {
            oe.setParamValue(t.gain, 0);
          });
        }
        destroy() {
          this.bands.forEach((t) => {
            t.disconnect();
          }),
            (this.bands = null),
            (this.bandsMap = null);
        }
      };
      let le = ae;
      (le.F32 = 32),
        (le.F64 = 64),
        (le.F125 = 125),
        (le.F250 = 250),
        (le.F500 = 500),
        (le.F1K = 1e3),
        (le.F2K = 2e3),
        (le.F4K = 4e3),
        (le.F8K = 8e3),
        (le.F16K = 16e3);
      class ue extends ie.A {
        constructor() {
          super(...arguments),
            (this.speed = 1),
            (this.muted = !1),
            (this.volume = 1),
            (this.paused = !1);
        }
        refresh() {
          this.emit("refresh");
        }
        refreshPaused() {
          this.emit("refreshPaused");
        }
        get filters() {
          return console.warn("HTML Audio does not support filters"), null;
        }
        set filters(t) {
          console.warn("HTML Audio does not support filters");
        }
        get audioContext() {
          return console.warn("HTML Audio does not support audioContext"), null;
        }
        toggleMute() {
          return (this.muted = !this.muted), this.refresh(), this.muted;
        }
        togglePause() {
          return (
            (this.paused = !this.paused), this.refreshPaused(), this.paused
          );
        }
        destroy() {
          this.removeAllListeners();
        }
      }
      let he = 0;
      const ce = class extends ie.A {
        constructor(t) {
          super(), (this.id = he++), this.init(t);
        }
        set(t, e) {
          if (void 0 === this[t])
            throw new Error(`Property with name ${t} does not exist.`);
          switch (t) {
            case "speed":
              this.speed = e;
              break;
            case "volume":
              this.volume = e;
              break;
            case "paused":
              this.paused = e;
              break;
            case "loop":
              this.loop = e;
              break;
            case "muted":
              this.muted = e;
          }
          return this;
        }
        get progress() {
          const { currentTime: t } = this._source;
          return t / this._duration;
        }
        get paused() {
          return this._paused;
        }
        set paused(t) {
          (this._paused = t), this.refreshPaused();
        }
        _onPlay() {
          this._playing = !0;
        }
        _onPause() {
          this._playing = !1;
        }
        init(t) {
          (this._playing = !1), (this._duration = t.source.duration);
          const e = (this._source = t.source.cloneNode(!1));
          (e.src = t.parent.url),
            (e.onplay = this._onPlay.bind(this)),
            (e.onpause = this._onPause.bind(this)),
            t.context.on("refresh", this.refresh, this),
            t.context.on("refreshPaused", this.refreshPaused, this),
            (this._media = t);
        }
        _internalStop() {
          this._source &&
            this._playing &&
            ((this._source.onended = null), this._source.pause());
        }
        stop() {
          this._internalStop(), this._source && this.emit("stop");
        }
        get speed() {
          return this._speed;
        }
        set speed(t) {
          (this._speed = t), this.refresh();
        }
        get volume() {
          return this._volume;
        }
        set volume(t) {
          (this._volume = t), this.refresh();
        }
        get loop() {
          return this._loop;
        }
        set loop(t) {
          (this._loop = t), this.refresh();
        }
        get muted() {
          return this._muted;
        }
        set muted(t) {
          (this._muted = t), this.refresh();
        }
        get filters() {
          return console.warn("HTML Audio does not support filters"), null;
        }
        set filters(t) {
          console.warn("HTML Audio does not support filters");
        }
        refresh() {
          const t = this._media.context,
            e = this._media.parent;
          this._source.loop = this._loop || e.loop;
          const i = t.volume * (t.muted ? 0 : 1),
            n = e.volume * (e.muted ? 0 : 1),
            s = this._volume * (this._muted ? 0 : 1);
          (this._source.volume = s * i * n),
            (this._source.playbackRate = this._speed * t.speed * e.speed);
        }
        refreshPaused() {
          const t = this._media.context,
            e = this._media.parent,
            i = this._paused || e.paused || t.paused;
          i !== this._pausedReal &&
            ((this._pausedReal = i),
            i
              ? (this._internalStop(), this.emit("paused"))
              : (this.emit("resumed"),
                this.play({
                  start: this._source.currentTime,
                  end: this._end,
                  volume: this._volume,
                  speed: this._speed,
                  loop: this._loop,
                })),
            this.emit("pause", i));
        }
        play(t) {
          const {
            start: e,
            end: i,
            speed: n,
            loop: s,
            volume: r,
            muted: o,
          } = t;
          i && console.assert(i > e, "End time is before start time"),
            (this._speed = n),
            (this._volume = r),
            (this._loop = !!s),
            (this._muted = o),
            this.refresh(),
            this.loop &&
              null !== i &&
              (console.warn(
                'Looping not support when specifying an "end" time'
              ),
              (this.loop = !1)),
            (this._start = e),
            (this._end = i || this._duration),
            (this._start = Math.max(0, this._start - ce.PADDING)),
            (this._end = Math.min(this._end + ce.PADDING, this._duration)),
            (this._source.onloadedmetadata = () => {
              this._source &&
                ((this._source.currentTime = e),
                (this._source.onloadedmetadata = null),
                this.emit("progress", e, this._duration),
                te.R.shared.add(this._onUpdate, this));
            }),
            (this._source.onended = this._onComplete.bind(this)),
            this._source.play(),
            this.emit("start");
        }
        _onUpdate() {
          this.emit("progress", this.progress, this._duration),
            this._source.currentTime >= this._end &&
              !this._source.loop &&
              this._onComplete();
        }
        _onComplete() {
          te.R.shared.remove(this._onUpdate, this),
            this._internalStop(),
            this.emit("progress", 1, this._duration),
            this.emit("end", this);
        }
        destroy() {
          te.R.shared.remove(this._onUpdate, this), this.removeAllListeners();
          const t = this._source;
          t &&
            ((t.onended = null),
            (t.onplay = null),
            (t.onpause = null),
            this._internalStop()),
            (this._source = null),
            (this._speed = 1),
            (this._volume = 1),
            (this._loop = !1),
            (this._end = null),
            (this._start = 0),
            (this._duration = 0),
            (this._playing = !1),
            (this._pausedReal = !1),
            (this._paused = !1),
            (this._muted = !1),
            this._media &&
              (this._media.context.off("refresh", this.refresh, this),
              this._media.context.off(
                "refreshPaused",
                this.refreshPaused,
                this
              ),
              (this._media = null));
        }
        toString() {
          return `[HTMLAudioInstance id=${this.id}]`;
        }
      };
      let de = ce;
      de.PADDING = 0.1;
      class pe extends ie.A {
        init(t) {
          (this.parent = t),
            (this._source = t.options.source || new Audio()),
            t.url && (this._source.src = t.url);
        }
        create() {
          return new de(this);
        }
        get isPlayable() {
          return !!this._source && 4 === this._source.readyState;
        }
        get duration() {
          return this._source.duration;
        }
        get context() {
          return this.parent.context;
        }
        get filters() {
          return null;
        }
        set filters(t) {
          console.warn("HTML Audio does not support filters");
        }
        destroy() {
          this.removeAllListeners(),
            (this.parent = null),
            this._source &&
              ((this._source.src = ""),
              this._source.load(),
              (this._source = null));
        }
        get source() {
          return this._source;
        }
        load(t) {
          const e = this._source,
            i = this.parent;
          if (4 === e.readyState) {
            i.isLoaded = !0;
            const e = i.autoPlayStart();
            return void (
              t &&
              setTimeout(() => {
                t(null, i, e);
              }, 0)
            );
          }
          if (!i.url)
            return void t(new Error("sound.url or sound.source must be set"));
          e.src = i.url;
          const n = () => {
              o(), (i.isLoaded = !0);
              const e = i.autoPlayStart();
              t && t(null, i, e);
            },
            s = () => {
              o(), t && t(new Error("Sound loading has been aborted"));
            },
            r = () => {
              o();
              const i = `Failed to load audio element (code: ${e.error.code})`;
              t ? t(new Error(i)) : console.error(i);
            },
            o = () => {
              e.removeEventListener("canplaythrough", n),
                e.removeEventListener("load", n),
                e.removeEventListener("abort", s),
                e.removeEventListener("error", r);
            };
          e.addEventListener("canplaythrough", n, !1),
            e.addEventListener("load", n, !1),
            e.addEventListener("abort", s, !1),
            e.addEventListener("error", r, !1),
            e.load();
        }
      }
      class fe {
        constructor(t, e) {
          (this.parent = t),
            Object.assign(this, e),
            (this.duration = this.end - this.start),
            console.assert(
              this.duration > 0,
              "End time must be after start time"
            );
        }
        play(t) {
          return this.parent.play({
            complete: t,
            speed: this.speed || this.parent.speed,
            end: this.end,
            start: this.start,
            loop: this.loop,
          });
        }
        destroy() {
          this.parent = null;
        }
      }
      const me = [
          "ogg",
          "oga",
          "opus",
          "m4a",
          "mp3",
          "mpeg",
          "wav",
          "aiff",
          "wma",
          "mid",
          "caf",
        ],
        ge = ["audio/mpeg", "audio/ogg"],
        ve = {};
      !(function (t) {
        const e = {
            m4a: "audio/mp4",
            oga: "audio/ogg",
            opus: 'audio/ogg; codecs="opus"',
            caf: 'audio/x-caf; codecs="opus"',
            ...(t || {}),
          },
          i = document.createElement("audio"),
          n = {},
          s = /^no$/;
        me.forEach((t) => {
          const r = i.canPlayType(`audio/${t}`).replace(s, ""),
            o = e[t] ? i.canPlayType(e[t]).replace(s, "") : "";
          n[t] = !!r || !!o;
        }),
          Object.assign(ve, n);
      })();
      let ye = 0;
      class xe extends ie.A {
        constructor(t) {
          super(),
            (this.id = ye++),
            (this._media = null),
            (this._paused = !1),
            (this._muted = !1),
            (this._elapsed = 0),
            this.init(t);
        }
        set(t, e) {
          if (void 0 === this[t])
            throw new Error(`Property with name ${t} does not exist.`);
          switch (t) {
            case "speed":
              this.speed = e;
              break;
            case "volume":
              this.volume = e;
              break;
            case "muted":
              this.muted = e;
              break;
            case "loop":
              this.loop = e;
              break;
            case "paused":
              this.paused = e;
          }
          return this;
        }
        stop() {
          this._source && (this._internalStop(), this.emit("stop"));
        }
        get speed() {
          return this._speed;
        }
        set speed(t) {
          (this._speed = t), this.refresh(), this._update(!0);
        }
        get volume() {
          return this._volume;
        }
        set volume(t) {
          (this._volume = t), this.refresh();
        }
        get muted() {
          return this._muted;
        }
        set muted(t) {
          (this._muted = t), this.refresh();
        }
        get loop() {
          return this._loop;
        }
        set loop(t) {
          (this._loop = t), this.refresh();
        }
        get filters() {
          return this._filters;
        }
        set filters(t) {
          this._filters &&
            (this._filters?.filter((t) => t).forEach((t) => t.disconnect()),
            (this._filters = null),
            this._source.connect(this._gain)),
            (this._filters = t?.length ? t.slice(0) : null),
            this.refresh();
        }
        refresh() {
          if (!this._source) return;
          const t = this._media.context,
            e = this._media.parent;
          this._source.loop = this._loop || e.loop;
          const i = t.volume * (t.muted ? 0 : 1),
            n = e.volume * (e.muted ? 0 : 1),
            s = this._volume * (this._muted ? 0 : 1);
          oe.setParamValue(this._gain.gain, s * n * i),
            oe.setParamValue(
              this._source.playbackRate,
              this._speed * e.speed * t.speed
            ),
            this.applyFilters();
        }
        applyFilters() {
          if (this._filters?.length) {
            this._source.disconnect();
            let t = this._source;
            this._filters.forEach((e) => {
              t.connect(e.destination), (t = e);
            }),
              t.connect(this._gain);
          }
        }
        refreshPaused() {
          const t = this._media.context,
            e = this._media.parent,
            i = this._paused || e.paused || t.paused;
          i !== this._pausedReal &&
            ((this._pausedReal = i),
            i
              ? (this._internalStop(), this.emit("paused"))
              : (this.emit("resumed"),
                this.play({
                  start: this._elapsed % this._duration,
                  end: this._end,
                  speed: this._speed,
                  loop: this._loop,
                  volume: this._volume,
                })),
            this.emit("pause", i));
        }
        play(t) {
          const {
            start: e,
            end: i,
            speed: n,
            loop: s,
            volume: r,
            muted: o,
            filters: a,
          } = t;
          i && console.assert(i > e, "End time is before start time"),
            (this._paused = !1);
          const { source: l, gain: u } = this._media.nodes.cloneBufferSource();
          (this._source = l),
            (this._gain = u),
            (this._speed = n),
            (this._volume = r),
            (this._loop = !!s),
            (this._muted = o),
            (this._filters = a),
            this.refresh();
          const h = this._source.buffer.duration;
          (this._duration = h),
            (this._end = i),
            (this._lastUpdate = this._now()),
            (this._elapsed = e),
            (this._source.onended = this._onComplete.bind(this)),
            this._loop
              ? ((this._source.loopEnd = i),
                (this._source.loopStart = e),
                this._source.start(0, e))
              : i
              ? this._source.start(0, e, i - e)
              : this._source.start(0, e),
            this.emit("start"),
            this._update(!0),
            this.enableTicker(!0);
        }
        enableTicker(t) {
          te.R.shared.remove(this._updateListener, this),
            t && te.R.shared.add(this._updateListener, this);
        }
        get progress() {
          return this._progress;
        }
        get paused() {
          return this._paused;
        }
        set paused(t) {
          (this._paused = t), this.refreshPaused();
        }
        destroy() {
          this.removeAllListeners(),
            this._internalStop(),
            this._gain && (this._gain.disconnect(), (this._gain = null)),
            this._media &&
              (this._media.context.events.off("refresh", this.refresh, this),
              this._media.context.events.off(
                "refreshPaused",
                this.refreshPaused,
                this
              ),
              (this._media = null)),
            this._filters?.forEach((t) => t.disconnect()),
            (this._filters = null),
            (this._end = null),
            (this._speed = 1),
            (this._volume = 1),
            (this._loop = !1),
            (this._elapsed = 0),
            (this._duration = 0),
            (this._paused = !1),
            (this._muted = !1),
            (this._pausedReal = !1);
        }
        toString() {
          return `[WebAudioInstance id=${this.id}]`;
        }
        _now() {
          return this._media.context.audioContext.currentTime;
        }
        _updateListener() {
          this._update();
        }
        _update(t = !1) {
          if (this._source) {
            const e = this._now(),
              i = e - this._lastUpdate;
            if (i > 0 || t) {
              const t = this._source.playbackRate.value;
              (this._elapsed += i * t), (this._lastUpdate = e);
              const n = this._duration;
              let s;
              if (this._source.loopStart) {
                const t = this._source.loopEnd - this._source.loopStart;
                s = (this._source.loopStart + (this._elapsed % t)) / n;
              } else s = (this._elapsed % n) / n;
              (this._progress = s), this.emit("progress", this._progress, n);
            }
          }
        }
        init(t) {
          (this._media = t),
            t.context.events.on("refresh", this.refresh, this),
            t.context.events.on("refreshPaused", this.refreshPaused, this);
        }
        _internalStop() {
          if (this._source) {
            this.enableTicker(!1),
              (this._source.onended = null),
              this._source.stop(0),
              this._source.disconnect();
            try {
              this._source.buffer = null;
            } catch (t) {
              console.warn(
                "Failed to set AudioBufferSourceNode.buffer to null:",
                t
              );
            }
            this._source = null;
          }
        }
        _onComplete() {
          if (this._source) {
            this.enableTicker(!1),
              (this._source.onended = null),
              this._source.disconnect();
            try {
              this._source.buffer = null;
            } catch (t) {
              console.warn(
                "Failed to set AudioBufferSourceNode.buffer to null:",
                t
              );
            }
          }
          (this._source = null),
            (this._progress = 1),
            this.emit("progress", 1, this._duration),
            this.emit("end", this);
        }
      }
      class be {
        constructor(t, e) {
          (this._output = e), (this._input = t);
        }
        get destination() {
          return this._input;
        }
        get filters() {
          return this._filters;
        }
        set filters(t) {
          if (
            (this._filters &&
              (this._filters.forEach((t) => {
                t && t.disconnect();
              }),
              (this._filters = null),
              this._input.connect(this._output)),
            t && t.length)
          ) {
            (this._filters = t.slice(0)), this._input.disconnect();
            let e = null;
            t.forEach((t) => {
              null === e
                ? this._input.connect(t.destination)
                : e.connect(t.destination),
                (e = t);
            }),
              e.connect(this._output);
          }
        }
        destroy() {
          (this.filters = null), (this._input = null), (this._output = null);
        }
      }
      const Se = class extends be {
        constructor(t) {
          const e = t.audioContext,
            i = e.createBufferSource(),
            n = e.createGain(),
            s = e.createAnalyser();
          i.connect(s),
            s.connect(n),
            n.connect(t.destination),
            super(s, n),
            (this.context = t),
            (this.bufferSource = i),
            (this.gain = n),
            (this.analyser = s);
        }
        get script() {
          return (
            this._script ||
              ((this._script = this.context.audioContext.createScriptProcessor(
                Se.BUFFER_SIZE
              )),
              this._script.connect(this.context.destination)),
            this._script
          );
        }
        destroy() {
          super.destroy(),
            this.bufferSource.disconnect(),
            this._script && this._script.disconnect(),
            this.gain.disconnect(),
            this.analyser.disconnect(),
            (this.bufferSource = null),
            (this._script = null),
            (this.gain = null),
            (this.analyser = null),
            (this.context = null);
        }
        cloneBufferSource() {
          const t = this.bufferSource,
            e = this.context.audioContext.createBufferSource();
          (e.buffer = t.buffer),
            oe.setParamValue(e.playbackRate, t.playbackRate.value),
            (e.loop = t.loop);
          const i = this.context.audioContext.createGain();
          return (
            e.connect(i), i.connect(this.destination), { source: e, gain: i }
          );
        }
        get bufferSize() {
          return this.script.bufferSize;
        }
      };
      let Ce = Se;
      Ce.BUFFER_SIZE = 0;
      class _e {
        init(t) {
          (this.parent = t),
            (this._nodes = new Ce(this.context)),
            (this._source = this._nodes.bufferSource),
            (this.source = t.options.source);
        }
        destroy() {
          (this.parent = null), this._nodes.destroy(), (this._nodes = null);
          try {
            this._source.buffer = null;
          } catch (t) {
            console.warn(
              "Failed to set AudioBufferSourceNode.buffer to null:",
              t
            );
          }
          (this._source = null), (this.source = null);
        }
        create() {
          return new xe(this);
        }
        get context() {
          return this.parent.context;
        }
        get isPlayable() {
          return !!this._source && !!this._source.buffer;
        }
        get filters() {
          return this._nodes.filters;
        }
        set filters(t) {
          this._nodes.filters = t;
        }
        get duration() {
          return (
            console.assert(
              this.isPlayable,
              "Sound not yet playable, no duration"
            ),
            this._source.buffer.duration
          );
        }
        get buffer() {
          return this._source.buffer;
        }
        set buffer(t) {
          this._source.buffer = t;
        }
        get nodes() {
          return this._nodes;
        }
        load(t) {
          this.source
            ? this._decode(this.source, t)
            : this.parent.url
            ? this._loadUrl(t)
            : t
            ? t(new Error("sound.url or sound.source must be set"))
            : console.error("sound.url or sound.source must be set");
        }
        async _loadUrl(t) {
          const e = this.parent.url,
            i = await _.e.get().fetch(e);
          this._decode(await i.arrayBuffer(), t);
        }
        _decode(t, e) {
          const i = (t, i) => {
            if (t) e && e(t);
            else {
              (this.parent.isLoaded = !0), (this.buffer = i);
              const t = this.parent.autoPlayStart();
              e && e(null, this.parent, t);
            }
          };
          if (t instanceof AudioBuffer) i(null, t);
          else {
            this.parent.context.decode(t, i);
          }
        }
      }
      const Te = class {
        static from(t) {
          let e = {};
          "string" == typeof t
            ? (e.url = t)
            : t instanceof ArrayBuffer ||
              t instanceof AudioBuffer ||
              t instanceof HTMLAudioElement
            ? (e.source = t)
            : Array.isArray(t)
            ? (e.url = t)
            : (e = t),
            (e = {
              autoPlay: !1,
              singleInstance: !1,
              url: null,
              source: null,
              preload: !1,
              volume: 1,
              speed: 1,
              complete: null,
              loaded: null,
              loop: !1,
              ...e,
            }),
            Object.freeze(e);
          const i = se().useLegacy ? new pe() : new _e();
          return new Te(i, e);
        }
        constructor(t, e) {
          (this.media = t),
            (this.options = e),
            (this._instances = []),
            (this._sprites = {}),
            this.media.init(this);
          const i = e.complete;
          (this._autoPlayOptions = i ? { complete: i } : null),
            (this.isLoaded = !1),
            (this._preloadQueue = null),
            (this.isPlaying = !1),
            (this.autoPlay = e.autoPlay),
            (this.singleInstance = e.singleInstance),
            (this.preload = e.preload || this.autoPlay),
            (this.url = Array.isArray(e.url) ? this.preferUrl(e.url) : e.url),
            (this.speed = e.speed),
            (this.volume = e.volume),
            (this.loop = e.loop),
            e.sprites && this.addSprites(e.sprites),
            this.preload && this._preload(e.loaded);
        }
        preferUrl(t) {
          const [e] = t
            .map((t) => ({ url: t, ext: x.A.extname(t).slice(1) }))
            .filter(({ ext: t }) => ve[t])
            .sort((t, e) => me.indexOf(t.ext) - me.indexOf(e.ext));
          if (!e) throw new Error("No supported file type found");
          return e.url;
        }
        get context() {
          return se().context;
        }
        pause() {
          return (this.isPlaying = !1), (this.paused = !0), this;
        }
        resume() {
          return (
            (this.isPlaying = this._instances.length > 0),
            (this.paused = !1),
            this
          );
        }
        get paused() {
          return this._paused;
        }
        set paused(t) {
          (this._paused = t), this.refreshPaused();
        }
        get speed() {
          return this._speed;
        }
        set speed(t) {
          (this._speed = t), this.refresh();
        }
        get filters() {
          return this.media.filters;
        }
        set filters(t) {
          this.media.filters = t;
        }
        addSprites(t, e) {
          if ("object" == typeof t) {
            const e = {};
            for (const i in t) e[i] = this.addSprites(i, t[i]);
            return e;
          }
          console.assert(!this._sprites[t], `Alias ${t} is already taken`);
          const i = new fe(this, e);
          return (this._sprites[t] = i), i;
        }
        destroy() {
          this._removeInstances(),
            this.removeSprites(),
            this.media.destroy(),
            (this.media = null),
            (this._sprites = null),
            (this._instances = null);
        }
        removeSprites(t) {
          if (t) {
            const e = this._sprites[t];
            void 0 !== e && (e.destroy(), delete this._sprites[t]);
          } else for (const t in this._sprites) this.removeSprites(t);
          return this;
        }
        get isPlayable() {
          return this.isLoaded && this.media && this.media.isPlayable;
        }
        stop() {
          if (!this.isPlayable)
            return (this.autoPlay = !1), (this._autoPlayOptions = null), this;
          this.isPlaying = !1;
          for (let t = this._instances.length - 1; t >= 0; t--)
            this._instances[t].stop();
          return this;
        }
        play(t, e) {
          let i;
          if ("string" == typeof t) {
            i = { sprite: t, loop: this.loop, complete: e };
          } else
            "function" == typeof t ? ((i = {}), (i.complete = t)) : (i = t);
          if (
            ((i = {
              complete: null,
              loaded: null,
              sprite: null,
              end: null,
              start: 0,
              volume: 1,
              speed: 1,
              muted: !1,
              loop: !1,
              ...(i || {}),
            }),
            i.sprite)
          ) {
            const t = i.sprite;
            console.assert(!!this._sprites[t], `Alias ${t} is not available`);
            const e = this._sprites[t];
            (i.start = e.start + (i.start || 0)),
              (i.end = e.end),
              (i.speed = e.speed || 1),
              (i.loop = e.loop || i.loop),
              delete i.sprite;
          }
          if ((i.offset && (i.start = i.offset), !this.isLoaded))
            return this._preloadQueue
              ? new Promise((t) => {
                  this._preloadQueue.push(() => {
                    t(this.play(i));
                  });
                })
              : ((this._preloadQueue = []),
                (this.autoPlay = !0),
                (this._autoPlayOptions = i),
                new Promise((t, e) => {
                  this._preload((n, s, r) => {
                    this._preloadQueue.forEach((t) => t()),
                      (this._preloadQueue = null),
                      n ? e(n) : (i.loaded && i.loaded(n, s, r), t(r));
                  });
                }));
          (this.singleInstance || i.singleInstance) && this._removeInstances();
          const n = this._createInstance();
          return (
            this._instances.push(n),
            (this.isPlaying = !0),
            n.once("end", () => {
              i.complete && i.complete(this), this._onComplete(n);
            }),
            n.once("stop", () => {
              this._onComplete(n);
            }),
            n.play(i),
            n
          );
        }
        refresh() {
          const t = this._instances.length;
          for (let e = 0; e < t; e++) this._instances[e].refresh();
        }
        refreshPaused() {
          const t = this._instances.length;
          for (let e = 0; e < t; e++) this._instances[e].refreshPaused();
        }
        get volume() {
          return this._volume;
        }
        set volume(t) {
          (this._volume = t), this.refresh();
        }
        get muted() {
          return this._muted;
        }
        set muted(t) {
          (this._muted = t), this.refresh();
        }
        get loop() {
          return this._loop;
        }
        set loop(t) {
          (this._loop = t), this.refresh();
        }
        _preload(t) {
          this.media.load(t);
        }
        get instances() {
          return this._instances;
        }
        get sprites() {
          return this._sprites;
        }
        get duration() {
          return this.media.duration;
        }
        autoPlayStart() {
          let t;
          return this.autoPlay && (t = this.play(this._autoPlayOptions)), t;
        }
        _removeInstances() {
          for (let t = this._instances.length - 1; t >= 0; t--)
            this._poolInstance(this._instances[t]);
          this._instances.length = 0;
        }
        _onComplete(t) {
          if (this._instances) {
            const e = this._instances.indexOf(t);
            e > -1 && this._instances.splice(e, 1),
              (this.isPlaying = this._instances.length > 0);
          }
          this._poolInstance(t);
        }
        _createInstance() {
          if (Te._pool.length > 0) {
            const t = Te._pool.pop();
            return t.init(this.media), t;
          }
          return this.media.create();
        }
        _poolInstance(t) {
          t.destroy(), Te._pool.indexOf(t) < 0 && Te._pool.push(t);
        }
      };
      let we = Te;
      we._pool = [];
      class Pe extends be {
        constructor() {
          const t = window,
            e = new Pe.AudioContext(),
            i = e.createDynamicsCompressor(),
            n = e.createAnalyser();
          n.connect(i),
            i.connect(e.destination),
            super(n, i),
            (this.autoPause = !0),
            (this._ctx = e),
            (this._offlineCtx = new Pe.OfflineAudioContext(
              1,
              2,
              t.OfflineAudioContext
                ? Math.max(8e3, Math.min(96e3, e.sampleRate))
                : 44100
            )),
            (this.compressor = i),
            (this.analyser = n),
            (this.events = new ie.A()),
            (this.volume = 1),
            (this.speed = 1),
            (this.muted = !1),
            (this.paused = !1),
            (this._locked =
              "suspended" === e.state &&
              ("ontouchstart" in globalThis || "onclick" in globalThis)),
            this._locked &&
              (this._unlock(),
              (this._unlock = this._unlock.bind(this)),
              document.addEventListener("mousedown", this._unlock, !0),
              document.addEventListener("touchstart", this._unlock, !0),
              document.addEventListener("touchend", this._unlock, !0)),
            (this.onFocus = this.onFocus.bind(this)),
            (this.onBlur = this.onBlur.bind(this)),
            globalThis.addEventListener("focus", this.onFocus),
            globalThis.addEventListener("blur", this.onBlur);
        }
        onFocus() {
          if (!this.autoPause) return;
          const t = this._ctx.state;
          ("suspended" !== t && "interrupted" !== t && this._locked) ||
            ((this.paused = this._pausedOnBlur), this.refreshPaused());
        }
        onBlur() {
          this.autoPause &&
            (this._locked ||
              ((this._pausedOnBlur = this._paused),
              (this.paused = !0),
              this.refreshPaused()));
        }
        _unlock() {
          this._locked &&
            (this.playEmptySound(),
            "running" === this._ctx.state &&
              (document.removeEventListener("mousedown", this._unlock, !0),
              document.removeEventListener("touchend", this._unlock, !0),
              document.removeEventListener("touchstart", this._unlock, !0),
              (this._locked = !1)));
        }
        playEmptySound() {
          const t = this._ctx.createBufferSource();
          (t.buffer = this._ctx.createBuffer(1, 1, 22050)),
            t.connect(this._ctx.destination),
            t.start(0, 0, 0),
            "suspended" === t.context.state && t.context.resume();
        }
        static get AudioContext() {
          const t = window;
          return t.AudioContext || t.webkitAudioContext || null;
        }
        static get OfflineAudioContext() {
          const t = window;
          return t.OfflineAudioContext || t.webkitOfflineAudioContext || null;
        }
        destroy() {
          super.destroy();
          const t = this._ctx;
          void 0 !== t.close && t.close(),
            globalThis.removeEventListener("focus", this.onFocus),
            globalThis.removeEventListener("blur", this.onBlur),
            this.events.removeAllListeners(),
            this.analyser.disconnect(),
            this.compressor.disconnect(),
            (this.analyser = null),
            (this.compressor = null),
            (this.events = null),
            (this._offlineCtx = null),
            (this._ctx = null);
        }
        get audioContext() {
          return this._ctx;
        }
        get offlineContext() {
          return this._offlineCtx;
        }
        set paused(t) {
          t && "running" === this._ctx.state
            ? this._ctx.suspend()
            : t || "suspended" !== this._ctx.state || this._ctx.resume(),
            (this._paused = t);
        }
        get paused() {
          return this._paused;
        }
        refresh() {
          this.events.emit("refresh");
        }
        refreshPaused() {
          this.events.emit("refreshPaused");
        }
        toggleMute() {
          return (this.muted = !this.muted), this.refresh(), this.muted;
        }
        togglePause() {
          return (
            (this.paused = !this.paused), this.refreshPaused(), this._paused
          );
        }
        decode(t, e) {
          const i = (t) => {
              e(new Error(t?.message || "Unable to decode file"));
            },
            n = this._offlineCtx.decodeAudioData(
              t,
              (t) => {
                e(null, t);
              },
              i
            );
          n && n.catch(i);
        }
      }
      const Ae = (t) => {
          const e = t.src;
          let i = t?.alias?.[0];
          return (i && t.src !== i) || (i = x.A.basename(e, x.A.extname(e))), i;
        },
        ke = {
          extension: t.Ag.Asset,
          detection: {
            test: async () => !0,
            add: async (t) => [...t, ...me.filter((t) => ve[t])],
            remove: async (t) => t.filter((e) => t.includes(e)),
          },
          loader: {
            name: "sound",
            extension: { type: [t.Ag.LoadParser], priority: P.T.High },
            test(t) {
              const e = x.A.extname(t).slice(1);
              return !!ve[e] || ge.some((e) => t.startsWith(`data:${e}`));
            },
            async load(t, e) {
              const i = await new Promise((i, n) =>
                we.from({
                  ...e.data,
                  url: t,
                  preload: !0,
                  loaded(t, s) {
                    t ? n(t) : i(s), e.data?.loaded?.(t, s);
                  },
                })
              );
              return se().add(Ae(e), i), i;
            },
            async unload(t, e) {
              se().remove(Ae(e));
            },
          },
        };
      t.XO.add(ke);
      !(function (t) {
        ne = t;
      })(
        new (class {
          constructor() {
            this.init();
          }
          init() {
            return (
              this.supported && (this._webAudioContext = new Pe()),
              (this._htmlAudioContext = new ue()),
              (this._sounds = {}),
              (this.useLegacy = !this.supported),
              this
            );
          }
          get context() {
            return this._context;
          }
          get filtersAll() {
            return this.useLegacy ? [] : this._context.filters;
          }
          set filtersAll(t) {
            this.useLegacy || (this._context.filters = t);
          }
          get supported() {
            return null !== Pe.AudioContext;
          }
          add(t, e) {
            if ("object" == typeof t) {
              const i = {};
              for (const n in t) {
                const s = this._getOptions(t[n], e);
                i[n] = this.add(n, s);
              }
              return i;
            }
            if (
              (console.assert(
                !this._sounds[t],
                `Sound with alias ${t} already exists.`
              ),
              e instanceof we)
            )
              return (this._sounds[t] = e), e;
            const i = this._getOptions(e),
              n = we.from(i);
            return (this._sounds[t] = n), n;
          }
          _getOptions(t, e) {
            let i;
            return (
              (i =
                "string" == typeof t || Array.isArray(t)
                  ? { url: t }
                  : t instanceof ArrayBuffer ||
                    t instanceof AudioBuffer ||
                    t instanceof HTMLAudioElement
                  ? { source: t }
                  : t),
              (i = { ...i, ...(e || {}) }),
              i
            );
          }
          get useLegacy() {
            return this._useLegacy;
          }
          set useLegacy(t) {
            (this._useLegacy = t),
              (this._context =
                !t && this.supported
                  ? this._webAudioContext
                  : this._htmlAudioContext);
          }
          get disableAutoPause() {
            return !this._webAudioContext.autoPause;
          }
          set disableAutoPause(t) {
            this._webAudioContext.autoPause = !t;
          }
          remove(t) {
            return (
              this.exists(t, !0),
              this._sounds[t].destroy(),
              delete this._sounds[t],
              this
            );
          }
          get volumeAll() {
            return this._context.volume;
          }
          set volumeAll(t) {
            (this._context.volume = t), this._context.refresh();
          }
          get speedAll() {
            return this._context.speed;
          }
          set speedAll(t) {
            (this._context.speed = t), this._context.refresh();
          }
          togglePauseAll() {
            return this._context.togglePause();
          }
          pauseAll() {
            return (
              (this._context.paused = !0), this._context.refreshPaused(), this
            );
          }
          resumeAll() {
            return (
              (this._context.paused = !1), this._context.refreshPaused(), this
            );
          }
          toggleMuteAll() {
            return this._context.toggleMute();
          }
          muteAll() {
            return (this._context.muted = !0), this._context.refresh(), this;
          }
          unmuteAll() {
            return (this._context.muted = !1), this._context.refresh(), this;
          }
          removeAll() {
            for (const t in this._sounds)
              this._sounds[t].destroy(), delete this._sounds[t];
            return this;
          }
          stopAll() {
            for (const t in this._sounds) this._sounds[t].stop();
            return this;
          }
          exists(t, e = !1) {
            const i = !!this._sounds[t];
            return e && console.assert(i, `No sound matching alias '${t}'.`), i;
          }
          isPlaying() {
            for (const t in this._sounds)
              if (this._sounds[t].isPlaying) return !0;
            return !1;
          }
          find(t) {
            return this.exists(t, !0), this._sounds[t];
          }
          play(t, e) {
            return this.find(t).play(e);
          }
          stop(t) {
            return this.find(t).stop();
          }
          pause(t) {
            return this.find(t).pause();
          }
          resume(t) {
            return this.find(t).resume();
          }
          volume(t, e) {
            const i = this.find(t);
            return void 0 !== e && (i.volume = e), i.volume;
          }
          speed(t, e) {
            const i = this.find(t);
            return void 0 !== e && (i.speed = e), i.speed;
          }
          duration(t) {
            return this.find(t).duration;
          }
          close() {
            return (
              this.removeAll(),
              (this._sounds = null),
              this._webAudioContext &&
                (this._webAudioContext.destroy(),
                (this._webAudioContext = null)),
              this._htmlAudioContext &&
                (this._htmlAudioContext.destroy(),
                (this._htmlAudioContext = null)),
              (this._context = null),
              this
            );
          }
        })()
      );
      class Me extends Gt.mc {
        constructor(t) {
          super(), (this.ui = t);
        }
        show() {
          (this.visible = !0), (this.eventMode = "static");
        }
        hide() {
          (this.visible = !1), (this.eventMode = "none");
        }
      }
      var Ee,
        Ie,
        De,
        Re,
        Be,
        Fe,
        Oe,
        ze,
        Le,
        He,
        Ue = n(2543),
        Ne = function (t, e, i, n) {
          return new (i || (i = Promise))(function (s, r) {
            function o(t) {
              try {
                l(n.next(t));
              } catch (t) {
                r(t);
              }
            }
            function a(t) {
              try {
                l(n.throw(t));
              } catch (t) {
                r(t);
              }
            }
            function l(t) {
              var e;
              t.done
                ? s(t.value)
                : ((e = t.value),
                  e instanceof i
                    ? e
                    : new i(function (t) {
                        t(e);
                      })).then(o, a);
            }
            l((n = n.apply(t, e || [])).next());
          });
        };
      class Ge extends Me {
        constructor(t, e) {
          var i, n, s, r;
          super(t),
            (this.options = (0, Ue.cloneDeep)(e)),
            (this.backgroundContainer = new Gt.mc()),
            this.addChild(this.backgroundContainer),
            (this.backgroundSprite = new Xt.k()),
            this.backgroundContainer.addChild(this.backgroundSprite);
          const o =
              null !==
                (n = null === (i = e.anchor) || void 0 === i ? void 0 : i.x) &&
              void 0 !== n
                ? n
                : 0,
            a =
              null !==
                (r = null === (s = e.anchor) || void 0 === s ? void 0 : s.y) &&
              void 0 !== r
                ? r
                : 0;
          this.backgroundSprite.anchor.set(o, a);
        }
        setHeight(t) {
          this.options.size.y = t;
        }
        setBackgroundTexture(t) {
          (this.options.frameTexture = t), this.updateBackground();
        }
        setBackgroundColor(t) {
          this.backgroundSprite.tint = t;
        }
        addElement(t) {
          return Ne(this, void 0, void 0, function* () {
            yield this.addChild(t),
              yield this.updateBounds(),
              !0 === this.options.centerChildren &&
                (yield this.centerChildren());
          });
        }
        clear() {
          for (let t = this.children.length - 1; t >= 0; t--)
            this.children[t] != this.backgroundContainer &&
              this.removeChildAt(t);
        }
        updateBounds() {
          return Ne(this, void 0, void 0, function* () {
            var t, e, i, n;
            this.backgroundContainer.visible = !1;
            const s = this.options.padding || new Et.b(0, 0),
              r =
                !0 === this.options.autoWidth
                  ? this.width + s.x
                  : null !==
                      (e =
                        null === (t = this.options.size) || void 0 === t
                          ? void 0
                          : t.x) && void 0 !== e
                  ? e
                  : 0,
              o =
                !0 === this.options.autoHeight
                  ? this.height + s.y
                  : null !==
                      (n =
                        null === (i = this.options.size) || void 0 === i
                          ? void 0
                          : i.y) && void 0 !== n
                  ? n
                  : 0;
            (this.options.size = new Et.b(r, o)),
              yield this.updateBackground(),
              (this.backgroundContainer.visible = !0);
          });
        }
        updateBackground() {
          return Ne(this, void 0, void 0, function* () {
            this.backgroundSprite.texture.destroy();
            const t = yield this.ui.frameTexture(this.options);
            this.backgroundSprite.texture = t;
          });
        }
        centerChildren() {
          return Ne(this, void 0, void 0, function* () {
            const t = new Et.b(
              this.backgroundSprite.width,
              this.backgroundSprite.height
            );
            for (let e = this.children.length - 1; e >= 0; e--)
              this.children[e] != this.backgroundContainer &&
                this.children[e].position.set(
                  Math.floor(0.5 * t.x),
                  Math.floor(0.5 * t.y)
                );
          });
        }
      }
      !(function (t) {
        (t[(t.None = -1)] = "None"),
          (t[(t.MAXHP = 0)] = "MAXHP"),
          (t[(t.MAXMP = 1)] = "MAXMP"),
          (t[(t.ATT = 2)] = "ATT"),
          (t[(t.DEF = 3)] = "DEF"),
          (t[(t.SPD = 4)] = "SPD"),
          (t[(t.DEX = 5)] = "DEX"),
          (t[(t.VIT = 6)] = "VIT"),
          (t[(t.WIS = 7)] = "WIS"),
          (t[(t.MPMULTIPLIER = 8)] = "MPMULTIPLIER"),
          (t[(t.XPBONUS = 9)] = "XPBONUS"),
          (t[(t.DMGBOOST = 10)] = "DMGBOOST");
      })(Ee || (Ee = {})),
        (function (t) {
          (t[(t.None = 0)] = "None"),
            (t[(t.Armored = 1)] = "Armored"),
            (t[(t.Berserk = 2)] = "Berserk"),
            (t[(t.Damaging = 3)] = "Damaging"),
            (t[(t.Energized = 4)] = "Energized"),
            (t[(t.Healing = 5)] = "Healing"),
            (t[(t.Inspired = 6)] = "Inspired"),
            (t[(t.Invulnerable = 7)] = "Invulnerable"),
            (t[(t.Speedy = 8)] = "Speedy"),
            (t[(t.StatIncrease = 9)] = "StatIncrease"),
            (t[(t.ArmorBroken = 10)] = "ArmorBroken"),
            (t[(t.Bleeding = 11)] = "Bleeding"),
            (t[(t.Blind = 12)] = "Blind"),
            (t[(t.Confused = 13)] = "Confused"),
            (t[(t.Curse = 14)] = "Curse"),
            (t[(t.Darkness = 15)] = "Darkness"),
            (t[(t.Dazed = 16)] = "Dazed"),
            (t[(t.Drought = 17)] = "Drought"),
            (t[(t.Drunk = 18)] = "Drunk"),
            (t[(t.Exposed = 19)] = "Exposed"),
            (t[(t.Hallucinating = 20)] = "Hallucinating"),
            (t[(t.Hexed = 21)] = "Hexed"),
            (t[(t.Paralyzed = 22)] = "Paralyzed"),
            (t[(t.PetStasis = 23)] = "PetStasis"),
            (t[(t.Quiet = 24)] = "Quiet"),
            (t[(t.Sick = 25)] = "Sick"),
            (t[(t.Silenced = 26)] = "Silenced"),
            (t[(t.Slowed = 27)] = "Slowed"),
            (t[(t.Stunned = 28)] = "Stunned"),
            (t[(t.Unstable = 29)] = "Unstable"),
            (t[(t.Weak = 30)] = "Weak"),
            (t[(t.StatReduction = 31)] = "StatReduction"),
            (t[(t.Invisible = 32)] = "Invisible"),
            (t[(t.Stasis = 33)] = "Stasis"),
            (t[(t.Petrify = 34)] = "Petrify"),
            (t[(t.Nothing = 35)] = "Nothing"),
            (t[(t.InCombat = 36)] = "InCombat"),
            (t[(t.StasisImmune = 37)] = "StasisImmune");
        })(Ie || (Ie = {})),
        (function (t) {
          (t[(t.Empty = 0)] = "Empty"),
            (t[(t.Sword = 1)] = "Sword"),
            (t[(t.Dagger = 2)] = "Dagger"),
            (t[(t.Bow = 3)] = "Bow"),
            (t[(t.Tome = 4)] = "Tome"),
            (t[(t.Shield = 5)] = "Shield"),
            (t[(t.Leather = 6)] = "Leather"),
            (t[(t.Heavy = 7)] = "Heavy"),
            (t[(t.Wand = 8)] = "Wand"),
            (t[(t.Accessory = 9)] = "Accessory"),
            (t[(t.Consumable = 10)] = "Consumable"),
            (t[(t.Spell = 11)] = "Spell"),
            (t[(t.Seal = 12)] = "Seal"),
            (t[(t.Cloak = 13)] = "Cloak"),
            (t[(t.Robe = 14)] = "Robe"),
            (t[(t.Quiver = 15)] = "Quiver"),
            (t[(t.Helm = 16)] = "Helm"),
            (t[(t.Staff = 17)] = "Staff"),
            (t[(t.Poison = 18)] = "Poison"),
            (t[(t.Skull = 19)] = "Skull"),
            (t[(t.Trap = 20)] = "Trap"),
            (t[(t.Orb = 21)] = "Orb"),
            (t[(t.Prism = 22)] = "Prism"),
            (t[(t.Scepter = 23)] = "Scepter"),
            (t[(t.Katana = 24)] = "Katana"),
            (t[(t.Star = 25)] = "Star"),
            (t[(t.Wakizashi = 27)] = "Wakizashi"),
            (t[(t.Lute = 28)] = "Lute"),
            (t[(t.Mace = 29)] = "Mace"),
            (t[(t.Sheath = 30)] = "Sheath");
        })(De || (De = {})),
        (function (t) {
          (t[(t.None = -1)] = "None"),
            (t[(t.Weapon = 0)] = "Weapon"),
            (t[(t.Ability = 1)] = "Ability"),
            (t[(t.Armor = 2)] = "Armor"),
            (t[(t.Accessory = 3)] = "Accessory");
        })(Re || (Re = {})),
        (function (t) {
          (t[(t.None = -1)] = "None"),
            (t[(t.NoStack = 0)] = "NoStack"),
            (t[(t.DiminishingReturns = 1)] = "DiminishingReturns"),
            (t[(t.MaxStack = 2)] = "MaxStack"),
            (t[(t.ArrayStack = 3)] = "ArrayStack");
        })(Be || (Be = {})),
        (function (t) {
          (t[(t.None = 0)] = "None"),
            (t[(t.Magic = 1)] = "Magic"),
            (t[(t.StatBoost = 2)] = "StatBoost"),
            (t[(t.StatusEffect = 3)] = "StatusEffect"),
            (t[(t.Projectile = 4)] = "Projectile"),
            (t[(t.Minion = 5)] = "Minion"),
            (t[(t.Heal = 6)] = "Heal"),
            (t[(t.DamageOverTime = 7)] = "DamageOverTime"),
            (t[(t.PoisonGrenade = 8)] = "PoisonGrenade"),
            (t[(t.Trap = 9)] = "Trap"),
            (t[(t.Teleport = 10)] = "Teleport"),
            (t[(t.Dash = 11)] = "Dash");
        })(Fe || (Fe = {})),
        (function (t) {
          (t[(t.Tiered = 0)] = "Tiered"),
            (t[(t.Set = 100)] = "Set"),
            (t[(t.Untiered = 101)] = "Untiered");
        })(Oe || (Oe = {})),
        (function (t) {
          (t[(t.None = -1)] = "None"),
            (t[(t.AprilFools = 0)] = "AprilFools"),
            (t[(t.Halloween = 1)] = "Halloween"),
            (t[(t.Christmas = 2)] = "Christmas");
        })(ze || (ze = {})),
        (function (t) {
          (t[(t.None = 0)] = "None"),
            (t[(t.MultiplyMinDamage = 1)] = "MultiplyMinDamage"),
            (t[(t.MultiplyMaxDamage = 2)] = "MultiplyMaxDamage"),
            (t[(t.MultiplyRateOfFire = 3)] = "MultiplyRateOfFire"),
            (t[(t.MultiplySpeed = 4)] = "MultiplySpeed"),
            (t[(t.MultiplyLifetimeMs = 5)] = "MultiplyLifetimeMs"),
            (t[(t.MultiplySize = 6)] = "MultiplySize"),
            (t[(t.SetBoomerang = 7)] = "SetBoomerang"),
            (t[(t.RemoveBoomerang = 8)] = "RemoveBoomerang"),
            (t[(t.SetPassesCover = 9)] = "SetPassesCover");
        })(Le || (Le = {})),
        (function (t) {
          (t[(t.None = -1)] = "None"),
            (t[(t.Calculator = 0)] = "Calculator"),
            (t[(t.SkinViewer = 1)] = "SkinViewer"),
            (t[(t.ItemSandbox = 2)] = "ItemSandbox"),
            (t[(t.ItemEditor = 3)] = "ItemEditor"),
            (t[(t.ItemChecklist = 4)] = "ItemChecklist");
        })(He || (He = {}));
      class Ve {
        static nearestPowerOf2(t) {
          let e = 0;
          for (; 1 << e < t; ) e++;
          return 1 << e;
        }
        static elapsedSeconds() {
          return 0.001 * (performance.now() - this.startTimestamp);
        }
        static clearInterval(t) {
          -1 != t && window.clearInterval(t);
        }
        static getBoundsReminder(t) {
          return [
            (t.getBounds().x - t.pivot.x) % 1,
            (t.getBounds().y - t.pivot.y) % 1,
          ];
        }
        static randomInt(t, e) {
          const i = e - t;
          return Math.floor(t + Math.random() * (i + 1));
        }
        static clamp(t, e, i) {
          return Math.max(e, Math.min(t, i));
        }
        static lerp(t, e, i) {
          return t + (e - t) * i;
        }
        static easeOut(t) {
          const e = 1 - t;
          return 1 - e * e;
        }
        static separators(t, e = 0) {
          return t.toFixed(e).replace(/\B(?=(\d{3})+(?!\d))/g, " ");
        }
        static stat(t, e, i = 0) {
          const n = 0 != i ? ` (${Ve.signed(i)})` : "";
          return `${Ve.signed(t)} ${Ve.baseStatName(e)}${n}`;
        }
        static damage(t, e = 0) {
          return `${t} Damage${0 != e ? ` (${Ve.signed(e)})` : ""}`;
        }
        static range(t, e = 0) {
          const i = 0 != e ? ` (${Ve.signed(e, 1)})` : "";
          return `${t.toFixed(1)} sqrs${i}`;
        }
        static heal(t, e = 0) {
          return `${t} HP${0 != e ? ` (${Ve.signed(e)})` : ""}`;
        }
        static time(t, e = 0) {
          const i = 0 != e ? ` (${Ve.signed(e, 1)})` : "";
          return `${t.toFixed(1)} second${t > 1 ? "s" : ""}${i}`;
        }
        static times(t, e = 0) {
          const i = 0 != e ? ` (${Ve.signed(e)})` : "";
          return "" + (1 == t ? "once" : `${t}${i} times`);
        }
        static targets(t, e = 0) {
          return `${t}${0 != e ? ` (${Ve.signed(e)})` : ""} target${
            1 == t ? "" : "s"
          }`;
        }
        static signedPercent(t, e = 0) {
          return `${this.signed(100 * t, e)}%`;
        }
        static percent(t, e = 0) {
          return `${(100 * t).toFixed(e)}%`;
        }
        static signed(t, e = 0) {
          return t > 0 ? `+${t.toFixed(e)}` : t.toFixed(e);
        }
        static value(t, e = 0) {
          return `${t}${0 != e ? ` (${Ve.signed(e)})` : ""}`;
        }
        static stringToToolType(t) {
          switch ((t = t.toLowerCase())) {
            case "skin_viewer":
              return He.SkinViewer;
            case "item_sandbox":
              return He.ItemSandbox;
            case "item_editor":
              return He.ItemEditor;
            case "item_checklist":
              return He.ItemChecklist;
            default:
              return He.Calculator;
          }
        }
        static toolTypeToString(t) {
          switch (t) {
            case He.SkinViewer:
              return "skin_viewer";
            case He.ItemSandbox:
              return "item_sandbox";
            case He.ItemEditor:
              return "item_editor";
            case He.ItemChecklist:
              return "item_checklist";
            default:
              return "calculator";
          }
        }
        static itemTier(t) {
          switch (t) {
            case Oe.Set:
              return ["ST", ti.orange];
            case Oe.Untiered:
              return ["UT", ti.purple];
          }
          return [`T${t}`, ti.white];
        }
        static getSeasonalEvent() {
          const t = new Date(),
            e = t.getMonth() + 1,
            i = t.getDate();
          return 4 == e && 1 == i
            ? ze.AprilFools
            : 10 == e
            ? ze.Halloween
            : 12 == e
            ? ze.Christmas
            : ze.None;
        }
        static separatorColor(t) {
          switch (t) {
            case Oe.Set:
              return ti.orange;
            case Oe.Untiered:
              return ti.purple;
          }
          return ti.gray;
        }
        static weaponDamageRange(t, e) {
          let i = 1 / 0,
            n = 0,
            s = 0,
            r = 0;
          const o = (0, Ue.cloneDeep)(t);
          for (const t of e)
            if (void 0 !== t.attackMutators)
              for (const e of t.attackMutators) {
                const t = o.get(e.projectileId);
                if (void 0 !== t)
                  switch (e.type) {
                    case Le.MultiplyMinDamage:
                      (t.minDamage = Math.round(t.minDamage * e.value)),
                        (s += e.value - 1),
                        r++;
                      break;
                    case Le.MultiplyMaxDamage:
                      (t.maxDamage = Math.round(t.maxDamage * e.value)),
                        (s += e.value - 1),
                        r++;
                  }
              }
          r > 0 && (s /= r);
          for (const t of o.values())
            0 != t.lifetimeMs &&
              0 != t.maxDamage &&
              (t.minDamage < i && (i = t.minDamage),
              t.maxDamage > n && (n = t.maxDamage));
          return [i, n, s];
        }
        static isWebGLSupported() {
          try {
            const t = document.createElement("canvas");
            return (
              !!window.WebGLRenderingContext &&
              null !==
                (t.getContext("webgl") || t.getContext("experimental-webgl"))
            );
          } catch (t) {
            return !1;
          }
        }
        static calculateRange(t) {
          const e = 0.001 * t.lifetimeMs,
            i = 0.001 * t.accelerationDelayMs,
            n = 0.1 * t.speed,
            s = 0.1 * t.speedClamp,
            r = 0.1 * t.acceleration,
            o = Math.sign(t.acceleration),
            a = Math.abs(s - n),
            l = 0.001 * t.circleTurnDelayMs,
            u = Math.cos((t.circleTurnAngle * Math.PI) / 180);
          let h = 0 == r ? 0 : 0 == a ? e - i : Math.min((a / r) * o, e - i),
            c = 0 == r || 0 == a ? e : i,
            d = Math.max(e - c - h, 0);
          u < 0.01 &&
            (0 == h && l < e ? (c = l) : l <= i && ((h = 0), (d = 0)));
          let p = n * c + (n * h + r * h * h * 0.5) + s * d;
          return t.boomerang && (p *= 0.5), p;
        }
        static procLabel(t) {
          switch (t) {
            case Fe.StatBoost:
              return "Stat Boost";
            case Fe.StatusEffect:
              return "Status Effect";
            default:
              return Fe[t];
          }
        }
        static procEffectType(t) {
          switch (t) {
            case "Magic":
              return Fe.Magic;
            case "Heal":
            case "HealNova":
              return Fe.Heal;
            case "StatBoostSelf":
            case "StatBoostAura":
              return Fe.StatBoost;
            case "ConditionEffectSelf":
            case "ConditionEffectAura":
            case "GenericActivate":
              return Fe.StatusEffect;
            case "Decoy":
            case "Shoot":
            case "ShurikenAbility":
            case "BulletNova":
            case "BulletCreate":
              return Fe.Projectile;
            case "Pet":
            case "SpawnCreep":
            case "ObjectToss":
              return Fe.Minion;
            case "PoisonGrenade":
              return Fe.PoisonGrenade;
            case "Trap":
              return Fe.Trap;
            default:
              return Fe.None;
          }
        }
        static stackType(t) {
          switch (t) {
            case "noStack":
            case "noStackItm":
              return Be.NoStack;
            case "stackConsumables":
            case "diminishingRetuns50":
            case "diminishingReturns":
              return Be.DiminishingReturns;
            case "maxStack":
              return Be.MaxStack;
            default:
              return Be.None;
          }
        }
        static baseStatName(t) {
          switch (t) {
            case Ee.MAXHP:
              return "Max HP";
            case Ee.MAXMP:
              return "Max MP";
            case Ee.ATT:
              return "Attack";
            case Ee.DEF:
              return "Defense";
            case Ee.DEX:
              return "Dexterity";
            case Ee.SPD:
              return "Speed";
            case Ee.VIT:
              return "Vitality";
            case Ee.WIS:
              return "Wisdom";
            default:
              return "No";
          }
        }
        static slotMetaType(t) {
          switch (t) {
            case De.Empty:
              return Re.None;
            case De.Sword:
            case De.Dagger:
            case De.Katana:
            case De.Staff:
            case De.Wand:
            case De.Bow:
              return Re.Weapon;
            case De.Robe:
            case De.Leather:
            case De.Heavy:
              return Re.Armor;
            case De.Accessory:
              return Re.Accessory;
            default:
              return Re.Ability;
          }
        }
        static statusEffectToString(t) {
          switch (t) {
            case Ie.ArmorBroken:
              return "Armor Broken";
            case Ie.PetStasis:
              return "Pet Stasis";
            case Ie.InCombat:
              return "In Combat";
            case Ie.StasisImmune:
              return "Stasis Immune";
            default:
              return Ie[t];
          }
        }
        static stringToStatusEffect(t) {
          switch (t) {
            case "Armor Broken":
              return Ie.ArmorBroken;
            case "Pet Stasis":
              return Ie.PetStasis;
            case "In Combat":
              return Ie.InCombat;
            case "Stasis Immune":
              return Ie.StasisImmune;
            default:
              return Ie[t];
          }
        }
        static numeral(t) {
          const e = t.toString();
          switch (e[e.length - 1]) {
            case "1":
              return e + "st";
            case "2":
              return e + "nd";
            case "3":
              return e + "rd";
            default:
              return e + "th";
          }
        }
        static hsv2rgb(t, e, i) {
          let n = 0,
            s = 0,
            r = 0;
          const o = Math.floor(6 * t),
            a = 6 * t - o,
            l = i * (1 - e),
            u = i * (1 - a * e),
            h = i * (1 - (1 - a) * e);
          switch (o % 6) {
            case 0:
              (n = i), (s = h), (r = l);
              break;
            case 1:
              (n = u), (s = i), (r = l);
              break;
            case 2:
              (n = l), (s = i), (r = h);
              break;
            case 3:
              (n = l), (s = u), (r = i);
              break;
            case 4:
              (n = h), (s = l), (r = i);
              break;
            case 5:
              (n = i), (s = l), (r = u);
          }
          return [n, s, r];
        }
        static rgb2hsv(t, e, i) {
          const n = Math.max(t, e, i),
            s = Math.min(t, e, i);
          let r = 0;
          const o = n - s,
            a = 0 == n ? 0 : o / n;
          if (n == s) r = 0;
          else
            switch (n) {
              case t:
                r = (e - i) / o + (e < i ? 6 : 0);
                break;
              case e:
                r = (i - t) / o + 2;
                break;
              case i:
                r = (t - e) / o + 4;
            }
          return (r /= 6), [r, a, n];
        }
        static setYPosition(t, e) {
          return (t.position.y = Math.floor(e)), Math.floor(t.height);
        }
      }
      (Ve.TOP_LEFT = { x: 0, y: 0 }),
        (Ve.TOP_RIGHT = { x: 1, y: 0 }),
        (Ve.CENTER_X = { x: 0.5, y: 0 }),
        (Ve.CENTER_Y = { x: 0, y: 0.5 }),
        (Ve.CENTER = { x: 0.5, y: 0.5 }),
        (Ve.BOTTOM_LEFT = { x: 0, y: 1 }),
        (Ve.BOTTOM_RIGHT = { x: 1, y: 1 }),
        (Ve.startTimestamp = performance.now());
      var je = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class $e extends Ge {
        constructor(t, e) {
          var i, n, s, r;
          super(t, e),
            (this.labeledFrameOptions = e),
            (this.options = e),
            (this.maskContainer = new Gt.mc()),
            this.addChild(this.maskContainer),
            (this.labelText = t.text({
              text: e.labelText,
              anchor: Ve.CENTER_X,
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                {
                  fill:
                    null !== (i = e.labelColor) && void 0 !== i ? i : ti.white,
                }
              ),
            })),
            this.labelText.position.set(0.5 * this.options.size.x, -6),
            this.addChild(this.labelText),
            (this.contentText = t.text({
              text: e.contentText,
              anchor: Ve.CENTER_X,
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                {
                  fill:
                    null !== (n = e.contentColor) && void 0 !== n
                      ? n
                      : ti.lightyellow,
                }
              ),
            })),
            this.contentText.position.set(0.5 * this.options.size.x, 12),
            this.contentText.pivot.set(
              null !== (s = e.pivotX) && void 0 !== s ? s : 0,
              null !== (r = e.pivotY) && void 0 !== r ? r : 0
            ),
            this.addChild(this.contentText),
            (this.labeledFrameOptions.backgroundColor = e.backgroundColor),
            (this.labelText.position.x = 0.5 * this.options.size.x),
            this.updateMask(),
            (this.labelText.position.x = 0.5 * this.options.size.x + 1);
        }
        updateBackground() {
          const t = Object.create(null, {
            updateBackground: { get: () => super.updateBackground },
          });
          return je(this, void 0, void 0, function* () {
            var e;
            yield t.updateBackground.call(this),
              (this.backgroundSprite.tint =
                null !== (e = this.labeledFrameOptions.backgroundColor) &&
                void 0 !== e
                  ? e
                  : 16777215);
          });
        }
        updateMask() {
          const t = new Vt.A();
          this.maskContainer.addChild(t),
            t.setSize({
              width: this.options.size.x,
              height: this.options.size.y,
            }),
            t.rect(0, 0, this.options.size.x, this.options.size.y),
            t.fill({ color: 16777215 });
          const e = this.getMaskDimensions();
          t.rect(e.x, e.y, e.width, e.height),
            t.cut(),
            (this.backgroundSprite.mask = this.maskContainer);
        }
        getMaskDimensions() {
          return {
            x: Math.floor(
              this.labelText.position.x - 0.5 * this.labelText.width - 6
            ),
            y: 0,
            width: this.labelText.width + 12,
            height: this.labelText.height,
          };
        }
        setBackgroundColor(t) {
          return je(this, void 0, void 0, function* () {
            (this.labeledFrameOptions.backgroundColor = t),
              (this.backgroundSprite.tint = t);
          });
        }
        setLabelColor(t) {
          (this.labeledFrameOptions.labelColor = t),
            (this.labelText.style.fill = t);
        }
        setContentColor(t) {
          (this.labeledFrameOptions.contentColor = t),
            (this.contentText.style.fill = t);
        }
        setContentText(t) {
          (this.contentText.text = t), this.updateMask();
        }
      }
      class qe extends Ge {
        constructor(t, e) {
          var i, n;
          super(t, e),
            (this.buttonOptions = e),
            (this.originalTexture =
              null !== (i = e.frameTexture) && void 0 !== i ? i : ""),
            (this.originalHeight = e.size.y),
            (this.pressedTexture =
              null !== (n = e.pressedTexture) && void 0 !== n ? n : ""),
            (this.onClick = e.onClick),
            (this.backgroundContainer.alpha = 0.7),
            (this.eventMode = "static"),
            (this.cursor = "pointer"),
            (this.onMouseDownBinding = this.onMouseDown.bind(this)),
            (this.onMouseUpBinding = this.onMouseUp.bind(this));
          const s = Object.assign(Object.assign({}, t.outlineTextStyle), {
            fontSize: 20,
            fill: e.contentColor,
          });
          (this.contentText = t.text({
            text: e.text,
            anchor: Ve.CENTER_X,
            style: s,
          })),
            (this.contentText.position.y = -12),
            (this.contentText.eventMode = "none"),
            this.addChild(this.contentText),
            this.addListener("mouseenter", this.onMouseEnter.bind(this)),
            this.addListener("mouseleave", this.onMouseLeave.bind(this)),
            this.addListener("mousedown", this.onMouseDownBinding),
            window.addEventListener("mouseup", this.onMouseUpBinding);
        }
        setTexture(t) {
          (this.buttonOptions.frameTexture = t), (this.originalTexture = t);
        }
        setPressedTexture(t) {
          (this.buttonOptions.pressedTexture = t), (this.pressedTexture = t);
        }
        setContentColor(t) {
          (this.buttonOptions.contentColor = t),
            (this.contentText.style.fill = t);
        }
        onMouseEnter(t) {
          this.backgroundContainer.alpha = 1;
        }
        onMouseLeave(t) {
          this.backgroundContainer.alpha = 0.7;
        }
        onMouseDown(t) {
          var e;
          this.ui.playClickSound(),
            this.pivot.set(0, -2),
            this.contentText.pivot.set(0, -2),
            (this.options.frameTexture = this.pressedTexture),
            (this.options.size.y = this.originalHeight - 4),
            this.updateBackground(),
            null === (e = this.onClick) || void 0 === e || e.call(this, t);
        }
        onMouseUp(t) {
          this.pivot.set(0, 0),
            this.contentText.pivot.set(0, 0),
            (this.options.frameTexture = this.originalTexture),
            (this.options.size.y = this.originalHeight),
            this.updateBackground();
        }
      }
      var We = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Xe extends Me {
        constructor(t, e, i, n) {
          super(t),
            (this.scrollSpeed = n),
            (this.size = i),
            (this.arrowSize = 20),
            (this.scrollContainer = e),
            (this.backgroundSprite = new Xt.k()),
            (this.upArrowSprite = new Xt.k()),
            (this.downArrowSprite = new Xt.k()),
            (this.distance = 0),
            (this.maxDistance = 0),
            (this.dragPositionYDelta = 0),
            (this.onMouseDragBinding = this.onMouseDrag.bind(this));
        }
        create() {
          return We(this, void 0, void 0, function* () {
            var t, e, i, n, s, r, o, l, u, h;
            (this.backgroundSprite.texture = new a.g(a.g.WHITE)),
              (this.backgroundSprite.width = 20),
              (this.backgroundSprite.tint =
                null !==
                  (e =
                    null === (t = this.ui.theme) || void 0 === t
                      ? void 0
                      : t.scrollbar.backgroundColor) && void 0 !== e
                  ? e
                  : 1447446),
              this.backgroundSprite.position.set(0, this.arrowSize),
              this.addChild(this.backgroundSprite),
              (this.backgroundSprite.eventMode = "static"),
              this.backgroundSprite.addListener(
                "mousedown",
                this.onBackgroundMouseDown.bind(this)
              );
            const c =
                null !==
                  (n =
                    null === (i = this.ui.theme) || void 0 === i
                      ? void 0
                      : i.scrollbar.thumb) && void 0 !== n
                  ? n
                  : "gray_scrollbar_frame",
              d = {
                size: new Et.b(this.size.x, this.size.y - 2 * this.arrowSize),
                frameTexture: c,
              };
            (this.thumbFrame = new Ge(this.ui, d)),
              (this.thumbFrame.eventMode = "static"),
              this.thumbFrame.updateBackground(),
              this.addChild(this.thumbFrame);
            const p =
                null !==
                  (o =
                    null ===
                      (r =
                        null === (s = this.ui) || void 0 === s
                          ? void 0
                          : s.theme) || void 0 === r
                      ? void 0
                      : r.scrollbar.upArrow) && void 0 !== o
                  ? o
                  : "scrollbar_arrow_up",
              f = yield this.ui.getTexture(`ui/icons/${p}`);
            (this.upArrowSprite.texture = f),
              this.upArrowSprite.scale.set(2),
              (this.upArrowSprite.eventMode = "static"),
              (this.upArrowSprite.cursor = "pointer"),
              this.upArrowSprite.addListener(
                "click",
                this.onArrowUpClick.bind(this)
              ),
              this.addChild(this.upArrowSprite);
            const m =
                null !==
                  (h =
                    null ===
                      (u =
                        null === (l = this.ui) || void 0 === l
                          ? void 0
                          : l.theme) || void 0 === u
                      ? void 0
                      : u.scrollbar.downArrow) && void 0 !== h
                  ? h
                  : "scrollbar_arrow_down",
              g = yield this.ui.getTexture(`ui/icons/${m}`);
            (this.downArrowSprite.texture = g),
              this.downArrowSprite.scale.set(2),
              (this.downArrowSprite.eventMode = "static"),
              (this.downArrowSprite.cursor = "pointer"),
              this.downArrowSprite.addListener(
                "click",
                this.onArrowDownClick.bind(this)
              ),
              this.addChild(this.downArrowSprite),
              this.thumbFrame.addListener(
                "mousedown",
                this.onThumbMouseDown.bind(this)
              ),
              window.addEventListener("mouseup", this.onMouseUp.bind(this));
          });
        }
        setBackgroundColor(t) {
          this.backgroundSprite.tint = t;
        }
        setArrowTextures(t, e) {
          return We(this, void 0, void 0, function* () {
            const i = yield this.ui.getTexture(`ui/icons/${t}`);
            this.upArrowSprite.texture = i;
            const n = yield this.ui.getTexture(`ui/icons/${e}`);
            this.downArrowSprite.texture = n;
          });
        }
        setThumbTexture(t) {
          void 0 !== this.thumbFrame &&
            (this.thumbFrame.setBackgroundTexture(t),
            this.thumbFrame.updateBackground());
        }
        onBackgroundMouseDown(t) {
          const e = this.backgroundSprite.getBounds(),
            i = t.clientY - e.top,
            n = Ve.clamp(i / e.height, 0, 1);
          this.updateThumbPosition(this.maxDistance * n, this.maxDistance),
            this.scrollContainer.onScrollBarMoved(n),
            this.onThumbMouseDown(t);
        }
        onArrowUpClick(t) {
          this.ui.playClickSound(),
            this.updateThumbPosition(0, this.maxDistance),
            this.scrollContainer.onScrollBarMoved(0);
        }
        onArrowDownClick(t) {
          this.ui.playClickSound(),
            this.updateThumbPosition(this.maxDistance, this.maxDistance),
            this.scrollContainer.onScrollBarMoved(1);
        }
        getScrollSpeed() {
          return this.scrollSpeed;
        }
        updateThumbPosition(t, e) {
          if (void 0 === this.thumbFrame) return;
          const i = 0 == e ? 0 : t / e,
            n = this.size.y - 2 * this.arrowSize;
          this.thumbFrame.position.set(
            0,
            (n - this.thumbFrame.height) * i + this.arrowSize
          );
        }
        updateThumb(t, e, i) {
          return We(this, void 0, void 0, function* () {
            if (
              0 != this.maxDistance &&
              this.maxDistance == i &&
              this.distance == e
            )
              return;
            if (
              ((this.maxDistance = i),
              (this.distance = e),
              (this.visible = 0 != this.maxDistance),
              0 == this.visible)
            )
              return;
            (this.size.y = t),
              (this.downArrowSprite.position.y = t - this.arrowSize),
              (this.backgroundSprite.height = Math.abs(t - 2 * this.arrowSize));
            const n = this.size.y - 2 * this.arrowSize;
            if (void 0 === this.thumbFrame) return;
            const s = n / Math.min(2 + i / Math.abs(n), 3.5);
            this.thumbFrame.setHeight(s),
              yield this.thumbFrame.updateBackground(),
              this.updateThumbPosition(e, i);
          });
        }
        onThumbMouseDown(t) {
          if (void 0 === this.thumbFrame) return;
          const e = this.backgroundSprite.getBounds();
          (this.dragPositionYDelta =
            t.clientY - e.top - this.thumbFrame.position.y - this.arrowSize),
            window.addEventListener("mousemove", this.onMouseDragBinding);
        }
        onMouseDrag(t) {
          if (void 0 === this.thumbFrame) return;
          const e = this.backgroundSprite.getBounds(),
            i = Ve.clamp(
              t.clientY - e.top - this.dragPositionYDelta - this.arrowSize,
              this.arrowSize,
              this.size.y - this.thumbFrame.height - this.arrowSize
            );
          this.thumbFrame.position.set(0, i);
          const n = this.backgroundSprite.height - this.thumbFrame.height,
            s = 0 == n ? 0 : (this.thumbFrame.position.y - this.arrowSize) / n;
          this.scrollContainer.onScrollBarMoved(s);
        }
        onMouseUp(t) {
          window.removeEventListener("mousemove", this.onMouseDragBinding);
        }
      }
      var Ye = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Ke extends Me {
        constructor(t, e) {
          var i, n, s, r, o, l, u, h;
          super(t),
            (this.options = e),
            (this.placeholder =
              null !== (i = e.placeholder) && void 0 !== i ? i : ""),
            (this._value = null !== (n = e.value) && void 0 !== n ? n : ""),
            (this.animationValue = 0),
            (this.maxLength =
              null !== (s = e.maxLength) && void 0 !== s ? s : 0),
            (this.clearOnClick =
              null !== (r = e.clearOnClick) && void 0 !== r && r),
            (this.isActive = !1),
            (this.input = document.createElement("input")),
            document.body.append(this.input),
            (this.background =
              null !== (o = e.background) && void 0 !== o ? o : new Xt.k()),
            this.addChild(this.background);
          const c = new Xt.k(a.g.WHITE);
          this.addChild(c);
          const d = this.background.getBounds();
          (c.width = d.width),
            (c.height = d.height),
            (this.inputText = t.text({
              text: this.placeholder,
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                e.textStyle
              ),
            }));
          const p = Math.floor(0.5 * d.height);
          (this.inputText.anchor.x =
            null !==
              (u =
                null === (l = this.options.anchor) || void 0 === l
                  ? void 0
                  : l.x) && void 0 !== u
              ? u
              : 0),
            this.inputText.position.set(
              d.width * this.inputText.anchor.x -
                16 * (this.inputText.anchor.x - 0.5),
              p - 9
            ),
            (this.inputText.mask = c),
            this.addChild(this.inputText),
            (this.cursorSprite = new Xt.k()),
            (this.cursorSprite.tint = new at.Q(
              null === (h = this.options.textStyle) || void 0 === h
                ? void 0
                : h.fill
            ).toNumber()),
            (this.cursorSprite.anchor.y = 0.5),
            (this.cursorSprite.position.y = p),
            (this.cursorSprite.mask = c),
            (this.cursorSprite.eventMode = "none"),
            this.addChild(this.cursorSprite),
            (this.eventMode = "static"),
            (this.background.eventMode = "static"),
            (this.background.cursor = "text"),
            this.background.addListener(
              "click",
              this.onElementClick.bind(this)
            ),
            window.addEventListener(
              "click",
              this.handleDeactivation.bind(this)
            ),
            this.input.addEventListener("input", this.onInputChange.bind(this)),
            window.addEventListener("keydown", this.onKeyDown.bind(this)),
            t.app.canvas.ticker.add(this.updateCursor.bind(this));
        }
        create() {
          this.createInputField(), this.createCursor();
        }
        get value() {
          return this._value;
        }
        set value(t) {
          (this._value = t),
            0 == this._value.length
              ? ((this.inputText.text = this.placeholder),
                void 0 !== this.cancelIcon && (this.cancelIcon.visible = !1),
                void 0 !== this.searchIcon && (this.searchIcon.visible = !0))
              : ((this.inputText.text = t),
                void 0 !== this.cancelIcon && (this.cancelIcon.visible = !0),
                void 0 !== this.searchIcon && (this.searchIcon.visible = !1));
        }
        setBackgroundTexture(t) {
          return Ye(this, void 0, void 0, function* () {
            const e = yield this.ui.frameTexture({
              frameTexture: t,
              size: new Et.b(this.background.width, this.background.height),
            });
            this.background.texture = e;
          });
        }
        setTextColor(t) {
          (this.inputText.style.fill = t), (this.cursorSprite.tint = t);
        }
        setSearchIcon(t) {
          (this.searchIcon = t), this.addChild(t);
        }
        setCancelIcon(t) {
          (this.cancelIcon = t),
            this.cancelIcon.position.set(-12, 13),
            this.cancelIcon.addListener(
              "mousedown",
              this.onCancelIconClick.bind(this)
            ),
            this.addChild(this.cancelIcon);
        }
        onCancelIconClick() {
          this.updateValue(""), this.stopEditing(!0), this.ui.playClickSound();
        }
        onKeyDown(t) {
          if (0 == this.isActive) return;
          const e = t.key;
          if (1 != t.ctrlKey || "v" != e)
            switch (((this.input.value = ""), e)) {
              case "Backspace":
                this.delete();
                break;
              case "Escape":
              case "Enter":
                this.stopEditing();
                break;
              default:
                if (1 != e.length) break;
                if (0 != this.maxLength && this._value.length >= this.maxLength)
                  break;
                this.ui.playKeyboardSound(), this.push(e);
            }
        }
        onInputChange(t) {
          if (this.input.value.length <= 1) return;
          this.ui.playKeyboardSound();
          const e = this.value + this.input.value;
          this.updateValue(e), (this.input.value = "");
        }
        createCursor() {
          const t = a.g.WHITE;
          (this.cursorSprite.texture = t),
            (this.cursorSprite.width = 2),
            (this.cursorSprite.height = 0.8 * this.inputText.height),
            (this.cursorSprite.alpha = 0);
        }
        createInputField() {
          return Ye(this, void 0, void 0, function* () {});
        }
        updateCursor(t) {
          0 != this.isActive &&
            ((this.animationValue += 0.1 * t.deltaTime),
            (this.cursorSprite.alpha = Math.round(
              0.5 * Math.sin(this.animationValue) + 0.5
            )));
        }
        updateCursorPosition() {
          this.cursorSprite.position.x =
            this.inputText.position.x +
            this.inputText.width * (1 - this.inputText.anchor.x);
        }
        push(t) {
          const e = this._value + t;
          this.updateValue(e);
        }
        presentValue(t) {
          this.inputText.text = t.substring(0, Math.min(t.length, 40));
        }
        updateValue(t) {
          (this._value = t),
            this.presentValue(t),
            this.updateCursorPosition(),
            this.emit("change", this._value);
        }
        delete() {
          if (0 == this._value.length) return;
          this.ui.playKeyboardSound();
          const t = this._value.split("");
          t.pop();
          const e = t.join("");
          this.updateValue(e);
        }
        onElementClick(t) {
          this.ui.playClickSound(),
            this.ui.focus(this.input),
            1 == this.clearOnClick && this.updateValue(""),
            1 != this.isActive && this.startEditing();
        }
        handleDeactivation(t) {
          if (0 == this.isActive) return;
          this.background.getBounds().containsPoint(t.clientX, t.clientY) ||
            this.stopEditing();
        }
        startEditing() {
          (this.isActive = !0),
            this.presentValue(this._value),
            this.updateCursorPosition(),
            void 0 !== this.cancelIcon && (this.cancelIcon.visible = !0),
            void 0 !== this.searchIcon && (this.searchIcon.visible = !1);
        }
        stopEditing(t = !1) {
          (0 != this.isActive || t) &&
            ((this.isActive = !1),
            this.ui.blur(this.input),
            (this.cursorSprite.alpha = 0),
            0 == this._value.length
              ? ((this.inputText.text = this.placeholder),
                void 0 !== this.cancelIcon && (this.cancelIcon.visible = !1))
              : void 0 !== this.cancelIcon && (this.cancelIcon.visible = !0),
            0 == this.value.length &&
              void 0 !== this.searchIcon &&
              (this.searchIcon.visible = !0));
        }
      }
      var Ze = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Qe extends Me {
        constructor(t, e) {
          var i, n;
          super(t),
            (this.backgroundTextureName =
              null !== (i = e.texture) && void 0 !== i ? i : "green_checkbox"),
            (this.value = null !== (n = e.isTicked) && void 0 !== n && n),
            (this.onChange = e.onChange),
            (this.interactiveBackground = new Xt.k(a.g.EMPTY)),
            (this.interactiveBackground.eventMode = "static"),
            (this.interactiveBackground.cursor = "pointer"),
            this.interactiveBackground.addListener(
              "mousedown",
              this.onMouseDown.bind(this)
            );
          const s = e.guidanceTooltip;
          void 0 !== s &&
            (this.interactiveBackground.addListener("mouseenter", () =>
              this.ui.app.tooltipHandler.showInformation(s)
            ),
            this.interactiveBackground.addListener(
              "mouseleave",
              this.ui.app.tooltipHandler.onMouseLeaveBinding
            )),
            this.addChild(this.interactiveBackground),
            (this.checkboxSprite = new Xt.k()),
            this.checkboxSprite.scale.set(2),
            (this.checkboxSprite.eventMode = "none"),
            this.addChild(this.checkboxSprite),
            (this.descriptionText = this.ui.themedText({ text: e.text })),
            this.descriptionText.position.set(40, 6),
            this.addChild(this.descriptionText),
            (this.interactiveBackground.width = this.width),
            (this.interactiveBackground.height = this.height);
        }
        setValue(t) {
          (this.value = t), this.update();
        }
        update() {
          return Ze(this, void 0, void 0, function* () {
            const t = (yield this.ui.getTexture(
                `ui/icons/${this.backgroundTextureName}`
              )).source,
              e = t.height,
              i = { x: +this.value * e, y: 0, width: e, height: e },
              n = new a.g({ source: t, frame: i });
            this.checkboxSprite.texture = n;
          });
        }
        setTexture(t) {
          (this.backgroundTextureName = t), this.update();
        }
        onMouseDown(t) {
          var e;
          (this.value = !this.value),
            this.update(),
            null === (e = this.onChange) ||
              void 0 === e ||
              e.call(this, this.value),
            this.ui.playClickSound();
        }
      }
      var Je = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class ti {
        constructor(t) {
          (this.focusedElement = null),
            (this.app = t),
            (this.clickSound = we.from("./assets/sounds/button.ogg")),
            (this.clickSound.singleInstance = !0),
            (this.clickSound.volume = 0.03),
            (this.keyboardSound = we.from("./assets/sounds/keyboard.ogg")),
            (this.keyboardSound.singleInstance = !0),
            (this.keyboardSound.volume = 0.2),
            (this.shootSound = we.from("./assets/sounds/shoot.ogg")),
            (this.shootSound.singleInstance = !0),
            (this.shootSound.volume = 0.3),
            (this.baseTextStyle = {
              fontFamily: "ChronoType",
              fontSize: 20,
              lineHeight: 18,
              fill: 15658734,
              dropShadow: { alpha: 0.5, distance: 1, angle: 90, blur: 4 },
              whiteSpace: "pre",
            }),
            (this.outlineTextStyle = {
              stroke: { color: ti.black, strokeThickness: 4 },
              dropShadow: { alpha: 0.7, distance: 0, angle: 90, blur: 3 },
            }),
            (this.themedTexts = new Array()),
            (this.windowFrames = new Array()),
            (this.thickLabeledFrames = new Array()),
            (this.smallButtons = new Array()),
            (this.bigButtons = new Array()),
            (this.scrollbars = new Array()),
            (this.searchbars = new Array()),
            (this.checkboxes = new Array());
        }
        hasFocus() {
          return null !== this.focusedElement;
        }
        focus(t) {
          (this.focusedElement = t), t.focus();
        }
        blur(t) {
          this.focusedElement === t && (this.focusedElement = null), t.blur();
        }
        onThemeUpdate(t) {
          return Je(this, void 0, void 0, function* () {
            var e,
              i,
              n,
              s,
              r,
              o,
              a,
              l,
              u,
              h,
              c,
              d,
              p,
              f,
              m,
              g,
              v,
              y,
              x,
              b,
              S,
              C,
              _,
              T,
              w,
              P,
              A,
              k,
              M,
              E,
              I,
              D,
              R,
              B,
              F,
              O,
              z,
              L;
            if (
              ((this.theme = this.app.dataHandler.themeData.get(t)),
              void 0 === this.theme)
            )
              return;
            this.app.canvas.onThemeUpdate(this.theme),
              this.app.mainPanelHandler.onThemeUpdate(this.theme),
              this.app.charactersHandler.onThemeUpdate(this.theme),
              this.app.chartHandler.onThemeUpdate(this.theme),
              this.app.skinViewerHandler.onThemeUpdate(this.theme),
              this.app.itemSandboxHandler.onThemeUpdate(this.theme),
              this.app.itemCreatorHandler.onThemeUpdate(this.theme),
              this.app.itemChecklistHandler.onThemeUpdate(this.theme),
              this.app.tooltipHandler.onThemeUpdate(this.theme);
            const H =
              null !==
                (i =
                  null === (e = this.theme) || void 0 === e
                    ? void 0
                    : e.windowTextColor) && void 0 !== i
                ? i
                : ti.white;
            for (const t of this.themedTexts) t.style.fill = H;
            const U =
                null !==
                  (s =
                    null === (n = this.theme) || void 0 === n
                      ? void 0
                      : n.windowTitleTextColor) && void 0 !== s
                  ? s
                  : ti.white,
              N =
                null !==
                  (o =
                    null === (r = this.theme) || void 0 === r
                      ? void 0
                      : r.windowFrame) && void 0 !== o
                  ? o
                  : "gray_dark_window_frame";
            for (const t of this.windowFrames)
              t.setTitleColor(U), t.setBackgroundTexture(N);
            const G =
                null !==
                  (l =
                    null === (a = this.theme) || void 0 === a
                      ? void 0
                      : a.labeledFrameLabelColor) && void 0 !== l
                  ? l
                  : ti.white,
              V =
                null !==
                  (h =
                    null === (u = this.theme) || void 0 === u
                      ? void 0
                      : u.labeledFrameBorderColor) && void 0 !== h
                  ? h
                  : ti.white;
            for (const t of this.thickLabeledFrames)
              t.setLabelColor(G), t.setBackgroundColor(V), t.updateBackground();
            const j =
                null !==
                  (d =
                    null === (c = this.theme) || void 0 === c
                      ? void 0
                      : c.smallButton.textColor) && void 0 !== d
                  ? d
                  : ti.white,
              $ =
                null !==
                  (f =
                    null === (p = this.theme) || void 0 === p
                      ? void 0
                      : p.smallButton.default) && void 0 !== f
                  ? f
                  : "gray_small_button_frame",
              q =
                null !==
                  (g =
                    null === (m = this.theme) || void 0 === m
                      ? void 0
                      : m.smallButton.pressed) && void 0 !== g
                  ? g
                  : "gray_small_button_pressed_frame";
            for (const t of this.smallButtons)
              t.setContentColor(j),
                t.setTexture($),
                t.setPressedTexture(q),
                t.updateBackground();
            const W =
                null !==
                  (y =
                    null === (v = this.theme) || void 0 === v
                      ? void 0
                      : v.bigButton.textColor) && void 0 !== y
                  ? y
                  : ti.white,
              X =
                null !==
                  (b =
                    null === (x = this.theme) || void 0 === x
                      ? void 0
                      : x.bigButton.default) && void 0 !== b
                  ? b
                  : "gray_big_button_frame",
              Y =
                null !==
                  (C =
                    null === (S = this.theme) || void 0 === S
                      ? void 0
                      : S.bigButton.pressed) && void 0 !== C
                  ? C
                  : "gray_big_button_pressed_frame";
            for (const t of this.bigButtons)
              t.setContentColor(W),
                t.setTexture(X),
                t.setPressedTexture(Y),
                t.updateBackground();
            const K =
                null !==
                  (T =
                    null === (_ = this.theme) || void 0 === _
                      ? void 0
                      : _.scrollbar.backgroundColor) && void 0 !== T
                  ? T
                  : ti.dimgray,
              Z =
                null !==
                  (P =
                    null === (w = this.theme) || void 0 === w
                      ? void 0
                      : w.scrollbar.thumb) && void 0 !== P
                  ? P
                  : "gray_scrollbar_frame",
              Q =
                null !==
                  (k =
                    null === (A = this.theme) || void 0 === A
                      ? void 0
                      : A.scrollbar.upArrow) && void 0 !== k
                  ? k
                  : "scrollbar_arrow_up",
              J =
                null !==
                  (E =
                    null === (M = this.theme) || void 0 === M
                      ? void 0
                      : M.scrollbar.downArrow) && void 0 !== E
                  ? E
                  : "scrollbar_arrow_down";
            for (const t of this.scrollbars)
              t.setBackgroundColor(K),
                t.setThumbTexture(Z),
                t.setArrowTextures(Q, J);
            const tt =
                null !==
                  (D =
                    null === (I = this.theme) || void 0 === I
                      ? void 0
                      : I.searchbar.backgroundFrame) && void 0 !== D
                  ? D
                  : "gray_searchbar_frame",
              et =
                null !==
                  (B =
                    null === (R = this.theme) || void 0 === R
                      ? void 0
                      : R.searchbar.icon) && void 0 !== B
                  ? B
                  : "search_icon",
              it =
                null !==
                  (O =
                    null === (F = this.theme) || void 0 === F
                      ? void 0
                      : F.searchbar.textColor) && void 0 !== O
                  ? O
                  : ti.lightyellow;
            for (const [t, e] of this.searchbars)
              t.setBackgroundTexture(tt),
                t.setTextColor(it),
                (e.texture = yield this.getTexture(`ui/icons/${et}`));
            const nt =
              null !==
                (L =
                  null === (z = this.theme) || void 0 === z
                    ? void 0
                    : z.checkbox.default) && void 0 !== L
                ? L
                : "green_checkbox";
            for (const t of this.checkboxes) t.setTexture(nt);
          });
        }
        windowFrame(t, e) {
          return Je(this, void 0, void 0, function* () {
            var i, n, s, r;
            e.frameTexture =
              null !==
                (n =
                  null === (i = this.theme) || void 0 === i
                    ? void 0
                    : i.windowFrame) && void 0 !== n
                ? n
                : "gray_dark_window_frame";
            const o =
                null !==
                  (r =
                    null === (s = this.theme) || void 0 === s
                      ? void 0
                      : s.windowTitleTextColor) && void 0 !== r
                  ? r
                  : ti.white,
              a = new t(this, e),
              l = a;
            return (
              l.create(),
              l.setTitleColor(o),
              this.windowFrames.push(l),
              Promise.resolve(a)
            );
          });
        }
        thickLabeledFrame(t) {
          return Je(this, void 0, void 0, function* () {
            var e, i, n, s;
            const r =
                null !==
                  (i =
                    null === (e = this.theme) || void 0 === e
                      ? void 0
                      : e.labeledFrameBorderColor) && void 0 !== i
                  ? i
                  : ti.white,
              o =
                null !==
                  (s =
                    null === (n = this.theme) || void 0 === n
                      ? void 0
                      : n.labeledFrameLabelColor) && void 0 !== s
                  ? s
                  : ti.white,
              a = new $e(
                this,
                Object.assign(Object.assign({}, t), {
                  frameTexture: "white_thick_frame",
                  backgroundColor: r,
                  labelColor: o,
                })
              );
            return (
              yield a.updateBackground(),
              this.thickLabeledFrames.push(a),
              Promise.resolve(a)
            );
          });
        }
        smallButton(t) {
          return Je(this, void 0, void 0, function* () {
            var e, i, n, s, r, o;
            const a =
                null !==
                  (i =
                    null === (e = this.theme) || void 0 === e
                      ? void 0
                      : e.smallButton.default) && void 0 !== i
                  ? i
                  : "gray_button_small_frame",
              l =
                null !==
                  (s =
                    null === (n = this.theme) || void 0 === n
                      ? void 0
                      : n.smallButton.pressed) && void 0 !== s
                  ? s
                  : "gray_button_small_pressed_frame",
              u =
                null !==
                  (o =
                    null === (r = this.theme) || void 0 === r
                      ? void 0
                      : r.smallButton.textColor) && void 0 !== o
                  ? o
                  : ti.white,
              h = new qe(
                this,
                Object.assign(Object.assign({}, t), {
                  frameTexture: a,
                  pressedTexture: l,
                  contentColor: u,
                })
              );
            return (
              yield h.updateBackground(),
              this.smallButtons.push(h),
              Promise.resolve(h)
            );
          });
        }
        bigButton(t) {
          return Je(this, void 0, void 0, function* () {
            var e, i, n, s, r, o;
            const a =
                null !==
                  (i =
                    null === (e = this.theme) || void 0 === e
                      ? void 0
                      : e.bigButton.default) && void 0 !== i
                  ? i
                  : "gray_button_big_frame",
              l =
                null !==
                  (s =
                    null === (n = this.theme) || void 0 === n
                      ? void 0
                      : n.bigButton.pressed) && void 0 !== s
                  ? s
                  : "gray_button_big_pressed_frame",
              u =
                null !==
                  (o =
                    null === (r = this.theme) || void 0 === r
                      ? void 0
                      : r.bigButton.textColor) && void 0 !== o
                  ? o
                  : ti.white,
              h = new qe(
                this,
                Object.assign(Object.assign({}, t), {
                  frameTexture: a,
                  pressedTexture: l,
                  contentColor: u,
                })
              );
            return (
              yield h.updateBackground(),
              this.bigButtons.push(h),
              Promise.resolve(h)
            );
          });
        }
        scrollbar(t, e, i) {
          const n = new Xe(this, t, e, i);
          return (n.zIndex = 1), n.create(), this.scrollbars.push(n), n;
        }
        checkbox(t) {
          return Je(this, void 0, void 0, function* () {
            const e = new Qe(this, t);
            return yield e.update(), this.checkboxes.push(e), e;
          });
        }
        searchbar(t) {
          return Je(this, void 0, void 0, function* () {
            var e, i, n, s, r, o, a;
            const l =
                null !== (e = t.size) && void 0 !== e ? e : { x: 128, y: 24 },
              u =
                null !==
                  (n =
                    null === (i = this.theme) || void 0 === i
                      ? void 0
                      : i.searchbar.backgroundFrame) && void 0 !== n
                  ? n
                  : "gray_searchbar_frame",
              h = yield this.frameTexture({ frameTexture: u, size: l }),
              c = new Xt.k(h);
            t.background = c;
            const d = new Ke(this, Object.assign({}, t)),
              p =
                null !==
                  (r =
                    null === (s = this.theme) || void 0 === s
                      ? void 0
                      : s.searchbar.textColor) && void 0 !== r
                  ? r
                  : ti.lightyellow;
            d.setTextColor(p), yield d.create();
            const f =
                null !==
                  (a =
                    null === (o = this.theme) || void 0 === o
                      ? void 0
                      : o.searchbar.icon) && void 0 !== a
                  ? a
                  : "search_icon",
              m = yield this.getTexture(`ui/icons/${f}`),
              g = new Xt.k(m);
            (g.eventMode = "none"),
              g.anchor.set(0.5, 0.5),
              g.scale.set(2, 2),
              g.position.set(d.width - 16, 12),
              d.setSearchIcon(g);
            const v = yield this.getTexture("ui/icons/cross_small_icon"),
              y = new Xt.k(v);
            return (
              (y.eventMode = "static"),
              (y.cursor = "pointer"),
              (y.visible = !1),
              y.anchor.set(0.5, 0.5),
              y.scale.set(2, 2),
              d.setCancelIcon(y),
              this.searchbars.push([d, g]),
              Promise.resolve(d)
            );
          });
        }
        playClickSound() {
          this.app.settingsHandler.playSound && this.clickSound.play();
        }
        playKeyboardSound() {
          this.app.settingsHandler.playSound && this.keyboardSound.play();
        }
        playShootSound() {
          this.app.settingsHandler.playSound && this.shootSound.play();
        }
        getShaderSource(t) {
          return Je(this, arguments, void 0, function* (t, e = "default") {
            const i = yield rt.get(`./assets/shaders/${e}.${t}`);
            return Promise.resolve(i);
          });
        }
        getTexture(t) {
          return Je(this, void 0, void 0, function* () {
            const e = yield rt.get(`./assets/sprites/${t}.png`);
            return (
              (e.source.autoGenerateMipmaps = !1),
              (e.source.scaleMode = "nearest"),
              Promise.resolve(e)
            );
          });
        }
        frameTexture(t) {
          return Je(this, void 0, void 0, function* () {
            const e = this.app.canvas.renderer,
              i = (yield this.getTexture(`ui/frames/${t.frameTexture}`)).source,
              n = Ht.Y.create({
                width: t.size.x,
                height: t.size.y,
                scaleMode: "nearest",
                resolution: 1,
              });
            if (void 0 === e || t.size.x <= 0 || t.size.y <= 0)
              return Promise.resolve(n);
            const s = new Gt.mc(),
              r = i.width / 3,
              o = { x: 2 * r, y: r, width: r, height: 1 },
              l = new a.g({ source: i, frame: o }),
              u = new Xt.k(l);
            s.addChild(u),
              u.position.set(t.size.x - r, r),
              u.scale.set(1, t.size.y - 2 * r);
            const h = { x: 2 * r, y: 2 * r, width: r, height: r },
              c = new a.g({ source: i, frame: h }),
              d = new Xt.k(c);
            s.addChild(d), d.position.set(t.size.x - r, t.size.y - r);
            const p = { x: r, y: 2 * r, width: 1, height: r },
              f = new a.g({ source: i, frame: p }),
              m = new Xt.k(f);
            s.addChild(m),
              m.position.set(r, t.size.y - r),
              m.scale.set(t.size.x - 2 * r, 1);
            const g = { x: 0, y: 2 * r, width: r, height: r },
              v = new a.g({ source: i, frame: g }),
              y = new Xt.k(v);
            s.addChild(y), y.position.set(0, t.size.y - r);
            const x = { x: 0, y: r, width: r, height: 1 },
              b = new a.g({ source: i, frame: x }),
              S = new Xt.k(b);
            s.addChild(S),
              S.position.set(0, r),
              S.scale.set(1, t.size.y - 2 * r);
            const C = { x: r, y: r, width: 1, height: 1 },
              _ = new a.g({ source: i, frame: C }),
              T = new Xt.k(_);
            s.addChild(T),
              T.position.set(r, r),
              T.scale.set(t.size.x - 2 * r, t.size.y - 2 * r);
            const w = { x: 0, y: 0, width: r, height: r },
              P = new a.g({ source: i, frame: w }),
              A = new Xt.k(P);
            s.addChild(A);
            const k = { x: r, y: 0, width: 1, height: r },
              M = new a.g({ source: i, frame: k }),
              E = new Xt.k(M);
            s.addChild(E),
              E.position.set(r, 0),
              E.scale.set(t.size.x - 2 * r, 1);
            const I = { x: 2 * r, y: 0, width: r, height: r },
              D = new a.g({ source: i, frame: I }),
              R = new Xt.k(D);
            return (
              s.addChild(R),
              R.position.set(t.size.x - r, 0),
              e.render({
                container: s,
                target: n,
                width: t.size.x,
                height: t.size.y,
              }),
              Promise.resolve(n)
            );
          });
        }
        rectangle(t) {
          var e, i, n, s, r;
          const o = new Vt.A(),
            a = null !== (e = t.borderWidth) && void 0 !== e ? e : 0,
            l = null !== (i = t.borderColor) && void 0 !== i ? i : 1447446,
            u = null !== (n = t.fillColor) && void 0 !== n ? n : 16777215,
            h = null !== (s = t.width) && void 0 !== s ? s : 100,
            c = null !== (r = t.height) && void 0 !== r ? r : 100;
          return (
            o.rect(0, 0, h, c),
            o.fill(u),
            o.stroke({ width: a, color: l }),
            (o.eventMode = "none"),
            o
          );
        }
        circle(t) {
          var e, i, n, s;
          const r = new Vt.A(),
            o = null !== (e = t.borderWidth) && void 0 !== e ? e : 0,
            a = null !== (i = t.borderColor) && void 0 !== i ? i : 1447446,
            l = null !== (n = t.fillColor) && void 0 !== n ? n : 16777215,
            u = null !== (s = t.radius) && void 0 !== s ? s : 50;
          return (
            r.circle(0, 0, u + o),
            r.fill({ color: a }),
            r.circle(0, 0, u),
            r.fill({ color: l }),
            r
          );
        }
        line(t) {
          var e, i;
          const n = new Vt.A();
          if (void 0 === t.points || t.points.length < 2) return n;
          const s = t.points,
            r = {
              width: null !== (e = t.width) && void 0 !== e ? e : 2,
              color: null !== (i = t.color) && void 0 !== i ? i : 16777215,
              cap: "round",
            };
          n.moveTo(s[0], s[1]);
          for (let t = 2; t < s.length; t += 2) n.lineTo(s[t], s[t + 1]);
          return n.stroke(r), n;
        }
        text(t) {
          var e;
          const i = new Jt(t);
          (i.style = Object.assign(
            Object.assign({}, this.baseTextStyle),
            t.style
          )),
            (i.eventMode = "none");
          const n =
            null !== (e = t.anchor) && void 0 !== e ? e : { x: 0, y: 0 };
          return (
            i.anchor.set(n.x, n.y),
            0 != i.anchor.x && i.width % 2 == 1 && (i.pivot.x = n.x),
            0 != i.anchor.y && i.height % 2 == 1 && (i.pivot.y = n.y),
            i
          );
        }
        themedText(t) {
          var e, i;
          t.style = Object.assign(Object.assign({}, t.style), {
            fill:
              null !==
                (i =
                  null === (e = this.theme) || void 0 === e
                    ? void 0
                    : e.windowTextColor) && void 0 !== i
                ? i
                : ti.white,
          });
          const n = this.text(t);
          return this.themedTexts.push(n), n;
        }
      }
      (ti.transparent = "rgba(0, 0, 0, 0)"),
        (ti.black = 657930),
        (ti.white = 15658734),
        (ti.gray = 9605778),
        (ti.dimgray = 6316128),
        (ti.darkgray = 4605510),
        (ti.darkergray = 2368548),
        (ti.blue = 36095),
        (ti.purple = 8721658),
        (ti.red = 14435915),
        (ti.orange = 16747520),
        (ti.yellow = 16762880),
        (ti.lightyellow = 16777100),
        (ti.lightgreen = 9227264),
        (ti.green = 2139212),
        (ti.maxHp = 14632266),
        (ti.maxMp = 6918645),
        (ti.attack = 13188825),
        (ti.defense = 5460819),
        (ti.speed = 3396210),
        (ti.dexterity = 14252587),
        (ti.vitality = 12255248),
        (ti.wisdom = 3898086);
      var ei,
        ii = function (t, e, i, n) {
          return new (i || (i = Promise))(function (s, r) {
            function o(t) {
              try {
                l(n.next(t));
              } catch (t) {
                r(t);
              }
            }
            function a(t) {
              try {
                l(n.throw(t));
              } catch (t) {
                r(t);
              }
            }
            function l(t) {
              var e;
              t.done
                ? s(t.value)
                : ((e = t.value),
                  e instanceof i
                    ? e
                    : new i(function (t) {
                        t(e);
                      })).then(o, a);
            }
            l((n = n.apply(t, e || [])).next());
          });
        };
      class ni {
        constructor(t) {
          (this.app = t),
            (this.renderer = new Lt.WebGLRenderer()),
            (this.ticker = new te.R()),
            (this.stage = new Gt.mc());
        }
        init() {
          return ii(this, void 0, void 0, function* () {
            (Nt.l.defaultOptions.textureGCActive = !1),
              (this.renderer = yield zt({
                preference: "webgl",
                width: window.innerWidth,
                height: window.innerHeight,
                antialias: !0,
                resolution: 1,
                backgroundColor: ti.black,
                autoDensity: !0,
                hello: !0,
              })),
              document.body.append(this.renderer.canvas);
          });
        }
        loadParsers() {
          const e = {
            extension: {
              name: "Shader Parser",
              type: t.Ag.LoadParser,
              priority: P.T.Normal,
            },
            test: (t) =>
              x.A.extname(t).includes(".frag") ||
              x.A.extname(t).includes(".vert"),
            load: (t) =>
              fetch(t)
                .then((e) => {
                  if (!e.ok)
                    throw new Error(`Failed to load shader source file: ${t}`);
                  return e.text();
                })
                .catch((t) => (console.error(t), null)),
          };
          rt.loader.parsers.push(e);
        }
        getAssetPaths() {
          const t = "./assets/sprites",
            e = "./assets/shaders";
          let i = [
            `${t}/rotmg/staticTextureAtlas.png`,
            `${t}/rotmg/charactersTextureAtlas.png`,
            `${t}/ui/icons/envelope_icon.png`,
            `${t}/ui/icons/collection_icon.png`,
            `${t}/ui/icons/dye_remover_icon.png`,
            `${t}/ui/icons/dye_icon.png`,
            `${t}/ui/icons/cloth_icon.png`,
            `${t}/ui/icons/player_flipbook_icon.png`,
            `${t}/ui/icons/player_arcane_icon.png`,
            `${t}/ui/icons/pet_flipbook_icon.png`,
            `${t}/ui/icons/pet_icon.png`,
            `${t}/ui/icons/pet_arcane_icon.png`,
            `${t}/ui/icons/swap_icon.png`,
            `${t}/ui/icons/bags.png`,
            `${t}/ui/icons/bug_icon.png`,
            `${t}/ui/icons/upcoming_icon.png`,
            `${t}/ui/icons/alert_icon.png`,
            `${t}/ui/icons/warning_icon.png`,
            `${t}/ui/icons/immunity_icon.png`,
            `${t}/ui/icons/curse_immunity_icon.png`,
            `${t}/ui/icons/armor_broken_immunity_icon.png`,
            `${t}/ui/icons/exposed_immunity_icon.png`,
            `${t}/ui/icons/arrow_up.png`,
            `${t}/ui/icons/arrow_down.png`,
            `${t}/ui/icons/immunity_icon.png`,
            `${t}/ui/icons/sword_icon.png`,
            `${t}/ui/icons/skull_icon.png`,
            `${t}/ui/icons/shield_icon.png`,
            `${t}/ui/icons/arrow_icon.png`,
            `${t}/ui/icons/exaltation_4.png`,
            `${t}/ui/icons/exaltation_5.png`,
            `${t}/ui/icons/color_picker.png`,
            `${t}/ui/icons/close_icon.png`,
            `${t}/ui/icons/dice_icon.png`,
            `${t}/ui/icons/delete_icon.png`,
            `${t}/ui/icons/cross_big_icon.png`,
            `${t}/ui/icons/cross_small_icon.png`,
            `${t}/ui/icons/solo_icon.png`,
            `${t}/ui/icons/combat_icon.png`,
            `${t}/ui/icons/clone_icon.png`,
            `${t}/ui/icons/settings_icon.png`,
            `${t}/ui/icons/heart_icon.png`,
            `${t}/ui/icons/changelog_icon.png`,
            `${t}/ui/icons/news_icon.png`,
            `${t}/ui/icons/status_effects.png`,
            `${t}/ui/icons/stat_input_cursor.png`,
            `${t}/ui/icons/discord_icon.png`,
            `${t}/ui/frames/white_thick_frame.png`,
            `${t}/ui/frames/white_thin_frame.png`,
            `${t}/ui/frames/bar_frame.png`,
            `${t}/ui/frames/white_frame.png`,
            `${t}/ui/frames/pure_white_frame.png`,
            `${t}/ui/icons/green_calculator_icon.png`,
            `${t}/ui/icons/green_item_sandbox_icon.png`,
            `${t}/ui/icons/green_skin_viewer_icon.png`,
            `${t}/ui/icons/green_item_editor_icon.png`,
            `${t}/ui/icons/green_loot_icon.png`,
            `${t}/ui/frames/gray_main_panel_frame.png`,
            `${t}/ui/frames/gray_dark_window_frame.png`,
            `${t}/ui/frames/gray_button_small_frame.png`,
            `${t}/ui/frames/gray_button_small_pressed_frame.png`,
            `${t}/ui/frames/gray_button_big_frame.png`,
            `${t}/ui/frames/gray_button_big_pressed_frame.png`,
            `${t}/ui/frames/gray_tooltip_frame.png`,
            `${t}/ui/frames/gray_ut_tooltip_frame.png`,
            `${t}/ui/frames/gray_st_tooltip_frame.png`,
            `${t}/ui/frames/gray_scrollbar_frame.png`,
            `${t}/ui/icons/scrollbar_arrow_up.png`,
            `${t}/ui/icons/scrollbar_arrow_down.png`,
            `${t}/ui/frames/gray_searchbar_frame.png`,
            `${t}/ui/icons/search_icon.png`,
            `${t}/ui/frames/gray_inventory_frame.png`,
            `${t}/ui/icons/green_checkbox.png`,
            `${t}/ui/icons/pink_calculator_icon.png`,
            `${t}/ui/icons/pink_item_sandbox_icon.png`,
            `${t}/ui/icons/pink_skin_viewer_icon.png`,
            `${t}/ui/icons/pink_item_editor_icon.png`,
            `${t}/ui/icons/pink_loot_icon.png`,
            `${t}/ui/frames/void_main_panel_frame.png`,
            `${t}/ui/frames/void_window_frame.png`,
            `${t}/ui/frames/void_button_small_frame.png`,
            `${t}/ui/frames/void_button_small_pressed_frame.png`,
            `${t}/ui/frames/void_button_big_frame.png`,
            `${t}/ui/frames/void_button_big_pressed_frame.png`,
            `${t}/ui/frames/void_tooltip_frame.png`,
            `${t}/ui/frames/void_ut_tooltip_frame.png`,
            `${t}/ui/frames/void_st_tooltip_frame.png`,
            `${t}/ui/frames/void_scrollbar_frame.png`,
            `${t}/ui/icons/void_scrollbar_arrow_up.png`,
            `${t}/ui/icons/void_scrollbar_arrow_down.png`,
            `${t}/ui/frames/void_searchbar_frame.png`,
            `${t}/ui/icons/void_search_icon.png`,
            `${t}/ui/icons/pink_checkbox.png`,
            `${t}/ui/icons/cyan_calculator_icon.png`,
            `${t}/ui/icons/cyan_item_sandbox_icon.png`,
            `${t}/ui/icons/cyan_skin_viewer_icon.png`,
            `${t}/ui/icons/cyan_item_editor_icon.png`,
            `${t}/ui/icons/cyan_loot_icon.png`,
            `${t}/ui/frames/abyss_main_panel_frame.png`,
            `${t}/ui/frames/abyss_window_frame.png`,
            `${t}/ui/frames/abyss_button_small_frame.png`,
            `${t}/ui/frames/abyss_button_small_pressed_frame.png`,
            `${t}/ui/frames/abyss_button_big_frame.png`,
            `${t}/ui/frames/abyss_button_big_pressed_frame.png`,
            `${t}/ui/frames/abyss_tooltip_frame.png`,
            `${t}/ui/frames/abyss_ut_tooltip_frame.png`,
            `${t}/ui/frames/abyss_st_tooltip_frame.png`,
            `${t}/ui/frames/abyss_scrollbar_frame.png`,
            `${t}/ui/icons/abyss_scrollbar_arrow_up.png`,
            `${t}/ui/icons/abyss_scrollbar_arrow_down.png`,
            `${t}/ui/frames/abyss_searchbar_frame.png`,
            `${t}/ui/icons/abyss_search_icon.png`,
            `${t}/ui/icons/cyan_checkbox.png`,
            `${t}/ui/icons/blue_calculator_icon.png`,
            `${t}/ui/icons/blue_item_sandbox_icon.png`,
            `${t}/ui/icons/blue_skin_viewer_icon.png`,
            `${t}/ui/icons/blue_item_editor_icon.png`,
            `${t}/ui/icons/blue_loot_icon.png`,
            `${t}/ui/icons/blue_checkbox.png`,
            `${t}/rotmg/shadow.png`,
            `${t}/rotmg/tilesets/realm_tileset.png`,
            `${t}/rotmg/tilesets/void_tileset.png`,
            `${t}/rotmg/tilesets/abyss_tileset.png`,
            `${t}/rotmg/tilesets/nexus_tileset.png`,
            `${t}/masks/textile_mask.png`,
            `${t}/masks/shiny_mask.png`,
            `${t}/rotmg/arcaneStyles/bubbles.png`,
            `${t}/rotmg/arcaneStyles/christmas.png`,
            `${t}/rotmg/arcaneStyles/coinflip_gray.png`,
            `${t}/rotmg/arcaneStyles/coinflip.png`,
            `${t}/rotmg/arcaneStyles/confetti_gray.png`,
            `${t}/rotmg/arcaneStyles/confetti.png`,
            `${t}/rotmg/arcaneStyles/explosion_gray.png`,
            `${t}/rotmg/arcaneStyles/fire_gray.png`,
            `${t}/rotmg/arcaneStyles/hearts_gray.png`,
            `${t}/rotmg/arcaneStyles/hearts.png`,
            `${t}/rotmg/arcaneStyles/morefire_gray.png`,
            `${t}/rotmg/arcaneStyles/stars.png`,
            `${e}/default.vert`,
            `${e}/picker.vert`,
            `${e}/shiny.frag`,
            `${e}/hsv_box.frag`,
            `${e}/hue_slider.frag`,
            `${e}/red_mask.frag`,
            `${e}/green_mask.frag`,
          ].map((t) => `${t}`);
          return i;
        }
        loadAssets(t) {
          this.loadParsers(),
            (K.config = { preferWorkers: !1, preferCreateImageBitmap: !0 });
          const e = this.getAssetPaths();
          rt.load(e, t);
        }
        onThemeUpdate(t) {
          var e;
          null === (e = this.renderer) ||
            void 0 === e ||
            e.background.color.setValue(t.backgroundColor);
        }
        getTexture(t) {
          return rt.get(`${t}`);
        }
        addChild(t) {
          this.stage.addChild(t);
        }
        onReady() {
          return ii(this, void 0, void 0, function* () {
            (this.renderer.canvas.style.opacity = "1"),
              this.ticker.add(this.render.bind(this)),
              this.ticker.start(),
              window.addEventListener("resize", this.onWindowResize.bind(this));
          });
        }
        render(t) {
          this.renderer.render(this.stage);
        }
        onWindowResize() {
          this.renderer.resize(window.innerWidth, window.innerHeight),
            (document.body.style.scale = "1");
        }
      }
      !(function (t) {
        (t[(t.AllDisabled = 0)] = "AllDisabled"),
          (t[(t.AllEnabled = 1)] = "AllEnabled"),
          (t[(t.CalculationsOnly = 2)] = "CalculationsOnly");
      })(ei || (ei = {}));
      var si,
        ri = function (t, e, i, n) {
          return new (i || (i = Promise))(function (s, r) {
            function o(t) {
              try {
                l(n.next(t));
              } catch (t) {
                r(t);
              }
            }
            function a(t) {
              try {
                l(n.throw(t));
              } catch (t) {
                r(t);
              }
            }
            function l(t) {
              var e;
              t.done
                ? s(t.value)
                : ((e = t.value),
                  e instanceof i
                    ? e
                    : new i(function (t) {
                        t(e);
                      })).then(o, a);
            }
            l((n = n.apply(t, e || [])).next());
          });
        };
      class oi extends Me {
        constructor(t, e) {
          var i, n, s, r, o;
          super(t),
            (this.options = e),
            (this.options.alpha =
              null !== (i = e.alpha) && void 0 !== i ? i : 0.8),
            (this.options.alphaOnHover =
              null !== (n = e.alphaOnHover) && void 0 !== n ? n : 1),
            (this.options.scale =
              null !== (s = e.scale) && void 0 !== s ? s : 2),
            (this.options.scaleOnHover =
              null !== (r = e.scaleOnHover) && void 0 !== r ? r : 2),
            (this.iconSprite = new Xt.k()),
            this.addChild(this.iconSprite);
          const a = null !== (o = e.anchor) && void 0 !== o ? o : Ve.TOP_LEFT;
          this.iconSprite.anchor.set(a.x, a.y),
            (this.iconSprite.alpha = this.options.alpha),
            this.iconSprite.scale.set(this.options.scale),
            (this.eventMode = "static"),
            (this.cursor = "pointer"),
            this.addListener("mouseenter", this.onMouseEnter.bind(this)),
            this.addListener("mouseleave", this.onMouseLeave.bind(this)),
            void 0 !== this.options.onClick &&
              this.addListener("click", this.options.onClick),
            void 0 !== this.options.onRightClick &&
              this.addListener("rightclick", this.options.onRightClick);
        }
        create() {
          return ri(this, void 0, void 0, function* () {
            this.setIcon(this.options.iconTexture);
          });
        }
        setIcon(t) {
          return ri(this, void 0, void 0, function* () {
            const e = yield this.ui.getTexture(`ui/icons/${t}`);
            (this.options.iconTexture = t), (this.iconSprite.texture = e);
          });
        }
        getColor() {
          return Number(this.iconSprite.tint);
        }
        setColor(t) {
          this.iconSprite.tint = t;
        }
        onMouseEnter(t) {
          (this.zIndex = 2),
            (this.iconSprite.alpha = this.options.alphaOnHover),
            this.iconSprite.scale.set(this.options.scaleOnHover),
            this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllEnabled &&
              void 0 !== this.options.guidanceTooltip &&
              this.ui.app.tooltipHandler.showInformation(
                this.options.guidanceTooltip
              );
        }
        onMouseLeave(t) {
          (this.zIndex = 1),
            (this.iconSprite.alpha = this.options.alpha),
            this.iconSprite.scale.set(this.options.scale),
            this.ui.app.tooltipHandler.hide();
        }
      }
      class ai {
        constructor(t) {
          this.app = t;
        }
        create(...t) {
          window.addEventListener("resize", this.onWindowResize.bind(this));
        }
        clear() {}
        onWindowResize(t) {}
      }
      !(function (t) {
        (t[(t.None = -1)] = "None"),
          (t[(t.Damage = 0)] = "Damage"),
          (t[(t.Burst = 1)] = "Burst"),
          (t[(t.Resilience = 2)] = "Resilience"),
          (t[(t.Distance = 3)] = "Distance");
      })(si || (si = {}));
      var li = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class ui extends Me {
        constructor(t) {
          super(t),
            (this.type = si.None),
            (this.reportEntries = new Array()),
            (this.size = new Et.b(0, 0)),
            (this.lastSelectedHorizontalAxisValue = -1),
            (this.lastSelectedEntry = void 0),
            (this.verticalAxis = {}),
            (this.horizontalAxis = {}),
            (this.chartTitle = this.ui.text({})),
            (this.backgroundContainer = new Gt.mc()),
            (this.curvesContainer = new Gt.mc()),
            (this.curvePointsContainer = new Gt.mc()),
            (this.hoveredReportPointCircle = this.ui.circle({
              radius: 6,
              borderWidth: 2,
              borderColor: ti.black,
              fillColor: 16777215,
            })),
            (this.upperInteractiveSprite = new Xt.k()),
            (this.bottomInteractiveSprite = new Xt.k()),
            (this.gridlineSelectionSprite = new Xt.k()),
            (this.gridlineSelectionText = t.text({ style: { fontSize: 16 } }));
        }
        create() {
          return li(this, void 0, void 0, function* () {
            (this.upperInteractiveSprite.texture = a.g.WHITE),
              this.upperInteractiveSprite.position.set(-8, -8),
              (this.upperInteractiveSprite.eventMode = "static"),
              this.upperInteractiveSprite.addListener(
                "mousemove",
                this.onUpperInteractiveSpriteMouseMove.bind(this)
              ),
              this.upperInteractiveSprite.addListener(
                "mouseleave",
                this.onUpperInteractiveSpriteMouseLeave.bind(this)
              ),
              this.addChild(this.upperInteractiveSprite),
              (this.bottomInteractiveSprite = new Xt.k()),
              (this.bottomInteractiveSprite.eventMode = "static"),
              this.bottomInteractiveSprite.addListener(
                "mousemove",
                this.onGridlineSelectionMouseMove.bind(this)
              ),
              this.bottomInteractiveSprite.addListener(
                "mouseleave",
                this.onGridlineSelectionMouseLeave.bind(this)
              ),
              this.addChild(this.bottomInteractiveSprite),
              this.addChild(this.backgroundContainer),
              this.chartTitle.anchor.set(0.5, 0),
              this.addChild(this.chartTitle),
              (this.gridlineSelectionSprite.texture = a.g.WHITE),
              this.gridlineSelectionSprite.anchor.set(0.5, 0),
              (this.gridlineSelectionSprite.visible = !1),
              this.addChild(this.gridlineSelectionSprite),
              this.gridlineSelectionText.anchor.set(0.5, 0),
              (this.gridlineSelectionText.visible = !1),
              this.addChild(this.gridlineSelectionText),
              this.addChild(this.curvesContainer),
              this.addChild(this.curvePointsContainer),
              (this.hoveredReportPointCircle.visible = !1),
              this.addChild(this.hoveredReportPointCircle),
              yield this.updateScale(),
              yield this.updateBackground();
          });
        }
        onThemeUpdate(t) {
          this.updateBackground(),
            this.updateReportEntries(this.reportEntries, !1);
        }
        updateReportEntries() {
          return li(
            this,
            arguments,
            void 0,
            function* (t = this.reportEntries, e = !0) {
              const i = [];
              for (let e = 0; e < t.length; e++) {
                const n = t[e].recalculate();
                i.push(n);
              }
              yield Promise.all(i);
              if (1 == (yield this.checkIfBackgroundNeedsUpdate(t)))
                yield this.updateScale(),
                  yield this.updateBackground(),
                  yield this.updateReportEntriesGraphics(e);
              else
                for (let i = 0; i < t.length; i++)
                  yield this.drawReportEntryGraphics(t[i], e);
            }
          );
        }
        getEntryValues(t) {
          for (let e = 0; e < this.reportEntries.length; e++)
            if (this.reportEntries[e] == t)
              return this.reportEntries[e].getValues();
          return [];
        }
        onUpperInteractiveSpriteMouseMove(t) {
          var e, i;
          const n = t.clientX - this.position.x,
            s = t.clientY - this.position.y,
            r = this.horizontalAxis.maxValue - this.horizontalAxis.minValue,
            o = Ve.clamp(
              Math.round((n / this.size.x) * r) + this.horizontalAxis.minValue,
              this.horizontalAxis.minValue,
              this.horizontalAxis.maxValue
            );
          let a,
            l = 1 / 0,
            u = 0;
          const h = Math.max(o - 1, this.horizontalAxis.minValue),
            c = Math.min(o + 1, this.horizontalAxis.maxValue);
          for (let t = 0; t < this.reportEntries.length; t++)
            for (let e = h; e <= c; e++) {
              const i = this.reportEntries[t],
                r =
                  n -
                  this.size.x *
                    ((e - this.horizontalAxis.minValue) /
                      this.horizontalAxis.maxValue),
                o = s - i.currentYCoords[e],
                h = r * r + o * o;
              h < 4e3 && l > h && ((a = i), (l = h), (u = e));
            }
          if (void 0 === a)
            return (
              (this.hoveredReportPointCircle.visible = !1),
              this.ui.app.tooltipHandler.hide(),
              void this.hideSelectionLine()
            );
          if (
            this.lastSelectedEntry === a &&
            this.lastSelectedHorizontalAxisValue == o
          )
            return;
          this.lastSelectedEntry = a;
          const d =
              null !==
                (i =
                  null === (e = this.ui.theme) || void 0 === e
                    ? void 0
                    : e.chartSelectionColor) && void 0 !== i
                ? i
                : ti.white,
            p = this.lastSelectedEntry.lineColor;
          this.hoveredReportPointCircle.destroy(),
            (this.hoveredReportPointCircle = this.ui.circle({
              radius: 6,
              borderWidth: 2,
              borderColor: d,
              fillColor: p,
            })),
            this.addChild(this.hoveredReportPointCircle),
            this.hoveredReportPointCircle.position.set(
              this.size.x * ((u - this.horizontalAxis.minValue) / r),
              a.currentYCoords[u]
            ),
            (this.hoveredReportPointCircle.visible = !0),
            a.showInformation(u),
            this.showSelectionLine(u);
        }
        onUpperInteractiveSpriteMouseLeave(t) {
          (this.hoveredReportPointCircle.visible = !1),
            this.ui.app.tooltipHandler.hide(),
            this.hideSelectionLine();
        }
        onGridlineSelection(t) {}
        onGridlineSelectionMouseMove(t) {
          const e = t.clientX - this.position.x,
            i = this.horizontalAxis.maxValue - this.horizontalAxis.minValue,
            n = Ve.clamp(
              this.horizontalAxis.minValue + Math.round((e / this.size.x) * i),
              this.horizontalAxis.minValue,
              this.horizontalAxis.maxValue
            );
          this.lastSelectedHorizontalAxisValue != n &&
            (this.showSelectionLine(n), this.onGridlineSelection(n));
        }
        onGridlineSelectionMouseLeave(t) {
          this.hideSelectionLine(), this.ui.app.tooltipHandler.hide();
        }
        showSelectionLine(t) {
          if (this.lastSelectedHorizontalAxisValue == t) return;
          this.lastSelectedHorizontalAxisValue = t;
          const e = this.horizontalAxis.maxValue - this.horizontalAxis.minValue,
            i =
              Ve.clamp((t - this.horizontalAxis.minValue) / e, 0, 1) *
              this.size.x;
          this.gridlineSelectionSprite.position.set(i, 0),
            (this.gridlineSelectionSprite.visible = !0),
            (this.gridlineSelectionText.text = `${t} ${this.horizontalAxis.valuePrefix}`),
            this.gridlineSelectionText.position.set(i, this.size.y + 24),
            (this.gridlineSelectionText.visible = !0);
        }
        hideSelectionLine() {
          (this.gridlineSelectionSprite.visible = !1),
            (this.gridlineSelectionText.visible = !1),
            (this.lastSelectedHorizontalAxisValue = -1),
            (this.lastSelectedEntry = void 0);
        }
        setTitleText(t) {
          this.chartTitle.text = t;
        }
        updateSize() {
          const t = Math.max(window.innerWidth - 540, 100),
            e = Math.max(window.innerHeight - 80, 100);
          return new Et.b(t, e);
        }
        updateBackground() {
          var t, e, i, n, s, r, o, a, l, u, h, c;
          this.backgroundContainer.removeChildren();
          const d = 12,
            p =
              null !==
                (e =
                  null === (t = this.ui.theme) || void 0 === t
                    ? void 0
                    : t.chartHorizontalLinesColor) && void 0 !== e
                ? e
                : ti.darkgray,
            f =
              null !==
                (n =
                  null === (i = this.ui.theme) || void 0 === i
                    ? void 0
                    : i.chartVerticalLinesColor) && void 0 !== n
                ? n
                : ti.darkergray,
            m =
              null !==
                (r =
                  null === (s = this.ui.theme) || void 0 === s
                    ? void 0
                    : s.chartTitleTextColor) && void 0 !== r
                ? r
                : ti.white,
            g =
              null !==
                (a =
                  null === (o = this.ui.theme) || void 0 === o
                    ? void 0
                    : o.chartBorderColor) && void 0 !== a
                ? a
                : ti.dimgray,
            v =
              null !==
                (u =
                  null === (l = this.ui.theme) || void 0 === l
                    ? void 0
                    : l.backgroundColor) && void 0 !== u
                ? u
                : ti.black,
            y =
              null !==
                (c =
                  null === (h = this.ui.theme) || void 0 === h
                    ? void 0
                    : h.chartSelectionColor) && void 0 !== c
                ? c
                : ti.white;
          (this.chartTitle.style.fill = m),
            (this.upperInteractiveSprite.tint = v),
            (this.gridlineSelectionSprite.tint = y),
            (this.gridlineSelectionText.style.fill = y),
            (this.chartTitle.visible = this.size.x > 300),
            this.chartTitle.position.set(0.5 * this.size.x, -22);
          const x = this.horizontalAxis.maxValue - this.horizontalAxis.minValue;
          for (let t = 0; t <= this.horizontalAxis.gridlinesCount; t++) {
            const e =
                (Math.floor((x * t) / this.horizontalAxis.gridlinesCount) / x) *
                this.size.x,
              i =
                this.horizontalAxis.minValue +
                this.horizontalAxis.valuePerGridline * t,
              n = `${Math.floor(i)} ${this.horizontalAxis.valuePrefix}`,
              s = this.ui.text({
                text: n,
                anchor: Ve.CENTER_X,
                style: { fill: g, fontSize: 16 },
              });
            if (
              (s.position.set(e, this.size.y + 24 - 11),
              this.backgroundContainer.addChild(s),
              0 == t || t == this.horizontalAxis.gridlinesCount)
            )
              continue;
            const r = [e, 0, e, this.size.y + d],
              o = this.ui.line({ points: r, width: 2, color: f });
            this.backgroundContainer.addChild(o);
          }
          for (let t = 0; t <= this.verticalAxis.gridlinesCount; t++) {
            const e = Math.floor(
                this.size.y -
                  (t / this.verticalAxis.gridlinesCount) * this.size.y
              ),
              i =
                this.verticalAxis.minValue +
                t * this.verticalAxis.valuePerGridline,
              n = `${Ve.separators(i)} ${this.verticalAxis.valuePrefix}`,
              s = this.ui.text({
                text: n,
                anchor: Ve.TOP_RIGHT,
                style: { fill: g, fontSize: 16 },
              });
            if (
              (s.position.set(-15, e - 9),
              this.backgroundContainer.addChild(s),
              0 == t || t == this.verticalAxis.gridlinesCount)
            )
              continue;
            const r = [-12, e, this.size.x, e],
              o = this.ui.line({ points: r, width: 2, color: p });
            this.backgroundContainer.addChild(o);
          }
          const b = [-12, 0, 0, 0],
            S = this.ui.line({ points: b, width: 2, color: g });
          this.backgroundContainer.addChild(S);
          const C = [-12, this.size.y, 0, this.size.y],
            _ = this.ui.line({ points: C, width: 2, color: g });
          this.backgroundContainer.addChild(_);
          const T = [0, this.size.y, 0, this.size.y + d],
            w = this.ui.line({ points: T, width: 2, color: g });
          this.backgroundContainer.addChild(w);
          const P = [this.size.x, this.size.y, this.size.x, this.size.y + d],
            A = this.ui.line({ points: P, width: 2, color: g });
          this.backgroundContainer.addChild(A);
          const k = this.ui.rectangle({
            width: this.size.x,
            height: this.size.y,
            fillColor: ti.transparent,
            borderWidth: 2,
            borderColor: g,
          });
          this.backgroundContainer.addChild(k),
            (this.upperInteractiveSprite.width = this.size.x + 16),
            (this.upperInteractiveSprite.height = this.size.y + 8),
            this.bottomInteractiveSprite.position.set(-20, this.size.y),
            (this.bottomInteractiveSprite.width = this.size.x + 40),
            (this.bottomInteractiveSprite.height = 40),
            (this.gridlineSelectionSprite.width = 2),
            (this.gridlineSelectionSprite.height = this.size.y + 24);
        }
        updateScale() {
          return li(this, void 0, void 0, function* () {
            this.size = this.updateSize();
            let t = 1 / 0,
              e = 0;
            for (let i = 0; i < this.reportEntries.length; i++) {
              const n = this.reportEntries[i].data;
              t > n.minValue && (t = n.minValue),
                e < n.maxValue && (e = n.maxValue);
            }
            t == 1 / 0 && (t = 0);
            const i = e - t,
              n = 1 + Math.ceil(0.02 * this.size.y);
            (this.verticalAxis.valuePerGridline =
              (1 + Math.floor((i / n) * (1 / this.verticalAxis.gridValue))) *
              this.verticalAxis.gridValue),
              (this.verticalAxis.minValue =
                Math.floor(t / this.verticalAxis.valuePerGridline) *
                this.verticalAxis.valuePerGridline),
              (this.verticalAxis.gridlinesCount = Math.max(
                1 +
                  Math.floor(
                    (e - 0.5 - this.verticalAxis.minValue) /
                      this.verticalAxis.valuePerGridline
                  ),
                2
              )),
              (this.verticalAxis.maxValue =
                this.verticalAxis.minValue +
                this.verticalAxis.valuePerGridline *
                  this.verticalAxis.gridlinesCount);
            const s =
              this.horizontalAxis.maxValue - this.horizontalAxis.minValue;
            (this.horizontalAxis.gridlinesCount = Math.max(
              Math.floor(0.016 * this.size.x),
              1
            )),
              (this.horizontalAxis.valuePerGridline =
                (s + 0.01) / this.horizontalAxis.gridlinesCount);
          });
        }
        checkIfBackgroundNeedsUpdate(t) {
          let e = 1 / 0,
            i = 0;
          for (let n = 0; n < t.length; n++) {
            const s = t[n].data;
            e > s.minValue && (e = s.minValue),
              i > s.maxValue && (i = s.maxValue);
          }
          return (
            Math.floor(e / this.verticalAxis.valuePerGridline) !=
              Math.floor(
                this.verticalAxis.minValue / this.verticalAxis.valuePerGridline
              ) ||
            Math.floor(i / this.verticalAxis.valuePerGridline) !=
              Math.floor(
                this.verticalAxis.maxValue / this.verticalAxis.valuePerGridline
              )
          );
        }
        createReportEntriesGraphics() {
          for (let t = 0; t < this.reportEntries.length; t++)
            this.drawReportEntryGraphics(this.reportEntries[t], !1);
        }
        drawReportEntryGraphics(t, e) {
          return li(this, void 0, void 0, function* () {
            const i = this.getEntryValues(t);
            if (0 == i.length) return;
            const n = new Array(),
              s = new Array(),
              r =
                this.verticalAxis.valuePerGridline *
                this.verticalAxis.gridlinesCount;
            let o = 0;
            for (let t = 0; t < i.length; t++) {
              const e = i[t] - this.verticalAxis.minValue,
                a = (t / (i.length - 1)) * this.size.x,
                l = this.size.y - (e / r) * this.size.y;
              if ((n.push(a, l), 0 != t && t < Math.floor(o))) continue;
              s.push(t);
              o +=
                (this.horizontalAxis.maxValue -
                  this.horizontalAxis.minValue +
                  0.01) /
                this.horizontalAxis.gridlinesCount;
            }
            yield t.draw(
              this.curvesContainer,
              n,
              this.curvePointsContainer,
              s,
              e
            );
          });
        }
        updateReportEntriesGraphics(t = !0) {
          for (let e = 0; e < this.reportEntries.length; e++)
            this.drawReportEntryGraphics(this.reportEntries[e], t);
        }
        removeReportEntries(t) {
          for (let e = this.reportEntries.length - 1; e >= 0; e--) {
            const i = t.indexOf(this.reportEntries[e]);
            -1 != i &&
              t[i] === this.reportEntries[e] &&
              (t.splice(i, 1),
              this.reportEntries[e].dispose(),
              this.reportEntries.splice(e, 1));
          }
        }
        setHorizontalAxisMaxValue(t) {
          this.horizontalAxis.maxValue = t;
        }
        updateBackgroundIfNeeded() {
          return li(this, void 0, void 0, function* () {
            0 !=
              (yield this.checkIfBackgroundNeedsUpdate(this.reportEntries)) &&
              (yield this.updateScale(),
              yield this.updateBackground(),
              this.updateReportEntriesGraphics(!0));
          });
        }
        onWindowResize(t) {
          return li(this, void 0, void 0, function* () {
            yield this.updateScale(),
              yield this.updateBackground(),
              this.updateReportEntriesGraphics(!1);
          });
        }
      }
      var hi = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class ci extends Me {
        constructor(t, e, i, n, s) {
          super(t),
            (this.chart = e),
            (this.character = i),
            (this.data = { character: i, minValue: 0, maxValue: 0 }),
            (this.lastYCoords = new Array()),
            (this.currentYCoords = new Array()),
            (this.nextYCoords = new Array()),
            (this.line = new Vt.A()),
            (this.lineTransitionIntervalId = -1),
            (this.lineTransitionStart = 0),
            (this.lineColor = i.lineColor),
            (this.lineInitialized = !1),
            (this.tooltipPoints = new Array()),
            (this.lineColor = i.lineColor),
            (this.simulation = n),
            (this.tooltip = s);
        }
        recalculate() {
          return hi(this, void 0, void 0, function* () {
            const t = yield this.simulation(this.character);
            return (
              (this.data.steps = t.steps),
              (this.data.stepsCount = t.stepsCount),
              (this.data.minValue = t.minValue),
              (this.data.maxValue = t.maxValue),
              (this.data.simulationTimeSeconds = t.simulationTimeSeconds),
              Promise.resolve(this.data)
            );
          });
        }
        showInformation(t) {
          this.tooltip(this.character, this.data, t, this.lineColor);
        }
        getValues() {
          return this.data.steps.map((t) => t.values[0]);
        }
        isValueWithinBounds(t, e) {
          return this.data.minValue > t && this.data.maxValue < e;
        }
        destroyTooltipPoints() {
          for (let t = 0; t < this.tooltipPoints.length; t++) {
            const e = this.tooltipPoints[t][1];
            if (null == e) return;
            e.destroy();
          }
        }
        createTooltipPoint() {
          return hi(this, void 0, void 0, function* () {
            var t, e;
            const i =
                null !==
                  (e =
                    null === (t = this.ui.theme) || void 0 === t
                      ? void 0
                      : t.backgroundColor) && void 0 !== e
                  ? e
                  : ti.black,
              n = yield this.ui.circle({
                radius: 3,
                borderWidth: 3,
                borderColor: i,
                fillColor: this.lineColor,
              });
            return (n.eventMode = "none"), Promise.resolve(n);
          });
        }
        redraw() {
          (this.line.tint = this.lineColor),
            this.line.clear(),
            this.line.moveTo(0, this.nextYCoords[0]);
          for (let t = 0; t < this.nextYCoords.length; t++)
            this.line.lineTo(
              (t / (this.nextYCoords.length - 0.99)) * this.chart.size.x,
              this.nextYCoords[t]
            ),
              (this.currentYCoords[t] = this.nextYCoords[t]);
          for (let t = 0; t < this.tooltipPoints.length; t++) {
            const [e, i] = this.tooltipPoints[t];
            i.position.set(
              (e / (this.nextYCoords.length - 0.99)) * this.chart.size.x,
              this.nextYCoords[e]
            );
          }
          this.line.stroke({ width: 3, color: 16777215 });
        }
        redrawSmooth() {
          const t = Math.min(
              1,
              0.004 * (performance.now() - this.lineTransitionStart)
            ),
            e = Ve.easeOut(t),
            i = Ve.lerp(this.lastYCoords[0], this.nextYCoords[0], e);
          this.line.clear(),
            (this.line.tint = this.lineColor),
            this.line.moveTo(0, i);
          for (let t = 0; t < this.nextYCoords.length; t++) {
            const i =
                (t / (this.nextYCoords.length - 0.99)) * this.chart.size.x,
              n = Ve.lerp(this.lastYCoords[t], this.nextYCoords[t], e);
            (this.currentYCoords[t] = n), this.line.lineTo(i, n);
          }
          this.line.stroke({ width: 3, color: 16777215 });
          for (let t = 0; t < this.tooltipPoints.length; t++) {
            const [e, i] = this.tooltipPoints[t],
              n = (e / (this.nextYCoords.length - 0.99)) * this.chart.size.x;
            i.position.set(n, this.currentYCoords[e]);
          }
          if (t >= 1)
            return (
              (this.lastYCoords = [...this.nextYCoords]),
              window.clearInterval(this.lineTransitionIntervalId),
              void (this.lineTransitionIntervalId = -1)
            );
        }
        changeTooltipPointsColor(t) {
          return hi(this, void 0, void 0, function* () {
            for (let t = 0; t < this.tooltipPoints.length; t++) {
              const e = this.tooltipPoints[t][1].parent,
                i = yield this.createTooltipPoint();
              i.position.set(
                this.tooltipPoints[t][1].position.x,
                this.tooltipPoints[t][1].position.y
              ),
                e.addChild(i),
                this.tooltipPoints[t][1].destroy(),
                (this.tooltipPoints[t][1] = i);
            }
          });
        }
        redrawTooltipPoints(t, e) {
          return hi(this, void 0, void 0, function* () {
            yield this.destroyTooltipPoints(),
              (this.tooltipPoints = new Array());
            for (let i = 0; i < e.length; i++) {
              const n = yield this.createTooltipPoint(),
                s =
                  0 == e[i]
                    ? 0
                    : (e[i] / (this.nextYCoords.length - 0.99)) *
                      this.chart.size.x;
              t.addChild(n),
                n.position.set(s, this.currentYCoords[e[i]]),
                this.tooltipPoints.push([e[i], n]);
            }
          });
        }
        setColor(t) {
          (this.lineColor = t),
            this.changeTooltipPointsColor(t),
            void 0 !== this.line && (this.line.tint = t);
        }
        draw(t, e, i, n, s) {
          return hi(this, void 0, void 0, function* () {
            this.nextYCoords = new Array();
            for (let t = 1; t < e.length; t += 2) this.nextYCoords.push(e[t]);
            if (0 == this.lineInitialized) {
              this.lineInitialized = !0;
              for (let t = 0; t < this.nextYCoords.length; t++) {
                const i = s ? this.chart.size.y : this.nextYCoords[t];
                (this.currentYCoords[t] = i), (e[2 * t + 1] = i);
              }
              (this.line = this.ui.line({ points: e, width: 2 })),
                (this.line.tint = this.lineColor),
                (this.line.eventMode = "none"),
                t.addChild(this.line);
            }
            (this.lastYCoords = [...this.currentYCoords]),
              yield this.redrawTooltipPoints(i, n),
              1 == s ? this.redrawSmoothInterval() : this.redraw();
          });
        }
        dispose() {
          Ve.clearInterval(this.lineTransitionIntervalId),
            (this.lineTransitionIntervalId = -1),
            this.line.destroy(),
            this.destroyTooltipPoints();
        }
        redrawSmoothInterval() {
          Ve.clearInterval(this.lineTransitionIntervalId),
            (this.lineTransitionStart = performance.now()),
            (this.lineTransitionIntervalId = window.setInterval(
              this.redrawSmooth.bind(this)
            ));
        }
        getCharacterInstance() {
          return this.character;
        }
        update(t = !0) {
          this.chart.updateReportEntries([this], t);
        }
      }
      var di = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class pi extends ui {
        constructor(t) {
          super(t),
            (this.type = si.Burst),
            (this.verticalAxis.valuePrefix = " HP"),
            (this.verticalAxis.gridValue = 1e3),
            (this.horizontalAxis.valuePrefix = "sec"),
            (this.horizontalAxis.minValue = 0),
            (this.horizontalAxis.maxValue =
              this.ui.app.settingsHandler.simulationTimeSeconds);
        }
        createReportEntry(t) {
          const e = new ci(
            this.ui,
            this,
            t,
            this.ui.app.simulationHandler.generateBurstReport.bind(
              this.ui.app.simulationHandler
            ),
            this.ui.app.tooltipHandler.showBurstReportInformation.bind(
              this.ui.app.tooltipHandler
            )
          );
          return this.reportEntries.push(e), Promise.resolve(e);
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return di(this, void 0, void 0, function* () {
            yield t.create.call(this), this.setTitleText("Burst Calculator");
          });
        }
        onGridlineSelection(t) {
          this.ui.app.tooltipHandler.showReportsSummaryInformation(
            this.reportEntries,
            t,
            "HP",
            !1
          );
        }
      }
      var fi = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class mi extends ui {
        constructor(t) {
          super(t),
            (this.type = si.Resilience),
            (this.verticalAxis.valuePrefix = "HP"),
            (this.verticalAxis.gridValue = 100),
            (this.horizontalAxis.valuePrefix = "sec"),
            (this.horizontalAxis.minValue = 0),
            (this.horizontalAxis.maxValue =
              this.ui.app.settingsHandler.simulationTimeSeconds);
        }
        createReportEntry(t) {
          const e = new ci(
            this.ui,
            this,
            t,
            this.ui.app.simulationHandler.generateResilienceReport.bind(
              this.ui.app.simulationHandler
            ),
            this.ui.app.tooltipHandler.showResilienceReportInformation.bind(
              this.ui.app.tooltipHandler
            )
          );
          return this.reportEntries.push(e), Promise.resolve(e);
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return fi(this, void 0, void 0, function* () {
            yield t.create.call(this),
              this.setTitleText("Resilience Calculator");
          });
        }
        onGridlineSelection(t) {
          this.ui.app.tooltipHandler.showReportsSummaryInformation(
            this.reportEntries,
            t,
            "HP",
            !0
          );
        }
      }
      var gi = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class vi extends ui {
        constructor(t) {
          super(t),
            (this.type = si.Distance),
            (this.verticalAxis.valuePrefix = "tiles"),
            (this.verticalAxis.gridValue = 10),
            (this.horizontalAxis.valuePrefix = "sec"),
            (this.horizontalAxis.minValue = 0),
            (this.horizontalAxis.maxValue =
              this.ui.app.settingsHandler.simulationTimeSeconds);
        }
        createReportEntry(t) {
          const e = new ci(
            this.ui,
            this,
            t,
            this.ui.app.simulationHandler.generateTravelReport.bind(
              this.ui.app.simulationHandler
            ),
            this.ui.app.tooltipHandler.showTravelReportInformation.bind(
              this.ui.app.tooltipHandler
            )
          );
          return this.reportEntries.push(e), Promise.resolve(e);
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return gi(this, void 0, void 0, function* () {
            yield t.create.call(this), this.setTitleText("Distance Calculator");
          });
        }
        onGridlineSelection(t) {
          this.ui.app.tooltipHandler.showReportsSummaryInformation(
            this.reportEntries,
            t,
            "tiles",
            !0
          );
        }
      }
      var yi = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class xi extends ui {
        constructor(t) {
          super(t),
            (this.type = si.Damage),
            (this.verticalAxis.valuePrefix = "DPS"),
            (this.verticalAxis.gridValue = 500),
            (this.horizontalAxis.valuePrefix = "DEF"),
            (this.horizontalAxis.minValue = 0),
            (this.horizontalAxis.maxValue = 100);
        }
        createReportEntry(t) {
          const e = new ci(
            this.ui,
            this,
            t,
            this.ui.app.simulationHandler.generateDamageReport.bind(
              this.ui.app.simulationHandler
            ),
            this.ui.app.tooltipHandler.showDamageReportInformation.bind(
              this.ui.app.tooltipHandler
            )
          );
          return this.reportEntries.push(e), Promise.resolve(e);
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return yi(this, void 0, void 0, function* () {
            yield t.create.call(this), this.setTitleText("DPS Calculator");
          });
        }
        onGridlineSelection(t) {
          this.ui.app.tooltipHandler.showReportsSummaryInformation(
            this.reportEntries,
            t,
            "DPS",
            !0
          );
        }
      }
      var bi,
        Si,
        Ci,
        _i,
        Ti,
        wi,
        Pi,
        Ai = function (t, e, i, n) {
          return new (i || (i = Promise))(function (s, r) {
            function o(t) {
              try {
                l(n.next(t));
              } catch (t) {
                r(t);
              }
            }
            function a(t) {
              try {
                l(n.throw(t));
              } catch (t) {
                r(t);
              }
            }
            function l(t) {
              var e;
              t.done
                ? s(t.value)
                : ((e = t.value),
                  e instanceof i
                    ? e
                    : new i(function (t) {
                        t(e);
                      })).then(o, a);
            }
            l((n = n.apply(t, e || [])).next());
          });
        };
      class ki extends ai {
        constructor(t) {
          super(t),
            (this.damageChart = new xi(this.app.ui)),
            (this.burstChart = new pi(this.app.ui)),
            (this.resilienceChart = new mi(this.app.ui)),
            (this.distanceChart = new vi(this.app.ui)),
            (this.charts = new Array(
              this.damageChart,
              this.burstChart,
              this.resilienceChart,
              this.distanceChart
            )),
            (this.chartsContainer = new Me(t.ui)),
            (this.activeChart = void 0),
            (this.currentSimulationType = si.Damage),
            (this.navigationContainer = new Gt.mc()),
            (this.navigationContainer.sortableChildren = !0),
            (this.damageSimulationIcon = new oi(t.ui, {
              iconTexture: "sword_icon",
              anchor: Ve.CENTER,
              guidanceTooltip: new Array(
                ["DPS Calculator", ti.white],
                ["Left Click to Show Calculator", ti.orange]
              ),
              onClick: (t) => this.changeSimulationType(si.Damage, !0),
            })),
            (this.targetBurstSimulationIcon = new oi(t.ui, {
              iconTexture: "skull_icon",
              anchor: Ve.CENTER,
              guidanceTooltip: new Array(
                ["Burst Calculator", ti.white],
                ["Left Click to Show Calculator", ti.orange]
              ),
              onClick: (t) => this.changeSimulationType(si.Burst, !0),
            })),
            (this.resilienceSimulationIcon = new oi(t.ui, {
              iconTexture: "shield_icon",
              anchor: Ve.CENTER,
              guidanceTooltip: new Array(
                ["Resilience Calculator", ti.white],
                ["Left Click to Show Calculator", ti.orange]
              ),
              onClick: (t) => this.changeSimulationType(si.Resilience, !0),
            })),
            (this.travelSimulationIcon = new oi(t.ui, {
              iconTexture: "arrow_icon",
              anchor: Ve.CENTER,
              guidanceTooltip: new Array(
                ["Distance Calculator", ti.white],
                ["Left Click to Show Calculator", ti.orange]
              ),
              onClick: (t) => this.changeSimulationType(si.Distance, !0),
            })),
            (this.navigationIcons = new Array(
              this.damageSimulationIcon,
              this.targetBurstSimulationIcon,
              this.resilienceSimulationIcon,
              this.travelSimulationIcon
            ));
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return Ai(this, void 0, void 0, function* () {
            const e = this.app.settingsHandler.simulationTimeSeconds;
            this.app.canvas.addChild(this.chartsContainer),
              yield this.damageChart.create(),
              this.damageChart.position.set(100, 40),
              this.chartsContainer.addChild(this.damageChart),
              this.burstChart.setHorizontalAxisMaxValue(e),
              yield this.burstChart.create(),
              this.burstChart.position.set(100, 40),
              this.chartsContainer.addChild(this.burstChart),
              this.resilienceChart.setHorizontalAxisMaxValue(e),
              yield this.resilienceChart.create(),
              this.resilienceChart.position.set(100, 40),
              this.chartsContainer.addChild(this.resilienceChart),
              this.distanceChart.setHorizontalAxisMaxValue(e),
              yield this.distanceChart.create(),
              this.distanceChart.position.set(100, 40),
              this.chartsContainer.addChild(this.distanceChart),
              (this.navigationContainer = new Gt.mc()),
              this.navigationContainer.position.set(
                this.damageChart.position.x + this.damageChart.size.x - 6,
                26
              ),
              this.chartsContainer.addChild(this.navigationContainer),
              this.damageSimulationIcon.create(),
              this.damageSimulationIcon.position.set(-60, 0),
              this.navigationContainer.addChild(this.damageSimulationIcon),
              this.targetBurstSimulationIcon.create(),
              this.targetBurstSimulationIcon.position.set(-40, 0),
              this.navigationContainer.addChild(this.targetBurstSimulationIcon),
              this.resilienceSimulationIcon.create(),
              this.resilienceSimulationIcon.position.set(-20, 0),
              this.navigationContainer.addChild(this.resilienceSimulationIcon),
              this.travelSimulationIcon.create(),
              this.travelSimulationIcon.position.set(0, 0),
              this.navigationContainer.addChild(this.travelSimulationIcon),
              this.changeSimulationType(this.currentSimulationType),
              t.create.call(this);
          });
        }
        onThemeUpdate(t) {
          this.damageChart.onThemeUpdate(t),
            this.burstChart.onThemeUpdate(t),
            this.resilienceChart.onThemeUpdate(t),
            this.distanceChart.onThemeUpdate(t);
        }
        hide() {
          this.chartsContainer.hide();
        }
        show() {
          this.chartsContainer.show();
        }
        updateBackgroundIfNeeded() {
          if (void 0 !== this.activeChart)
            switch (this.activeChart.type) {
              case si.Damage:
                this.damageChart.updateBackgroundIfNeeded();
                break;
              case si.Burst:
                this.burstChart.updateBackgroundIfNeeded();
                break;
              case si.Resilience:
                this.resilienceChart.updateBackgroundIfNeeded();
                break;
              case si.Distance:
                this.distanceChart.updateBackgroundIfNeeded();
            }
        }
        updateReportEntries(t = void 0, e = !0) {
          if (void 0 !== this.activeChart)
            switch (this.activeChart.type) {
              case si.Damage: {
                const i =
                  null == t ? void 0 : t.map((t) => t.damageReportEntry);
                this.damageChart.updateReportEntries(i, e);
                break;
              }
              case si.Burst: {
                const i = null == t ? void 0 : t.map((t) => t.burstReportEntry);
                this.burstChart.updateReportEntries(i, e);
                break;
              }
              case si.Resilience: {
                const i =
                  null == t ? void 0 : t.map((t) => t.survivabilityReportEntry);
                this.resilienceChart.updateReportEntries(i, e);
                break;
              }
              case si.Distance: {
                const i =
                  null == t ? void 0 : t.map((t) => t.travelReportEntry);
                this.distanceChart.updateReportEntries(i, e);
                break;
              }
            }
        }
        createReportEntries(t) {
          return Ai(this, void 0, void 0, function* () {
            const e = {
              damageReportEntry: yield this.damageChart.createReportEntry(t),
              burstReportEntry: yield this.burstChart.createReportEntry(t),
              survivabilityReportEntry:
                yield this.resilienceChart.createReportEntry(t),
              travelReportEntry: yield this.distanceChart.createReportEntry(t),
            };
            return Promise.resolve(e);
          });
        }
        removeReportEntries(t) {
          const e = t.map((t) => t.damageReportEntry);
          this.damageChart.removeReportEntries(e);
          const i = t.map((t) => t.burstReportEntry);
          this.burstChart.removeReportEntries(i);
          const n = t.map((t) => t.survivabilityReportEntry);
          this.resilienceChart.removeReportEntries(n);
          const s = t.map((t) => t.travelReportEntry);
          this.distanceChart.removeReportEntries(s);
        }
        onWindowResize(t) {
          void 0 !== this.activeChart &&
            (this.activeChart.onWindowResize(t),
            this.navigationContainer.position.set(
              this.activeChart.position.x + this.activeChart.size.x - 6,
              26
            ));
        }
        changeSimulationType(t = this.currentSimulationType, e = !1) {
          var i, n;
          if (
            void 0 !== this.activeChart &&
            this.chartsContainer.visible &&
            this.currentSimulationType == t
          )
            return;
          const s =
            null !==
              (n =
                null === (i = this.app.ui.theme) || void 0 === i
                  ? void 0
                  : i.semitransparencyMultiplier) && void 0 !== n
              ? n
              : 1;
          switch (
            (this.navigationIcons.map((t) => (t.alpha = 0.2 * s)),
            this.charts.map((t) => (t.visible = !1)),
            t)
          ) {
            case si.Burst:
              this.app.changeWindowTitle("Burst Calculator"),
                (this.targetBurstSimulationIcon.alpha = 1),
                (this.activeChart = this.burstChart),
                (this.burstChart.visible = !0);
              break;
            case si.Resilience:
              this.app.changeWindowTitle("Resilience Calculator"),
                (this.resilienceSimulationIcon.alpha = 1),
                (this.activeChart = this.resilienceChart),
                (this.resilienceChart.visible = !0);
              break;
            case si.Distance:
              this.app.changeWindowTitle("Distance Calculator"),
                (this.travelSimulationIcon.alpha = 1),
                (this.activeChart = this.distanceChart),
                (this.distanceChart.visible = !0);
              break;
            default:
              this.app.changeWindowTitle("DPS Calculator"),
                (this.damageSimulationIcon.alpha = 1),
                (this.activeChart = this.damageChart),
                (this.damageChart.visible = !0);
          }
          this.activeChart.updateReportEntries(void 0, !1),
            (this.currentSimulationType = t),
            1 == e && this.app.ui.playClickSound();
        }
        updateSimulationTimeSeconds(t) {
          this.burstChart.setHorizontalAxisMaxValue(t),
            this.resilienceChart.setHorizontalAxisMaxValue(t),
            this.distanceChart.setHorizontalAxisMaxValue(t),
            this.updateReportEntries(void 0, !1);
        }
      }
      !(function (t) {
        (t[(t.Never = 0)] = "Never"),
          (t[(t.OffCooldown = 1)] = "OffCooldown"),
          (t[(t.OffCooldownAndHold = 2)] = "OffCooldownAndHold"),
          (t[(t.HoldToEnd = 3)] = "HoldToEnd"),
          (t[(t.Summon = 4)] = "Summon");
      })(bi || (bi = {})),
        (function (t) {
          (t[(t.None = 0)] = "None"),
            (t[(t.OnShoot = 1)] = "OnShoot"),
            (t[(t.OnAbilityUse = 2)] = "OnAbilityUse"),
            (t[(t.OnAbilityStartUse = 3)] = "OnAbilityStartUse"),
            (t[(t.OnAbilityEndUse = 4)] = "OnAbilityEndUse"),
            (t[(t.OnAbilityHold = 5)] = "OnAbilityHold"),
            (t[(t.OnPlayerHit = 6)] = "OnPlayerHit");
        })(Si || (Si = {})),
        (function (t) {
          (t[(t.None = -1)] = "None"),
            (t[(t.HpThreshold = 0)] = "HpThreshold"),
            (t[(t.MinHpRequired = 1)] = "MinHpRequired"),
            (t[(t.HpThresholdRelative = 2)] = "HpThresholdRelative"),
            (t[(t.MinHpRequiredRelative = 3)] = "MinHpRequiredRelative"),
            (t[(t.MinMpRequired = 4)] = "MinMpRequired"),
            (t[(t.HasStatusEffect = 5)] = "HasStatusEffect"),
            (t[(t.MustWearId = 6)] = "MustWearId"),
            (t[(t.CannotWearId = 7)] = "CannotWearId"),
            (t[(t.OrCannotWearId = 8)] = "OrCannotWearId"),
            (t[(t.ChargeIndex = 9)] = "ChargeIndex"),
            (t[(t.DamageThreshold = 10)] = "DamageThreshold");
        })(Ci || (Ci = {}));
      class Mi {
        constructor(t) {
          (this.stats = t),
            (this.statProcs = new Map()),
            (this.totalValues = new Array()),
            this.recalculate(0);
        }
        recalculate(t) {
          for (let t = 0; t < this.stats.count; t++)
            this.totalValues[t] = this.stats.getStatValue(t);
          for (const [e, i] of this.statProcs.entries()) {
            for (; i.pointer < i.valueAtTime.length; ) {
              const [e, n] = i.valueAtTime[i.pointer];
              if (e > t) break;
              i.pointer++;
            }
            const n = i.valueAtTime.length - i.pointer;
            if (n < 1) continue;
            let s = 0;
            switch (e.stackType) {
              case Be.None:
                for (let t = i.pointer; t < i.pointer + n; t++)
                  s += i.valueAtTime[i.pointer][1];
                break;
              case Be.NoStack:
                s = i.valueAtTime[i.pointer][1];
                break;
              case Be.DiminishingReturns: {
                let t = 1;
                const e = 0.5;
                for (let r = i.pointer; r < i.pointer + n; r++)
                  (s += Math.floor(i.valueAtTime[r][1] * t)), (t *= e);
                break;
              }
              case Be.MaxStack:
                for (let t = i.pointer; t < i.pointer + n; t++)
                  s < i.valueAtTime[t][1] && (s = i.valueAtTime[t][1]);
                break;
              case Be.ArrayStack: {
                if (void 0 === e.stackValues) break;
                if (0 == e.stackValues.length) break;
                const t = Math.min(n - 1, e.stackValues.length - 1);
                if (1 == e.multiply) {
                  const i = this.stats.getStatValue(e.statType),
                    n = 0.01 * e.stackValues[t];
                  s = Math.round(i * n);
                  break;
                }
                s = e.stackValues[t];
                break;
              }
            }
            this.totalValues[e.statType] += s;
          }
        }
        getCurrentStatValue(t) {
          return this.totalValues[t];
        }
        addStatProc(t, e, i) {
          var n;
          const s =
            null !== (n = this.statProcs.get(e)) && void 0 !== n
              ? n
              : { pointer: 0, valueAtTime: new Array() };
          let r = e.amount;
          if (e.scalingStatType > Ee.None) {
            const i = Math.max(
              0,
              t.getStatValue(e.scalingStatType) - e.scalingStatThreshold
            );
            r += e.scalingStatIncrease * i;
          }
          const o = [i, r];
          s.valueAtTime.push(o), this.statProcs.set(e, s);
        }
      }
      !(function (t) {
        (t[(t.AllExcluded = 0)] = "AllExcluded"),
          (t[(t.ExcludeToggles = 1)] = "ExcludeToggles"),
          (t[(t.ExcludeEquipment = 2)] = "ExcludeEquipment"),
          (t[(t.AllIncluded = 3)] = "AllIncluded");
      })(_i || (_i = {})),
        (function (t) {
          (t[(t.Ping20Ms = 0)] = "Ping20Ms"),
            (t[(t.Ping50Ms = 1)] = "Ping50Ms"),
            (t[(t.Ping100Ms = 2)] = "Ping100Ms"),
            (t[(t.Ping200Ms = 3)] = "Ping200Ms");
        })(Ti || (Ti = {})),
        (function (t) {
          (t[(t.Normal = 0)] = "Normal"), (t[(t.Dash = 1)] = "Dash");
        })(wi || (wi = {})),
        (function (t) {
          (t[(t.Never = 0)] = "Never"),
            (t[(t.RespectValue = 1)] = "RespectValue"),
            (t[(t.AnyHit = 2)] = "AnyHit");
        })(Pi || (Pi = {}));
      var Ei = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Ii extends ai {
        constructor(t, e) {
          super(t), (this.dataHandler = e), (this.dotTickMs = 100);
        }
        simulate(t) {
          return Ei(this, void 0, void 0, function* () {
            const e = t.characterStatus,
              i = e.base,
              n = t.equipmentDetails,
              s = 0.001 * t.tickMs,
              r = Math.round(0.001 * t.durationMs);
            e.stats.recalculate(0);
            const o = {
                id: 0,
                equipmentDetails: this.createEquipmentDetailsStep(
                  0,
                  t.durationMs,
                  n
                ),
                travelledTiles: 0,
                currentHitpoints: e.currentHp,
                maxHitpoints: e.stats.getCurrentStatValue(Ee.MAXHP),
                totalDamageTaken: 0,
              },
              a = new Array(o);
            for (let r = 0; r < t.durationMs; r += t.tickMs) {
              const o = r == t.durationMs - t.tickMs;
              switch ((e.stats.recalculate(r), e.movementType)) {
                case wi.Normal:
                  this.moveCharacter(t, r, s);
                  break;
                case wi.Dash: {
                  if (void 0 === e.currentDashProc) break;
                  const i = Math.min(
                    e.dashMaxTimeMs - e.dashCurrentTimeMs,
                    t.tickMs
                  );
                  e.dashCurrentTimeMs += i;
                  const n = e.currentDashProc.speed * i * 0.001;
                  e.travelledTiles += n;
                  if (
                    ((this.getProcDetails(
                      t.equipmentDetails,
                      e.currentDashProc
                    ).value += n),
                    e.dashCurrentTimeMs >= e.dashMaxTimeMs)
                  ) {
                    e.movementType = wi.Normal;
                    const i = 0.001 * (e.dashCurrentTimeMs - e.dashMaxTimeMs);
                    this.moveCharacter(t, r, i);
                  }
                  break;
                }
              }
              const l = 1 + e.stats.getCurrentStatValue(Ee.DMGBOOST),
                u = e.stats.getCurrentStatValue(Ee.ATT),
                h = e.stats.getCurrentStatValue(Ee.DEX);
              (e.weaponDamageMultiplier = (0.5 + 0.02 * u) * l),
                (e.weaponAttacksPerSecond = 1.5 + (h / 75) * 6.5),
                e.playerStatusEffects[Ie.Weak] >= r
                  ? (e.weaponDamageMultiplier = 0.5)
                  : e.playerStatusEffects[Ie.Damaging] >= r &&
                    (e.weaponDamageMultiplier *= 1.25),
                e.playerStatusEffects[Ie.Stunned] >= r
                  ? (e.weaponAttacksPerSecond = 0)
                  : e.playerStatusEffects[Ie.Dazed] >= r
                  ? (e.weaponAttacksPerSecond = 1.5)
                  : e.playerStatusEffects[Ie.Berserk] >= r &&
                    (e.weaponAttacksPerSecond *= 1.25);
              const c = e.playerStatusEffects[Ie.InCombat] >= r,
                d = e.stats.getCurrentStatValue(Ee.MAXHP),
                p = e.stats.getCurrentStatValue(Ee.VIT),
                f = e.playerStatusEffects[Ie.Invulnerable] >= r,
                m = e.playerStatusEffects[Ie.Sick] >= r,
                g = e.playerStatusEffects[Ie.Bleeding] >= r,
                v = e.playerStatusEffects[Ie.PetStasis] >= r;
              let y =
                (+!m *
                  (1 +
                    (+!g * p * (1 == c ? 0.12 : 0.24) +
                      10 * +(e.playerStatusEffects[Ie.Healing] >= r))) +
                  -20 * +(g && !f)) *
                s;
              e.currentHp < d &&
                !v &&
                !m &&
                r >= e.petHpRecoveryTimestamp &&
                ((y += e.petHpRecoveryValue),
                (e.petHpRecoveryTimestamp = r + e.petHpRecoveryCooldownMs)),
                0 != y &&
                  ((e.currentHp = Ve.clamp(e.currentHp + y, 0, d)),
                  y < 0 && (e.totalDamageTaken -= y));
              const x = e.stats.getCurrentStatValue(Ee.MAXMP),
                b = e.stats.getCurrentStatValue(Ee.WIS),
                S = e.playerStatusEffects[Ie.Silenced] >= r,
                C = e.playerStatusEffects[Ie.Energized] >= r,
                _ = e.playerStatusEffects[Ie.Quiet] >= r;
              let T =
                (0.5 + +!_ * b * (1 == c ? 0.06 : 0.12) + 10 * +(!_ && C)) * s;
              if (
                (e.currentMp < x &&
                  !v &&
                  !_ &&
                  r >= e.petMpRecoveryTimestamp &&
                  ((T += e.petMpRecoveryValue),
                  (e.petMpRecoveryTimestamp = r + e.petMpRecoveryCooldownMs)),
                (e.currentMp += T),
                e.currentMp >= x && ((e.ranOutOfMana = !1), (e.currentMp = x)),
                1 == e.canUseAbility && 0 == S)
              ) {
                switch ((e.abilityCurrentCooldownTicks--, i.abilityUse)) {
                  case bi.Summon:
                    (e.isPressingSpace = e.summonCounter < 3),
                      (e.appliedAbilityCooldown = !1);
                    break;
                  case bi.OffCooldown:
                    (e.isPressingSpace = !0), (e.appliedAbilityCooldown = !1);
                    break;
                  case bi.OffCooldownAndHold:
                    if (
                      ((e.isPressingSpace = !0), e.currentMp < e.abilityMpCost)
                    )
                      break;
                    if (e.abilityCurrentCooldownTicks > 0) break;
                    (e.appliedAbilityCooldown = !1), (e.isHoldingSpace = !0);
                    break;
                  case bi.HoldToEnd:
                    if (0 == e.ranOutOfMana && r > 0) break;
                    if (
                      1 == e.ranOutOfMana &&
                      e.currentMp != e.stats.getCurrentStatValue(Ee.MAXMP)
                    )
                      break;
                    if (e.abilityCurrentCooldownTicks > 0) break;
                    (e.isPressingSpace = !0),
                      (e.isHoldingSpace = !0),
                      (e.appliedAbilityCooldown = !1);
                }
                if (1 == e.isPressingSpace) {
                  if (
                    e.abilityCurrentCharges > 0 &&
                    --e.abilityCurrentChargeCooldownTicks <= 0
                  ) {
                    (e.abilityCurrentChargeCooldownTicks =
                      e.abilityMaxChargeCooldownTicks),
                      e.abilityCurrentCharges--,
                      e.abilityUseCount++;
                    for (
                      let i = 0;
                      i < e.procs[Si.OnAbilityStartUse].length;
                      i++
                    )
                      this.handleProc(t, Si.OnAbilityStartUse, i, r);
                    for (let i = 0; i < e.procs[Si.OnAbilityEndUse].length; i++)
                      this.handleProc(t, Si.OnAbilityEndUse, i, r);
                  } else if (
                    e.abilityCurrentCooldownTicks <= 0 &&
                    e.currentMp >= e.abilityMpCost
                  ) {
                    0 == e.appliedAbilityCooldown &&
                      ((e.appliedAbilityCooldown = !0),
                      (e.abilityCurrentCooldownTicks =
                        e.abilityMaxCooldownTicks),
                      (e.abilityCurrentChargeCooldownTicks =
                        e.abilityMaxChargeCooldownTicks)),
                      (e.currentMp -= e.abilityMpCost),
                      (e.abilityCurrentCharges = e.abilityMaxCharges),
                      e.abilityUseCount++,
                      n[Re.Ability].baseData.castCount++,
                      (n[Re.Ability].baseData.mpSpent += e.abilityMpCost);
                    for (let i = 0; i < e.procs[Si.OnAbilityUse].length; i++)
                      this.handleProc(t, Si.OnAbilityUse, i, r);
                  }
                  e.isPressingSpace = !1;
                }
                if (1 == e.isHoldingSpace && 0 != e.abilityMpDrain)
                  if (0 == Math.floor(e.currentMp))
                    (e.ranOutOfMana = !0), (e.isHoldingSpace = !1);
                  else {
                    0 == e.appliedAbilityCooldown &&
                      ((e.appliedAbilityCooldown = !0),
                      (e.abilityCurrentCooldownTicks =
                        e.abilityMaxCooldownTicks));
                    const o = Math.min(e.abilityMpDrain * s, e.currentMp);
                    (e.currentMp -= o),
                      (n[Re.Ability].baseData.mpSpent += o),
                      i.abilityUse == bi.HoldToEnd &&
                      0 == Math.floor(e.currentMp)
                        ? ((e.ranOutOfMana = !0), (e.isHoldingSpace = !1))
                        : i.abilityUse == bi.OffCooldownAndHold &&
                          (e.currentMp <= e.abilityMpCost ||
                            e.abilityCurrentCooldownTicks <= 0) &&
                          (e.isHoldingSpace = !1);
                    for (let i = 0; i < e.procs[Si.OnAbilityHold].length; i++)
                      this.handleProc(t, Si.OnAbilityHold, i, r);
                  }
              }
              if (
                ((e.dotTickProgress += t.tickMs),
                e.dotTickProgress >= this.dotTickMs)
              ) {
                let t = Math.floor(e.dotTickProgress / this.dotTickMs);
                e.dotTickProgress -= this.dotTickMs * t;
                for (const [t, i] of e.dots.entries())
                  for (let s = i.length - 1; s >= 0; s--) {
                    const a = i[s];
                    if (a.endTimeMs >= r && !o) continue;
                    const l =
                        0.001 * (Math.min(a.endTimeMs, r) - a.startTimeMs),
                      u = a.damagePerSecond * l,
                      h = t.sourceSlot;
                    this.addProcDamageData(r, n[h], t, e, u, u, 1, 100, !1),
                      i.splice(s, 1);
                  }
              }
              const w = [];
              for (let t = 0; t < e.minions.length; t++)
                w.push(e.minions[t].id);
              for (let i = e.minions.length - 1; i >= 0; i--) {
                const s = e.minions[i];
                if (void 0 !== s) {
                  if (1 == s.spawned) {
                    if (0 != s.evolveOnSpawn.length)
                      for (let t = e.minions.length - 1; t >= 0; t--) {
                        const i = e.minions[t];
                        for (let t = 0; t < s.evolveOnSpawn.length; t++)
                          if (i.tags.includes(s.evolveOnSpawn[t])) {
                            this.evolveObject(i, s.tags);
                            break;
                          }
                      }
                    s.spawned = !1;
                  }
                  if (
                    ((s.currentLifetimeMs += t.tickMs),
                    (0 != s.currentTriggerCount &&
                      s.currentLifetimeMs >= s.lifetimeMs) ||
                      0 == s.isAlive)
                  )
                    this.onSummonedObjectDeath(e, s), e.minions.splice(i, 1);
                  else if (
                    !(
                      s.currentLifetimeMs < s.currentDelayMs ||
                      ((s.currentTriggerTimer -= t.tickMs),
                      s.currentTriggerTimer > 0)
                    )
                  ) {
                    if (
                      ((s.currentTriggerTimer += s.triggerCooldownMs),
                      s.heal > 0 && this.healCharacter(s.sourceProc, t, s.heal),
                      1 == e.includeStatusEffectsFromEquipment &&
                        void 0 !== s.statusEffectAura)
                    )
                      for (let e = 0; e < s.statusEffectAura.length; e++) {
                        const i = s.statusEffectAura[e],
                          n = s.simulationProc.objectProcs.get(i.type);
                        void 0 !== n &&
                          this.addStatusEffect(t, r, n, i.type, i.durationMs);
                      }
                    if (s.maxDamage > 0) {
                      let t = s.minDamage,
                        i = s.maxDamage;
                      if (s.scalingStatType > Ee.None) {
                        const n = Math.max(
                            0,
                            e.stats.getCurrentStatValue(s.scalingStatType) -
                              s.scalingStatThreshold
                          ),
                          r = Math.floor(n / s.scalingStatInterval),
                          o = s.scalingStatIncrease * r;
                        (t += o), (i += o);
                      }
                      if (s.decreaseDamagePerTriggerCount > 0) {
                        const e = Math.floor(
                            s.currentTriggerCount /
                              s.decreaseDamagePerTriggerCount
                          ),
                          n = s.decreaseDamage * e;
                        (t -= n), (i -= n);
                      }
                      1 == s.damageScaling &&
                        ((t *= e.weaponDamageMultiplier),
                        (i *= e.weaponDamageMultiplier)),
                        (t = Math.floor(t)),
                        (i = Math.floor(i));
                      const o = s.projectileCount,
                        a = void 0 === s.parent ? s : s.parent,
                        l = a.sourceProc.sourceSlot;
                      if (1 == a.mergeWithEquipment)
                        (n[l].baseData.hitCount += o),
                          this.addDamageData(
                            r,
                            n[l],
                            e,
                            t,
                            i,
                            o,
                            s.ignoreDefense
                          );
                      else {
                        (this.getProcDetails(n, a.sourceProc).hitCount += o),
                          this.addProcDamageData(
                            r,
                            n[l],
                            s.sourceProc,
                            e,
                            t,
                            i,
                            o,
                            s.ignoreDefense
                          );
                      }
                    }
                    if (
                      void 0 !== s.subObjectPerTrigger &&
                      0 !== s.subObjectPerTrigger.length
                    ) {
                      const e = s.subObjectPerTrigger[s.currentTriggerCount];
                      if (void 0 !== e) {
                        const i = s.sourceProc;
                        this.summonObject(t, s.simulationProc, i, e, s, !0);
                      }
                    }
                    s.currentTriggerCount++,
                      0 != s.delayPerTriggerCount &&
                        s.currentTriggerCount % s.delayPerTriggerCount == 0 &&
                        (s.currentDelayMs = s.currentLifetimeMs + s.delayMs);
                  }
                }
              }
              for (let o = 0; o < e.weaponAttacks.length; o++) {
                const a = e.weaponAttacks[o],
                  l = e.weaponAttacksPerSecond * a.rateOfFire * s;
                a.attackTimer += l;
                let u = 0,
                  c = 0;
                if (0 == a.burstMaxCount) {
                  if (a.attackTimer < 1) continue;
                  const t = Math.floor(a.attackTimer);
                  (a.attackTimer -= t),
                    (a.attackProgress += t * i.weaponShotsAccuracy),
                    (u = t),
                    (c = Math.floor(a.attackProgress)),
                    (a.attackProgress -= c);
                } else {
                  if (
                    ((a.burstCooldownTimer -= s * e.burstAttackRateModifier),
                    e.playerStatusEffects[Ie.Berserk] >= r &&
                      (a.burstCooldownTimer -= 0.25 * s),
                    a.attackTimer < 1)
                  )
                    continue;
                  if (a.burstCooldownTimer <= 0) {
                    const t = Ve.clamp(h, 0, 75) / 75;
                    (a.burstCooldownTimer = Ve.lerp(
                      a.burstMaxDelay,
                      a.burstMinDelay,
                      t
                    )),
                      (a.attackTimer = Math.min(1, a.attackTimer)),
                      (a.burstCurrentCount = 0);
                  }
                  if (a.burstCurrentCount < a.burstMaxCount) {
                    const t = Math.floor(a.attackTimer);
                    (a.attackTimer -= t),
                      (a.attackProgress += t * i.weaponShotsAccuracy),
                      (u = Math.min(a.burstMaxCount - a.burstCurrentCount, t)),
                      (a.burstCurrentCount += u),
                      (c = Math.min(Math.floor(a.attackProgress), u)),
                      (a.attackProgress -= c);
                  }
                }
                if (0 != u) {
                  if (0 == o)
                    for (let i = 0; i < e.procs[Si.OnShoot].length; i++)
                      this.handleProc(t, Si.OnShoot, i, r, u);
                  if (0 != c && a.projectile.maxDamage > 0) {
                    void 0 !== a.projectile.dotProc &&
                      this.addDamageOverTime(t, a.projectile.dotProc, r, c);
                    const i = Math.floor(
                        a.projectile.minDamage * e.weaponDamageMultiplier
                      ),
                      s = Math.floor(
                        a.projectile.maxDamage * e.weaponDamageMultiplier
                      ),
                      o = a.projectileCount * c,
                      l = a.projectile.ignoreDefense;
                    if (1 == a.mergeWithEquipment)
                      (n[Re.Weapon].baseData.hitCount += o),
                        this.addDamageData(r, n[Re.Weapon], e, i, s, o, l);
                    else {
                      const t = e.enchantProcs.get(a.enchantId);
                      if (void 0 !== t) {
                        (this.getProcDetails(n, t).hitCount += o),
                          this.addProcDamageData(
                            r,
                            n[Re.Weapon],
                            t,
                            e,
                            i,
                            s,
                            o,
                            l
                          );
                      }
                    }
                  }
                }
              }
              if (
                ((e.hitCurrentProgress += e.hitProgressPerTick),
                e.hitCurrentProgress >= 1)
              ) {
                const i = Math.floor(e.hitCurrentProgress);
                e.hitCurrentProgress -= i;
                let n = e.stats.getCurrentStatValue(Ee.DEF);
                e.playerStatusEffects[Ie.ArmorBroken] >= r
                  ? (n = 0)
                  : e.playerStatusEffects[Ie.Armored] >= r &&
                    (n = Math.floor(1.5 * n)),
                  e.playerStatusEffects[Ie.Exposed] >= r && (n -= 20);
                const s = e.base.hitDamage;
                let o = Math.max(s - n, Math.floor(0.1 * s));
                e.playerStatusEffects[Ie.Invulnerable] >= r
                  ? (o = 0)
                  : e.playerStatusEffects[Ie.Curse] >= r &&
                    (o = Math.floor(1.25 * o)),
                  (e.currentHp = Math.max(e.currentHp - o, 0)),
                  (e.totalDamageTaken += o);
                for (let n = 0; n < e.procs[Si.OnPlayerHit].length; n++)
                  this.handleProc(t, Si.OnPlayerHit, n, r, i, o);
              }
              const P = Math.floor(0.001 * (r + t.tickMs));
              if (P == e.lastTimeSeconds) continue;
              e.lastTimeSeconds = P;
              const A = {
                id: P,
                equipmentDetails: this.createEquipmentDetailsStep(
                  r,
                  t.durationMs,
                  n
                ),
                travelledTiles: e.travelledTiles,
                currentHitpoints: e.currentHp,
                maxHitpoints: e.stats.getCurrentStatValue(Ee.MAXHP),
                totalDamageTaken: e.totalDamageTaken,
              };
              a[P] = A;
            }
            const l = { character: i, steps: a, durationSeconds: r };
            return Promise.resolve(l);
          });
        }
        addStatusEffect(t, e, i, n, s) {
          const r = t.characterStatus.playerStatusEffects,
            o = t.equipmentDetails,
            a = e + s;
          r[n] = a;
          const l = Math.min(s, t.durationMs - e),
            u =
              l -
              Math.min(
                i.durationTimestamp > e ? i.durationTimestamp - e : 0,
                l
              ),
            h = this.getProcDetails(o, i.base);
          (h.procCount += 1),
            (h.uptimeMs += u),
            (h.durationTimestamp = a),
            (i.durationTimestamp = a);
        }
        createEquipmentDetailsStep(t, e, i) {
          const n = new Array();
          for (let s = 0; s < 4; s++) {
            const r = new Map();
            for (const [t, e] of i[s].baseData.damageData.entries())
              r.set(t, Object.assign({}, e));
            const o = Object.assign(Object.assign({}, i[s].baseData), {
                damageData: r,
              }),
              a = new Map();
            for (const [n, r] of i[s].procsData) {
              const i = new Map();
              for (const [t, e] of r.damageData.entries())
                i.set(t, Object.assign({}, e));
              const s = (0, Ue.cloneDeep)(r);
              (s.uptimeMs -= Math.max(Math.min(r.durationTimestamp, e) - t, 0)),
                a.set(
                  n,
                  Object.assign(Object.assign({}, s), { damageData: i })
                );
            }
            const l = Object.assign(Object.assign({}, i[s]), {
              baseData: o,
              procsData: a,
            });
            n[s] = l;
          }
          return n;
        }
        prepareSimulationData(t) {
          return Ei(this, void 0, void 0, function* () {
            var e, i, n;
            const [s, r] = this.getSimulationSettingsData(),
              o = yield this.prepareCharacterStatus(t),
              a = new Array(),
              l = {
                damageDone: 0,
                hitCount: 0,
                castCount: 0,
                procCount: 0,
                mpSpent: 0,
                uptimeMs: 0,
                value: 0,
                durationTimestamp: 0,
              };
            for (let s = 0; s < 4; s++) {
              const r = new Map(),
                o = new Map();
              let u =
                null !==
                  (n =
                    null ===
                      (i =
                        null === (e = t.equipment[s]) || void 0 === e
                          ? void 0
                          : e.base) || void 0 === i
                      ? void 0
                      : i.name) && void 0 !== n
                  ? n
                  : s;
              const h = (t) => (u.length > t ? "\n" : " ");
              if (s == Re.Ability)
                switch (t.abilityUse) {
                  case bi.OffCooldown:
                    u += `${h(22)}(Off Cooldown)`;
                    break;
                  case bi.OffCooldownAndHold:
                    u += `${h(14)}(Off Cooldown + Hold)`;
                    break;
                  case bi.HoldToEnd:
                    u += `${h(14)}(Hold Till Mana Ends)`;
                    break;
                  case bi.Summon:
                    u += `${h(28)}(Summon)`;
                }
              const c = Object.assign(Object.assign({}, l), {
                  name: u,
                  slotMetaType: s,
                  damageData: r,
                }),
                d = Object.assign(Object.assign({}, l), {
                  name: u,
                  slotMetaType: s,
                  damageData: r,
                  baseData: c,
                  procsData: o,
                });
              a[s] = d;
            }
            const u = {
              characterStatus: o,
              equipmentDetails: a,
              durationMs: s,
              tickMs: r,
            };
            return Promise.resolve(u);
          });
        }
        generateDamageReport(t) {
          return Ei(this, void 0, void 0, function* () {
            const e = performance.now(),
              i = yield this.prepareSimulationData(t),
              n = yield this.simulate(i),
              s = n.durationSeconds,
              r = new Array();
            let o = 1 / 0,
              a = 0;
            const l = n.steps[n.steps.length - 1].equipmentDetails;
            for (let t = 0; t <= 100; t++) {
              const e = new Array();
              let i = 0;
              for (let n = 0; n < 4; n++) {
                const s = Object.assign(
                  Object.assign({}, this.createDetails()),
                  {
                    name: l[n].name,
                    slotMetaType: l[n].slotMetaType,
                    baseData: Object.assign({}, this.createDetails()),
                    procsData: new Map(),
                  }
                );
                (e[n] = s),
                  (l[n].damageDone = 0),
                  (l[n].baseData.damageDone = 0);
                const r = l[n].baseData.damageData.values();
                for (const e of r) {
                  let i = Math.max(t - e.ignoreDefense, 0),
                    s = yield this.calculateAverageDamage(e.min, e.max, i);
                  (s += 20 * +e.isTargetExposed),
                    (s += +e.isTargetCursed * s * 0.25);
                  const r = s * e.hitCount;
                  (l[n].damageDone += r), (l[n].baseData.damageDone += r);
                }
                this.addDetails(s, l[n].baseData),
                  this.addDetails(s.baseData, l[n].baseData);
                for (const [e, i] of l[n].procsData.entries()) {
                  i.damageDone = 0;
                  for (const e of i.damageData.values()) {
                    const n = Math.max(t - e.ignoreDefense, 0);
                    let s =
                      e.min == e.max && 0 == n
                        ? e.min
                        : yield this.calculateAverageDamage(e.min, e.max, n);
                    (s += 20 * +e.isTargetExposed),
                      (s += +e.isTargetCursed * s * 0.25);
                    const r = s * e.hitCount;
                    i.damageDone += r;
                  }
                  this.addDetails(s, i),
                    s.procsData.set(e, Object.assign({}, i));
                }
                i += s.damageDone;
              }
              const n = i / s,
                u = { id: t, equipmentDetails: e, values: [n] };
              (r[t] = u), a < n && (a = n), o > n && (o = n);
            }
            const u = {
                character: t,
                steps: r,
                stepsCount: r.length,
                minValue: o,
                maxValue: a,
                simulationTimeSeconds: s,
              },
              h = performance.now() - e;
            return (
              console.log(`Damage simulation executed in ${h} ms`),
              Promise.resolve(u)
            );
          });
        }
        generateBurstReport(t) {
          return Ei(this, void 0, void 0, function* () {
            const e = performance.now(),
              i = Object.assign({}, t.targetData),
              n = yield this.prepareSimulationData(t),
              s = yield this.simulate(n),
              r = s.durationSeconds,
              o = new Array();
            let a = 1 / 0,
              l = 0,
              u = 0;
            const h = i.hitpoints;
            let c = 5;
            for (let e = 0; e < s.steps.length; e++) {
              const n = s.steps[e].equipmentDetails;
              i.heal > 0 &&
                e >= c &&
                ((c = e + 5),
                (i.hitpoints = Math.min(i.hitpoints + i.heal, h)));
              const r = new Array();
              let d = 0,
                p = i.defense;
              1 == t.targetPermaStatusEffects.get(Ie.Armored) &&
                (p = Math.floor(1.5 * p));
              for (let t = 0; t < 4; t++) {
                const e = n[t],
                  i = Object.assign(Object.assign({}, this.createDetails()), {
                    name: e.name,
                    slotMetaType: e.slotMetaType,
                    baseData: Object.assign({}, this.createDetails()),
                    procsData: new Map(),
                  });
                (e.damageDone = 0), (e.baseData.damageDone = 0);
                const s = n[t].baseData.damageData.values();
                for (const t of s) {
                  let i = Math.max(p - t.ignoreDefense, 0),
                    n = yield this.calculateAverageDamage(t.min, t.max, i);
                  (n += 20 * +t.isTargetExposed),
                    (n += +t.isTargetCursed * n * 0.25);
                  const s = n * t.hitCount;
                  (e.damageDone += s), (e.baseData.damageDone += s);
                }
                this.addDetails(i, e.baseData),
                  this.addDetails(i.baseData, e.baseData);
                for (const [t, n] of e.procsData.entries()) {
                  n.damageDone = 0;
                  for (const t of n.damageData.values()) {
                    const e = Math.max(p - t.ignoreDefense, 0);
                    let i =
                      t.min == t.max && 0 == e
                        ? t.min
                        : yield this.calculateAverageDamage(t.min, t.max, e);
                    (i += 20 * +t.isTargetExposed),
                      (i += +t.isTargetCursed * i * 0.25);
                    const s = i * t.hitCount;
                    n.damageDone += s;
                  }
                  this.addDetails(i, n),
                    i.procsData.set(t, Object.assign({}, n));
                }
                (r[t] = i), (d += i.damageDone);
              }
              const f = 0 == e ? 0 : d / e,
                m = d - u;
              (u = d), (i.hitpoints -= m), i.hitpoints < 0 && (i.hitpoints = 0);
              const g = {
                id: e,
                equipmentDetails: r,
                values: [i.hitpoints, f],
              };
              (o[e] = g),
                l < i.hitpoints && (l = i.hitpoints),
                a >= i.hitpoints && (a = i.hitpoints);
            }
            const d = {
                character: t,
                steps: o,
                stepsCount: o.length,
                minValue: a,
                maxValue: l,
                simulationTimeSeconds: r,
              },
              p = performance.now() - e;
            return (
              console.log(`Target burst simulation executed in ${p} ms`),
              Promise.resolve(d)
            );
          });
        }
        generateResilienceReport(t) {
          return Ei(this, void 0, void 0, function* () {
            const e = performance.now(),
              i = yield this.prepareSimulationData(t),
              n = yield this.simulate(i),
              s = n.durationSeconds,
              r = new Array();
            let o = 1 / 0,
              a = 0;
            for (let t = 0; t < n.steps.length; t++) {
              const e = new Array();
              for (let i = 0; i < 4; i++) {
                const s = Object.assign(
                  Object.assign({}, this.createDetails()),
                  {
                    name: n.steps[t].equipmentDetails[i].name,
                    slotMetaType: n.steps[t].equipmentDetails[i].slotMetaType,
                    baseData: Object.assign({}, this.createDetails()),
                    procsData: new Map(),
                  }
                );
                this.addDetails(s, n.steps[t].equipmentDetails[i].baseData),
                  this.addDetails(
                    s.baseData,
                    n.steps[t].equipmentDetails[i].baseData
                  );
                for (const [e, r] of n.steps[t].equipmentDetails[
                  i
                ].procsData.entries())
                  this.addDetails(s, r),
                    s.procsData.set(e, Object.assign({}, r));
                e[i] = s;
              }
              const i = n.steps[t].currentHitpoints;
              o > i && (o = i), a < i && (a = i);
              const s = {
                id: t,
                equipmentDetails: e,
                values: [
                  i,
                  n.steps[t].maxHitpoints,
                  n.steps[t].totalDamageTaken,
                ],
              };
              r[t] = s;
            }
            const l = {
                character: t,
                steps: r,
                stepsCount: r.length,
                minValue: o,
                maxValue: a,
                simulationTimeSeconds: s,
              },
              u = performance.now() - e;
            return (
              console.log(`Resilience simulation executed in ${u} ms`),
              Promise.resolve(l)
            );
          });
        }
        generateTravelReport(t) {
          return Ei(this, void 0, void 0, function* () {
            const e = performance.now(),
              i = yield this.prepareSimulationData(t),
              n = yield this.simulate(i),
              s = n.durationSeconds,
              r = new Array();
            let o = 1 / 0,
              a = 0;
            for (let t = 0; t < n.steps.length; t++) {
              const e = new Array();
              for (let i = 0; i < 4; i++) {
                const s = Object.assign(
                  Object.assign({}, this.createDetails()),
                  {
                    name: n.steps[t].equipmentDetails[i].name,
                    slotMetaType: n.steps[t].equipmentDetails[i].slotMetaType,
                    baseData: Object.assign({}, this.createDetails()),
                    procsData: new Map(),
                  }
                );
                this.addDetails(s, n.steps[t].equipmentDetails[i].baseData),
                  this.addDetails(
                    s.baseData,
                    n.steps[t].equipmentDetails[i].baseData
                  );
                for (const [e, r] of n.steps[t].equipmentDetails[
                  i
                ].procsData.entries())
                  this.addDetails(s, r),
                    s.procsData.set(e, Object.assign({}, r));
                e[i] = s;
              }
              const i = n.steps[t].travelledTiles;
              o > i && (o = i), a < i && (a = i);
              const s = { id: t, equipmentDetails: e, values: [i] };
              r[t] = s;
            }
            const l = {
                character: t,
                steps: r,
                stepsCount: r.length,
                minValue: o,
                maxValue: a,
                simulationTimeSeconds: s,
              },
              u = performance.now() - e;
            return (
              console.log(`Travel distance simulation executed in ${u} ms`),
              Promise.resolve(l)
            );
          });
        }
        prepareCharacterStatus(t) {
          var e, i, n, s, r, o, a, l, u, h, c;
          const [d, p] = this.getSimulationSettingsData(),
            f = { base: t, lastTimeSeconds: 0 };
          (f.currentHp = Math.floor(
            t.stats.getStatValue(Ee.MAXHP) * t.startingHpPercent
          )),
            (f.totalDamageTaken = 0),
            (f.movementType = wi.Normal),
            (f.currentDashProc = void 0),
            (f.dashMaxTimeMs = 0),
            (f.dashCurrentTimeMs = 0),
            (f.travelledTiles = 0),
            (f.dots = new Map()),
            (f.dotTickProgress = 0),
            (f.minions = new Array()),
            (f.stats = new Mi(t.stats)),
            (f.currentMp = Math.floor(
              f.stats.getCurrentStatValue(Ee.MAXMP) * t.startingMpPercent
            )),
            (f.summonCounter = 0);
          const m = Ve.clamp(t.hitIntervalMs, 1, 1e4);
          (f.hitProgressPerTick = (p / m) * +(t.onhitProcTrigger != Pi.Never)),
            (f.hitCurrentProgress = 0);
          const g = t.equipment[Re.Weapon],
            v = null == g ? void 0 : g.base,
            y = t.equipment[Re.Ability],
            x = null == y ? void 0 : y.base,
            b = t.equipment[Re.Armor],
            S = null == b ? void 0 : b.base,
            C = t.equipment[Re.Accessory],
            _ = null == C ? void 0 : C.base;
          (f.enchantProcs = new Map()), (f.procs = new Array());
          const T = Object.keys(Si).length / 2;
          for (let t = 0; t < T; t++) f.procs[t] = new Array();
          this.stripProcs(v, f),
            this.stripProcs(x, f, !0),
            this.stripProcs(S, f),
            this.stripProcs(_, f),
            (f.includeStatusEffectsFromEquipment = !(
              t.applyStatusEffects == _i.AllExcluded ||
              t.applyStatusEffects == _i.ExcludeEquipment
            ));
          const w = Object.keys(Ie).length / 2,
            P = !(
              t.applyStatusEffects == _i.AllExcluded ||
              t.applyStatusEffects == _i.ExcludeToggles
            );
          f.playerStatusEffects = new Array();
          for (let i = 0; i < w; i++) {
            const n =
              null !== (e = t.playerPermaStatusEffects.get(i)) &&
              void 0 !== e &&
              e &&
              P;
            f.playerStatusEffects[i] = 1 == n ? d : -1;
          }
          f.targetStatusEffects = new Array();
          for (let e = 0; e < w; e++) {
            const s =
              !(
                null !== (i = t.targetImmunities.get(e)) &&
                void 0 !== i &&
                i
              ) &&
              null !== (n = t.targetPermaStatusEffects.get(e)) &&
              void 0 !== n &&
              n &&
              P;
            f.targetStatusEffects[e] = 1 == s ? d : -1;
          }
          const A = Math.min(
              t.abilityMode,
              Math.max(
                (null !==
                  (r =
                    null === (s = null == x ? void 0 : x.abilities) ||
                    void 0 === s
                      ? void 0
                      : s.length) && void 0 !== r
                  ? r
                  : 0) - 1,
                0
              )
            ),
            k =
              void 0 === x || t.abilityUse == bi.Never
                ? void 0
                : x.abilities[A];
          if (
            ((f.canUseAbility =
              void 0 !== k &&
              !t.playerPermaStatusEffects.get(Ie.Silenced) &&
              !t.playerPermaStatusEffects.get(Ie.Quiet)),
            (f.abilityCurrentCooldownTicks = 0),
            (f.abilityCurrentChargeCooldownTicks = 0),
            (f.abilityCurrentCharges = 0),
            (f.abilityUseCount = 0),
            (f.isPressingSpace = !1),
            (f.isHoldingSpace = !1),
            (f.appliedAbilityCooldown = !1),
            (f.ranOutOfMana = !1),
            void 0 !== k)
          ) {
            f.activeAbility = k;
            const e = t.stats.getStatValue(Ee.MPMULTIPLIER);
            f.abilityMpCost = Math.floor(
              (null !== (o = null == k ? void 0 : k.mpCost) && void 0 !== o
                ? o
                : 0) * e
            );
            const i =
                null !== (a = null == k ? void 0 : k.totalMpCostPerSecond) &&
                void 0 !== a
                  ? a
                  : 0,
              n =
                null !== (l = null == k ? void 0 : k.baseMpCostPerSecond) &&
                void 0 !== l
                  ? l
                  : 0;
            f.abilityMpDrain = i - Math.floor(n * (1 - e));
            let s = 0;
            switch (this.app.settingsHandler.inGamePingMs) {
              case Ti.Ping20Ms:
                s = 20;
                break;
              case Ti.Ping50Ms:
                s = 51;
                break;
              case Ti.Ping100Ms:
                s = 101;
                break;
              case Ti.Ping200Ms:
                s = 201;
            }
            (f.abilityMaxCooldownTicks = Math.ceil(
              ((void 0 === (null == k ? void 0 : k.cooldownMs) ||
              0 == k.cooldownMs
                ? 500
                : k.cooldownMs) +
                s) /
                p
            )),
              (f.abilityMaxChargeCooldownTicks = Math.ceil(
                ((void 0 === (null == k ? void 0 : k.chargeCooldownMs)
                  ? 500
                  : k.chargeCooldownMs) +
                  s) /
                  p
              )),
              (f.abilityMaxCharges =
                null !== (u = null == k ? void 0 : k.channelCharges) &&
                void 0 !== u
                  ? u
                  : 0),
              this.stripProcsFromAbility(k, f);
          }
          const M = {
            attackTimer: f.playerStatusEffects[Ie.Stunned] > 0 ? 0 : 1,
            attackProgress: 0,
            burstCooldownTimer: 0,
            burstCurrentCount: 0,
            enchantId: -1,
          };
          f.burstAttackRateModifier = 1;
          const E =
              null !== (h = null == v ? void 0 : v.attacks) && void 0 !== h
                ? h
                : new Array(),
            I = (0, Ue.cloneDeep)(E);
          f.weaponAttacks = new Array();
          for (let t = 0; t < I.length; t++)
            f.weaponAttacks.push(Object.assign(Object.assign({}, I[t]), M));
          this.stripEnchants(g, f),
            this.stripEnchants(y, f),
            this.stripEnchants(b, f),
            this.stripEnchants(C, f);
          for (let e = 0; e < I.length; e++) {
            const i = 0.025 * t.damageExaltationLevel;
            let n = I[e].projectile.minDamage,
              s = I[e].projectile.maxDamage;
            (n += Math.ceil(n * i)),
              (s += Math.ceil(s * i)),
              (s = Math.max(n, s - 1)),
              (I[e].projectile.minDamage = n),
              (I[e].projectile.maxDamage = s);
          }
          const D =
              null !== (c = t.playerPermaStatusEffects.get(Ie.InCombat)) &&
              void 0 !== c &&
              c,
            [R, B] = this.dataHandler.getPetHeal(t.petHealLevel, D),
            [F, O] = this.dataHandler.getPetMagicHeal(t.petMagicHealLevel, D);
          return (
            (f.petHpRecoveryValue = R),
            (f.petHpRecoveryCooldownMs = 1e3 * B + 10),
            (f.petHpRecoveryTimestamp = 0),
            (f.petMpRecoveryValue = F),
            (f.petMpRecoveryCooldownMs = 1e3 * O + 10),
            (f.petMpRecoveryTimestamp = 0),
            f
          );
        }
        setDamageData(t, e, i, n, s, r, o, a = !0) {
          const l = a && i.targetStatusEffects[Ie.Exposed] >= t,
            u = a && i.targetStatusEffects[Ie.Curse] >= t,
            h = `${n};${s};${(o +=
              1e4 *
              +(a && i.targetStatusEffects[Ie.ArmorBroken] >= t))};${+l};${+u}`,
            c = e.get(h);
          void 0 === c
            ? e.set(h, {
                min: n,
                max: s,
                hitCount: r,
                ignoreDefense: o,
                isTargetExposed: l,
                isTargetCursed: u,
              })
            : (c.hitCount += r);
        }
        createDetails() {
          return {
            damageDone: 0,
            recoveredHp: 0,
            hitCount: 0,
            castCount: 0,
            procCount: 0,
            mpSpent: 0,
            uptimeMs: 0,
            value: 0,
            durationTimestamp: 0,
          };
        }
        addDetails(t, e) {
          (t.damageDone += e.damageDone),
            (t.recoveredHp += e.recoveredHp),
            (t.hitCount += e.hitCount),
            (t.mpSpent += e.mpSpent),
            (t.castCount += e.castCount),
            (t.procCount += e.procCount),
            (t.uptimeMs += e.uptimeMs),
            (t.value += e.value),
            (t.durationTimestamp = Math.max(
              t.durationTimestamp,
              e.durationTimestamp
            ));
        }
        addProcDamageData(t, e, i, n, s, r, o, a, l = !0) {
          var u;
          const h = (
            null !== (u = e.procsData.get(i)) && void 0 !== u
              ? u
              : this.createProcDetails(e, i)
          ).damageData;
          this.setDamageData(t, h, n, s, r, o, a, l);
        }
        addDamageData(t, e, i, n, s, r, o, a = !0) {
          const l = e.baseData.damageData;
          this.setDamageData(t, l, i, n, s, r, o, a);
        }
        createProcDetails(t, e) {
          const i = {
            damageData: new Map(),
            name: e.sourceName,
            damageDone: 0,
            recoveredHp: 0,
            hitCount: 0,
            castCount: 0,
            procCount: 0,
            mpSpent: 0,
            uptimeMs: 0,
            value: 0,
            durationTimestamp: 0,
          };
          return t.procsData.set(e, i), i;
        }
        getProcDetails(t, e) {
          var i;
          const n = t[e.sourceSlot];
          return null !== (i = n.procsData.get(e)) && void 0 !== i
            ? i
            : this.createProcDetails(n, e);
        }
        getSimulationSettingsData() {
          return [
            Ve.clamp(
              1e3 * this.app.settingsHandler.simulationTimeSeconds,
              5e3,
              6e4
            ),
            10,
          ];
        }
        onSummonedObjectDeath(t, e) {
          if (
            0 != e.isAlive &&
            (e.maxDamageOnDeath > 0 &&
              t.minions.push({
                minDamage: e.minDamageOnDeath,
                maxDamage: e.maxDamageOnDeath,
                subObjectPerTrigger: new Array(),
                spawnObjectsPerTrigger: new Array(),
                subObjectPerCast: new Array(),
                children: new Array(),
                ignoreDefense: 0,
                projectileCount: 1,
                sourceProc: e.sourceProc,
                simulationProc: e.simulationProc,
                currentLifetimeMs: 0,
                currentTriggerTimer: 0,
                lifetimeMs: 0,
                isAlive: !0,
              }),
            1 == e.isSummon && t.summonCounter--,
            0 != e.destroyChildren)
          ) {
            for (let i = t.minions.length - 1; i >= 0; i--)
              t.minions[i].parent == e &&
                this.onSummonedObjectDeath(t, t.minions[i]);
            e.isAlive = !1;
          }
        }
        removeOldestMinionObject(t, e) {
          if (0 != t.minions.length)
            for (let i = 0; i < t.minions.length; i++) {
              const n = t.minions[i];
              if (n.id == e) {
                this.onSummonedObjectDeath(t, n);
                break;
              }
            }
        }
        evolveObject(t, e) {
          if (0 == t.evolveId.length) return;
          let i = 0 == t.uniqueEvolveInstigator;
          for (let n = 0; n < e.length; n++)
            t.evolveInstigatorsTags.includes(e[n]) ||
              ((i = !0), t.evolveInstigatorsTags.push(e[n]));
          if (0 == i) return;
          const n = this.dataHandler.objectsData.get(t.evolveId);
          void 0 !== n &&
            ((t.id = n.id),
            (t.evolveId = n.evolveId),
            (t.lifetimeMs = n.lifetimeMs),
            (t.minDamage = n.minDamage),
            (t.maxDamage = n.maxDamage),
            (t.heal = n.heal),
            (t.projectileCount = n.projectileCount),
            (t.triggerCooldownMs = n.triggerCooldownMs),
            (t.statusEffectOnHit = n.statusEffectOnHit),
            (t.statusEffectAura = n.statusEffectAura),
            (t.tags = n.tags));
        }
        summonObject(t, e, i, n, s, r) {
          const o = t.characterStatus,
            a = new Array(),
            l = new Array(),
            u = t.characterStatus;
          if (void 0 === n) {
            const t = i,
              n = 0,
              r = Object.assign(Object.assign({}, t), {
                isAlive: true,
                spawned: true,
                sourceProc: i,
                simulationProc: e,
                currentTriggerCount: 0,
                currentTriggerTimer: 0,
                currentLifetimeMs: 0,
                currentDelayMs: n,
                children: a,
                parent: s,
              });
            return void o.minions.push(r);
          }
          const h = this.dataHandler.objectsData.get(n);
          if (void 0 === h) return;
          const c = null != r ? r : h.mergeWithEquipment,
            d = h.delayMs,
            p = Object.assign(Object.assign({}, h), {
              isAlive: true,
              spawned: true,
              mergeWithEquipment: c,
              sourceProc: i,
              simulationProc: e,
              currentTriggerCount: 0,
              currentTriggerTimer: 0,
              currentLifetimeMs: 0,
              currentDelayMs: d,
              children: a,
              parent: s,
              evolveInstigatorsTags: l,
            });
          if (0 !== h.subObjectPerCast.length) {
            const e =
              h.subObjectPerCast[o.abilityUseCount % h.subObjectPerCast.length];
            this.summonObject(
              t,
              p.simulationProc,
              i,
              e,
              null != s ? s : p,
              h.mergeWithEquipment
            );
          }
          if (0 === h.spawnObjectsPerTrigger.length)
            1 == h.isSummon &&
              (o.summonCounter >= 3 && this.removeOldestMinionObject(u, n),
              o.summonCounter++),
              void 0 !== s && s.children.push(p),
              o.minions.push(p);
          else
            for (let e = 0; e < h.spawnObjectsPerTrigger.length; e++) {
              const n = h.spawnObjectsPerTrigger[e];
              this.summonObject(
                t,
                p.simulationProc,
                i,
                n,
                null != s ? s : p,
                h.mergeWithEquipment
              );
            }
        }
        healCharacter(t, e, i) {
          const n = e.characterStatus,
            s = n.stats.getCurrentStatValue(Ee.MAXHP) - n.currentHp;
          if (0 == (i = Math.min(s, i))) return;
          n.currentHp += i;
          const r = this.getProcDetails(e.equipmentDetails, t);
          (r.recoveredHp += i), r.procCount++;
        }
        moveCharacter(t, e, i) {
          if (0 == i) return;
          const n = t.characterStatus;
          let s = 4 + (n.stats.getCurrentStatValue(Ee.SPD) / 75) * 5.6;
          n.playerStatusEffects[Ie.Paralyzed] >= e ||
            (n.playerStatusEffects[Ie.Slowed] >= e
              ? (s = 4)
              : n.playerStatusEffects[Ie.Speedy] >= e && (s *= 1.5),
            s < 0 && (s = 0),
            (n.travelledTiles += s * i));
        }
        addDamageOverTime(t, e, i, n) {
          var s;
          const r = t.characterStatus,
            o = i + e.durationMs,
            a = null !== (s = r.dots.get(e)) && void 0 !== s ? s : new Array();
          let l = e.damage;
          if (e.scalingStatType > Ee.None) {
            const t = Math.max(
                0,
                r.stats.getCurrentStatValue(e.scalingStatType) -
                  e.scalingStatThreshold
              ),
              i = Math.floor(t / e.scalingStatInterval);
            l += Math.ceil(e.scalingStatIncrease * i);
          }
          l *= n;
          const u = {
            sourceProc: e,
            startTimeMs: i,
            endTimeMs: o,
            damagePerSecond: l / (0.001 * e.durationMs),
          };
          a.push(u), r.dots.set(e, a);
        }
        handleProc(t, e, i, n, s = 1, r = 0) {
          var o, a, l;
          const u = t.characterStatus,
            h = t.equipmentDetails,
            c = u.procs[e][i];
          if (c.cooldownTimestamp >= n + 0.5 * t.tickMs) return;
          const d =
            0 != c.base.cooldownMs || (e != Si.OnShoot && e != Si.OnPlayerHit)
              ? 1
              : s;
          if (((c.chanceProgress += c.base.chance * d), c.chanceProgress < 1))
            return;
          const p = Math.floor(c.chanceProgress);
          (c.chanceProgress =
            0 == c.base.cooldownMs ? c.chanceProgress - p : 0),
            (c.cooldownTimestamp = n + c.base.cooldownMs);
          for (let t = 0; t < c.liveRequirements.length; t++) {
            const e = c.liveRequirements[t];
            switch (e.type) {
              case Ci.HasStatusEffect: {
                const t = e.value;
                if (u.playerStatusEffects[t] < n) return;
                break;
              }
              case Ci.ChargeIndex:
                if (u.abilityMaxCharges - u.abilityCurrentCharges != e.value)
                  return;
                break;
              case Ci.MinMpRequired: {
                const t = e.value;
                if (u.currentMp < t) return;
                break;
              }
              case Ci.DamageThreshold:
                if (r <= e.value) return;
                break;
            }
          }
          switch (c.base.effectType) {
            case Fe.Projectile: {
              const e = c.base;
              let i = e.projectile.minDamage,
                r = e.projectile.maxDamage;
              const d =
                null === (o = e.affectedByStatusEffects) || void 0 === o || o;
              let p = e.projectileCount;
              if (1 == e.abilitySource) {
                if (
                  ((c.hitProgress +=
                    e.projectileCount * u.base.abilityShotsAccuracy),
                  c.hitProgress < 1)
                )
                  break;
                (p = Math.floor(c.hitProgress)), (c.hitProgress -= p);
              }
              if (0 == p) break;
              if (e.scalingStatType > Ee.None) {
                const t = Math.max(
                    0,
                    u.stats.getCurrentStatValue(e.scalingStatType) -
                      e.scalingStatThreshold
                  ),
                  n = Math.floor(t / e.scalingStatInterval),
                  s = e.scalingStatIncrease * n;
                (i += s), (r += s);
              }
              (i = Math.floor(i)), (r = Math.floor(r));
              let f = p;
              0 == c.base.cooldownMs && (f *= s);
              const m = e.projectile.ignoreDefense,
                g = e.sourceSlot,
                v =
                  null === (a = e.projectile) || void 0 === a
                    ? void 0
                    : a.statusEffects;
              if (1 == u.includeStatusEffectsFromEquipment && void 0 !== v)
                for (let t = 0; t < v.length; t++)
                  (null !== (l = u.base.targetImmunities.get(v[t].type)) &&
                    void 0 !== l &&
                    l) ||
                    (u.targetStatusEffects[v[t].type] = n + v[t].durationMs);
              if (e.stealHp > 0) {
                let s = u.base.targetData.defense;
                u.targetStatusEffects[Ie.ArmorBroken] >= n
                  ? (s = 0)
                  : u.targetStatusEffects[Ie.Armored] >= n &&
                    (s = Math.floor(1.5 * s)),
                  u.targetStatusEffects[Ie.Exposed] >= n && (s -= 20),
                  (s = Math.max(s - m, 0));
                let o = this.calculateAverageDamage(i, r, s),
                  a = e.stealHp;
                u.targetStatusEffects[Ie.Curse] >= n &&
                  ((o = Math.floor(1.25 * o)), (a = Math.floor(1.25 * a)));
                const l = Math.max(Math.min(o - s, a), 0);
                this.healCharacter(e, t, l);
              }
              if (1 == c.base.mergeWithEquipment)
                (h[g].baseData.hitCount += f),
                  this.addDamageData(n, h[g], u, i, r, f, m, d);
              else {
                (this.getProcDetails(h, c.base).hitCount += f),
                  this.addProcDamageData(n, h[g], c.base, u, i, r, f, m, d);
              }
              break;
            }
            case Fe.DamageOverTime: {
              const e = c.base;
              this.addDamageOverTime(t, e, n, p);
              break;
            }
            case Fe.Magic: {
              const t = c.base,
                e = Math.min(
                  t.amount * p,
                  u.stats.getCurrentStatValue(Ee.MAXMP) - u.currentMp
                ),
                i = this.getProcDetails(h, c.base);
              (i.procCount += p), (i.value += e), (u.currentMp += e);
              break;
            }
            case Fe.StatusEffect: {
              const e = u.includeStatusEffectsFromEquipment,
                i = c.base;
              if (!e && i.statusEffectType != Ie.StasisImmune) break;
              let s = i.durationMs;
              if (i.scalingStatType > Ee.None) {
                const t = Math.max(
                  0,
                  u.stats.getCurrentStatValue(i.scalingStatType) -
                    i.scalingStatThreshold
                );
                s += Math.floor(0.1 * t) * i.scalingStatDurationMs;
              }
              this.addStatusEffect(t, n, c, i.statusEffectType, s);
              break;
            }
            case Fe.StatBoost: {
              const e = c.base;
              let i = e.durationMs;
              if (e.scalingStatType > Ee.None) {
                const t = Math.max(
                  0,
                  u.stats.getCurrentStatValue(e.scalingStatType) -
                    e.scalingStatThreshold
                );
                i += 1e3 * Math.floor(0.1 * t);
              }
              const s = Math.min(i, t.durationMs - n),
                r =
                  s -
                  Math.min(
                    c.durationTimestamp > n ? c.durationTimestamp - n : 0,
                    s
                  ),
                o = n + s,
                a = this.getProcDetails(h, c.base);
              (a.procCount += p),
                (a.uptimeMs += r),
                (a.durationTimestamp = o),
                (c.durationTimestamp = o),
                u.stats.addStatProc(u.base.stats, e, o);
              break;
            }
            case Fe.Minion: {
              const e = c.base,
                i = e.objectId;
              if (0 == e.mergeWithEquipment) {
                this.getProcDetails(h, c.base).procCount += p;
              }
              this.summonObject(t, c, e, i);
              break;
            }
            case Fe.Teleport: {
              const t = c.base.maxDistance;
              u.travelledTiles += t;
              const e = this.getProcDetails(h, c.base);
              (e.procCount += p), (e.value += t);
              break;
            }
            case Fe.Dash: {
              const t = c.base;
              (u.movementType = wi.Dash),
                (u.currentDashProc = t),
                (u.dashMaxTimeMs = t.maxDurationMs),
                (u.dashCurrentTimeMs = 0);
              this.getProcDetails(h, c.base).procCount += p;
              break;
            }
            case Fe.Heal: {
              const e = c.base;
              let i = e.amount;
              if (e.scalingStatType > Ee.None) {
                const t = Math.max(
                  0,
                  u.stats.getCurrentStatValue(e.scalingStatType) -
                    e.scalingStatThreshold
                );
                i += Math.floor(0.1 * t) * e.scalingStatIncrease;
              }
              this.healCharacter(e, t, i);
              break;
            }
            default:
              this.getProcDetails(h, c.base).procCount++;
              break;
          }
          if (0 != c.base.manaCost) {
            u.currentMp -= c.base.manaCost;
            this.getProcDetails(h, c.base).mpSpent += c.base.manaCost;
          }
        }
        calculateAverageDamage(t, e, i) {
          const n = e - t + 1,
            s = Ve.clamp(Math.floor(1.1 * i + 1.5) - t, 0, n),
            r = n - s,
            o = 1 / n;
          let a = r * (e - i - 0.5 * (r - 1));
          for (let e = t; e < t + s; e++) {
            a += Math.max(Math.floor(0.1 * e), e - i);
          }
          return a * o;
        }
        parseProcRequirements(t, e, i, n = !1) {
          var s, r, o, a, l, u, h, c;
          if (void 0 === t.requirements) return !0;
          for (let d = 0; d < t.requirements.length; d++) {
            let p = t.requirements[d];
            switch (p.type) {
              case Ci.MinHpRequired:
                if (
                  Math.floor(
                    (null !==
                      (r =
                        null === (s = e.stats.getStat(Ee.MAXHP)) || void 0 === s
                          ? void 0
                          : s.totalValue) && void 0 !== r
                      ? r
                      : 0) * e.startingHpPercent
                  ) < p.value
                )
                  return !1;
                break;
              case Ci.HpThreshold:
                if (
                  Math.floor(
                    (null !==
                      (a =
                        null === (o = e.stats.getStat(Ee.MAXHP)) || void 0 === o
                          ? void 0
                          : o.totalValue) && void 0 !== a
                      ? a
                      : 0) * e.startingHpPercent
                  ) >= p.value
                )
                  return !1;
                break;
              case Ci.MinHpRequiredRelative: {
                const t = p.value;
                if (e.startingHpPercent < t) return !1;
                break;
              }
              case Ci.HpThresholdRelative: {
                const t = p.value;
                if (e.startingHpPercent >= t) return !1;
                break;
              }
              case Ci.MustWearId: {
                let t = 0;
                const i = p.value.split(";");
                for (let n = 0; n < i.length; n++) {
                  const s = Number(i[n]);
                  for (let i = 0; i < 4; i++)
                    (null ===
                      (u =
                        null === (l = e.equipment[i]) || void 0 === l
                          ? void 0
                          : l.base) || void 0 === u
                      ? void 0
                      : u.id) == s && t++;
                }
                if (t != i.length) return !1;
                break;
              }
              case Ci.CannotWearId: {
                let t = 0;
                const i = p.value.split(";");
                for (let n = 0; n < i.length; n++) {
                  const s = Number(i[n]);
                  for (let i = 0; i < 4; i++) {
                    const n =
                      null === (h = e.equipment[i]) || void 0 === h
                        ? void 0
                        : h.base;
                    (null == n ? void 0 : n.id) == s && t++;
                  }
                }
                if (1 == i.length && 1 == t) return !1;
                if (i.length > 1 && (t == i.length || 0 == t)) return !1;
                break;
              }
              case Ci.OrCannotWearId: {
                const t = p.value.split(";");
                for (let i = 0; i < t.length; i++) {
                  const n = Number(t[i]);
                  for (let t = 0; t < 4; t++) {
                    const i =
                      null === (c = e.equipment[t]) || void 0 === c
                        ? void 0
                        : c.base;
                    if ((null == i ? void 0 : i.id) == n) return !1;
                  }
                }
                break;
              }
              case Ci.DamageThreshold:
                if (
                  e.onhitProcTrigger == Pi.Never ||
                  e.onhitProcTrigger == Pi.AnyHit
                )
                  break;
                i.push(p);
                break;
              case Ci.ChargeIndex:
              case Ci.HasStatusEffect:
                i.push(p);
                break;
              case Ci.MinMpRequired:
                if (1 == n) {
                  const t = e.stats.getStatValue(Ee.MPMULTIPLIER),
                    n = Math.round(p.value * t),
                    s = { type: p.type, value: n };
                  i.push(s);
                  break;
                }
                i.push(p);
            }
          }
          return !0;
        }
        stripEnchants(t, e) {
          var i, n;
          if (void 0 === t) return;
          const s = t.enchants;
          if (void 0 === s) return;
          const r = {
            attackTimer: e.playerStatusEffects[Ie.Stunned] > 0 ? 0 : 1,
            attackProgress: 0,
            burstCooldownTimer: 0,
            burstCurrentCount: 0,
            enchantId: -1,
          };
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.id < 0) continue;
            for (let t = 0; t < a.attackMutators.length; t++) {
              const i = a.attackMutators[t];
              for (let t = 0; t < e.weaponAttacks.length; t++) {
                const n = e.weaponAttacks[t];
                if (i.projectileId == n.projectileId)
                  switch (i.type) {
                    case Le.MultiplyRateOfFire:
                      0 == i.projectileId &&
                        (e.burstAttackRateModifier = i.value),
                        (n.rateOfFire *= i.value);
                      break;
                    case Le.MultiplyMinDamage:
                      n.projectile.minDamage = Math.round(
                        n.projectile.minDamage * i.value
                      );
                      break;
                    case Le.MultiplyMaxDamage:
                      n.projectile.maxDamage = Math.round(
                        n.projectile.maxDamage * i.value
                      );
                  }
              }
            }
            for (let t = 0; t < a.setAttacks.length; t++) {
              const i = a.setAttacks[t];
              for (let t = 0; t < e.weaponAttacks.length; t++) {
                e.weaponAttacks[t].subAttackId == i.subAttackId &&
                  (e.weaponAttacks[t] = Object.assign(
                    Object.assign(Object.assign({}, i), r),
                    { mergeWithEquipment: !0 }
                  ));
              }
            }
            for (let t = 0; t < a.addAttacks.length; t++) {
              const i = a.addAttacks[t],
                n = t,
                s = { sourceName: a.name, sourceSlot: Re.Weapon };
              e.weaponAttacks.push(
                Object.assign(Object.assign(Object.assign({}, i), r), {
                  enchantId: n,
                })
              ),
                e.enchantProcs.set(n, s);
            }
            const l = Ve.slotMetaType(
              null !==
                (n =
                  null === (i = t.base) || void 0 === i
                    ? void 0
                    : i.slotType) && void 0 !== n
                ? n
                : 0
            );
            this.stripProcsHelper(a.procs, e, l);
          }
        }
        stripProcsHelper(t, e, i, n = !1) {
          if (void 0 !== t)
            for (let s = 0; s < t.length; s++) {
              let r = Object.assign(Object.assign({}, t[s]), { sourceSlot: i });
              const o = e.procs[r.type],
                a = new Array(),
                l = {
                  durationTimestamp: 0,
                  cooldownTimestamp: 0,
                  chanceProgress: 0,
                  hitProgress: 0,
                  liveRequirements: a,
                },
                u = this.parseProcRequirements(r, e.base, a, n),
                h = new Map();
              if (0 != u) {
                if (r.effectType == Fe.Minion) {
                  const t = r,
                    e = this.app.dataHandler.objectsData.get(t.objectId),
                    n = (t) => {
                      const e = {
                        sourceName: `Status Effect: ${Ve.statusEffectToString(
                          t.type
                        )}`,
                        effectType: Fe.StatusEffect,
                        statusEffectType: t.type,
                        sourceSlot: i,
                      };
                      return Object.assign(Object.assign({}, l), { base: e });
                    };
                  if (void 0 !== e) {
                    t.heal = e.heal;
                    for (let t = 0; t < e.statusEffectAura.length; t++) {
                      const i = n(e.statusEffectAura[t]);
                      h.set(e.statusEffectAura[t].type, i);
                    }
                    for (let t = 0; t < e.statusEffectOnHit.length; t++) {
                      const i = n(e.statusEffectOnHit[t]);
                      h.set(e.statusEffectOnHit[t].type, i);
                    }
                  }
                  r = Object.assign({}, t);
                }
                o.push(
                  Object.assign(Object.assign({}, l), {
                    base: r,
                    objectProcs: h,
                  })
                ),
                  (e.procs[r.type] = o);
              }
            }
        }
        stripProcsFromAbility(t, e) {
          if (void 0 === t) return;
          const i = t.procs;
          this.stripProcsHelper(i, e, Re.Ability, !0);
        }
        stripProcs(t, e, i = !1) {
          if (void 0 === t) return;
          const n = t.procs,
            s = Ve.slotMetaType(t.slotType);
          this.stripProcsHelper(n, e, s, i);
        }
      }
      var Di,
        Ri,
        Bi,
        Fi,
        Oi,
        zi,
        Li = n(8343),
        Hi = n.n(Li);
      !(function (t) {
        (t[(t.None = -1)] = "None"),
          (t[(t.Rogue = 0)] = "Rogue"),
          (t[(t.Archer = 1)] = "Archer"),
          (t[(t.Wizard = 2)] = "Wizard"),
          (t[(t.Priest = 3)] = "Priest"),
          (t[(t.Warrior = 4)] = "Warrior"),
          (t[(t.Knight = 5)] = "Knight"),
          (t[(t.Paladin = 6)] = "Paladin"),
          (t[(t.Assassin = 7)] = "Assassin"),
          (t[(t.Necromancer = 8)] = "Necromancer"),
          (t[(t.Huntress = 9)] = "Huntress"),
          (t[(t.Mystic = 10)] = "Mystic"),
          (t[(t.Trickster = 11)] = "Trickster"),
          (t[(t.Sorcerer = 12)] = "Sorcerer"),
          (t[(t.Ninja = 13)] = "Ninja"),
          (t[(t.Samurai = 14)] = "Samurai"),
          (t[(t.Bard = 15)] = "Bard"),
          (t[(t.Summoner = 16)] = "Summoner"),
          (t[(t.Kensei = 17)] = "Kensei");
      })(Di || (Di = {})),
        (function (t) {
          (t[(t.None = 0)] = "None"),
            (t[(t.GenericActivate = 1)] = "GenericActivate"),
            (t[(t.StatBoostSelf = 2)] = "StatBoostSelf"),
            (t[(t.StatBoostAura = 3)] = "StatBoostAura"),
            (t[(t.ConditionEffectSelf = 4)] = "ConditionEffectSelf"),
            (t[(t.ConditionEffectAura = 5)] = "ConditionEffectAura"),
            (t[(t.ClearConditionEffectSelf = 6)] = "ClearConditionEffectSelf"),
            (t[(t.HealNova = 7)] = "HealNova"),
            (t[(t.PoisonGrenade = 8)] = "PoisonGrenade"),
            (t[(t.VampireBlast = 9)] = "VampireBlast"),
            (t[(t.Trap = 10)] = "Trap"),
            (t[(t.Lightning = 11)] = "Lightning"),
            (t[(t.EffectBlast = 12)] = "EffectBlast"),
            (t[(t.Decoy = 13)] = "Decoy"),
            (t[(t.Teleport = 14)] = "Teleport"),
            (t[(t.BulletNova = 15)] = "BulletNova"),
            (t[(t.BulletCreate = 16)] = "BulletCreate"),
            (t[(t.Shoot = 17)] = "Shoot"),
            (t[(t.ShurikenAbility = 18)] = "ShurikenAbility"),
            (t[(t.Pet = 19)] = "Pet"),
            (t[(t.SpawnCreep = 20)] = "SpawnCreep"),
            (t[(t.ObjectToss = 21)] = "ObjectToss"),
            (t[(t.ChannelDash = 22)] = "ChannelDash"),
            (t[(t.Dash = 23)] = "Dash");
        })(Ri || (Ri = {})),
        (function (t) {
          (t[(t.None = -1)] = "None"),
            (t[(t.BrownBag = 0)] = "BrownBag"),
            (t[(t.PinkBag = 1)] = "PinkBag"),
            (t[(t.PurpleBag = 2)] = "PurpleBag"),
            (t[(t.EggBasket = 3)] = "EggBasket"),
            (t[(t.CyanBag = 4)] = "CyanBag"),
            (t[(t.BlueBag = 5)] = "BlueBag"),
            (t[(t.WhiteBag = 6)] = "WhiteBag"),
            (t[(t.GoldenBag = 7)] = "GoldenBag"),
            (t[(t.OrangeBag = 8)] = "OrangeBag"),
            (t[(t.RedBag = 9)] = "RedBag");
        })(Bi || (Bi = {})),
        (function (t) {
          (t[(t.None = -1)] = "None"),
            (t[(t.Miscellaneous = 0)] = "Miscellaneous"),
            (t[(t.Aquatic = 1)] = "Aquatic"),
            (t[(t.Automaton = 2)] = "Automaton"),
            (t[(t.Avian = 3)] = "Avian"),
            (t[(t.Canine = 4)] = "Canine"),
            (t[(t.Exotic = 5)] = "Exotic"),
            (t[(t.Farm = 6)] = "Farm"),
            (t[(t.Feline = 7)] = "Feline"),
            (t[(t.Humanoid = 8)] = "Humanoid"),
            (t[(t.Insect = 9)] = "Insect"),
            (t[(t.Penguin = 10)] = "Penguin"),
            (t[(t.Reptile = 11)] = "Reptile"),
            (t[(t.Spooky = 12)] = "Spooky"),
            (t[(t.Woodland = 13)] = "Woodland");
        })(Fi || (Fi = {})),
        (function (t) {
          (t[(t.None = -1)] = "None"),
            (t[(t.SetGeneration1 = 0)] = "SetGeneration1"),
            (t[(t.SetGeneration2 = 1)] = "SetGeneration2"),
            (t[(t.SetGeneration3 = 2)] = "SetGeneration3"),
            (t[(t.Fungal = 3)] = "Fungal"),
            (t[(t.Crystal = 4)] = "Crystal"),
            (t[(t.Nest = 5)] = "Nest"),
            (t[(t.Shatters = 6)] = "Shatters"),
            (t[(t.Marble = 7)] = "Marble"),
            (t[(t.Cult = 8)] = "Cult"),
            (t[(t.Void = 9)] = "Void"),
            (t[(t.Sanctuary = 10)] = "Sanctuary"),
            (t[(t.Kogbold = 11)] = "Kogbold"),
            (t[(t.Moonlight = 12)] = "Moonlight");
        })(Oi || (Oi = {})),
        (function (t) {
          (t[(t.Debug = -1)] = "Debug"),
            (t[(t.Legacy = 0)] = "Legacy"),
            (t[(t.Vanity = 1)] = "Vanity"),
            (t[(t.Shiny = 2)] = "Shiny"),
            (t[(t.LowTier = 3)] = "LowTier"),
            (t[(t.HighTier = 4)] = "HighTier"),
            (t[(t.TopTier = 5)] = "TopTier"),
            (t[(t.SetTier = 6)] = "SetTier"),
            (t[(t.Halloween = 7)] = "Halloween"),
            (t[(t.Oryxmas = 8)] = "Oryxmas"),
            (t[(t.ValentinesDay = 9)] = "ValentinesDay"),
            (t[(t.StPatricksDay = 10)] = "StPatricksDay"),
            (t[(t.Easter = 11)] = "Easter"),
            (t[(t.Alien = 12)] = "Alien"),
            (t[(t.AgentsOfOryx = 13)] = "AgentsOfOryx"),
            (t[(t.Aspirant = 14)] = "Aspirant"),
            (t[(t.Syndicate = 15)] = "Syndicate"),
            (t[(t.Antinomy = 16)] = "Antinomy"),
            (t[(t.Rehearsal = 17)] = "Rehearsal"),
            (t[(t.Construction = 18)] = "Construction"),
            (t[(t.AllOther = 99)] = "AllOther");
        })(zi || (zi = {}));
      var Ui = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            var e;
            t.done
              ? s(t.value)
              : ((e = t.value),
                e instanceof i
                  ? e
                  : new i(function (t) {
                      t(e);
                    })).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Ni extends ai {
        constructor(t) {
          super(t),
            (this.xmlParser = new (Hi())()),
            (this.petHealData = new Map()),
            (this.staticTextureAtlasCoordsData = new Map()),
            (this.animatedTextureCoordsData = new Map()),
            (this.sTierEquipmentData = new Map()),
            (this.classEventReskinsData = new Map()),
            (this.enchantmentsTierData = new Map()),
            (this.adjustmentsData = new Map()),
            (this.alwaysCenteredSkinNamesData = new Map()),
            (this.skinScaleData = new Map()),
            (this.alwaysCenteredSkinsData = new Map()),
            (this.themeData = new Map()),
            (this.classesData = new Map()),
            (this.skinsData = new Map()),
            (this.equipmentData = new Map()),
            (this.objectsData = new Map()),
            (this.attackData = new Map()),
            (this.eliglibleClassNamesPerSlotType = new Map()),
            (this.classDirtyTypeMap = new Map()),
            (this.equipmentSetsData = new Map()),
            (this.enchantmentsData = new Map()),
            (this.changelogData = new Map()),
            (this.statusEffectDescriptionData = new Map()),
            (this.baseStatDescriptionData = new Map()),
            (this.enemiesData = new Map()),
            (this.incompleteEnchantmentIds = new Array()),
            (this.petFamiliesData = new Map()),
            (this.dyesData = new Map()),
            (this.collectionTypeData = new Map()),
            (this.itemChecklistTags = new Map());
        }
        getLatestUpdate() {
          return Array.from(this.app.dataHandler.changelogData.values())[0];
        }
        loadThemeData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(`./data/json/themes.json`)).text(),
              e = yield JSON.parse(t),
              i = Object.keys(e);
            for (const t of i) {
              const i = e[t];
              this.themeData.set(i.index, i);
            }
            return Promise.resolve(!0);
          });
        }
        loadAlwaysCenteredSkinsData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(
                `./data/json/centeredSkins.json`
              )).text(),
              e = yield JSON.parse(t),
              i = Object.keys(e);
            for (const t of i) this.alwaysCenteredSkinNamesData.set(t, null);
            return Promise.resolve(!0);
          });
        }
        loadClassType() {
          return Ui(this, void 0, void 0, function* () {
            return (
              this.classDirtyTypeMap.set(768, Di.Rogue),
              this.classDirtyTypeMap.set(775, Di.Archer),
              this.classDirtyTypeMap.set(782, Di.Wizard),
              this.classDirtyTypeMap.set(784, Di.Priest),
              this.classDirtyTypeMap.set(797, Di.Warrior),
              this.classDirtyTypeMap.set(798, Di.Knight),
              this.classDirtyTypeMap.set(799, Di.Paladin),
              this.classDirtyTypeMap.set(800, Di.Assassin),
              this.classDirtyTypeMap.set(801, Di.Necromancer),
              this.classDirtyTypeMap.set(802, Di.Huntress),
              this.classDirtyTypeMap.set(803, Di.Mystic),
              this.classDirtyTypeMap.set(804, Di.Trickster),
              this.classDirtyTypeMap.set(805, Di.Sorcerer),
              this.classDirtyTypeMap.set(806, Di.Ninja),
              this.classDirtyTypeMap.set(785, Di.Samurai),
              this.classDirtyTypeMap.set(796, Di.Bard),
              this.classDirtyTypeMap.set(817, Di.Summoner),
              this.classDirtyTypeMap.set(818, Di.Kensei),
              Promise.resolve(!0)
            );
          });
        }
        loadCollectionType() {
          return Ui(this, void 0, void 0, function* () {
            return (
              this.collectionTypeData.set(1, Oi.SetGeneration1),
              this.collectionTypeData.set(2, Oi.SetGeneration2),
              this.collectionTypeData.set(3, Oi.SetGeneration3),
              this.collectionTypeData.set(11, Oi.Fungal),
              this.collectionTypeData.set(12, Oi.Crystal),
              this.collectionTypeData.set(13, Oi.Nest),
              this.collectionTypeData.set(14, Oi.Shatters),
              this.collectionTypeData.set(15, Oi.Marble),
              this.collectionTypeData.set(16, Oi.Cult),
              this.collectionTypeData.set(17, Oi.Void),
              this.collectionTypeData.set(18, Oi.Sanctuary),
              this.collectionTypeData.set(19, Oi.Kogbold),
              this.collectionTypeData.set(94, Oi.Moonlight),
              Promise.resolve(!0)
            );
          });
        }
        loadStatusEffectDescriptionData() {
          return Ui(this, void 0, void 0, function* () {
            return (
              this.statusEffectDescriptionData.set(Ie.ArmorBroken, [
                "Reduces Defense Stat to 0",
              ]),
              this.statusEffectDescriptionData.set(Ie.Armored, [
                "Increases Defense Stat by 50%",
              ]),
              this.statusEffectDescriptionData.set(Ie.Berserk, [
                "Increases Weapon Rate of Fire by 25%",
              ]),
              this.statusEffectDescriptionData.set(Ie.Bleeding, [
                "Drains 20 HP Per Second",
                "Disables VIT's HP Regeneration",
              ]),
              this.statusEffectDescriptionData.set(Ie.Blind, [
                "Covers your game screen in dimmed grayscale.",
              ]),
              this.statusEffectDescriptionData.set(Ie.Confused, [
                "Swaps your movement control keys",
                "Down swaps with Left; Up swaps with Right",
              ]),
              this.statusEffectDescriptionData.set(Ie.Curse, [
                "Increases Damage Taken by 25%",
              ]),
              this.statusEffectDescriptionData.set(Ie.Damaging, [
                "Increases Weapon Damage by 25%",
              ]),
              this.statusEffectDescriptionData.set(Ie.Darkness, [
                "Covers your game screen in darkness",
              ]),
              this.statusEffectDescriptionData.set(Ie.Dazed, [
                "Sets Dexterity Stat to 0",
                "Nullifies Berserk Status Effect",
              ]),
              this.statusEffectDescriptionData.set(Ie.Drought, [
                "Disables Consumables Effects",
              ]),
              this.statusEffectDescriptionData.set(Ie.Drunk, [
                "Blurs your game screen",
              ]),
              this.statusEffectDescriptionData.set(Ie.Energized, [
                "Regenerates 10 MP Per Second",
              ]),
              this.statusEffectDescriptionData.set(Ie.Exposed, [
                "Reduced Defense Stat by 20",
              ]),
              this.statusEffectDescriptionData.set(Ie.Healing, [
                "Regenerates 20 HP Per Second",
              ]),
              this.statusEffectDescriptionData.set(Ie.InCombat, [
                "Decreases HP and MP Regeneration by 50%",
                "Limits Pet Support",
              ]),
              this.statusEffectDescriptionData.set(Ie.Inspired, [
                "Increases Weapon Projectile Speed by 25%",
              ]),
              this.statusEffectDescriptionData.set(Ie.Invisible, [
                "Makes you not targetable by Enemies",
              ]),
              this.statusEffectDescriptionData.set(Ie.Invulnerable, [
                "You Can't Receive Any Damage",
              ]),
              this.statusEffectDescriptionData.set(Ie.Paralyzed, [
                "You Can't Move",
              ]),
              this.statusEffectDescriptionData.set(Ie.PetStasis, [
                "Disables Pet Support",
              ]),
              this.statusEffectDescriptionData.set(Ie.Petrify, [
                "You Can't Move Or Shoot",
              ]),
              this.statusEffectDescriptionData.set(Ie.Sick, [
                "Nullifies All HP Recovery",
              ]),
              this.statusEffectDescriptionData.set(Ie.Quiet, [
                "Sets Your Current MP to 0",
              ]),
              this.statusEffectDescriptionData.set(Ie.Silenced, [
                "Disables Ability",
              ]),
              this.statusEffectDescriptionData.set(Ie.Slowed, [
                "Sets Speed Stat to 0",
              ]),
              this.statusEffectDescriptionData.set(Ie.Speedy, [
                "Increases Movement Speed by 50%",
              ]),
              this.statusEffectDescriptionData.set(Ie.Stasis, [
                "You Can't Perform Any Action",
              ]),
              this.statusEffectDescriptionData.set(Ie.Stunned, [
                "Disables Weapon",
              ]),
              this.statusEffectDescriptionData.set(Ie.Unstable, [
                "Your Weapon Accuracy Decreases",
              ]),
              this.statusEffectDescriptionData.set(Ie.Weak, [
                "Sets Attack Stat to 0",
                "Nullifies Damaging Status Effect",
              ]),
              Promise.resolve(!0)
            );
          });
        }
        loadBaseStatDescriptionData() {
          return Ui(this, void 0, void 0, function* () {
            return (
              this.baseStatDescriptionData.set(Ee.ATT, [
                "Increases Weapon Damage by 2%",
              ]),
              this.baseStatDescriptionData.set(Ee.DEF, [
                "Reduces Damage Taken by 1",
                "Increases In-Combat State Trigger Threshold",
              ]),
              this.baseStatDescriptionData.set(Ee.SPD, [
                "Increases Movement Speed by ~0.075 tiles/s",
              ]),
              this.baseStatDescriptionData.set(Ee.DEX, [
                "Increases Attack Speed by ~0.087/s",
              ]),
              this.baseStatDescriptionData.set(Ee.VIT, [
                "Increases HP Recovery by 0.06/s",
                "Reduces In-Combat Time by 0.05s",
              ]),
              this.baseStatDescriptionData.set(Ee.WIS, [
                "Increases MP Recovery by 0.12/s",
              ]),
              Promise.resolve(!0)
            );
          });
        }
        loadSkinsXMLData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(`./data/xml/skins.xml`)).text(),
              e = yield (yield fetch(`./data/xml/equipSkins.xml`)).text(),
              i = yield this.loadSkinsData(t, e);
            return Promise.resolve(i);
          });
        }
        loadEnchantmentXMLData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(`./data/xml/enchantments.xml`)).text(),
              e = yield this.loadEnchantmentsData(t);
            return Promise.resolve(e);
          });
        }
        loadEquipmentSetXMLData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(
                `./data/xml/equipmentsets.xml`
              )).text(),
              e = yield this.loadEquipmentSetData(t);
            return Promise.resolve(e);
          });
        }
        loadEquipmentXMLData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(`./data/xml/equip.xml`)).text(),
              e = yield this.loadEquipmentData(t);
            return Promise.resolve(e);
          });
        }
        loadClassXMLData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(`./data/xml/players.xml`)).text(),
              e = yield this.loadClassData(t);
            return Promise.resolve(e);
          });
        }
        loadPetsXMLData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(`./data/xml/equipEggs.xml`)).text(),
              e = yield (yield fetch(`./data/xml/pets.xml`)).text();
            let i = yield this.loadPetFamiliesData(t),
              n = yield this.loadPetSkinsData(e);
            return Promise.resolve(i && n);
          });
        }
        loadPetFamiliesData(t) {
          return Ui(this, void 0, void 0, function* () {
            var e;
            const i = this.xmlParser.xml2js(t).Objects.Object;
            for (const t of i) {
              if (void 0 === t.PetFamily || 0 != t.Tier) continue;
              const i = Number(
                  null !== (e = Fi[t.PetFamily]) && void 0 !== e
                    ? e
                    : Fi.Miscellaneous
                ),
                n = {
                  type: i,
                  name: Fi[i],
                  texture: {
                    fileName: t.Texture.File,
                    index: Number(t.Texture.Index),
                    offsetX: 0,
                    offsetY: 0,
                  },
                  skins: new Map(),
                };
              this.petFamiliesData.set(i, n);
            }
            return Promise.resolve(!0);
          });
        }
        loadPetSkinsData(t) {
          return Ui(this, void 0, void 0, function* () {
            var e;
            const i = this.xmlParser.xml2js(t).Objects.Object;
            for (const t of i) {
              if (void 0 === t.PetSkin) continue;
              if (void 0 === t.AnimatedTexture) continue;
              const i = this.createSkinData(t);
              (i.id = Number(t._type)),
                (i.type = Number(
                  null !== (e = Fi[t.Family]) && void 0 !== e
                    ? e
                    : Fi.Miscellaneous
                ));
              const n = this.petFamiliesData.get(i.type);
              void 0 !== n && n.skins.set(i.id, i);
            }
            return Promise.resolve(!0);
          });
        }
        loadClassEventReskinsData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(`./data/json/skins.json`)).text(),
              e = yield JSON.parse(t),
              i = Object.keys(e);
            for (let t = 0; t < i.length; t++) {
              const n = new Array(),
                s = Di[i[t]];
              (n[0] = this.parseTextureData(e[i[t]].AprilFools)),
                (n[1] = this.parseTextureData(e[i[t]].Halloween)),
                (n[2] = this.parseTextureData(e[i[t]].Christmas)),
                this.classEventReskinsData.set(s, n);
            }
            return Promise.resolve(!0);
          });
        }
        loadAdjustmentsData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(
                `./data/json/adjustments.json`
              )).text(),
              e = yield JSON.parse(t),
              i = Object.keys(e);
            for (const t of i) {
              const i = e[t];
              this.adjustmentsData.set(t, i);
            }
            return Promise.resolve(!0);
          });
        }
        loadEnchantmentsTierData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(
                `./data/json/enchant_tiers.json`
              )).text(),
              e = yield JSON.parse(t),
              i = Object.keys(e);
            for (let t = 0; t < i.length; t++) {
              const n = Number(i[t]),
                s = e[n],
                r = new Map();
              this.enchantmentsTierData.set(n, r);
              for (const t of s) {
                const e = t.minTier,
                  i = t.enchantTier;
                r.set(i, e);
              }
            }
            return Promise.resolve(!0);
          });
        }
        loadEnemiesData() {
          return Ui(this, void 0, void 0, function* () {
            var t, e, i, n, s, r;
            const o = yield (yield fetch(`./data/json/enemies.json`)).text(),
              a = yield JSON.parse(o),
              l = Object.keys(a);
            for (let o = 0; o < l.length; o++) {
              const u = l[o],
                h = a[u],
                c = h.texture,
                d = null !== (t = h.hitpoints) && void 0 !== t ? t : 1e4,
                p = null !== (e = h.defense) && void 0 !== e ? e : 0,
                f = null !== (i = h.heal) && void 0 !== i ? i : 0,
                m = new Array(),
                g = null === (n = h.mirrorable) || void 0 === n || n;
              for (
                let t = 0;
                null !==
                  (r =
                    t <
                    (null === (s = h.immunities) || void 0 === s
                      ? void 0
                      : s.length)) &&
                void 0 !== r &&
                r;
                t++
              ) {
                const e = Ie[h.immunities[t]];
                m.push(e);
              }
              const v = {
                name: u,
                portraitTexture: c,
                hitpoints: d,
                defense: p,
                heal: f,
                statusEffectImmunities: m,
                mirrorable: g,
              };
              this.enemiesData.set(u, v);
            }
            return Promise.resolve(!0);
          });
        }
        loadSTierEquipmentData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(`./data/json/stier.json`)).text(),
              e = yield JSON.parse(t),
              i = Object.keys(e);
            for (let t = 0; t < i.length; t++) {
              const n = Di[i[t]],
                s = new Array();
              for (let n = 0; n < 4; n++) {
                const r = Number(e[i[t]][n].id),
                  o = e[i[t]][n].enchants,
                  a = new Array();
                for (let t = 0; t < o.length; t++) {
                  const e = this.enchantmentsData.get(Number(o[t]));
                  void 0 !== e && a.push(e);
                }
                s.push({ id: r, enchants: a });
              }
              this.sTierEquipmentData.set(n, s);
            }
            return Promise.resolve(!0);
          });
        }
        loadChangelogData() {
          return Ui(this, void 0, void 0, function* () {
            var t, e, i, n, s, r, o, a, l, u;
            const h = yield (yield fetch(`./data/json/changelog.json`)).text(),
              c = yield JSON.parse(h),
              d = Object.keys(c);
            for (let h = 0; h < d.length; h++) {
              const p = d[h],
                f = null === (t = c[p].visible) || void 0 === t || t,
                m = null !== (e = c[p].title) && void 0 !== e ? e : "",
                g = null !== (i = c[p].icon) && void 0 !== i ? i : "",
                v = Number(
                  null !== (n = c[p].color) && void 0 !== n ? n : ti.yellow
                ),
                y = null !== (s = c[p].date) && void 0 !== s ? s : "",
                x = null !== (r = c[p].exaltVersion) && void 0 !== r ? r : "",
                b =
                  null !== (o = c[p].changes) && void 0 !== o ? o : new Array(),
                S =
                  null !== (a = c[p].equipment) && void 0 !== a
                    ? a
                    : new Array(),
                C = new Array();
              for (let t = 0; t < S.length; t++)
                C.push({ id: Number(S[t].id), slotType: S[t].slotType });
              const _ =
                  null !== (l = c[p].playerSkins) && void 0 !== l
                    ? l
                    : new Array(),
                T = new Array();
              for (let t = 0; t < _.length; t++) {
                const e = { id: Number(_[t].id), type: Number(_[t].type) };
                T.push(e);
              }
              const w =
                  null !== (u = c[p].petSkins) && void 0 !== u
                    ? u
                    : new Array(),
                P = new Array();
              for (let t = 0; t < w.length; t++) {
                const e = { id: Number(w[t].id), type: Number(w[t].type) };
                P.push(e);
              }
              const A = {
                id: p,
                visible: f,
                title: m,
                icon: g,
                color: v,
                date: y,
                exaltVersion: x,
                changes: b,
                equipment: C,
                playerSkins: T,
                petSkins: P,
              };
              this.changelogData.set(p, A);
            }
            return Promise.resolve(!0);
          });
        }
        loadAttacksData() {
          return Ui(this, void 0, void 0, function* () {
            var t, e, i, n, s, r, o, a, l;
            const u = yield (yield fetch(`./data/json/attacks.json`)).text(),
              h = yield JSON.parse(u),
              c = Object.keys(h);
            for (let u = 0; u < c.length; u++) {
              const d = c[u],
                p = h[d],
                f = new Map();
              this.attackData.set(d, f);
              const m = Object.keys(p);
              for (let u = 0; u < m.length; u++) {
                const h = Number(m[u]),
                  c = p[m[u]],
                  d = {
                    projectile: {
                      minDamage:
                        null !== (t = c.projectile.minDamage) && void 0 !== t
                          ? t
                          : 0,
                      maxDamage:
                        null !== (e = c.projectile.maxDamage) && void 0 !== e
                          ? e
                          : 0,
                      ignoreDefense:
                        1e4 *
                        +(
                          null !== (i = c.projectile.ignoreDefense) &&
                          void 0 !== i &&
                          i
                        ),
                    },
                    projectileId: -1,
                    projectileCount:
                      null !== (n = c.projectileCount) && void 0 !== n ? n : 0,
                    burstMaxCount:
                      null !== (s = c.burstMaxCount) && void 0 !== s ? s : 0,
                    burstMinDelay:
                      null !== (r = c.burstMinDelay) && void 0 !== r ? r : 0,
                    burstMaxDelay:
                      null !== (o = c.burstMaxDelay) && void 0 !== o ? o : 0,
                    rateOfFire:
                      null !== (a = c.rateOfFire) && void 0 !== a ? a : 0,
                    arcGap: null !== (l = c.arcGap) && void 0 !== l ? l : 0,
                    mergeWithEquipment: !1,
                  };
                f.set(h, d);
              }
            }
            return Promise.resolve(!0);
          });
        }
        loadObjectData() {
          return Ui(this, void 0, void 0, function* () {
            var t,
              e,
              i,
              n,
              s,
              r,
              o,
              a,
              l,
              u,
              h,
              c,
              d,
              p,
              f,
              m,
              g,
              v,
              y,
              x,
              b,
              S,
              C,
              _,
              T,
              w,
              P,
              A,
              k;
            const M = yield (yield fetch(`./data/json/objects.json`)).text(),
              E = yield JSON.parse(M),
              I = Object.keys(E);
            for (let M = 0; M < I.length; M++) {
              const D = I[M],
                R = E[D],
                B = null !== (t = R.id) && void 0 !== t ? t : D,
                F = null !== (e = R.tags) && void 0 !== e ? e : new Array(),
                O = null !== (i = R.displayId) && void 0 !== i ? i : D,
                z = null !== (n = R.minDamage) && void 0 !== n ? n : 0,
                L = null !== (s = R.maxDamage) && void 0 !== s ? s : 0,
                H = null !== (r = R.minDamageOnDeath) && void 0 !== r ? r : 0,
                U = null !== (o = R.maxDamageOnDeath) && void 0 !== o ? o : 0,
                N = null !== (a = R.heal) && void 0 !== a ? a : 0,
                G = null !== (l = R.decreaseDamage) && void 0 !== l ? l : 0,
                V =
                  null !== (u = R.decreaseDamagePerTriggerCount) && void 0 !== u
                    ? u
                    : 0,
                j = null !== (h = R.triggerCooldownMs) && void 0 !== h ? h : 0,
                $ = null !== (c = R.delayMs) && void 0 !== c ? c : 0,
                q =
                  null !== (d = R.delayPerTriggerCount) && void 0 !== d ? d : 0,
                W = null !== (p = R.projectileCount) && void 0 !== p ? p : 1,
                X =
                  1e4 * +(null !== (f = R.ignoreDefense) && void 0 !== f && f),
                Y =
                  null !== (m = R.scalingStatType) && void 0 !== m
                    ? m
                    : Ee.None,
                K =
                  null !== (g = R.scalingStatThreshold) && void 0 !== g
                    ? g
                    : 50,
                Z =
                  null !== (v = R.scalingStatInterval) && void 0 !== v ? v : 0,
                Q =
                  null !== (y = R.scalingStatIncrease) && void 0 !== y ? y : 0,
                J = null === (x = R.mergeWithEquipment) || void 0 === x || x,
                tt = null !== (b = R.isSummon) && void 0 !== b && b,
                et =
                  null !== (S = R.subObjectPerTrigger) && void 0 !== S
                    ? S
                    : new Array(),
                it =
                  null !== (C = R.spawnObjectsPerTrigger) && void 0 !== C
                    ? C
                    : new Array(),
                nt =
                  null !== (_ = R.subObjectPerCast) && void 0 !== _
                    ? _
                    : new Array(),
                st = null === (T = R.destroyChildren) || void 0 === T || T,
                rt = null !== (w = R.lifetimeMs) && void 0 !== w ? w : 0,
                ot = !0,
                at = null !== (P = R.evolveId) && void 0 !== P ? P : "",
                lt =
                  null !== (A = R.evolveOnSpawn) && void 0 !== A
                    ? A
                    : new Array(),
                ut =
                  null !== (k = R.uniqueEvolveInstigator) && void 0 !== k && k,
                ht = new Array();
              if (void 0 !== R.statusEffectOnHit)
                for (let t = 0; t < R.statusEffectOnHit.length; t++)
                  this.parseStatusEffect(ht, R.statusEffectOnHit[t]);
              const ct = new Array();
              if (void 0 !== R.statusEffectAura)
                for (let t = 0; t < R.statusEffectAura.length; t++)
                  this.parseStatusEffect(ct, R.statusEffectAura[t]);
              const dt = Object.assign(Object.assign({}, R), {
                id: B,
                displayId: O,
                tags: F,
                heal: N,
                minDamage: z,
                maxDamage: L,
                minDamageOnDeath: H,
                maxDamageOnDeath: U,
                decreaseDamage: G,
                decreaseDamagePerTriggerCount: V,
                ignoreDefense: X,
                triggerCooldownMs: j,
                delayMs: $,
                delayPerTriggerCount: q,
                projectileCount: W,
                scalingStatType: Y,
                scalingStatThreshold: K,
                scalingStatInterval: Z,
                scalingStatIncrease: Q,
                mergeWithEquipment: J,
                isSummon: tt,
                subObjectPerTrigger: et,
                spawnObjectsPerTrigger: it,
                subObjectPerCast: nt,
                destroyChildren: st,
                lifetimeMs: rt,
                isAlive: ot,
                statusEffectOnHit: ht,
                statusEffectAura: ct,
                evolveId: at,
                evolveOnSpawn: lt,
                uniqueEvolveInstigator: ut,
              });
              this.objectsData.set(B, dt);
            }
            return Promise.resolve(!0);
          });
        }
        loadPetHealData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(`./data/json/pet.json`)).text(),
              e = yield JSON.parse(t);
            for (let t = 0; t <= 100; t++) {
              const i = {
                delay: e.delayValues[t],
                healValue: e.healValues[t],
                magicHealValue: e.magicHealValues[t],
              };
              this.petHealData.set(t, i);
            }
            return Promise.resolve(!0);
          });
        }
        parseStatusEffect(t, e) {
          var i;
          const n = {
            type: Ie[e.type],
            durationMs: Number(
              null !== (i = e.durationMs) && void 0 !== i ? i : 0
            ),
          };
          t.push(n);
        }
        getAttackHash(t, e) {
          return `${t.projectileCount},${t.arcGap},${Math.floor(
            100 * t.rateOfFire
          )},${this.getProjectileHash(e)}`;
        }
        getProjectileHash(t) {
          return `${t.minDamage},${t.maxDamage},${
            t.ignoreDefense
          },${+t.passObstacles},${+t.pierceTargets},${t.precalculatedRange.toFixed(
            2
          )}`;
        }
        getProcSourceName(t, e) {
          return "" + (void 0 !== t ? `${t}` : `${Ve.procLabel(e)} Proc`);
        }
        getObjectData(t) {
          for (let e of this.objectsData.values()) if (e.id == t) return e;
        }
        parseProjectileDataHelper(t, e) {
          var i, n, s, r, o, a, l, u, h, c, d, p, f;
          const m = new Array();
          if (void 0 !== t.ConditionEffect) {
            const e = Array.isArray(t.ConditionEffect)
              ? t.ConditionEffect
              : [t.ConditionEffect];
            for (let t = 0; t < e.length; t++) {
              const r = e[t],
                o = Number(
                  null !== (i = Ve.stringToStatusEffect(r.__text)) &&
                    void 0 !== i
                    ? i
                    : Ie.None
                ),
                a =
                  1e3 *
                  Number(null !== (n = r._duration) && void 0 !== n ? n : 0),
                l = Number(
                  null !== (s = r._bleedDamage) && void 0 !== s ? s : 0
                );
              m.push({ type: o, durationMs: a, value: l });
            }
          }
          const g = {
            index: e,
            objectId: null !== (r = t.ObjectId) && void 0 !== r ? r : "unknown",
            lifetimeMs: Number(
              null !== (o = t.LifetimeMS) && void 0 !== o ? o : 0
            ),
            speed: Number(null !== (a = t.Speed) && void 0 !== a ? a : 0),
            speedClamp: Number(
              null !== (l = t.SpeedClamp) && void 0 !== l ? l : 0
            ),
            acceleration: Number(
              null !== (u = t.Acceleration) && void 0 !== u ? u : 0
            ),
            accelerationDelayMs: Number(
              null !== (h = t.AccelerationDelay) && void 0 !== h ? h : 0
            ),
            circleTurnDelayMs: Number(
              null !== (c = t.CircleTurnDelay) && void 0 !== c ? c : 0
            ),
            circleTurnAngle: Number(
              null !== (d = t.CircleTurnAngle) && void 0 !== d ? d : 0
            ),
            boomerang: void 0 !== t.Boomerang,
            minDamage: Number(
              null !== (p = t.MinDamage) && void 0 !== p ? p : 0
            ),
            maxDamage: Number(
              null !== (f = t.MaxDamage) && void 0 !== f ? f : 0
            ),
            ignoreDefense: 1e4 * +(void 0 !== t.ArmorPiercing),
            pierceTargets: void 0 !== t.MultiHit,
            passObstacles: void 0 !== t.PassesCover,
            statusEffects: m,
          };
          return (g.precalculatedRange = Ve.calculateRange(g)), g;
        }
        parseProjectileData(t) {
          var e;
          const i = new Map();
          if (void 0 === t) return i;
          const n = Array.isArray(t) ? t : [t];
          for (let t = 0; t < n.length; t++) {
            const s = Number(null !== (e = n[t]._id) && void 0 !== e ? e : 0),
              r = this.parseProjectileDataHelper(n[t], s);
            i.set(s, r);
          }
          return i;
        }
        parseAttackDataHelper(t, e, i, n, s) {
          var r, o, a, l, u, h, c;
          return {
            projectile: (0, Ue.cloneDeep)(n.get(i)),
            projectileId: i,
            subAttackId: e,
            projectileCount: Number(
              null !== (r = t.NumProjectiles) && void 0 !== r ? r : 0
            ),
            rateOfFire: Number(
              null !==
                (a =
                  null !==
                    (o = Array.isArray(t.RateOfFire)
                      ? t.RateOfFire[t.RateOfFire.length - 1]
                      : t.RateOfFire) && void 0 !== o
                    ? o
                    : s) && void 0 !== a
                ? a
                : 1
            ),
            arcGap: Number(null !== (l = t.ArcGap) && void 0 !== l ? l : 0),
            burstMaxCount: Number(
              null !== (u = t.BurstCount) && void 0 !== u ? u : 0
            ),
            burstMinDelay: Number(
              null !== (h = t.BurstMinDelay) && void 0 !== h ? h : 0
            ),
            burstMaxDelay: Number(
              null !== (c = t.BurstDelay) && void 0 !== c ? c : 0
            ),
            mergeWithEquipment: !0,
          };
        }
        parseAttackData(t, e, i) {
          var n, s;
          const r = new Array();
          if (void 0 === t) return r;
          const o = Array.isArray(t) ? t : [t];
          for (let t = 0; t < o.length; t++) {
            const a = Number(
                null !== (n = o[t]._index) && void 0 !== n ? n : t
              ),
              l = Number(
                null !== (s = o[t]._projectileId) && void 0 !== s ? s : 0
              ),
              u = this.parseAttackDataHelper(o[t], a, l, e, i);
            r.push(u);
          }
          return r;
        }
        stripProcRequirements(t) {
          var e, i;
          const n = new Array();
          if (void 0 !== t._damageThreshold) {
            const e = Number(t._damageThreshold),
              i = { type: Ci.DamageThreshold, value: e };
            n.push(i);
          }
          if (void 0 !== t._hpMinThreshold) {
            const e = Number(t._hpMinThreshold),
              i = { type: Ci.HpThreshold, value: e };
            n.push(i);
          } else if (void 0 !== t._hpRequired) {
            const e = Number(t._hpRequired),
              i = { type: Ci.MinHpRequired, value: e };
            n.push(i);
          }
          if (void 0 !== t._hpMinThresholdRelative) {
            const e = Number(t._hpMinThresholdRelative),
              i = { type: Ci.HpThresholdRelative, value: e };
            n.push(i);
          } else if (void 0 !== t._hpRequiredRelative) {
            const e = Number(t._hpRequiredRelative),
              i = { type: Ci.MinHpRequiredRelative, value: e };
            n.push(i);
          }
          if (void 0 !== t._manaRequired || void 0 !== t._manaCost) {
            const s = Number(
              null !==
                (i =
                  null !== (e = t._manaRequired) && void 0 !== e
                    ? e
                    : t._manaCost) && void 0 !== i
                ? i
                : 0
            );
            if (0 != s) {
              const t = { type: Ci.MinMpRequired, value: s };
              n.push(t);
            }
          }
          if (void 0 !== t._requiredConditions) {
            const e = t._requiredConditions.split(";");
            for (let t = 0; t < e.length; t++) {
              const i = Ve.stringToStatusEffect(e[t]),
                s = { type: Ci.HasStatusEffect, value: i };
              n.push(s);
            }
          }
          if (void 0 !== t._mustWear) {
            const e = t._mustWear,
              i = { type: Ci.MustWearId, value: e };
            n.push(i);
          }
          if (void 0 !== t._mustNotWear) {
            const e = t._mustNotWear,
              i = { type: Ci.CannotWearId, value: e };
            n.push(i);
          }
          if (void 0 !== t._mustNotWearOR) {
            const e = t._mustNotWearOR,
              i = { type: Ci.OrCannotWearId, value: e };
            n.push(i);
          }
          if (void 0 !== t._onDashIndex) {
            const e = Number(t._onDashIndex),
              i = { type: Ci.ChargeIndex, value: e };
            n.push(i);
          }
          return n;
        }
        parseProcData(t, e, i) {
          var n,
            s,
            r,
            o,
            a,
            l,
            u,
            h,
            c,
            d,
            p,
            f,
            m,
            g,
            v,
            y,
            x,
            b,
            S,
            C,
            _,
            T,
            w,
            P,
            A,
            k;
          const M = Ve.procEffectType(t.__text),
            E = null !== (n = t._objectId) && void 0 !== n ? n : t._type,
            I =
              null === (s = this.getObjectData(E)) || void 0 === s
                ? void 0
                : s.displayId,
            D = this.getProcSourceName(I, M),
            R = Number(null !== (r = t._proc) && void 0 !== r ? r : 1),
            B = Math.round(
              1e3 * Number(null !== (o = t._cooldown) && void 0 !== o ? o : 0)
            ),
            F = this.stripProcRequirements(t);
          let O = !0;
          const z = {
            type: e,
            effectType: M,
            sourceName: D,
            chance: R,
            cooldownMs: B,
            requirements: F,
            manaCost: Number(
              null !== (a = t._manaCost) && void 0 !== a ? a : 0
            ),
          };
          switch (M) {
            case Fe.Magic: {
              const e = Number(
                  null !== (l = t._amount) && void 0 !== l ? l : 0
                ),
                n = "MP Recovery",
                s = Object.assign(Object.assign({}, z), {
                  sourceName: n,
                  amount: e,
                });
              i.push(s);
              break;
            }
            case Fe.StatusEffect: {
              const e = !(void 0 !== t._target && "enemy" == t._target),
                n = 1e3 * Number(t._duration),
                s = Ve.stringToStatusEffect(t._effect),
                r = void 0 === t._wisMod ? Ee.None : Ee.WIS,
                o = r >= 0 ? 50 : 0,
                a = `Status Effect: ${Ve.statusEffectToString(s)}`,
                l = Object.assign(Object.assign({}, z), {
                  isPlayerTarget: e,
                  statusEffectType: s,
                  durationMs: n,
                  sourceName: a,
                  scalingStatType: r,
                  scalingStatThreshold: o,
                });
              i.push(l);
              break;
            }
            case Fe.StatBoost: {
              const e = Number(
                  null !== (u = t._amount) && void 0 !== u ? u : 0
                ),
                n = Number(Ee[t._stat]),
                s = 1e3 * Number(t._duration),
                r = Number(Ve.stackType(t._channel)),
                o = `Stat ${e < 0 ? "Decrease" : "Increase"}: ${Ve.baseStatName(
                  n
                )}`;
              if (0 == e) break;
              const a = Object.assign(Object.assign({}, z), {
                amount: e,
                statType: n,
                durationMs: s,
                stackType: r,
                sourceName: o,
              });
              i.push(a);
              break;
            }
            case Fe.Projectile: {
              const n = Number(null !== (h = t._type) && void 0 !== h ? h : 0),
                s = Number(null !== (c = t._numShots) && void 0 !== c ? c : 1);
              let r = !1;
              for (let t = 0; t < i.length; t++)
                if (i[t].type == e && i[t].effectType == M) {
                  const e = i[t];
                  let o = !0;
                  if (F.length != i[t].requirements.length) o = !1;
                  else
                    for (let e = 0; e < F.length; e++)
                      if (
                        F[e].type != i[t].requirements[e].type ||
                        F[e].value != i[t].requirements[e].value
                      ) {
                        o = !1;
                        break;
                      }
                  if (1 == o && e.projectileId == n) {
                    (e.projectileCount += s), (r = !0);
                    break;
                  }
                }
              if (1 == r) break;
              const o = this.getObjectData(E);
              if (void 0 === o) {
                O = !1;
                break;
              }
              const a = {
                minDamage: o.minDamage,
                maxDamage: o.maxDamage,
                ignoreDefense: o.ignoreDefense,
              };
              if (void 0 === a) break;
              const l =
                  null === (d = null == o ? void 0 : o.mergeWithEquipment) ||
                  void 0 === d ||
                  d,
                u =
                  null !== (p = null == o ? void 0 : o.displayId) &&
                  void 0 !== p
                    ? p
                    : "Projectiles",
                f = Object.assign(Object.assign({}, z), {
                  sourceName: u,
                  projectileId: n,
                  projectile: a,
                  projectileCount: s,
                  mergeWithEquipment: l,
                });
              i.push(f);
              break;
            }
            case Fe.Minion: {
              const e = t._objectId,
                n = this.objectsData.get(e);
              if (void 0 === n) break;
              const s =
                  "Summon" + (void 0 === n.displayId ? "" : ` ${n.displayId}`),
                r = Object.assign(Object.assign(Object.assign({}, n), z), {
                  sourceName: s,
                  objectId: e,
                });
              i.push(r);
              break;
            }
            case Fe.PoisonGrenade: {
              const e = Number(
                  null !== (f = t._totalDamage) && void 0 !== f ? f : 0
                ),
                n = Number(
                  null !== (m = t._impactDamage) && void 0 !== m ? m : 0
                ),
                s = Number(null !== (g = t._duration) && void 0 !== g ? g : 0),
                r = Number(
                  Ee[null !== (v = t._scalingStat) && void 0 !== v ? v : "None"]
                ),
                o = Number(
                  null !== (y = t._statModScalingMin) && void 0 !== y ? y : 0
                ),
                a =
                  0.1 *
                  Number(
                    null !== (x = t._statModDamage) && void 0 !== x ? x : 0
                  ),
                l =
                  0.1 *
                  Number(
                    null !== (b = t._statModImpactDamage) && void 0 !== b
                      ? b
                      : 0
                  ),
                u = Number(
                  null !== (S = t._damageBoost) && void 0 !== S ? S : 0
                ),
                h = Number(
                  null !== (C = t._statModDamageBoost) && void 0 !== C ? C : 0
                );
              if (0 != u || 0 != h) {
                const t = Object.assign(Object.assign({}, z), {
                  effectType: Fe.StatBoost,
                  sourceName: `Damage Boost (${Ve.baseStatName(r)} Scaling)`,
                  statType: Ee.DMGBOOST,
                  stackType: Be.MaxStack,
                  amount: u,
                  durationMs: 1e3 * s,
                  scalingStatType: r,
                  scalingStatThreshold: o,
                  scalingStatIncrease: h,
                  mergeWithEquipment: !1,
                });
                i.push(t);
              }
              if (0 == t._numShots) break;
              if (0 != n) {
                const t = Object.assign(Object.assign({}, z), {
                  effectType: Fe.Projectile,
                  sourceName: `Impact (${Ve.baseStatName(r)} Scaling)`,
                  projectile: {
                    minDamage: n,
                    maxDamage: n,
                    ignoreDefense: 1e4,
                  },
                  projectileCount: 1,
                  scalingStatType: r,
                  scalingStatThreshold: 50,
                  scalingStatInterval: 1,
                  scalingStatIncrease: l,
                  affectedByStatusEffects: !1,
                  mergeWithEquipment: !0,
                });
                i.push(t);
              }
              const c = Math.max(e - n, 0);
              if (0 == c) break;
              const d = Object.assign(Object.assign({}, z), {
                effectType: Fe.DamageOverTime,
                sourceName: `Poison (${Ve.baseStatName(r)} Scaling)`,
                damage: c,
                durationMs: 1e3 * s,
                scalingStatType: r,
                scalingStatThreshold: o,
                scalingStatInterval: 1,
                scalingStatIncrease: a,
                mergeWithEquipment: !0,
              });
              i.push(d);
              break;
            }
            case Fe.Trap: {
              const e = Number(
                  null !== (_ = t._totalDamage) && void 0 !== _ ? _ : 0
                ),
                n =
                  (Number(null !== (T = t._throwTime) && void 0 !== T ? T : 1),
                  Number(null !== (w = t._duration) && void 0 !== w ? w : 0),
                  Number(null !== (P = t._radius) && void 0 !== P ? P : 0),
                  Number(
                    null !== (A = t._sensitivity) && void 0 !== A ? A : 0.5
                  ),
                  this.createStatusEffectHelper(t._condEffect, t._condDuration),
                  1e4 *
                    +Boolean(
                      null !== (k = t._armorPierce) && void 0 !== k && k
                    )),
                s = t._objectId,
                r = this.getProcSourceName(s, Fe.Projectile),
                o = Object.assign(Object.assign({}, z), {
                  effectType: Fe.Projectile,
                  sourceName: r,
                  mergeWithEquipment: !0,
                  projectile: { minDamage: e, maxDamage: e, ignoreDefense: n },
                  projectileCount: 1,
                });
              i.push(o);
              break;
            }
          }
          return O;
        }
        parseEnchantmentOnHitProcs(t) {
          const e = Array.isArray(t) ? t : [t],
            i = new Array();
          let n = !0;
          for (let t = 0; t < e.length; t++) {
            const s = e[t];
            this.parseProcData(s, Si.OnPlayerHit, i) || (n = !1);
          }
          return [n, i];
        }
        parseEquipmentProcData(t, e, i) {
          const n = new Array();
          for (let i = 0; i < t.length; i++) {
            const s = t[i];
            this.parseProcData(s, e, n);
          }
          const s = Ve.slotMetaType(i.slotType);
          for (let t = 0; t < n.length; t++) {
            n[t].sourceSlot = s;
          }
          return n;
        }
        parseTextureData(t) {
          var e, i, n, s;
          return {
            fileName:
              null !== (e = null == t ? void 0 : t.File) && void 0 !== e
                ? e
                : "unknown",
            index: Number(
              null !== (i = null == t ? void 0 : t.Index) && void 0 !== i
                ? i
                : 0
            ),
            offsetX:
              0.25 *
              Number(
                null !== (n = null == t ? void 0 : t._xOffset) && void 0 !== n
                  ? n
                  : 0
              ),
            offsetY:
              0.25 *
              Number(
                null !== (s = null == t ? void 0 : t._yOffset) && void 0 !== s
                  ? s
                  : 0
              ),
          };
        }
        createStatusEffectHelper(t, e) {
          return (
            "Armor Broken" == t && (t = "ArmorBroken"),
            {
              type: Number(Ie[null != t ? t : "None"]),
              durationMs: 1e3 * Number(null != e ? e : 0),
            }
          );
        }
        getStaticTextureCoordsData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(
                `./data/json/staticTextureAtlas.json`
              )).text(),
              e = yield JSON.parse(t);
            yield e.forEach((t) =>
              Ui(this, void 0, void 0, function* () {
                var e;
                const i = t.s,
                  n = t.i,
                  s = Number(t.x),
                  r = Number(t.y),
                  o = Number(t.w),
                  a = Number(t.h),
                  l =
                    null !== (e = this.staticTextureAtlasCoordsData.get(i)) &&
                    void 0 !== e
                      ? e
                      : new Map(),
                  u = { x: s, y: r, width: o, height: a };
                l.set(n, u), this.staticTextureAtlasCoordsData.set(i, l);
              })
            );
          });
        }
        getAnimatedTextureCoordsData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(
                `./data/json/charactersTextureAtlas.json`
              )).text(),
              e = yield JSON.parse(t);
            yield e.forEach((t) =>
              Ui(this, void 0, void 0, function* () {
                var e;
                const i = t.s,
                  n = t.i,
                  s = new Array();
                for (const e of t.f) {
                  const t = {
                    action: Number(e.a),
                    direction: Number(e.d),
                    coords: {
                      x: Number(e.x),
                      y: Number(e.y),
                      width: Number(e.w),
                      height: Number(e.h),
                    },
                  };
                  s.push(t);
                }
                const r =
                  null !== (e = this.animatedTextureCoordsData.get(i)) &&
                  void 0 !== e
                    ? e
                    : new Map();
                r.set(n, s), this.animatedTextureCoordsData.set(i, r);
              })
            );
          });
        }
        getTextureHelper(t) {
          return Ui(this, void 0, void 0, function* () {
            const e = (yield this.app.ui.getTexture("rotmg/staticTextureAtlas"))
                .source,
              i = new a.g({ source: e, frame: t });
            return Promise.resolve(i);
          });
        }
        getTextureCoords(t) {
          var e;
          return void 0 === t
            ? { x: 0, y: 0, width: 0, height: 0 }
            : null ===
                (e = this.staticTextureAtlasCoordsData.get(t.fileName)) ||
              void 0 === e
            ? void 0
            : e.get(t.index);
        }
        getAnimatedTextureData(t, e) {
          var i, n;
          return null !==
            (n =
              null === (i = this.animatedTextureCoordsData.get(t)) ||
              void 0 === i
                ? void 0
                : i.get(e)) && void 0 !== n
            ? n
            : new Array();
        }
        getStaticTexture(t) {
          return Ui(this, void 0, void 0, function* () {
            const e = { x: 0, y: 0, width: 0, height: 0 };
            if (void 0 === t) return Promise.resolve(this.getTextureHelper(e));
            const i = this.staticTextureAtlasCoordsData.get(t.fileName);
            if (void 0 === i) return Promise.resolve(this.getTextureHelper(e));
            const n = i.get(t.index);
            return void 0 === n
              ? Promise.resolve(this.getTextureHelper(e))
              : Promise.resolve(this.getTextureHelper(n));
          });
        }
        getClass(t) {
          return this.classesData.get(t);
        }
        getPetHeal(t, e) {
          const i = this.petHealData.get(t);
          if (void 0 === i) return [0, 0];
          return [i.healValue, i.delay + 2 * +e];
        }
        getPetMagicHeal(t, e) {
          const i = this.petHealData.get(t);
          if (void 0 === i) return [0, 0];
          return [i.magicHealValue, i.delay + 2 * +e];
        }
        getEnemyData(t) {
          return Ui(this, void 0, void 0, function* () {
            var e;
            const i =
              null !== (e = this.enemiesData.get(t)) && void 0 !== e
                ? e
                : {
                    name: "Enemy",
                    hitpoints: 1e4,
                    defense: 0,
                    statusEffectImmunities: new Array(),
                  };
            return Promise.resolve(i);
          });
        }
        getEquipmentData(t, e) {
          return Ui(this, void 0, void 0, function* () {
            const i = this.equipmentData.get(e);
            if (void 0 === i) return Promise.resolve(void 0);
            const n = i.get(t);
            return Promise.resolve(n);
          });
        }
        statsOnEquip(t) {
          return Ui(this, void 0, void 0, function* () {
            var e, i;
            const n = new Array();
            t = Array.isArray(t) ? t : [t];
            for (let s = 0; s < t.length; s++) {
              const r = t[s];
              if (void 0 !== r)
                switch (r.__text) {
                  case "AbilityUseDiscount": {
                    const t = {
                      type: Ee.MPMULTIPLIER,
                      value: Number(
                        null !== (e = r._multiplier) && void 0 !== e ? e : 1
                      ),
                      relativeTo: Ee.None,
                    };
                    n.push(t);
                    break;
                  }
                  case "IncrementStat":
                  case "IncrementStatRelative": {
                    const t = {
                      type: Number(Ee[r._stat]),
                      value: Number(r._amount),
                      relativeTo: Number(
                        null !== (i = Ee[r._statRelativeTo]) && void 0 !== i
                          ? i
                          : Ee.None
                      ),
                    };
                    n.push(t);
                    break;
                  }
                }
            }
            return Promise.resolve(n);
          });
        }
        getProjectileFromObject(t) {
          var e;
          const i = this.getObjectData(t);
          if (void 0 === i) return;
          return {
            minDamage: i.minDamage,
            maxDamage: i.maxDamage,
            ignoreDefense:
              1e4 * +(null !== (e = i.ignoreDefense) && void 0 !== e && e),
          };
        }
        parseTooltipData(t) {
          var e, i;
          const n = new Array();
          if (void 0 === t) return n;
          const s = Array.isArray(t.EffectInfo) ? t.EffectInfo : [t.EffectInfo];
          for (let t = 0; t < s.length; t++) {
            let r = null !== (e = s[t]._name) && void 0 !== e ? e : "";
            if ("Effect on Self:" == r) continue;
            const o = null !== (i = s[t]._description) && void 0 !== i ? i : "";
            (0 == r.length && 0 == o.length) ||
              (0 != r.length && ":" != r[r.length - 1] && (r += ":"),
              n.push({ name: r, description: o }));
          }
          return n;
        }
        parseAbilityStripActivateHelper(t, e, i, n) {
          var s,
            r,
            o,
            a,
            l,
            u,
            h,
            c,
            d,
            p,
            f,
            m,
            g,
            v,
            y,
            x,
            b,
            S,
            C,
            _,
            T,
            w,
            P,
            A,
            k,
            M,
            E,
            I,
            D,
            R,
            B,
            F,
            O,
            z,
            L,
            H,
            U,
            N,
            G,
            V,
            j,
            $,
            q,
            W,
            X,
            Y,
            K,
            Z,
            Q,
            J,
            tt,
            et,
            it,
            nt,
            st,
            rt,
            ot,
            at,
            lt,
            ut,
            ht,
            ct,
            dt,
            pt,
            ft,
            mt,
            gt,
            vt,
            yt,
            xt,
            bt,
            St,
            Ct,
            _t,
            Tt,
            wt,
            Pt,
            At,
            kt,
            Mt,
            Et,
            It,
            Dt,
            Rt,
            Bt,
            Ft,
            Ot,
            zt,
            Lt,
            Ht,
            Ut,
            Nt,
            Gt,
            Vt,
            jt,
            $t,
            qt,
            Wt,
            Xt,
            Yt;
          const Kt = Array.isArray(t.Activate) ? t.Activate : [t.Activate],
            Zt = i.onUse,
            Qt = i.procs;
          for (let t = 0; t < Kt.length; t++) {
            const Jt = Kt[t];
            if (void 0 === Jt) continue;
            const te = Number(
              null !==
                (o =
                  Ri[
                    null !==
                      (r = null !== (s = Jt.__text) && void 0 !== s ? s : Jt) &&
                    void 0 !== r
                      ? r
                      : "None"
                  ]) && void 0 !== o
                ? o
                : Ri.None
            );
            let ee = {};
            const ie = Number(null !== (a = Jt._proc) && void 0 !== a ? a : 1),
              ne = this.stripProcRequirements(Jt),
              se = Number(null !== (l = Jt._manaCost) && void 0 !== l ? l : 0),
              re = {
                type: n,
                sourceSlot: Ve.slotMetaType(e.slotType),
                chance: ie,
                cooldownMs: 0,
                mergeWithEquipment: !0,
                requirements: ne,
                manaCost: se,
              };
            switch (te) {
              case Ri.StatBoostSelf: {
                ee = {
                  statType: Number(
                    Ee[null !== (u = Jt._stat) && void 0 !== u ? u : "None"]
                  ),
                  amount: Number(
                    null !== (h = Jt._amount) && void 0 !== h ? h : 0
                  ),
                  duration: Number(
                    null !== (c = Jt._duration) && void 0 !== c ? c : 0
                  ),
                  scalingStatType: Number(
                    Ee[
                      null !== (d = Jt._scalingStat) && void 0 !== d
                        ? d
                        : "None"
                    ]
                  ),
                  scalingStatThreshold: Number(
                    null !== (p = Jt._wisMin) && void 0 !== p ? p : 0
                  ),
                  scalingStatIncrease: Number(
                    null !== (f = Jt._wisAmountBase) && void 0 !== f ? f : 0
                  ),
                };
                const t = ee.amount;
                if (0 == t) break;
                const e = ee.statType,
                  i = Fe.StatBoost,
                  n = Ve.stackType(Jt._channel),
                  s = `Stat ${
                    t < 0 ? "Decrease" : "Increase"
                  }: ${Ve.baseStatName(e)}`,
                  r = 1e3 * ee.duration,
                  o = ee.scalingStatType,
                  a = ee.scalingStatThreshold,
                  l = ee.scalingStatIncrease,
                  m = Object.assign(Object.assign({}, re), {
                    statType: e,
                    effectType: i,
                    stackType: n,
                    sourceName: s,
                    durationMs: r,
                    amount: t,
                    scalingStatType: o,
                    scalingStatThreshold: a,
                    scalingStatIncrease: l,
                  });
                Qt.push(m);
                break;
              }
              case Ri.StatBoostAura: {
                ee = {
                  statType: Number(
                    Ee[null !== (m = Jt._stat) && void 0 !== m ? m : "None"]
                  ),
                  amount: Number(
                    null !== (g = Jt._amount) && void 0 !== g ? g : 0
                  ),
                  duration: Number(
                    null !== (v = Jt._duration) && void 0 !== v ? v : 0
                  ),
                  range: Number(
                    null !== (y = null == Jt ? void 0 : Jt._range) &&
                      void 0 !== y
                      ? y
                      : 0
                  ),
                  scalingStatType: Number(
                    Ee[
                      null !== (x = Jt._scalingStat) && void 0 !== x ? x : "WIS"
                    ]
                  ),
                  scalingStatThreshold: Number(
                    null !== (b = Jt._wisMin) && void 0 !== b ? b : 0
                  ),
                  scalingStatIncrease: Number(
                    null !== (S = Jt._wisAmountBase) && void 0 !== S ? S : 0
                  ),
                };
                const t = ee.amount;
                if (0 == t) break;
                const e = ee.statType,
                  i = Fe.StatBoost,
                  n = Ve.stackType(Jt._channel),
                  s = `Stat ${
                    t < 0 ? "Decrease" : "Increase"
                  }: ${Ve.baseStatName(e)}`,
                  r = 1e3 * ee.duration,
                  o = ee.scalingStatType,
                  a = ee.scalingStatThreshold,
                  l = ee.scalingStatIncrease,
                  u = Object.assign(Object.assign({}, re), {
                    statType: e,
                    effectType: i,
                    stackType: n,
                    sourceName: s,
                    durationMs: r,
                    amount: t,
                    scalingStatType: o,
                    scalingStatThreshold: a,
                    scalingStatIncrease: l,
                  });
                Qt.push(u);
                break;
              }
              case Ri.ConditionEffectSelf: {
                ee = {
                  statusEffectType: Number(
                    Ie[null !== (C = Jt._effect) && void 0 !== C ? C : "None"]
                  ),
                  duration: Number(
                    null !== (_ = Jt._duration) && void 0 !== _ ? _ : 0
                  ),
                  scalingStatType: Number(
                    Ee[
                      (
                        null !== (T = Jt._scalingStat) && void 0 !== T
                          ? T
                          : void 0 !== Jt._wisMin
                      )
                        ? "WIS"
                        : "None"
                    ]
                  ),
                  scalingStatDurationBase: Number(
                    null !== (w = Jt._wisDurationBase) && void 0 !== w ? w : 1
                  ),
                  scalingStatThreshold: Number(
                    null !== (P = Jt._wisMin) && void 0 !== P ? P : 0
                  ),
                };
                const t = !0,
                  e = Fe.StatusEffect,
                  i = ee.statusEffectType,
                  n = `Status Effect: ${Ve.statusEffectToString(i)}`,
                  s = 1e3 * ee.duration,
                  r = ee.scalingStatThreshold,
                  o = ee.scalingStatType,
                  a = 1e3 * ee.scalingStatDurationBase,
                  l = Object.assign(Object.assign({}, re), {
                    isPlayerTarget: t,
                    effectType: e,
                    statusEffectType: i,
                    durationMs: s,
                    sourceName: n,
                    scalingStatType: o,
                    scalingStatThreshold: r,
                    scalingStatDurationMs: a,
                  });
                Qt.push(l);
                break;
              }
              case Ri.ConditionEffectAura: {
                ee = {
                  statusEffectType: Number(
                    Ie[null !== (A = Jt._effect) && void 0 !== A ? A : "None"]
                  ),
                  duration: Number(
                    null !== (k = Jt._duration) && void 0 !== k ? k : 0
                  ),
                  range: Number(
                    null !== (M = Jt._range) && void 0 !== M ? M : 0
                  ),
                  scalingStatType: Number(
                    Ee[
                      (
                        null !== (E = Jt._scalingStat) && void 0 !== E
                          ? E
                          : void 0 !== Jt._wisMin
                      )
                        ? "WIS"
                        : "None"
                    ]
                  ),
                  scalingStatDurationBase: Number(
                    null !== (I = Jt._wisDurationBase) && void 0 !== I ? I : 1
                  ),
                  scalingStatThreshold: Number(
                    null !== (D = Jt._wisMin) && void 0 !== D ? D : 0
                  ),
                };
                const t = !0,
                  e = Fe.StatusEffect,
                  i = ee.statusEffectType,
                  n = `Status Effect: ${Ve.statusEffectToString(i)}`,
                  s = 1e3 * ee.duration,
                  r = ee.scalingStatThreshold,
                  o = ee.scalingStatType,
                  a = 1e3 * ee.scalingStatDurationBase,
                  l = Object.assign(Object.assign({}, re), {
                    isPlayerTarget: t,
                    effectType: e,
                    statusEffectType: i,
                    durationMs: s,
                    sourceName: n,
                    scalingStatType: o,
                    scalingStatThreshold: r,
                    scalingStatDurationMs: a,
                  });
                Qt.push(l);
                break;
              }
              case Ri.HealNova:
                if (
                  ((ee = {
                    amount: Number(
                      null !== (R = Jt._amount) && void 0 !== R ? R : 0
                    ),
                    range: Number(
                      null !== (B = Jt._range) && void 0 !== B ? B : 0
                    ),
                    damage: Number(
                      null !== (F = Jt._damage) && void 0 !== F ? F : 0
                    ),
                    splitHeal: Boolean(
                      null !== (O = Jt._splitHealing) && void 0 !== O && O
                    ),
                    scalingStatType: Number(
                      Ee[
                        null !== (z = Jt._scalingStat) && void 0 !== z
                          ? z
                          : "WIS"
                      ]
                    ),
                    scalingStatBaseHeal: Number(
                      null !== (L = Jt._wisHealBase) && void 0 !== L ? L : 0
                    ),
                    scalingStatBaseDamage: Number(
                      null !== (H = Jt._wisDamageBase) && void 0 !== H ? H : 0
                    ),
                    scalingStatThreshold: Number(
                      null !== (U = Jt._wisMin) && void 0 !== U ? U : 0
                    ),
                  }),
                  0 != ee.damage)
                ) {
                  const t = ee.damage,
                    e = Object.assign(Object.assign({}, re), {
                      effectType: Fe.Projectile,
                      sourceName: `Area Damage (${Ve.baseStatName(
                        ee.scalingStatType
                      )} Scaling)`,
                      projectile: {
                        minDamage: t,
                        maxDamage: t,
                        ignoreDefense: 0,
                      },
                      projectileCount: 1,
                      scalingStatType: ee.scalingStatType,
                      scalingStatInterval: 10,
                      scalingStatIncrease: ee.scalingStatBaseDamage,
                      scalingStatThreshold: ee.scalingStatThreshold,
                      affectedByStatusEffects: !1,
                      mergeWithEquipment: !0,
                    });
                  Qt.push(e);
                }
                if (0 != ee.amount) {
                  const t = Object.assign(Object.assign({}, re), {
                    effectType: Fe.Heal,
                    sourceName: `Heal (${Ve.baseStatName(
                      ee.scalingStatType
                    )} Scaling)`,
                    amount: ee.amount,
                    scalingStatType: ee.scalingStatType,
                    scalingStatIncrease: ee.scalingStatBaseHeal,
                    scalingStatThreshold: ee.scalingStatThreshold,
                  });
                  Qt.push(t);
                }
                break;
              case Ri.PoisonGrenade: {
                if (
                  ((ee = {
                    totalDamage: Number(
                      null !== (N = Jt._totalDamage) && void 0 !== N ? N : 0
                    ),
                    impactDamage: Number(
                      null !== (G = Jt._impactDamage) && void 0 !== G ? G : 0
                    ),
                    throwTime: Number(
                      null !== (V = Jt._throwTime) && void 0 !== V ? V : 0
                    ),
                    duration: Number(
                      null !== (j = Jt._duration) && void 0 !== j ? j : 0
                    ),
                    radius: Number(
                      null !== ($ = Jt._radius) && void 0 !== $ ? $ : 0
                    ),
                    damageBoost:
                      Number(
                        null !== (q = Jt._damageBoost) && void 0 !== q ? q : 1
                      ) - 1,
                    scalingStatType: Number(
                      Ee[
                        null !== (W = Jt._scalingStat) && void 0 !== W
                          ? W
                          : "WIS"
                      ]
                    ),
                    scalingStatThreshold: Number(
                      null !== (X = Jt._statModScalingMin) && void 0 !== X
                        ? X
                        : 0
                    ),
                    scalingStatTotalDamage:
                      0.1 *
                      Number(
                        null !== (Y = Jt._statModDamage) && void 0 !== Y ? Y : 0
                      ),
                    scalingStatImpactDamage:
                      0.1 *
                      Number(
                        null !== (K = Jt._statModImpactDamage) && void 0 !== K
                          ? K
                          : 0
                      ),
                    scalingStatRadius: Number(
                      null !== (Z = Jt._statModRadius) && void 0 !== Z ? Z : 0
                    ),
                    scalingStatDamageBoost: Number(
                      null !== (Q = Jt._statModDamageBoost) && void 0 !== Q
                        ? Q
                        : 0
                    ),
                    statusEffect: this.createStatusEffectHelper(
                      Jt._condEffect,
                      Jt._condDuration
                    ),
                  }),
                  0 == Jt._numShots)
                )
                  break;
                if (0 != ee.damageBoost || 0 != ee.scalingStatDamageBoost) {
                  const t = Object.assign(Object.assign({}, re), {
                    effectType: Fe.StatBoost,
                    sourceName: `Damage Boost (${Ve.baseStatName(
                      ee.scalingStatType
                    )} Scaling)`,
                    statType: Ee.DMGBOOST,
                    stackType: Be.MaxStack,
                    amount: ee.damageBoost,
                    durationMs: 1e3 * ee.duration,
                    scalingStatType: ee.scalingStatType,
                    scalingStatThreshold: ee.scalingStatThreshold,
                    scalingStatIncrease: ee.scalingStatDamageBoost,
                    mergeWithEquipment: !1,
                  });
                  Qt.push(t);
                }
                if (0 != ee.statusEffect.type) {
                  const t = new Array(ee.statusEffect),
                    e = Object.assign(Object.assign({}, re), {
                      effectType: Fe.Projectile,
                      sourceName: `Impact (${Ve.baseStatName(
                        ee.scalingStatType
                      )} Scaling)`,
                      projectile: {
                        minDamage: 0,
                        maxDamage: 0,
                        ignoreDefense: 0,
                        statusEffects: t,
                      },
                      projectileCount: 1,
                      affectedByStatusEffects: !1,
                      mergeWithEquipment: !1,
                    });
                  Qt.push(e);
                }
                if (0 != ee.impactDamage) {
                  const t = Object.assign(Object.assign({}, re), {
                    effectType: Fe.Projectile,
                    sourceName: `Impact (${Ve.baseStatName(
                      ee.scalingStatType
                    )} Scaling)`,
                    projectile: {
                      minDamage: ee.impactDamage,
                      maxDamage: ee.impactDamage,
                      ignoreDefense: 1e4,
                    },
                    projectileCount: 1,
                    scalingStatType: ee.scalingStatType,
                    scalingStatThreshold: ee.scalingStatThreshold,
                    scalingStatInterval: 1,
                    scalingStatIncrease: ee.scalingStatImpactDamage,
                    affectedByStatusEffects: !1,
                    mergeWithEquipment: !1,
                  });
                  Qt.push(t);
                }
                const t = Math.max(ee.totalDamage - ee.impactDamage, 0);
                if (0 == t) break;
                const e = Object.assign(Object.assign({}, re), {
                  effectType: Fe.DamageOverTime,
                  sourceName: `Poison (${Ve.baseStatName(
                    ee.scalingStatType
                  )} Scaling)`,
                  damage: t,
                  durationMs: 1e3 * ee.duration,
                  scalingStatType: ee.scalingStatType,
                  scalingStatThreshold: ee.scalingStatThreshold,
                  scalingStatInterval: 1,
                  scalingStatIncrease: Math.max(
                    ee.scalingStatTotalDamage - ee.scalingStatImpactDamage,
                    0
                  ),
                  mergeWithEquipment: !1,
                });
                Qt.push(e);
                break;
              }
              case Ri.VampireBlast:
                {
                  ee = {
                    damage: Number(
                      null !== (J = Jt._totalDamage) && void 0 !== J ? J : 0
                    ),
                    ignoreDefense: Number(
                      null !== (tt = Jt._ignoreDef) && void 0 !== tt ? tt : 0
                    ),
                    heal: Number(
                      null !== (et = Jt._heal) && void 0 !== et ? et : 0
                    ),
                    radius: Number(
                      null !== (it = Jt._radius) && void 0 !== it ? it : 0
                    ),
                    healRange: Number(
                      null !== (nt = Jt._healRange) && void 0 !== nt ? nt : 0
                    ),
                    scalingStatType: Number(
                      Ee[
                        null !== (st = Jt._scalingStat) && void 0 !== st
                          ? st
                          : "WIS"
                      ]
                    ),
                    scalingStatThreshold: Number(
                      null !== (rt = Jt._wisMin) && void 0 !== rt ? rt : 50
                    ),
                    scalingStatIncrease: Number(
                      null !== (ot = Jt._wisDamageBase) && void 0 !== ot
                        ? ot
                        : 0
                    ),
                    statusEffect: this.createStatusEffectHelper(
                      Jt._condEffect,
                      Jt._condDuration
                    ),
                  };
                  const t = this.getProcSourceName("Life Leech", Fe.Projectile),
                    e = Object.assign(Object.assign({}, re), {
                      effectType: Fe.Projectile,
                      sourceName: t,
                      projectile: {
                        minDamage: ee.damage,
                        maxDamage: ee.damage,
                        ignoreDefense: ee.ignoreDefense,
                      },
                      projectileCount: 1,
                      stealHp: ee.heal,
                      scalingStatType: ee.scalingStatType,
                      scalingStatThreshold: ee.scalingStatThreshold,
                      scalingStatInterval: 10,
                      scalingStatIncrease: ee.scalingStatIncrease,
                    });
                  Qt.push(e);
                }
                break;
              case Ri.Trap:
                {
                  ee = {
                    damage: Number(
                      null !== (at = Jt._totalDamage) && void 0 !== at ? at : 0
                    ),
                    throwTime: Number(
                      null !== (lt = Jt._throwTime) && void 0 !== lt ? lt : 1
                    ),
                    duration: Number(
                      null !== (ut = Jt._duration) && void 0 !== ut ? ut : 0
                    ),
                    radius: Number(
                      null !== (ht = Jt._radius) && void 0 !== ht ? ht : 0
                    ),
                    sensitivity: Number(
                      null !== (ct = Jt._sensitivity) && void 0 !== ct
                        ? ct
                        : 0.5
                    ),
                    statusEffect: this.createStatusEffectHelper(
                      Jt._condEffect,
                      Jt._condDuration
                    ),
                    ignoreDefense:
                      1e4 *
                      +Boolean(
                        null !== (dt = Jt._armorPierce) && void 0 !== dt && dt
                      ),
                  };
                  const t = Jt._objectId,
                    e = this.getProcSourceName(t, Fe.Projectile),
                    i = Object.assign(Object.assign({}, re), {
                      effectType: Fe.Projectile,
                      sourceName: e,
                      mergeWithEquipment: !0,
                      projectile: {
                        minDamage: ee.damage,
                        maxDamage: ee.damage,
                        ignoreDefense: ee.ignoreDefense,
                      },
                      projectileCount: 1,
                    });
                  Qt.push(i);
                }
                break;
              case Ri.Lightning: {
                const t = Number(
                  null !== (pt = Jt._aoeActivationCount) && void 0 !== pt
                    ? pt
                    : 0
                );
                ee = {
                  lightningDamage: Number(
                    null !== (ft = Jt._totalDamage) && void 0 !== ft ? ft : 0
                  ),
                  lightningDamagePerTargetChange: -Number(
                    null !== (mt = Jt._decrDamage) && void 0 !== mt ? mt : 0
                  ),
                  lightningMaxTargets: Number(
                    null !== (gt = Jt._maxTargets) && void 0 !== gt ? gt : 0
                  ),
                  lightningScalingStatDamage:
                    0.1 *
                    Number(
                      null !== (vt = Jt._wisDamageBase) && void 0 !== vt
                        ? vt
                        : 0
                    ),
                  lightningScalingStatMaxTargets: Number(
                    null !== (yt = Jt._wisPerTarget) && void 0 !== yt ? yt : 10
                  ),
                  lightningScalingStatType: Ee.WIS,
                  lightningScalingStatThreshold: Number(
                    null !== (xt = Jt._wisMin) && void 0 !== xt ? xt : 50
                  ),
                  shockblastDamage: Number(
                    null !== (bt = Jt._aoeDamage) && void 0 !== bt ? bt : 0
                  ),
                  shockblastTriggerTimes: t,
                  shockblastCooldown:
                    Number(
                      null !== (St = Jt._aoeTime) && void 0 !== St ? St : 1
                    ) / t,
                  shockblastMaxTargets: Number(
                    null !== (Ct = Jt._aoeMaxTargets) && void 0 !== Ct ? Ct : 0
                  ),
                  shockblastRadius: Number(
                    null !== (_t = Jt._aoeRange) && void 0 !== _t ? _t : 0
                  ),
                  shockblastScalingStatDamage:
                    0.1 *
                    Number(
                      null !== (Tt = Jt._statModDamage) && void 0 !== Tt
                        ? Tt
                        : 0
                    ),
                  shockblastScalingStatRadius: Number(
                    null !== (wt = Jt._statModRadius) && void 0 !== wt ? wt : 0
                  ),
                  shockblastScalingStatMaxTargets: Number(
                    null !== (Pt = Jt._statModPerTarget) && void 0 !== Pt
                      ? Pt
                      : 0
                  ),
                  shockblastScalingStatType: Number(
                    Ee[
                      null !== (At = Jt._scalingStat) && void 0 !== At
                        ? At
                        : "WIS"
                    ]
                  ),
                  shockblastScalingStatThreshold: Number(
                    null !== (kt = Jt._statModScalingMin) && void 0 !== kt
                      ? kt
                      : 0
                  ),
                  statusEffect: this.createStatusEffectHelper(
                    Jt._condEffect,
                    Jt._condDuration
                  ),
                };
                const e = Object.assign(Object.assign({}, re), {
                  effectType: Fe.Projectile,
                  sourceName: `Lightning (${Ve.baseStatName(
                    ee.lightningScalingStatType
                  )} Scaling)`,
                  projectile: {
                    minDamage: ee.lightningDamage,
                    maxDamage: ee.lightningDamage,
                    ignoreDefense: 0,
                  },
                  projectileCount: 1,
                  scalingStatType: ee.lightningScalingStatType,
                  scalingStatThreshold: ee.lightningScalingStatThreshold,
                  scalingStatInterval: 1,
                  scalingStatIncrease: ee.lightningScalingStatDamage,
                  mergeWithEquipment: !1,
                });
                Qt.push(e);
                const i = Object.assign(Object.assign({}, re), {
                  effectType: Fe.Minion,
                  sourceName: `Shockblast (${Ve.baseStatName(
                    ee.shockblastScalingStatType
                  )} Scaling)`,
                  minDamage: ee.shockblastDamage,
                  maxDamage: ee.shockblastDamage,
                  projectileCount: 1,
                  ignoreDefense: 1e4,
                  triggerCooldownMs: 1e3 * ee.shockblastCooldown,
                  lifetimeMs:
                    1e3 * ee.shockblastCooldown * ee.shockblastTriggerTimes,
                  scalingStatType: ee.shockblastScalingStatType,
                  scalingStatThreshold: ee.shockblastScalingStatThreshold,
                  scalingStatInterval: 1,
                  scalingStatIncrease: ee.shockblastScalingStatDamage,
                  mergeWithEquipment: !1,
                  evolveOnSpawn: new Array(),
                  tags: new Array(),
                });
                Qt.push(i);
                break;
              }
              case Ri.EffectBlast:
                ee = {
                  radius: Number(
                    null !== (Mt = Jt._radius) && void 0 !== Mt ? Mt : 3
                  ),
                  scalingStatType: Number(
                    Ee[
                      null !== (Et = Jt._scalingStat) && void 0 !== Et
                        ? Et
                        : "WIS"
                    ]
                  ),
                  scalingStatThreshold: Number(
                    null !== (It = Jt._wisMin) && void 0 !== It ? It : 50
                  ),
                  statusEffect: this.createStatusEffectHelper(
                    Jt._condEffect,
                    Jt._condDuration
                  ),
                };
                break;
              case Ri.ChannelDash: {
                const t = Number(
                  null !== (Dt = Jt._amount) && void 0 !== Dt ? Dt : 0
                );
                i.channelCharges = t;
                break;
              }
              case Ri.Dash: {
                const t = Number(
                    null !== (Rt = Jt._damage) && void 0 !== Rt ? Rt : 0
                  ),
                  e = Object.assign(Object.assign({}, re), {
                    effectType: Fe.Projectile,
                    sourceName: "Trail",
                    projectile: {
                      minDamage: t,
                      maxDamage: t,
                      ignoreDefense: 0,
                    },
                    projectileCount: 1,
                    mergeWithEquipment: !1,
                  });
                Qt.push(e);
                const i = Number(
                    null !== (Bt = Jt._maxDistance) && void 0 !== Bt ? Bt : 0
                  ),
                  n = Number(
                    null !== (Ft = Jt._speed) && void 0 !== Ft ? Ft : 0
                  ),
                  s = 1e3 * Number(0 == n ? 0 : i / n),
                  r = Object.assign(Object.assign({}, re), {
                    effectType: Fe.Dash,
                    sourceName: "Dash",
                    maxDistance: i,
                    speed: n,
                    maxDurationMs: s,
                  });
                Qt.push(r);
                const o = Number(
                  Ee[null !== (Ot = Jt._stat) && void 0 !== Ot ? Ot : "None"]
                );
                if (o === Ee.None) break;
                const a = void 0 !== Jt._effect && "Multiplied" == Jt._effect,
                  l = `Stat Increase: ${Ve.baseStatName(o)}${
                    1 == a ? "%" : ""
                  }`,
                  u = Jt._amountPerEnemy.split(",").map((t) => Number(t)),
                  h =
                    1e3 *
                    Number(
                      null !== (zt = Jt._effectDuration) && void 0 !== zt
                        ? zt
                        : 0
                    ),
                  c = Object.assign(Object.assign({}, re), {
                    effectType: Fe.StatBoost,
                    sourceName: l,
                    statType: o,
                    stackType: Be.ArrayStack,
                    stackValues: u,
                    multiply: a,
                    durationMs: h,
                  });
                Qt.push(c);
                break;
              }
              case Ri.Decoy:
              case Ri.Shoot:
              case Ri.BulletNova:
              case Ri.BulletCreate:
              case Ri.ShurikenAbility: {
                if (te == Ri.ShurikenAbility) {
                  const t = !0,
                    n = Ve.stringToStatusEffect(
                      null !== (Lt = Jt._effect) && void 0 !== Lt
                        ? Lt
                        : "Speedy"
                    ),
                    s = `Status Effect: ${Ve.statusEffectToString(n)}`,
                    r = 200,
                    o = 0,
                    a = Ee.None;
                  0 == i.baseMpCostPerSecond && (i.totalMpCostPerSecond += 10);
                  const l = Object.assign(Object.assign({}, re), {
                    isPlayerTarget: t,
                    sourceName: s,
                    effectType: Fe.StatusEffect,
                    type: Si.OnAbilityHold,
                    statusEffectType: n,
                    durationMs: r,
                    scalingStatThreshold: o,
                    scalingStatType: a,
                  });
                  Qt.push(l);
                  const u = e.projectiles.get(0);
                  if (void 0 === u || 0 == u.maxDamage) break;
                  if (0 == i.multiPhase) break;
                  if (
                    Qt.some((t) => {
                      if (t.effectType != Fe.Projectile) return !1;
                      return t.projectile == u;
                    })
                  )
                    break;
                }
                const n =
                    null !== (Ht = Jt._objectId) && void 0 !== Ht
                      ? Ht
                      : Jt._type,
                  s = this.getObjectData(n),
                  r = this.getProcSourceName(
                    null == s ? void 0 : s.displayId,
                    Fe.Projectile
                  );
                let o = Number(
                  null !==
                    (Vt =
                      null !==
                        (Nt =
                          null !== (Ut = Jt._numShots) && void 0 !== Ut
                            ? Ut
                            : te == Ri.BulletNova
                            ? 20
                            : void 0) && void 0 !== Nt
                        ? Nt
                        : null === (Gt = e.attacks[0]) || void 0 === Gt
                        ? void 0
                        : Gt.projectileCount) && void 0 !== Vt
                    ? Vt
                    : 1
                );
                const a = this.app.dataHandler.adjustmentsData.get(e.name);
                if (
                  (void 0 !== a &&
                    void 0 !== a.limitShots &&
                    t < a.limitShots.length &&
                    (o = Math.min(o, a.limitShots[t])),
                  te == Ri.Decoy)
                ) {
                  if (
                    ((ee = {
                      duration: Number(
                        null !== (jt = Jt._duration) && void 0 !== jt ? jt : 0
                      ),
                      speed: Number(
                        null !== ($t = Jt._speed) && void 0 !== $t ? $t : 0
                      ),
                    }),
                    void 0 === Jt._numShots)
                  )
                    break;
                } else
                  te == Ri.BulletNova &&
                    void 0 !== e.attacks[0] &&
                    (e.attacks[0].projectileCount = o);
                const l =
                    null === (qt = null == s ? void 0 : s.mergeWithEquipment) ||
                    void 0 === qt ||
                    qt,
                  u =
                    null !==
                      (Wt = this.getProjectileFromObject(Jt._objectId)) &&
                    void 0 !== Wt
                      ? Wt
                      : e.projectiles.get(0);
                if (void 0 === u) break;
                const h = Object.assign(Object.assign({}, re), {
                  effectType: Fe.Projectile,
                  sourceName: r,
                  mergeWithEquipment: l,
                  projectile: u,
                  projectileCount: o,
                  abilitySource: !0,
                });
                Qt.push(h);
                break;
              }
              case Ri.Pet:
              case Ri.SpawnCreep:
              case Ri.ObjectToss: {
                const t = Jt._objectId,
                  e = this.getObjectData(t);
                if (void 0 === e) break;
                const i =
                  1e3 *
                  Number(
                    null !== (Xt = Jt._throwTime) && void 0 !== Xt ? Xt : 0
                  );
                ee = { objectId: null == e ? void 0 : e.id };
                const n = this.getProcSourceName(
                    null == e ? void 0 : e.displayId,
                    Fe.Minion
                  ),
                  s = Object.assign(Object.assign({}, re), {
                    objectId: t,
                    effectType: Fe.Minion,
                    sourceName: n,
                    delayMs: i,
                  });
                Qt.push(s);
                break;
              }
              case Ri.Teleport: {
                const t = Number(
                  null !== (Yt = Jt._maxDistance) && void 0 !== Yt ? Yt : 13
                );
                ee = { maxDistance: t };
                const e = Object.assign(Object.assign({}, re), {
                  sourceName: "Teleport to Target",
                  maxDistance: t,
                  effectType: Fe.Teleport,
                });
                Qt.push(e);
                break;
              }
            }
            void 0 === Jt._ignoreOnTooltip &&
              Zt.push(Object.assign(Object.assign({}, ee), { type: te }));
          }
        }
        parseEquipmentProcs(t, e, i, n) {
          return Ui(this, void 0, void 0, function* () {
            if (void 0 !== t.OnPlayerShootActivate) {
              const n = Array.isArray(t.OnPlayerShootActivate)
                  ? t.OnPlayerShootActivate
                  : [t.OnPlayerShootActivate],
                s = yield this.parseEquipmentProcData(n, Si.OnShoot, e);
              i.push(...s);
            }
            if (void 0 !== t.OnPlayerAbilityActivate) {
              const s = Array.isArray(t.OnPlayerAbilityActivate)
                  ? t.OnPlayerAbilityActivate
                  : [t.OnPlayerAbilityActivate],
                r = yield this.parseEquipmentProcData(s, n, e);
              i.push(...r);
            }
            if (void 0 !== t.OnPlayerHitActivate) {
              const n = Array.isArray(t.OnPlayerHitActivate)
                  ? t.OnPlayerHitActivate
                  : [t.OnPlayerHitActivate],
                s = yield this.parseEquipmentProcData(n, Si.OnPlayerHit, e);
              i.push(...s);
            }
          });
        }
        parseAbility(t, e, i, n) {
          return Ui(this, arguments, void 0, function* (t, e, i, n, s = !1) {
            var r, o, a, l;
            const u = new Array(),
              h = new Array(),
              c = Number(
                null !==
                  (o =
                    null !== (r = t.MpEndCost) && void 0 !== r
                      ? r
                      : t.MpCost) && void 0 !== o
                  ? o
                  : 0
              ),
              d = Number(
                null !== (a = t.MpCostPerSecond) && void 0 !== a ? a : 0
              ),
              p = {
                onUse: u,
                procs: h,
                mpCost: c,
                baseMpCostPerSecond: d,
                totalMpCostPerSecond: d,
                cooldownMs: Math.round(
                  1e3 *
                    Number(null !== (l = t.Cooldown) && void 0 !== l ? l : 0.5)
                ),
                chargeCooldownMs: 500,
                multiPhase: i,
                tooltipData: n
                  ? this.parseTooltipData(t.ExtraTooltipData)
                  : new Array(),
              };
            let f = !1;
            return (
              void 0 !== t.Activate &&
                (yield this.parseAbilityStripActivateHelper(
                  t,
                  e,
                  p,
                  Si.OnAbilityUse
                ),
                1 == s &&
                  (yield this.parseEquipmentProcs(t, e, h, Si.OnAbilityUse)),
                (f = !0)),
              void 0 !== t.StartUse &&
                (yield this.parseAbilityStripActivateHelper(
                  t.StartUse,
                  e,
                  p,
                  Si.OnAbilityStartUse
                ),
                yield this.parseEquipmentProcs(
                  t.StartUse,
                  e,
                  h,
                  Si.OnAbilityStartUse
                ),
                (f = !0)),
              void 0 !== t.EndUse &&
                (yield this.parseAbilityStripActivateHelper(
                  t.EndUse,
                  e,
                  p,
                  Si.OnAbilityEndUse
                ),
                yield this.parseEquipmentProcs(
                  t.EndUse,
                  e,
                  h,
                  Si.OnAbilityEndUse
                ),
                (f = !0)),
              0 == f ? Promise.resolve(void 0) : Promise.resolve(p)
            );
          });
        }
        parseAttackMutatorData(t, e) {
          var i, n;
          const s = Array.isArray(t) ? t : [t],
            r = new Array();
          for (let t = 0; t < s.length; t++) {
            const o = Number(
                null !== (i = s[t]._projectileId) && void 0 !== i ? i : 0
              ),
              a = {
                type: e,
                value: Number(
                  null !== (n = s[t].__text) && void 0 !== n ? n : 0
                ),
                projectileId: o,
              };
            r.push(a);
          }
          return r;
        }
        parseEnchantSubAttack(t, e) {
          var i, n, s;
          const r = Array.isArray(t) ? t : [t];
          let o = !0;
          for (let t = 0; t < r.length; t++) {
            const a = r[t],
              l = a._subAttackObject,
              u = Number(
                null !== (i = a._subAttackIndex) && void 0 !== i ? i : 0
              ),
              h =
                null === (n = this.attackData.get(l)) || void 0 === n
                  ? void 0
                  : n.get(u);
            if (void 0 === h) {
              o = !1;
              continue;
            }
            const c = Number(null !== (s = a.__text) && void 0 !== s ? s : 0);
            (h.subAttackId = c), e.push(h);
          }
          return o;
        }
        loadEnchantmentsData(t) {
          return Ui(this, void 0, void 0, function* () {
            var e, i, n, s, r, o, a, l, u, h, c, d;
            const p = this.xmlParser.xml2js(t).Enchantments.Enchantment;
            for (let t = 0; t < p.length; t++) {
              const f = p[t],
                m = Number(f._type),
                g = f.DisplayId,
                v = f.Prefix,
                y = f.Description,
                x = this.parseTextureData(f.Texture),
                b = new Array(),
                S = new Array(),
                C = new Array(),
                _ = new Array(),
                T = new Array();
              let w = !0;
              if (void 0 !== f.Mutators) {
                const t = yield this.statsOnEquip(f.Mutators.ActivateOnEquip);
                if (
                  (b.push(...t),
                  void 0 !== f.Mutators.SetSubAttack &&
                    (this.parseEnchantSubAttack(f.Mutators.SetSubAttack, C) ||
                      (w = !1)),
                  void 0 !== f.Mutators.AddSubAttack &&
                    (this.parseEnchantSubAttack(f.Mutators.AddSubAttack, S) ||
                      (w = !1)),
                  void 0 !== f.Mutators.MultiplyMinDamage)
                ) {
                  const t = this.parseAttackMutatorData(
                    f.Mutators.MultiplyMinDamage,
                    Le.MultiplyMinDamage
                  );
                  _.push(...t);
                }
                if (void 0 !== f.Mutators.MultiplyMaxDamage) {
                  const t = this.parseAttackMutatorData(
                    f.Mutators.MultiplyMaxDamage,
                    Le.MultiplyMaxDamage
                  );
                  _.push(...t);
                }
                if (void 0 !== f.Mutators.MultiplyRateOfFire) {
                  const t = this.parseAttackMutatorData(
                    f.Mutators.MultiplyRateOfFire,
                    Le.MultiplyRateOfFire
                  );
                  _.push(...t);
                }
                if (void 0 !== f.Mutators.MultiplySpeed) {
                  const t = this.parseAttackMutatorData(
                    f.Mutators.MultiplySpeed,
                    Le.MultiplySpeed
                  );
                  _.push(...t);
                }
                if (void 0 !== f.Mutators.SetPassesCover) {
                  const t = this.parseAttackMutatorData(
                    f.Mutators.SetPassesCover,
                    Le.SetPassesCover
                  );
                  _.push(...t);
                }
                if (void 0 !== f.Mutators.SetBoomerang) {
                  const t = this.parseAttackMutatorData(
                    f.Mutators.SetBoomerang,
                    Le.SetBoomerang
                  );
                  _.push(...t);
                }
                if (void 0 !== f.Mutators.RemoveBoomerang) {
                  const t = this.parseAttackMutatorData(
                    f.Mutators.RemoveBoomerang,
                    Le.RemoveBoomerang
                  );
                  _.push(...t);
                }
                if (void 0 !== f.Mutators.MultiplyLifetimeMS) {
                  const t = this.parseAttackMutatorData(
                    f.Mutators.MultiplyLifetimeMS,
                    Le.MultiplyLifetimeMs
                  );
                  _.push(...t);
                }
                if (void 0 !== f.Mutators.MultiplySize) {
                  const t = this.parseAttackMutatorData(
                    f.Mutators.MultiplySize,
                    Le.MultiplySize
                  );
                  _.push(...t);
                }
                if (void 0 !== f.Mutators.AddOnPlayerHitActivate) {
                  const [t, e] = yield this.parseEnchantmentOnHitProcs(
                    f.Mutators.AddOnPlayerHitActivate
                  );
                  T.push(...e), t || (w = !1);
                }
                if (void 0 !== f.Mutators.MultiplyMPCost) {
                  const t = {
                    type: Ee.MPMULTIPLIER,
                    value: Number(f.Mutators.MultiplyMPCost),
                    relativeTo: Ee.None,
                  };
                  b.push(t);
                }
              }
              const P = (
                  null !==
                    (i =
                      null === (e = f.EnchantmentLabels) || void 0 === e
                        ? void 0
                        : e.toLowerCase()) && void 0 !== i
                    ? i
                    : ""
                )
                  .split(",")
                  .filter((t) => 0 != t.length),
                A = (
                  null !==
                    (s =
                      null === (n = f.CompatibleWithItemLabels) || void 0 === n
                        ? void 0
                        : n.toLowerCase()) && void 0 !== s
                    ? s
                    : ""
                )
                  .split(",")
                  .filter((t) => 0 != t.length),
                k = (
                  null !==
                    (o =
                      null === (r = f.CompatibleWithItemIds) || void 0 === r
                        ? void 0
                        : r.toLowerCase()) && void 0 !== o
                    ? o
                    : ""
                )
                  .split(",")
                  .filter((t) => 0 != t.length)
                  .map((t) => Number(t)),
                M = new Array(),
                E = (
                  null !==
                    (l =
                      null === (a = f.IncompatibleWithItemLabels) ||
                      void 0 === a
                        ? void 0
                        : a.toLowerCase()) && void 0 !== l
                    ? l
                    : ""
                )
                  .split(",")
                  .filter((t) => 0 != t.length),
                I = (
                  null !==
                    (h =
                      null === (u = f.IncompatibleWithItemIds) || void 0 === u
                        ? void 0
                        : u.toLowerCase()) && void 0 !== h
                    ? h
                    : ""
                )
                  .split(",")
                  .filter((t) => 0 != t.length)
                  .map((t) => Number(t)),
                D = (
                  null !==
                    (d =
                      null === (c = f.IncompatibleWithEnchantLabels) ||
                      void 0 === c
                        ? void 0
                        : c.toLowerCase()) && void 0 !== d
                    ? d
                    : ""
                )
                  .split(",")
                  .filter((t) => 0 != t.length),
                R = new Array(g, v);
              b.forEach((t) => R.push(Ee[t.type]));
              const B = `"${R.join('"').toLowerCase()}"`;
              let F = 0;
              A.includes("tiered") &&
                (g.includes(" IV")
                  ? (F = 4)
                  : g.includes(" III")
                  ? (F = 3)
                  : g.includes(" II")
                  ? (F = 2)
                  : g.search(" I") == g.length - 2 && (F = 1));
              const O = {
                id: m,
                name: g,
                prefix: v,
                description: y,
                tier: F,
                searchLabels: B,
                texture: x,
                statsOnEquip: b,
                addAttacks: S,
                setAttacks: C,
                attackMutators: _,
                procs: T,
                compatibleEquipmentLabels: A,
                compatibleEquipmentIds: k,
                enchantLabels: P,
                incompatibleEquipmentLabels: E,
                incompatibleTieredEquipmentLabels: M,
                incompatibleEquipmentIds: I,
                incompatibleEnchantLabels: D,
                isComplete: w,
              };
              this.filterIncompatibleTypes(O), this.enchantmentsData.set(m, O);
            }
            return Promise.resolve(!0);
          });
        }
        filterIncompatibleTypes(t) {
          const e = new Array(),
            i = new Array(),
            n = new Array(30),
            s = (t) => t.forEach((t) => (n[t] = !0)),
            r = [1, 2, 3, 8, 17, 24],
            o = [5, 12, 16, 25, 27, 30],
            a = [13, 15, 18, 20, 22, 28],
            l = [4, 11, 19, 21, 23, 29],
            u = [6, 7, 14];
          t.statsOnEquip.forEach((t) => {
            switch (t.type) {
              case Ee.MAXHP:
                s([...r, ...o, ...a, ...l]);
                break;
              case Ee.MAXMP:
                s([...r, ...u]);
                break;
              case Ee.ATT:
                s([...a, ...l, ...u]);
                break;
              case Ee.DEF:
                s([...r, ...a, ...l]);
                break;
              case Ee.SPD:
                s([...r, ...o, ...u]);
                break;
              case Ee.DEX:
                s([...o, ...l, ...u]);
                break;
              case Ee.VIT:
                s([...r, ...o, ...a, ...l]);
                break;
              case Ee.WIS:
                s([...o, ...a, ...u]);
                break;
              case Ee.MPMULTIPLIER:
                s([...r]);
            }
          });
          let h = 0;
          t.attackMutators.forEach((t) => {
            switch (t.type) {
              case Le.SetBoomerang:
                i.push("flail");
                break;
              case Le.SetPassesCover:
                i.push("dualblade");
                break;
              case Le.RemoveBoomerang:
                i.push("flail");
            }
            t.type != Le.MultiplyRateOfFire &&
              t.type != Le.MultiplyMinDamage &&
              t.type != Le.MultiplyMaxDamage &&
              h < t.projectileId + 1 &&
              (h = t.projectileId + 1);
          }),
            0 != h &&
              3 != h &&
              i.push(
                "flail",
                "longbow",
                "morningstar",
                "staff",
                "bow",
                "spellblade",
                "dualblade",
                "sword",
                "katana",
                "dagger",
                "wand",
                "tachi"
              );
          const c = new Array();
          for (let t = De.Sword; t <= De.Sheath; t++) n[t] && c.push(t);
          t.compatibleEquipmentLabels.push(...e),
            t.incompatibleTieredEquipmentLabels.push(...i),
            (t.incompatibleSlotTypes = c);
        }
        getSTierEquipment(t, e) {
          const i = this.sTierEquipmentData.get(t);
          return void 0 === i ? { id: 0, enchants: [] } : i[e];
        }
        getEnchants(t) {
          const e = new Array();
          t: for (const i of this.enchantmentsData.values())
            if (i.compatibleEquipmentIds.includes(t.id)) e.push(i);
            else {
              if (t.tier < Oe.Set) {
                const e = Ve.slotMetaType(t.slotType),
                  n = this.enchantmentsTierData.get(e),
                  s = null == n ? void 0 : n.get(i.tier);
                if (void 0 === s) continue;
                if (t.tier < s) continue;
                for (const e of t.labels)
                  if (i.incompatibleTieredEquipmentLabels.includes(e))
                    continue t;
                if (i.incompatibleSlotTypes.includes(t.slotType)) continue;
              }
              if (!i.incompatibleEquipmentIds.includes(t.id)) {
                for (const e of t.labels) {
                  if (i.incompatibleEquipmentLabels.includes(e)) continue t;
                  for (const e of i.compatibleEquipmentLabels)
                    if (!t.labels.includes(e)) continue t;
                }
                e.push(i);
              }
            }
          return e;
        }
        loadEquipmentSetData(t) {
          return Ui(this, void 0, void 0, function* () {
            var e, i;
            const n = this.xmlParser.xml2js(t).EquipmentSets.EquipmentSet;
            for (let t = 0; t < n.length; t++) {
              const s = n[t],
                r = Number(s._type),
                o = s._id,
                a = new Map(),
                l = new Map();
              for (let t = 0; t < s.Setpiece.length; t++) {
                const n = Number(s.Setpiece[t]._slot || -1),
                  r = Number(
                    null !== (e = s.Setpiece[t]._itemtype) && void 0 !== e
                      ? e
                      : 0
                  ),
                  o = null !== (i = l.get(n)) && void 0 !== i ? i : new Array();
                o.push(r), l.set(n, o);
              }
              if (void 0 !== s.ActivateOnEquip2) {
                const t = yield this.statsOnEquip(s.ActivateOnEquip2);
                a.set(2, t);
              }
              if (void 0 !== s.ActivateOnEquip3) {
                const t = yield this.statsOnEquip(s.ActivateOnEquip3);
                a.set(3, t);
              }
              if (void 0 !== s.ActivateOnEquipAll) {
                const t = yield this.statsOnEquip(s.ActivateOnEquipAll),
                  e = Array.isArray(s.ActivateOnEquipAll)
                    ? s.ActivateOnEquipAll
                    : new Array(s.ActivateOnEquipAll);
                for (const t of e)
                  if (void 0 !== t._skinType && void 0 !== t._size) {
                    const e = Number(t._skinType),
                      i = 0.05 * Number(t._size);
                    this.skinScaleData.set(e, i);
                  }
                a.set(4, t);
              }
              const u = { id: r, name: o, statsOnEquip: a, equipmentIds: l };
              this.equipmentSetsData.set(r, u);
            }
            return Promise.resolve(!0);
          });
        }
        loadEquipmentData(t) {
          return Ui(this, void 0, void 0, function* () {
            var e,
              i,
              n,
              s,
              r,
              o,
              a,
              l,
              u,
              h,
              c,
              d,
              p,
              f,
              m,
              g,
              v,
              y,
              x,
              b,
              S,
              C,
              _,
              T,
              w,
              P,
              A;
            const k = this.xmlParser.xml2js(t).Objects.Object,
              M =
                null !== (e = this.itemChecklistTags.get(zi.AllOther)) &&
                void 0 !== e
                  ? e
                  : new Map();
            this.itemChecklistTags.set(zi.AllOther, M);
            for (let t = 0; t < k.length; t++) {
              const e = k[t];
              if (void 0 === e.SlotType) continue;
              if (void 0 === e.BagType) continue;
              const E = (
                  null !==
                    (n =
                      null === (i = e.Labels) || void 0 === i
                        ? void 0
                        : i.toLowerCase()) && void 0 !== n
                    ? n
                    : ""
                )
                  .split(",")
                  .filter((t) => 0 != t.length),
                I = [...E],
                D = Number(e._type),
                R = Array.isArray(e.DisplayId)
                  ? e.DisplayId[0].toString()
                  : (null !==
                      (r =
                        null !== (s = e.DisplayId) && void 0 !== s
                          ? s
                          : e._id) && void 0 !== r
                      ? r
                      : ""
                    ).toString();
              I.push(R);
              const B =
                  null !==
                    (o = this.collectionTypeData.get(
                      Number(e._collectionIcon)
                    )) && void 0 !== o
                    ? o
                    : Oi.None,
                F =
                  void 0 !== e.Tier
                    ? Number(e.Tier)
                    : E.includes("st")
                    ? Oe.Set
                    : Oe.Untiered,
                O = this.parseTextureData(e.Texture),
                z = Number(e.SlotType),
                L = void 0 !== e.Soulbound,
                H = (
                  null !== (a = e.Description) && void 0 !== a ? a : ""
                ).replaceAll("\\n", "\n"),
                U = this.parseProjectileData(e.Projectile),
                N = Number(null !== (l = e.RateOfFire) && void 0 !== l ? l : 1),
                G = Number(
                  null !== (u = e.NumProjectiles) && void 0 !== u ? u : 1
                ),
                V = Number(null !== (h = e.ArcGap) && void 0 !== h ? h : 0),
                j = Number(null !== (c = e.BurstCount) && void 0 !== c ? c : 0),
                $ = Number(
                  null !== (d = e.BurstMinDelay) && void 0 !== d ? d : 0
                ),
                q = Number(null !== (p = e.BurstDelay) && void 0 !== p ? p : 0),
                W = void 0 !== e.MultiPhase,
                X = void 0 !== e.InventoryAnimation;
              1 == X && I.push("shiny");
              const Y =
                null !== (f = this.parseAttackData(e.Subattack, U, N)) &&
                void 0 !== f
                  ? f
                  : [];
              0 == Y.length &&
                0 != U.size &&
                Y.push({
                  projectile: (0, Ue.cloneDeep)(U.get(0)),
                  projectileId: 0,
                  subAttackId: 0,
                  projectileCount: G,
                  rateOfFire: N,
                  arcGap: V,
                  burstMaxCount: j,
                  burstMinDelay: $,
                  burstMaxDelay: q,
                  mergeWithEquipment: !0,
                });
              const K = new Map(),
                Z = new Map();
              for (const [t, e] of U.entries()) {
                const i = this.getProjectileHash(e);
                K.set(i, [t, e]);
              }
              for (let t = 0; t < Y.length; t++) {
                const e = Y[t],
                  i = U.get(
                    null !== (m = e.projectileId) && void 0 !== m ? m : 0
                  );
                if (void 0 === i) continue;
                const n = this.getAttackHash(e, i),
                  s =
                    (null !==
                      (v =
                        null === (g = Z.get(n)) || void 0 === g
                          ? void 0
                          : g.bulletCount) && void 0 !== v
                      ? v
                      : 0) + 1;
                Z.set(n, { attack: e, bulletCount: s });
              }
              const Q = [...Z.values()],
                J = Number(
                  null !==
                    (x =
                      null === (y = e.EnchantmentSlots) || void 0 === y
                        ? void 0
                        : y._maxNumber) && void 0 !== x
                    ? x
                    : 0
                ),
                tt = Number(null !== (b = e.XPBonus) && void 0 !== b ? b : 0),
                et = Number(null !== (S = e.feedPower) && void 0 !== S ? S : 0),
                it = Number(
                  null !== (C = e.BagType) && void 0 !== C ? C : Bi.None
                ),
                nt = Number(null !== (_ = e._setType) && void 0 !== _ ? _ : 0);
              if (0 != nt) {
                const t =
                  null !==
                    (w =
                      null === (T = this.equipmentSetsData.get(nt)) ||
                      void 0 === T
                        ? void 0
                        : T.name) && void 0 !== w
                    ? w
                    : "";
                I.push(t);
              }
              const st = yield this.statsOnEquip(e.ActivateOnEquip);
              st.forEach((t) => I.push(Ee[t.type]));
              const rt = `"${I.join('"')}"`.toLowerCase(),
                ot = new Array(),
                at = new Array(),
                lt = new Array(),
                ut = {
                  id: D,
                  name: R,
                  description: H,
                  texture: O,
                  slotType: z,
                  collectionType: B,
                  tier: F,
                  soulbound: L,
                  projectiles: U,
                  attacks: Y,
                  uniqueAttacks: Q,
                  tooltipData: lt,
                  procs: at,
                  statsOnEquip: st,
                  abilities: ot,
                  xpBonus: tt,
                  feedPower: et,
                  bagType: it,
                  enchantSlots: J,
                  setId: nt,
                  labels: E,
                  searchLabels: rt,
                  isShiny: X,
                };
              if (void 0 !== e.ExtraTooltipData) {
                const t = yield this.parseTooltipData(e.ExtraTooltipData);
                lt.push(...t);
              }
              for (const t of U.values())
                for (let e = 0; e < t.statusEffects.length; e++) {
                  const i = t.statusEffects[e];
                  if (i.type == Ie.Bleeding) {
                    const e = 0.001 * i.durationMs;
                    t.dotProc = {
                      sourceName: "Bleeding",
                      sourceSlot: Ve.slotMetaType(z),
                      damage: i.value * e,
                      durationMs: i.durationMs,
                      cooldownMs: 0,
                      mergeWithEquipment: !1,
                    };
                  }
                }
              if (void 0 !== e.Ability) {
                const t = Array.isArray(e.Ability) ? e.Ability : [e.Ability];
                for (let e = 0; e < t.length; e++) {
                  const i = t[e],
                    n = yield this.parseAbility(i, ut, W, !0, !0);
                  void 0 !== n && ot.push(n);
                }
              } else {
                const t = yield this.parseAbility(e, ut, W, !1);
                void 0 !== t
                  ? ot.push(t)
                  : yield this.parseAbilityStripActivateHelper(
                      e,
                      ut,
                      {},
                      Si.None
                    ),
                  yield this.parseEquipmentProcs(e, ut, at, Si.OnAbilityUse);
              }
              const ht =
                null !== (P = this.equipmentData.get(z)) && void 0 !== P
                  ? P
                  : new Map();
              ht.set(D, ut), this.equipmentData.set(z, ht);
              let ct = !1;
              for (const t of this.itemChecklistTags.keys())
                if (
                  null === (A = this.itemChecklistTags.get(t)) || void 0 === A
                    ? void 0
                    : A.has(D)
                ) {
                  ct = !0;
                  break;
                }
              ct || M.set(D, null);
            }
            return Promise.resolve(!0);
          });
        }
        loadClassData(t) {
          return Ui(this, void 0, void 0, function* () {
            var e, i, n, s, r, o, a, l, u, h;
            const c = this.xmlParser.xml2js(t).Objects.Object,
              d = Ve.getSeasonalEvent();
            for (let t = 0; t < c.length; t++) {
              const p = c[t],
                f = p._id;
              if (void 0 === f) return Promise.resolve(!1);
              const m = Di[f],
                g = this.classEventReskinsData.get(m),
                v =
                  d >= 0 && void 0 !== g
                    ? g[d]
                    : this.parseTextureData(p.AnimatedTexture),
                y = this.parseTextureData(p.AnimatedTexture),
                x = p.SlotTypes.split(","),
                b = new Array(0, 0, 0, De.Accessory);
              for (let t = 0; t < 3; t++) {
                if (void 0 === x[t]) continue;
                b[t] = Number(x[t]);
                let i =
                  null !==
                    (e = this.eliglibleClassNamesPerSlotType.get(b[t])) &&
                  void 0 !== e
                    ? e
                    : new Array();
                i.push(Di[m]), this.eliglibleClassNamesPerSlotType.set(b[t], i);
              }
              const S = p.Equipment.split(","),
                C = new Array();
              for (let t = 0; t < 4; t++)
                C[t] = Number(null !== (i = S[t]) && void 0 !== i ? i : 0);
              const _ = {
                type: m,
                portraitTexture: v,
                truePortraitTexture: y,
                equipmentSlots: b,
                starterEquipmentIds: C,
                maxedBaseStats: new Array(
                  Number(
                    null !== (n = p.MaxHitPoints._max) && void 0 !== n ? n : 0
                  ),
                  Number(
                    null !== (s = p.MaxMagicPoints._max) && void 0 !== s ? s : 0
                  ),
                  Number(null !== (r = p.Attack._max) && void 0 !== r ? r : 0),
                  Number(null !== (o = p.Defense._max) && void 0 !== o ? o : 0),
                  Number(null !== (a = p.Speed._max) && void 0 !== a ? a : 0),
                  Number(
                    null !== (l = p.Dexterity._max) && void 0 !== l ? l : 0
                  ),
                  Number(null !== (u = p.HpRegen._max) && void 0 !== u ? u : 0),
                  Number(null !== (h = p.MpRegen._max) && void 0 !== h ? h : 0)
                ),
              };
              this.classesData.set(m, _);
            }
            return Promise.resolve(!0);
          });
        }
        createSkinData(t) {
          var e, i, n, s, r, o, a, l, u, h, c, d;
          const p = Number(null !== (e = t._type) && void 0 !== e ? e : 0),
            f =
              null !==
                (n = null !== (i = t.DisplayId) && void 0 !== i ? i : t._id) &&
              void 0 !== n
                ? n
                : "Default Skin",
            m = Number(null !== (s = t.ItemTier) && void 0 !== s ? s : 0),
            g = void 0 !== t.Soulbound,
            v = (
              null !== (r = t.Description) && void 0 !== r ? r : ""
            ).replaceAll("\\n", "\n"),
            y = Number(null !== (o = t.feedPower) && void 0 !== o ? o : 0),
            x =
              null !== (a = t.fileName) && void 0 !== a
                ? a
                : t.AnimatedTexture.File,
            b = Number(
              null !== (l = t.index) && void 0 !== l
                ? l
                : null === (u = t.AnimatedTexture) || void 0 === u
                ? void 0
                : u.Index
            ),
            S = {
              name: f,
              tier: m,
              soulbound: g,
              description: v,
              feedPower: y,
              fileName: x,
              index: b,
              bagType: Number(
                null !== (h = t.BagType) && void 0 !== h ? h : Bi.None
              ),
              scale:
                null !== (c = this.skinScaleData.get(p)) && void 0 !== c
                  ? c
                  : 5,
            };
          if (void 0 !== this.alwaysCenteredSkinNamesData.get(f)) {
            const t =
              null !== (d = this.alwaysCenteredSkinsData.get(x)) && void 0 !== d
                ? d
                : new Map();
            t.set(b, null), this.alwaysCenteredSkinsData.set(x, t);
          }
          return S;
        }
        loadSkinsData(t, e) {
          return Ui(this, void 0, void 0, function* () {
            var i, n, s, r;
            const o = this.xmlParser.xml2js(t).Objects.Object,
              a = this.xmlParser.xml2js(e).Objects.Object,
              l = new Map();
            for (const [t, e] of this.classesData) {
              const n = this.createSkinData(e.truePortraitTexture);
              (n.id = 0), (n.type = t);
              const s =
                null !== (i = this.skinsData.get(n.type)) && void 0 !== i
                  ? i
                  : new Map();
              s.set(n.id, n), this.skinsData.set(n.type, s);
            }
            for (const t of a) {
              const e = this.createSkinData(t);
              l.set(e.id, e);
            }
            for (const t of o) {
              const e = Number(t._type),
                i =
                  null !== (n = l.get(e)) && void 0 !== n
                    ? n
                    : this.createSkinData(t);
              i.id = e;
              const o = Number(t.PlayerClassType);
              i.type =
                null !== (s = this.classDirtyTypeMap.get(o)) && void 0 !== s
                  ? s
                  : Di.Wizard;
              const a =
                null !== (r = this.skinsData.get(i.type)) && void 0 !== r
                  ? r
                  : new Map();
              a.set(e, i), this.skinsData.set(i.type, a);
            }
            return Promise.resolve(!0);
          });
        }
        loadDyesData() {
          return Ui(this, void 0, void 0, function* () {
            const t = yield (yield fetch(`./data/json/dyes.json`)).text(),
              e = yield JSON.parse(t),
              i = Object.keys(e);
            for (const t of i) {
              const i = e[t];
              this.dyesData.set(i.id, i);
            }
            return Promise.resolve(!0);
          });
        }
        loadItemChecklistTagsData() {
          return Ui(this, void 0, void 0, function* () {
            var t;
            const e = yield (yield fetch(
                `./data/json/itemChecklistTags.json`
              )).text(),
              i = yield JSON.parse(e),
              n = Object.keys(i);
            for (const e of n) {
              const n = Number(zi[e]),
                s =
                  null !== (t = this.itemChecklistTags.get(n)) && void 0 !== t
                    ? t
                    : new Map();
              for (const t of i[e]) s.set(t, null);
              this.itemChecklistTags.set(n, s);
            }
            return Promise.resolve(!0);
          });
        }
      }
      var Gi =
          "in vec2 aPosition;\nout vec2 vTextureCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n}\n",
        Vi =
          "struct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n  };\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}",
        ji = Object.defineProperty,
        $i = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? ji(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const qi = class t extends ct.d {
        constructor(e) {
          e = { ...t.DEFAULT_OPTIONS, ...e };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct AdjustmentUniforms {\n  uGamma: f32,\n  uContrast: f32,\n  uSaturation: f32,\n  uBrightness: f32,\n  uColor: vec4<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> adjustmentUniforms : AdjustmentUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n  var sample = textureSample(uTexture, uSampler, uv);\n  let color = adjustmentUniforms.uColor;\n\n  if (sample.a > 0.0) \n  {\n    sample = vec4<f32>(sample.rgb / sample.a, sample.a);\n    var rgb: vec3<f32> = pow(sample.rgb, vec3<f32>(1. / adjustmentUniforms.uGamma));\n    rgb = mix(vec3<f32>(.5), mix(vec3<f32>(dot(vec3<f32>(.2125, .7154, .0721), rgb)), rgb, adjustmentUniforms.uSaturation), adjustmentUniforms.uContrast);\n    rgb.r *= color.r;\n    rgb.g *= color.g;\n    rgb.b *= color.b;\n    sample = vec4<f32>(rgb.rgb * adjustmentUniforms.uBrightness, sample.a);\n    sample = vec4<f32>(sample.rgb * sample.a, sample.a);\n  }\n\n  return sample * color.a;\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uGamma;\nuniform float uContrast;\nuniform float uSaturation;\nuniform float uBrightness;\nuniform vec4 uColor;\n\nvoid main()\n{\n    vec4 c = texture(uTexture, vTextureCoord);\n\n    if (c.a > 0.0) {\n        c.rgb /= c.a;\n\n        vec3 rgb = pow(c.rgb, vec3(1. / uGamma));\n        rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb)), rgb, uSaturation), uContrast);\n        rgb.r *= uColor.r;\n        rgb.g *= uColor.g;\n        rgb.b *= uColor.b;\n        c.rgb = rgb * uBrightness;\n\n        c.rgb *= c.a;\n    }\n\n    finalColor = c * uColor.a;\n}\n",
              name: "adjustment-filter",
            }),
            resources: {
              adjustmentUniforms: {
                uGamma: { value: e.gamma, type: "f32" },
                uContrast: { value: e.contrast, type: "f32" },
                uSaturation: { value: e.saturation, type: "f32" },
                uBrightness: { value: e.brightness, type: "f32" },
                uColor: {
                  value: [e.red, e.green, e.blue, e.alpha],
                  type: "vec4<f32>",
                },
              },
            },
          }),
            $i(this, "uniforms"),
            (this.uniforms = this.resources.adjustmentUniforms.uniforms);
        }
        get gamma() {
          return this.uniforms.uGamma;
        }
        set gamma(t) {
          this.uniforms.uGamma = t;
        }
        get contrast() {
          return this.uniforms.uContrast;
        }
        set contrast(t) {
          this.uniforms.uContrast = t;
        }
        get saturation() {
          return this.uniforms.uSaturation;
        }
        set saturation(t) {
          this.uniforms.uSaturation = t;
        }
        get brightness() {
          return this.uniforms.uBrightness;
        }
        set brightness(t) {
          this.uniforms.uBrightness = t;
        }
        get red() {
          return this.uniforms.uColor[0];
        }
        set red(t) {
          this.uniforms.uColor[0] = t;
        }
        get green() {
          return this.uniforms.uColor[1];
        }
        set green(t) {
          this.uniforms.uColor[1] = t;
        }
        get blue() {
          return this.uniforms.uColor[2];
        }
        set blue(t) {
          this.uniforms.uColor[2] = t;
        }
        get alpha() {
          return this.uniforms.uColor[3];
        }
        set alpha(t) {
          this.uniforms.uColor[3] = t;
        }
      };
      $i(qi, "DEFAULT_OPTIONS", {
        gamma: 1,
        contrast: 1,
        saturation: 1,
        brightness: 1,
        red: 1,
        green: 1,
        blue: 1,
        alpha: 1,
      });
      var Wi = Object.defineProperty,
        Xi = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? Wi(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Yi = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          ("number" == typeof i || Array.isArray(i)) &&
            ((0, yt.t)(
              "6.0.0",
              "KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }"
            ),
            (i = { strength: i }),
            void 0 !== e[1] && (i.quality = e[1]),
            void 0 !== e[2] && (i.clamp = e[2])),
            (i = { ...t.DEFAULT_OPTIONS, ...i });
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source: i?.clamp
                  ? "struct KawaseBlurUniforms {\n  uOffset:vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOffset = kawaseBlurUniforms.uOffset;\n  var color: vec4<f32> = vec4(0.0);\n\n  // Sample top left pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample top right pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample bottom right pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Sample bottom left pixel\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n  // Average\n  color *= 0.25;\n    \n  return color;\n}"
                  : "struct KawaseBlurUniforms {\n  uOffset:vec2<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOffset = kawaseBlurUniforms.uOffset;\n  var color: vec4<f32> = vec4<f32>(0.0);\n\n  // Sample top left pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y));\n  // Sample top right pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y));\n  // Sample bottom right pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y));\n  // Sample bottom left pixel\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y));\n  // Average\n  color *= 0.25;\n\n  return color;\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment: i?.clamp
                ? "\nprecision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uOffset;\n\nuniform vec4 uInputClamp;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample top right pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample bottom right pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Sample bottom left pixel\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\n\n    // Average\n    color *= 0.25;\n\n    finalColor = color;\n}\n"
                : "\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uOffset;\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n\n    // Sample top left pixel\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample top right pixel\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\n\n    // Sample bottom right pixel\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Sample bottom left pixel\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\n\n    // Average\n    color *= 0.25;\n\n    finalColor = color;\n}",
              name: "kawase-blur-filter",
            }),
            resources: {
              kawaseBlurUniforms: {
                uOffset: { value: new Float32Array(2), type: "vec2<f32>" },
              },
            },
          }),
            Xi(this, "uniforms"),
            Xi(this, "_pixelSize", { x: 0, y: 0 }),
            Xi(this, "_clamp"),
            Xi(this, "_kernels", []),
            Xi(this, "_blur"),
            Xi(this, "_quality"),
            (this.uniforms = this.resources.kawaseBlurUniforms.uniforms),
            (this.pixelSize = i.pixelSize ?? { x: 1, y: 1 }),
            Array.isArray(i.strength)
              ? (this.kernels = i.strength)
              : "number" == typeof i.strength &&
                ((this._blur = i.strength), (this.quality = i.quality ?? 3)),
            (this._clamp = !!i.clamp);
        }
        apply(t, e, i, n) {
          const s = this.pixelSizeX / e.source.width,
            r = this.pixelSizeY / e.source.height;
          let o;
          if (1 === this._quality || 0 === this._blur)
            (o = this._kernels[0] + 0.5),
              (this.uniforms.uOffset[0] = o * s),
              (this.uniforms.uOffset[1] = o * r),
              t.applyFilter(this, e, i, n);
          else {
            const a = gt.W.getSameSizeTexture(e);
            let l,
              u = e,
              h = a;
            const c = this._quality - 1;
            for (let e = 0; e < c; e++)
              (o = this._kernels[e] + 0.5),
                (this.uniforms.uOffset[0] = o * s),
                (this.uniforms.uOffset[1] = o * r),
                t.applyFilter(this, u, h, !0),
                (l = u),
                (u = h),
                (h = l);
            (o = this._kernels[c] + 0.5),
              (this.uniforms.uOffset[0] = o * s),
              (this.uniforms.uOffset[1] = o * r),
              t.applyFilter(this, u, i, n),
              gt.W.returnTexture(a);
          }
        }
        get strength() {
          return this._blur;
        }
        set strength(t) {
          (this._blur = t), this._generateKernels();
        }
        get quality() {
          return this._quality;
        }
        set quality(t) {
          (this._quality = Math.max(1, Math.round(t))), this._generateKernels();
        }
        get kernels() {
          return this._kernels;
        }
        set kernels(t) {
          Array.isArray(t) && t.length > 0
            ? ((this._kernels = t),
              (this._quality = t.length),
              (this._blur = Math.max(...t)))
            : ((this._kernels = [0]), (this._quality = 1));
        }
        get pixelSize() {
          return this._pixelSize;
        }
        set pixelSize(t) {
          if ("number" != typeof t)
            return Array.isArray(t)
              ? ((this.pixelSizeX = t[0]), void (this.pixelSizeY = t[1]))
              : void (this._pixelSize = t);
          this.pixelSizeX = this.pixelSizeY = t;
        }
        get pixelSizeX() {
          return this.pixelSize.x;
        }
        set pixelSizeX(t) {
          this.pixelSize.x = t;
        }
        get pixelSizeY() {
          return this.pixelSize.y;
        }
        set pixelSizeY(t) {
          this.pixelSize.y = t;
        }
        get clamp() {
          return this._clamp;
        }
        _updatePadding() {
          this.padding = Math.ceil(
            this._kernels.reduce((t, e) => t + e + 0.5, 0)
          );
        }
        _generateKernels() {
          const t = this._blur,
            e = this._quality,
            i = [t];
          if (t > 0) {
            let n = t;
            const s = t / e;
            for (let t = 1; t < e; t++) (n -= s), i.push(n);
          }
          (this._kernels = i), this._updatePadding();
        }
      };
      Xi(Yi, "DEFAULT_OPTIONS", {
        strength: 4,
        quality: 3,
        clamp: !1,
        pixelSize: { x: 1, y: 1 },
      });
      let Ki = Yi;
      var Zi = Object.defineProperty,
        Qi = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? Zi(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Ji = class t extends ct.d {
        constructor(e) {
          e = { ...t.DEFAULT_OPTIONS, ...e };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct ExtractBrightnessUniforms {\n  uThreshold: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> extractBrightnessUniforms : ExtractBrightnessUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  // A simple & fast algorithm for getting brightness.\n  // It's inaccurate, but good enough for this feature.\n  let max: f32 = max(max(color.r, color.g), color.b);\n  let min: f32 = min(min(color.r, color.g), color.b);\n  let brightness: f32 = (max + min) * 0.5;\n\n  return select(vec4<f32>(0.), color, brightness > extractBrightnessUniforms.uThreshold);\n}\n",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uThreshold;\n\nvoid main() {\n    vec4 color = texture(uTexture, vTextureCoord);\n\n    // A simple & fast algorithm for getting brightness.\n    // It's inaccuracy , but good enought for this feature.\n    float _max = max(max(color.r, color.g), color.b);\n    float _min = min(min(color.r, color.g), color.b);\n    float brightness = (_max + _min) * 0.5;\n\n    if(brightness > uThreshold) {\n        finalColor = color;\n    } else {\n        finalColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n",
              name: "extract-brightness-filter",
            }),
            resources: {
              extractBrightnessUniforms: {
                uThreshold: { value: e.threshold, type: "f32" },
              },
            },
          }),
            Qi(this, "uniforms"),
            (this.uniforms = this.resources.extractBrightnessUniforms.uniforms);
        }
        get threshold() {
          return this.uniforms.uThreshold;
        }
        set threshold(t) {
          this.uniforms.uThreshold = t;
        }
      };
      Qi(Ji, "DEFAULT_OPTIONS", { threshold: 0.5 });
      let tn = Ji;
      var en = Object.defineProperty,
        nn = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? en(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const sn = class t extends ct.d {
        constructor(e) {
          e = { ...t.DEFAULT_OPTIONS, ...e };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct AdvancedBloomUniforms {\n  uBloomScale: f32,\n  uBrightness: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> advancedBloomUniforms : AdvancedBloomUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color = textureSample(uTexture, uSampler, uv);\n  color = vec4<f32>(color.rgb * advancedBloomUniforms.uBrightness, color.a);\n\n  var bloomColor = vec4<f32>(textureSample(uMapTexture, uSampler, uv).rgb, 0.0);\n  bloomColor = vec4<f32>(bloomColor.rgb * advancedBloomUniforms.uBloomScale, bloomColor.a);\n  \n  return color + bloomColor;\n}\n",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\nuniform float uBloomScale;\nuniform float uBrightness;\n\nvoid main() {\n    vec4 color = texture(uTexture, vTextureCoord);\n    color.rgb *= uBrightness;\n    vec4 bloomColor = vec4(texture(uMapTexture, vTextureCoord).rgb, 0.0);\n    bloomColor.rgb *= uBloomScale;\n    finalColor = color + bloomColor;\n}\n",
              name: "advanced-bloom-filter",
            }),
            resources: {
              advancedBloomUniforms: {
                uBloomScale: { value: e.bloomScale, type: "f32" },
                uBrightness: { value: e.brightness, type: "f32" },
              },
              uMapTexture: a.g.WHITE,
            },
          }),
            nn(this, "uniforms"),
            nn(this, "bloomScale", 1),
            nn(this, "brightness", 1),
            nn(this, "_extractFilter"),
            nn(this, "_blurFilter"),
            (this.uniforms = this.resources.advancedBloomUniforms.uniforms),
            (this._extractFilter = new tn({ threshold: e.threshold })),
            (this._blurFilter = new Ki({
              strength: e.kernels ?? e.blur,
              quality: e.kernels ? void 0 : e.quality,
            })),
            Object.assign(this, e);
        }
        apply(t, e, i, n) {
          const s = gt.W.getSameSizeTexture(e);
          this._extractFilter.apply(t, e, s, !0);
          const r = gt.W.getSameSizeTexture(e);
          this._blurFilter.apply(t, s, r, !0),
            (this.uniforms.uBloomScale = this.bloomScale),
            (this.uniforms.uBrightness = this.brightness),
            (this.resources.uMapTexture = r.source),
            t.applyFilter(this, e, i, n),
            gt.W.returnTexture(r),
            gt.W.returnTexture(s);
        }
        get threshold() {
          return this._extractFilter.threshold;
        }
        set threshold(t) {
          this._extractFilter.threshold = t;
        }
        get kernels() {
          return this._blurFilter.kernels;
        }
        set kernels(t) {
          this._blurFilter.kernels = t;
        }
        get blur() {
          return this._blurFilter.strength;
        }
        set blur(t) {
          this._blurFilter.strength = t;
        }
        get quality() {
          return this._blurFilter.quality;
        }
        set quality(t) {
          this._blurFilter.quality = t;
        }
        get pixelSize() {
          return this._blurFilter.pixelSize;
        }
        set pixelSize(t) {
          "number" == typeof t && (t = { x: t, y: t }),
            Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this._blurFilter.pixelSize = t);
        }
        get pixelSizeX() {
          return this._blurFilter.pixelSizeX;
        }
        set pixelSizeX(t) {
          this._blurFilter.pixelSizeX = t;
        }
        get pixelSizeY() {
          return this._blurFilter.pixelSizeY;
        }
        set pixelSizeY(t) {
          this._blurFilter.pixelSizeY = t;
        }
      };
      nn(sn, "DEFAULT_OPTIONS", {
        threshold: 0.5,
        bloomScale: 1,
        brightness: 1,
        blur: 8,
        quality: 4,
        pixelSize: { x: 1, y: 1 },
      });
      var rn = Object.defineProperty,
        on = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? rn(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const an = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          "number" == typeof i &&
            ((0, yt.t)(
              "6.0.0",
              "AsciiFilter constructor params are now options object. See params: { size, color, replaceColor }"
            ),
            (i = { size: i }));
          const n = i?.color && !1 !== i.replaceColor;
          i = { ...t.DEFAULT_OPTIONS, ...i };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct AsciiUniforms {\n    uSize: f32,\n    uColor: vec3<f32>,\n    uReplaceColor: f32,\n};\n\nstruct GlobalFilterUniforms {\n    uInputSize:vec4<f32>,\n    uInputPixel:vec4<f32>,\n    uInputClamp:vec4<f32>,\n    uOutputFrame:vec4<f32>,\n    uGlobalFrame:vec4<f32>,\n    uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> asciiUniforms : AsciiUniforms;\n\n@fragment\nfn mainFragment(\n    @location(0) uv: vec2<f32>,\n    @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n    let pixelSize: f32 = asciiUniforms.uSize;\n    let coord: vec2<f32> = mapCoord(uv);\n\n    // get the rounded color..\n    var pixCoord: vec2<f32> = pixelate(coord, vec2<f32>(pixelSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    var color = textureSample(uTexture, uSampler, pixCoord);\n\n    // determine the character to use\n    let gray: f32 = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n    \n    var n: f32 = 65536.0; // .\n    if (gray > 0.2) {\n        n = 65600.0;    // :\n    }\n    if (gray > 0.3) {\n        n = 332772.0;   // *\n    }\n    if (gray > 0.4) {\n        n = 15255086.0; // o\n    }\n    if (gray > 0.5) {\n        n = 23385164.0; // &\n    }\n    if (gray > 0.6) {\n        n = 15252014.0; // 8\n    }\n    if (gray > 0.7) {\n        n = 13199452.0; // @\n    }\n    if (gray > 0.8) {\n        n = 11512810.0; // #\n    }\n\n    // get the mod..\n    let modd: vec2<f32> = getMod(coord, vec2<f32>(pixelSize));\n    return select(color, vec4<f32>(asciiUniforms.uColor, 1.), asciiUniforms.uReplaceColor > 0.5) * character(n, vec2<f32>(-1.0) + modd * 2.0);\n}\n\nfn pixelate(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\n{\n    return floor( coord / size ) * size;\n}\n\nfn getMod(coord: vec2<f32>, size: vec2<f32>) -> vec2<f32>\n{\n    return moduloVec2( coord , size) / size;\n}\n\nfn character(n: f32, p: vec2<f32>) -> f32\n{\n    var q: vec2<f32> = floor(p*vec2<f32>(4.0, 4.0) + 2.5);\n\n    if (clamp(q.x, 0.0, 4.0) == q.x)\n    {\n        if (clamp(q.y, 0.0, 4.0) == q.y)\n        {\n        if (i32(modulo(n/exp2(q.x + 5.0*q.y), 2.0)) == 1)\n        {\n            return 1.0;\n        }\n        }\n    }\n\n    return 0.0;\n}\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}\n\nfn moduloVec2(x: vec2<f32>, y: vec2<f32>) -> vec2<f32>\n{\n  return x - y * floor(x/y);\n}\n\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n    var mappedCoord: vec2<f32> = coord;\n    mappedCoord *= gfu.uInputSize.xy;\n    mappedCoord += gfu.uOutputFrame.xy;\n    return mappedCoord;\n}\n\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n    var mappedCoord: vec2<f32> = coord;\n    mappedCoord -= gfu.uOutputFrame.xy;\n    mappedCoord /= gfu.uInputSize.xy;\n    return mappedCoord;\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uSize;\nuniform vec3 uColor;\nuniform float uReplaceColor;\n\nuniform vec4 uInputSize;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= uInputSize.xy;\n    coord += uInputSize.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= uInputSize.zw;\n    coord /= uInputSize.xy;\n\n    return coord;\n}\n\nvec2 pixelate(vec2 coord, vec2 size)\n{\n    return floor(coord / size) * size;\n}\n\nvec2 getMod(vec2 coord, vec2 size)\n{\n    return mod(coord, size) / size;\n}\n\nfloat character(float n, vec2 p)\n{\n    p = floor(p*vec2(4.0, 4.0) + 2.5);\n\n    if (clamp(p.x, 0.0, 4.0) == p.x)\n    {\n        if (clamp(p.y, 0.0, 4.0) == p.y)\n        {\n            if (int(mod(n/exp2(p.x + 5.0*p.y), 2.0)) == 1) return 1.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main()\n{\n    vec2 coord = mapCoord(vTextureCoord);\n\n    // get the grid position\n    vec2 pixCoord = pixelate(coord, vec2(uSize));\n    pixCoord = unmapCoord(pixCoord);\n\n    // sample the color at grid position\n    vec4 color = texture(uTexture, pixCoord);\n\n    // brightness of the color as it's perceived by the human eye\n    float gray = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n\n    // determine the character to use\n    float n =  65536.0;             // .\n    if (gray > 0.2) n = 65600.0;    // :\n    if (gray > 0.3) n = 332772.0;   // *\n    if (gray > 0.4) n = 15255086.0; // o\n    if (gray > 0.5) n = 23385164.0; // &\n    if (gray > 0.6) n = 15252014.0; // 8\n    if (gray > 0.7) n = 13199452.0; // @\n    if (gray > 0.8) n = 11512810.0; // #\n\n    // get the mod..\n    vec2 modd = getMod(coord, vec2(uSize));\n\n    finalColor = (uReplaceColor > 0.5 ? vec4(uColor, 1.) : color) * character( n, vec2(-1.0) + modd * 2.0);\n}\n",
              name: "ascii-filter",
            }),
            resources: {
              asciiUniforms: {
                uSize: { value: i.size, type: "f32" },
                uColor: { value: new Float32Array(3), type: "vec3<f32>" },
                uReplaceColor: { value: Number(n), type: "f32" },
              },
            },
          }),
            on(this, "uniforms"),
            on(this, "_color"),
            (this.uniforms = this.resources.asciiUniforms.uniforms),
            (this._color = new at.Q()),
            (this.color = i.color ?? 16777215);
        }
        get size() {
          return this.uniforms.uSize;
        }
        set size(t) {
          this.uniforms.uSize = t;
        }
        get color() {
          return this._color.value;
        }
        set color(t) {
          this._color.setValue(t);
          const [e, i, n] = this._color.toArray();
          (this.uniforms.uColor[0] = e),
            (this.uniforms.uColor[1] = i),
            (this.uniforms.uColor[2] = n);
        }
        get replaceColor() {
          return this.uniforms.uReplaceColor > 0.5;
        }
        set replaceColor(t) {
          this.uniforms.uReplaceColor = t ? 1 : 0;
        }
      };
      on(an, "DEFAULT_OPTIONS", { size: 8, color: 16777215, replaceColor: !1 });
      Object.defineProperty;
      var ln = Object.defineProperty,
        un = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? ln(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const hn = class t extends ct.d {
        constructor(e) {
          const i =
            ((e = { ...t.DEFAULT_OPTIONS, ...e }).rotation ?? 45) * kt.Td;
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct BevelUniforms {\n  uLightColor: vec3<f32>,\n  uLightAlpha: f32,\n  uShadowColor: vec3<f32>,\n  uShadowAlpha: f32,\n  uTransform: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> bevelUniforms : BevelUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let transform = vec2<f32>(1.0 / gfu.uInputSize.xy) * vec2<f32>(bevelUniforms.uTransform.x, bevelUniforms.uTransform.y);\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let lightSample: f32 = textureSample(uTexture, uSampler, uv - transform).a;\n  let shadowSample: f32 = textureSample(uTexture, uSampler, uv + transform).a;\n\n  let light = vec4<f32>(bevelUniforms.uLightColor, bevelUniforms.uLightAlpha);\n  let shadow = vec4<f32>(bevelUniforms.uShadowColor, bevelUniforms.uShadowAlpha);\n\n  color = vec4<f32>(mix(color.rgb, light.rgb, clamp((color.a - lightSample) * light.a, 0.0, 1.0)), color.a);\n  color = vec4<f32>(mix(color.rgb, shadow.rgb, clamp((color.a - shadowSample) * shadow.a, 0.0, 1.0)), color.a);\n  \n  return vec4<f32>(color.rgb * color.a, color.a);\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uTransform;\nuniform vec3 uLightColor;\nuniform float uLightAlpha;\nuniform vec3 uShadowColor;\nuniform float uShadowAlpha;\n\nuniform vec4 uInputSize;\n\nvoid main(void) {\n    vec2 transform = vec2(1.0 / uInputSize) * vec2(uTransform.x, uTransform.y);\n    vec4 color = texture(uTexture, vTextureCoord);\n    float light = texture(uTexture, vTextureCoord - transform).a;\n    float shadow = texture(uTexture, vTextureCoord + transform).a;\n\n    color.rgb = mix(color.rgb, uLightColor, clamp((color.a - light) * uLightAlpha, 0.0, 1.0));\n    color.rgb = mix(color.rgb, uShadowColor, clamp((color.a - shadow) * uShadowAlpha, 0.0, 1.0));\n    finalColor = vec4(color.rgb * color.a, color.a);\n}\n",
              name: "bevel-filter",
            }),
            resources: {
              bevelUniforms: {
                uLightColor: { value: new Float32Array(3), type: "vec3<f32>" },
                uLightAlpha: { value: e.lightAlpha, type: "f32" },
                uShadowColor: { value: new Float32Array(3), type: "vec3<f32>" },
                uShadowAlpha: { value: e.shadowAlpha, type: "f32" },
                uTransform: { value: new Float32Array(2), type: "vec2<f32>" },
              },
            },
            padding: 1,
          }),
            un(this, "uniforms"),
            un(this, "_thickness"),
            un(this, "_rotation"),
            un(this, "_lightColor"),
            un(this, "_shadowColor"),
            (this.uniforms = this.resources.bevelUniforms.uniforms),
            (this._lightColor = new at.Q()),
            (this._shadowColor = new at.Q()),
            (this.lightColor = e.lightColor ?? 16777215),
            (this.shadowColor = e.shadowColor ?? 0),
            Object.assign(this, e, { rotation: i });
        }
        get rotation() {
          return this._rotation / kt.Td;
        }
        set rotation(t) {
          (this._rotation = t * kt.Td), this._updateTransform();
        }
        get thickness() {
          return this._thickness;
        }
        set thickness(t) {
          (this._thickness = t), this._updateTransform();
        }
        get lightColor() {
          return this._lightColor.value;
        }
        set lightColor(t) {
          this._lightColor.setValue(t);
          const [e, i, n] = this._lightColor.toArray();
          (this.uniforms.uLightColor[0] = e),
            (this.uniforms.uLightColor[1] = i),
            (this.uniforms.uLightColor[2] = n);
        }
        get lightAlpha() {
          return this.uniforms.uLightAlpha;
        }
        set lightAlpha(t) {
          this.uniforms.uLightAlpha = t;
        }
        get shadowColor() {
          return this._shadowColor.value;
        }
        set shadowColor(t) {
          this._shadowColor.setValue(t);
          const [e, i, n] = this._shadowColor.toArray();
          (this.uniforms.uShadowColor[0] = e),
            (this.uniforms.uShadowColor[1] = i),
            (this.uniforms.uShadowColor[2] = n);
        }
        get shadowAlpha() {
          return this.uniforms.uShadowAlpha;
        }
        set shadowAlpha(t) {
          this.uniforms.uShadowAlpha = t;
        }
        _updateTransform() {
          (this.uniforms.uTransform[0] =
            this.thickness * Math.cos(this._rotation)),
            (this.uniforms.uTransform[1] =
              this.thickness * Math.sin(this._rotation));
        }
      };
      un(hn, "DEFAULT_OPTIONS", {
        rotation: 45,
        thickness: 2,
        lightColor: 16777215,
        lightAlpha: 0.7,
        shadowColor: 0,
        shadowAlpha: 0.7,
      });
      var cn = Object.defineProperty,
        dn = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? cn(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const pn = class t extends mt {
        constructor(...e) {
          let i = e[0] ?? {};
          if (
            "number" == typeof i ||
            Array.isArray(i) ||
            ("x" in i && "y" in i)
          ) {
            (0, yt.t)(
              "6.0.0",
              "BloomFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"
            );
            let t = i;
            Array.isArray(t) && (t = { x: t[0], y: t[1] }),
              (i = { strength: t }),
              void 0 !== e[1] && (i.quality = e[1]),
              void 0 !== e[2] && (i.resolution = e[2]),
              void 0 !== e[3] && (i.kernelSize = e[3]);
          }
          (i = { ...t.DEFAULT_OPTIONS, ...i }),
            super(),
            dn(this, "_blurXFilter"),
            dn(this, "_blurYFilter"),
            dn(this, "_strength"),
            (this._strength = { x: 2, y: 2 }),
            i.strength &&
              ("number" == typeof i.strength
                ? ((this._strength.x = i.strength),
                  (this._strength.y = i.strength))
                : ((this._strength.x = i.strength.x),
                  (this._strength.y = i.strength.y))),
            (this._blurXFilter = new Tt({
              ...i,
              horizontal: !0,
              strength: this.strengthX,
            })),
            (this._blurYFilter = new Tt({
              ...i,
              horizontal: !1,
              strength: this.strengthY,
            })),
            (this._blurYFilter.blendMode = "screen"),
            Object.assign(this, i);
        }
        apply(t, e, i, n) {
          const s = gt.W.getSameSizeTexture(e);
          t.applyFilter(this, e, i, n),
            this._blurXFilter.apply(t, e, s, !0),
            this._blurYFilter.apply(t, s, i, !1),
            gt.W.returnTexture(s);
        }
        get strength() {
          return this._strength;
        }
        set strength(t) {
          (this._strength = "number" == typeof t ? { x: t, y: t } : t),
            this._updateStrength();
        }
        get strengthX() {
          return this.strength.x;
        }
        set strengthX(t) {
          (this.strength.x = t), this._updateStrength();
        }
        get strengthY() {
          return this.strength.y;
        }
        set strengthY(t) {
          (this.strength.y = t), this._updateStrength();
        }
        _updateStrength() {
          (this._blurXFilter.blur = this.strengthX),
            (this._blurYFilter.blur = this.strengthY);
        }
        get blur() {
          return (
            (0, yt.t)(
              "6.0.0",
              "BloomFilter.blur is deprecated, please use BloomFilter.strength instead"
            ),
            this.strengthX
          );
        }
        set blur(t) {
          (0, yt.t)(
            "6.0.0",
            "BloomFilter.blur is deprecated, please use BloomFilter.strength instead"
          ),
            (this.strength = t);
        }
        get blurX() {
          return (
            (0, yt.t)(
              "6.0.0",
              "BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead"
            ),
            this.strengthX
          );
        }
        set blurX(t) {
          (0, yt.t)(
            "6.0.0",
            "BloomFilter.blurX is deprecated, please use BloomFilter.strengthX instead"
          ),
            (this.strengthX = t);
        }
        get blurY() {
          return (
            (0, yt.t)(
              "6.0.0",
              "BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead"
            ),
            this.strengthY
          );
        }
        set blurY(t) {
          (0, yt.t)(
            "6.0.0",
            "BloomFilter.blurY is deprecated, please use BloomFilter.strengthY instead"
          ),
            (this.strengthY = t);
        }
      };
      dn(pn, "DEFAULT_OPTIONS", {
        strength: { x: 2, y: 2 },
        quality: 4,
        resolution: 1,
        kernelSize: 5,
      });
      var fn = Object.defineProperty,
        mn = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? fn(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const gn = class t extends ct.d {
        constructor(e) {
          e = { ...t.DEFAULT_OPTIONS, ...e };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct BulgePinchUniforms {\n  uDimensions: vec2<f32>,\n  uCenter: vec2<f32>,\n  uRadius: f32,\n  uStrength: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> bulgePinchUniforms : BulgePinchUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let dimensions: vec2<f32> = bulgePinchUniforms.uDimensions;\n  let center: vec2<f32> = bulgePinchUniforms.uCenter;\n  let radius: f32 = bulgePinchUniforms.uRadius;\n  let strength: f32 = bulgePinchUniforms.uStrength;\n  var coord: vec2<f32> = (uv * gfu.uInputSize.xy) - center * dimensions.xy;\n\n  let distance: f32 = length(coord);\n\n  if (distance < radius) {\n      let percent: f32 = distance / radius;\n      if (strength > 0.0) {\n          coord *= mix(1.0, smoothstep(0.0, radius / distance, percent), strength * 0.75);\n      } else {\n          coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\n      }\n  }\n    coord += (center * dimensions.xy);\n    coord /= gfu.uInputSize.xy;\n\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\n    var color: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\n    if (coord.x != clampedCoord.x && coord.y != clampedCoord.y) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    return color;\n}\n\nfn compareVec2(x: vec2<f32>, y: vec2<f32>) -> bool\n{\n  if (x.x == y.x && x.y == y.y)\n  {\n    return true;\n  }\n\n  return false;\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uDimensions;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform float uStrength;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nvoid main()\n{\n    vec2 coord = vTextureCoord * uInputSize.xy;\n    coord -= uCenter * uDimensions.xy;\n    float distance = length(coord);\n\n    if (distance < uRadius) {\n        float percent = distance / uRadius;\n        if (uStrength > 0.0) {\n            coord *= mix(1.0, smoothstep(0.0, uRadius / distance, percent), uStrength * 0.75);\n        } else {\n            coord *= mix(1.0, pow(percent, 1.0 + uStrength * 0.75) * uRadius / distance, 1.0 - percent);\n        }\n    }\n\n    coord += uCenter * uDimensions.xy;\n    coord /= uInputSize.xy;\n    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\n    vec4 color = texture(uTexture, clampedCoord);\n\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    finalColor = color;\n}\n",
              name: "bulge-pinch-filter",
            }),
            resources: {
              bulgePinchUniforms: {
                uDimensions: { value: [0, 0], type: "vec2<f32>" },
                uCenter: { value: e.center, type: "vec2<f32>" },
                uRadius: { value: e.radius, type: "f32" },
                uStrength: { value: e.strength, type: "f32" },
              },
            },
          }),
            mn(this, "uniforms"),
            (this.uniforms = this.resources.bulgePinchUniforms.uniforms),
            Object.assign(this, e);
        }
        apply(t, e, i, n) {
          (this.uniforms.uDimensions[0] = e.frame.width),
            (this.uniforms.uDimensions[1] = e.frame.height),
            t.applyFilter(this, e, i, n);
        }
        get center() {
          return this.uniforms.uCenter;
        }
        set center(t) {
          "number" == typeof t && (t = { x: t, y: t }),
            Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this.uniforms.uCenter = t);
        }
        get centerX() {
          return this.uniforms.uCenter.x;
        }
        set centerX(t) {
          this.uniforms.uCenter.x = t;
        }
        get centerY() {
          return this.uniforms.uCenter.y;
        }
        set centerY(t) {
          this.uniforms.uCenter.y = t;
        }
        get radius() {
          return this.uniforms.uRadius;
        }
        set radius(t) {
          this.uniforms.uRadius = t;
        }
        get strength() {
          return this.uniforms.uStrength;
        }
        set strength(t) {
          this.uniforms.uStrength = t;
        }
      };
      mn(gn, "DEFAULT_OPTIONS", {
        center: { x: 0.5, y: 0.5 },
        radius: 100,
        strength: 1,
      });
      var vn,
        yn,
        xn =
          "struct BaseUniforms {\n  uOptions: vec4<f32>,\n  uCounts: vec2<f32>,\n};\n\nstruct StopsUniforms {\n  uColors: array<vec3<f32>, MAX_STOPS>,\n  uStops: array<vec4<f32>, MAX_STOPS>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> baseUniforms : BaseUniforms;\n@group(1) @binding(1) var<uniform> stopsUniforms : StopsUniforms;\n\nstruct VSOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>,\n  @location(1) coord : vec2<f32>\n};\n\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\n{\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn filterCoord( vTextureCoord:vec2<f32> ) -> vec2<f32>\n{\n    return vTextureCoord * gfu.uInputSize.xy / gfu.uOutputFrame.zw;\n}\n\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -> vec2<f32>\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2<f32>, \n) -> VSOutput {\n  let vTextureCoord: vec2<f32> = filterTextureCoord(aPosition);\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   vTextureCoord,\n   filterCoord(vTextureCoord),\n  );\n}\n\nstruct ColorStop {\n  offset: f32,\n  color: vec3<f32>,\n  alpha: f32,\n};\n\nfn rotate2d(angle: f32) -> mat2x2<f32>{\n  return mat2x2(cos(angle), -sin(angle),\n  sin(angle), cos(angle));\n}\n\nfn projectLinearPosition(pos: vec2<f32>, angle: f32) -> f32 {\n  var center: vec2<f32> = vec2<f32>(0.5);\n  var result: vec2<f32> = pos - center;\n  result = rotate2d(angle) * result;\n  result = result + center;\n  return clamp(result.x, 0.0, 1.0);\n}\n\nfn projectRadialPosition(pos: vec2<f32>) -> f32 {\n  var r: f32 = distance(pos, vec2<f32>(0.5));\n  return clamp(2.0 * r, 0.0, 1.0);\n}\n\nfn projectAnglePosition(pos: vec2<f32>, angle: f32) -> f32 {\n  var center: vec2<f32> = pos - vec2<f32>(0.5, 0.5);\n  var polarAngle: f32 = atan2(-center.y, center.x);\n  return ((polarAngle + angle) % PI_2) / PI_2;\n}\n\nfn projectPosition(pos: vec2<f32>, gradientType: i32, angle: f32) -> f32 {\n  if (gradientType == TYPE_LINEAR) {\n      return projectLinearPosition(pos, angle);\n  } else if (gradientType == TYPE_RADIAL) {\n      return projectRadialPosition(pos);\n  } else if (gradientType == TYPE_CONIC) {\n      return projectAnglePosition(pos, angle);\n  }\n\n  return pos.y;\n}\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>,\n  @location(1) coord : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uType: i32 = i32(baseUniforms.uOptions[0]);\n  let uAngle: f32 = baseUniforms.uOptions[1];\n  let uAlpha: f32 = baseUniforms.uOptions[2];\n  let uReplace: f32 = baseUniforms.uOptions[3];\n\n  let uNumStops: i32 = i32(baseUniforms.uCounts[0]);\n  let uMaxColors: f32 = baseUniforms.uCounts[1];\n\n  // current/original color\n  var currentColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  // skip calculations if gradient alpha is 0\n  if (uAlpha == 0.0) { return currentColor; }\n\n  // project position\n  var y: f32 = projectPosition(coord, uType, radians(uAngle));\n\n  // check gradient bounds\n  var offsetMin: f32 = stopsUniforms.uStops[0][0];\n  var offsetMax: f32 = 0.0;\n\n  let numStops: i32 = uNumStops;\n\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\n      if (i == numStops - 1) { // last index\n          offsetMax = stopsUniforms.uStops[i][0];\n      }\n  }\n\n  if (y  < offsetMin || y > offsetMax) { return currentColor; }\n\n  // limit colors\n  if (uMaxColors > 0.0) {\n      var stepSize: f32 = 1.0 / uMaxColors;\n      var stepNumber: f32 = floor(y / stepSize);\n      y = stepSize * (stepNumber + 0.5); // offset by 0.5 to use color from middle of segment\n  }\n\n  // find color stops\n  var stopFrom: ColorStop;\n  var stopTo: ColorStop;\n\n  for (var i: i32 = 0; i < MAX_STOPS; i = i + 1) {\n      if (y >= stopsUniforms.uStops[i][0]) {\n          stopFrom = ColorStop(stopsUniforms.uStops[i][0], stopsUniforms.uColors[i], stopsUniforms.uStops[i][1]);\n          stopTo = ColorStop(stopsUniforms.uStops[i + 1][0], stopsUniforms.uColors[i + 1], stopsUniforms.uStops[i + 1][1]);\n      }\n\n      if (i == numStops - 1) { // last index\n          break;\n      }\n  }\n\n  // mix colors from stops\n  var colorFrom: vec4<f32> = vec4<f32>(stopFrom.color * stopFrom.alpha, stopFrom.alpha);\n  var colorTo: vec4<f32> = vec4<f32>(stopTo.color * stopTo.alpha, stopTo.alpha);\n\n  var segmentHeight: f32 = stopTo.offset - stopFrom.offset;\n  var relativePos: f32 = y - stopFrom.offset; // position from 0 to [segmentHeight]\n  var relativePercent: f32 = relativePos / segmentHeight; // position in percent between [from.offset] and [to.offset].\n\n  var gradientAlpha: f32 = uAlpha * currentColor.a;\n  var gradientColor: vec4<f32> = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\n\n  if (uReplace < 0.5) {\n      // mix resulting color with current color\n      return gradientColor + currentColor * (1.0 - gradientColor.a);\n  } else {\n      // replace with gradient color\n      return gradientColor;\n  }\n}\n\nconst PI: f32 = 3.14159265358979323846264;\nconst PI_2: f32 = PI * 2.0;\n\nconst TYPE_LINEAR: i32 = 0;\nconst TYPE_RADIAL: i32 = 1;\nconst TYPE_CONIC: i32 = 2;\nconst MAX_STOPS: i32 = 32;";
      ((yn = yn || {}).stringify =
        ((vn = {
          "visit_linear-gradient": function (t) {
            return vn.visit_gradient(t);
          },
          "visit_repeating-linear-gradient": function (t) {
            return vn.visit_gradient(t);
          },
          "visit_radial-gradient": function (t) {
            return vn.visit_gradient(t);
          },
          "visit_repeating-radial-gradient": function (t) {
            return vn.visit_gradient(t);
          },
          visit_gradient: function (t) {
            var e = vn.visit(t.orientation);
            return (
              e && (e += ", "), t.type + "(" + e + vn.visit(t.colorStops) + ")"
            );
          },
          visit_shape: function (t) {
            var e = t.value,
              i = vn.visit(t.at),
              n = vn.visit(t.style);
            return n && (e += " " + n), i && (e += " at " + i), e;
          },
          "visit_default-radial": function (t) {
            var e = "",
              i = vn.visit(t.at);
            return i && (e += i), e;
          },
          "visit_extent-keyword": function (t) {
            var e = t.value,
              i = vn.visit(t.at);
            return i && (e += " at " + i), e;
          },
          "visit_position-keyword": function (t) {
            return t.value;
          },
          visit_position: function (t) {
            return vn.visit(t.value.x) + " " + vn.visit(t.value.y);
          },
          "visit_%": function (t) {
            return t.value + "%";
          },
          visit_em: function (t) {
            return t.value + "em";
          },
          visit_px: function (t) {
            return t.value + "px";
          },
          visit_literal: function (t) {
            return vn.visit_color(t.value, t);
          },
          visit_hex: function (t) {
            return vn.visit_color("#" + t.value, t);
          },
          visit_rgb: function (t) {
            return vn.visit_color("rgb(" + t.value.join(", ") + ")", t);
          },
          visit_rgba: function (t) {
            return vn.visit_color("rgba(" + t.value.join(", ") + ")", t);
          },
          visit_color: function (t, e) {
            var i = t,
              n = vn.visit(e.length);
            return n && (i += " " + n), i;
          },
          visit_angular: function (t) {
            return t.value + "deg";
          },
          visit_directional: function (t) {
            return "to " + t.value;
          },
          visit_array: function (t) {
            var e = "",
              i = t.length;
            return (
              t.forEach(function (t, n) {
                (e += vn.visit(t)), n < i - 1 && (e += ", ");
              }),
              e
            );
          },
          visit: function (t) {
            if (!t) return "";
            if (t instanceof Array) return vn.visit_array(t, "");
            if (t.type) {
              var e = vn["visit_" + t.type];
              if (e) return e(t);
              throw Error("Missing visitor visit_" + t.type);
            }
            throw Error("Invalid node.");
          },
        }),
        function (t) {
          return vn.visit(t);
        })),
        ((yn = yn || {}).parse = (function () {
          var t = {
              linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
              repeatingLinearGradient:
                /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
              radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
              repeatingRadialGradient:
                /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
              sideOrCorner:
                /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
              extentKeywords:
                /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
              positionKeywords: /^(left|center|right|top|bottom)/i,
              pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
              percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
              emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
              angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
              startCall: /^\(/,
              endCall: /^\)/,
              comma: /^,/,
              hexColor: /^\#([0-9a-fA-F]+)/,
              literalColor: /^([a-zA-Z]+)/,
              rgbColor: /^rgb/i,
              rgbaColor: /^rgba/i,
              number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/,
            },
            e = "";
          function i(t) {
            var i = new Error(e + ": " + t);
            throw ((i.source = e), i);
          }
          function n() {
            var t = p(s);
            return e.length > 0 && i("Invalid input not EOF"), t;
          }
          function s() {
            return (
              r("linear-gradient", t.linearGradient, a) ||
              r("repeating-linear-gradient", t.repeatingLinearGradient, a) ||
              r("radial-gradient", t.radialGradient, l) ||
              r("repeating-radial-gradient", t.repeatingRadialGradient, l)
            );
          }
          function r(e, n, s) {
            return o(n, function (n) {
              var r = s();
              return (
                r && (x(t.comma) || i("Missing comma before color stops")),
                { type: e, orientation: r, colorStops: p(f) }
              );
            });
          }
          function o(e, n) {
            var s = x(e);
            if (s) {
              x(t.startCall) || i("Missing (");
              var r = n(s);
              return x(t.endCall) || i("Missing )"), r;
            }
          }
          function a() {
            return (
              y("directional", t.sideOrCorner, 1) ||
              y("angular", t.angleValue, 1)
            );
          }
          function l() {
            var i,
              n,
              s = u();
            return (
              s &&
                ((i = []).push(s),
                (n = e),
                x(t.comma) && ((s = u()) ? i.push(s) : (e = n))),
              i
            );
          }
          function u() {
            var t =
              (function () {
                var t = y("shape", /^(circle)/i, 0);
                t && (t.style = v() || h());
                return t;
              })() ||
              (function () {
                var t = y("shape", /^(ellipse)/i, 0);
                t && (t.style = g() || h());
                return t;
              })();
            if (t) t.at = c();
            else {
              var e = h();
              if (e) {
                t = e;
                var i = c();
                i && (t.at = i);
              } else {
                var n = d();
                n && (t = { type: "default-radial", at: n });
              }
            }
            return t;
          }
          function h() {
            return y("extent-keyword", t.extentKeywords, 1);
          }
          function c() {
            if (y("position", /^at/, 0)) {
              var t = d();
              return t || i("Missing positioning value"), t;
            }
          }
          function d() {
            var t = { x: g(), y: g() };
            if (t.x || t.y) return { type: "position", value: t };
          }
          function p(e) {
            var n = e(),
              s = [];
            if (n)
              for (s.push(n); x(t.comma); )
                (n = e()) ? s.push(n) : i("One extra comma");
            return s;
          }
          function f() {
            var e =
              y("hex", t.hexColor, 1) ||
              o(t.rgbaColor, function () {
                return { type: "rgba", value: p(m) };
              }) ||
              o(t.rgbColor, function () {
                return { type: "rgb", value: p(m) };
              }) ||
              y("literal", t.literalColor, 0);
            return e || i("Expected color definition"), (e.length = g()), e;
          }
          function m() {
            return x(t.number)[1];
          }
          function g() {
            return (
              y("%", t.percentageValue, 1) ||
              y("position-keyword", t.positionKeywords, 1) ||
              v()
            );
          }
          function v() {
            return y("px", t.pixelValue, 1) || y("em", t.emValue, 1);
          }
          function y(t, e, i) {
            var n = x(e);
            if (n) return { type: t, value: n[i] };
          }
          function x(t) {
            var i, n;
            return (
              (n = /^[\n\r\t\s]+/.exec(e)) && b(n[0].length),
              (i = t.exec(e)) && b(i[0].length),
              i
            );
          }
          function b(t) {
            e = e.substr(t);
          }
          return function (t) {
            return (e = t.toString()), n();
          };
        })());
      var bn = yn.parse;
      function Sn(t) {
        const e = bn(
          (function (t) {
            let e = t.replace(/\s{2,}/gu, " ");
            return (
              (e = e.replace(/;/g, "")),
              (e = e.replace(/ ,/g, ",")),
              (e = e.replace(/\( /g, "(")),
              (e = e.replace(/ \)/g, ")")),
              e.trim()
            );
          })(t)
        );
        if (0 === e.length) throw new Error("Invalid CSS gradient.");
        if (1 !== e.length)
          throw new Error(
            "Unsupported CSS gradient (multiple gradients is not supported)."
          );
        const i = e[0];
        return {
          type: (function (t) {
            const e = { "linear-gradient": 0, "radial-gradient": 1 };
            if (!(t in e)) throw new Error(`Unsupported gradient type "${t}"`);
            return e[t];
          })(i.type),
          stops: (function (t) {
            const e = (function (t) {
                const e = [],
                  i = -1;
                for (let n = 0; n < t.length; n++) {
                  const s = t[n];
                  let r = i;
                  "literal" === s.type &&
                    s.length &&
                    "type" in s.length &&
                    "%" === s.length.type &&
                    "value" in s.length &&
                    (r = parseFloat(s.length.value) / 100),
                    e.push(r);
                }
                const n = (t) => {
                  for (let n = t; n < e.length; n++)
                    if (e[n] !== i) return { indexDelta: n - t, offset: e[n] };
                  return { indexDelta: e.length - 1 - t, offset: 1 };
                };
                let s = 0;
                for (let t = 0; t < e.length; t++) {
                  const r = e[t];
                  if (r !== i) s = r;
                  else if (0 === t) e[t] = 0;
                  else if (t + 1 === e.length) e[t] = 1;
                  else {
                    const i = n(t),
                      r = (i.offset - s) / (1 + i.indexDelta);
                    for (let n = 0; n <= i.indexDelta; n++)
                      e[t + n] = s + (n + 1) * r;
                    (t += i.indexDelta), (s = e[t]);
                  }
                }
                return e.map(_n);
              })(t),
              i = [],
              n = new at.Q();
            for (let s = 0; s < t.length; s++) {
              const r = Cn(t[s]),
                o = n.setValue(r).toArray();
              i.push({ offset: e[s], color: o.slice(0, 3), alpha: o[3] });
            }
            return i;
          })(i.colorStops),
          angle: (function (t) {
            if (void 0 === t) return 0;
            if ("type" in t && "value" in t)
              switch (t.type) {
                case "angular":
                  return parseFloat(t.value);
                case "directional":
                  return (function (t) {
                    const e = {
                      left: 270,
                      top: 0,
                      bottom: 180,
                      right: 90,
                      "left top": 315,
                      "top left": 315,
                      "left bottom": 225,
                      "bottom left": 225,
                      "right top": 45,
                      "top right": 45,
                      "right bottom": 135,
                      "bottom right": 135,
                    };
                    if (!(t in e))
                      throw new Error(`Unsupported directional value "${t}"`);
                    return e[t];
                  })(t.value);
              }
            return 0;
          })(i.orientation),
        };
      }
      function Cn(t) {
        switch (t.type) {
          case "hex":
            return `#${t.value}`;
          case "literal":
            return t.value;
          default:
            return `${t.type}(${t.value.join(",")})`;
        }
      }
      function _n(t) {
        return t.toString().length > 6
          ? parseFloat(t.toString().substring(0, 6))
          : t;
      }
      yn.stringify;
      var Tn = Object.defineProperty,
        wn = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? Tn(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Pn = class t extends ct.d {
        constructor(e) {
          if (
            !(e =
              e && "css" in e
                ? {
                    ...Sn(e.css || ""),
                    alpha: e.alpha ?? t.defaults.alpha,
                    maxColors: e.maxColors ?? t.defaults.maxColors,
                  }
                : { ...t.defaults, ...e }).stops ||
            e.stops.length < 2
          )
            throw new Error(
              "ColorGradientFilter requires at least 2 color stops."
            );
          super({
            gpuProgram: ut.B.from({
              vertex: { source: xn, entryPoint: "mainVertex" },
              fragment: { source: xn, entryPoint: "mainFragment" },
            }),
            glProgram: lt.M.from({
              vertex:
                "in vec2 aPosition;\nout vec2 vTextureCoord;\nout vec2 vFilterCoord;\n\nuniform vec4 uInputSize;\nuniform vec4 uOutputFrame;\nuniform vec4 uOutputTexture;\n\nvec4 filterVertexPosition( void )\n{\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\n    \n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nvec2 filterTextureCoord( void )\n{\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\n}\n\nvoid main(void)\n{\n    gl_Position = filterVertexPosition();\n    vTextureCoord = filterTextureCoord();\n    vFilterCoord = vTextureCoord * uInputSize.xy / uOutputFrame.zw;\n}\n",
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nin vec2 vFilterCoord;\nout vec4 finalColor;\n\nconst int TYPE_LINEAR = 0;\nconst int TYPE_RADIAL = 1;\nconst int TYPE_CONIC = 2;\nconst int MAX_STOPS = 32;\n\nuniform sampler2D uTexture;\nuniform vec4 uOptions;\nuniform vec2 uCounts;\nuniform vec3 uColors[MAX_STOPS];\nuniform vec4 uStops[MAX_STOPS];\n\nconst float PI = 3.1415926538;\nconst float PI_2 = PI*2.;\n\nstruct ColorStop {\n    float offset;\n    vec3 color;\n    float alpha;\n};\n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle), -sin(angle),\n    sin(angle), cos(angle));\n}\n\nfloat projectLinearPosition(vec2 pos, float angle){\n    vec2 center = vec2(0.5);\n    vec2 result = pos - center;\n    result = rotate2d(angle) * result;\n    result = result + center;\n    return clamp(result.x, 0., 1.);\n}\n\nfloat projectRadialPosition(vec2 pos) {\n    float r = distance(pos, vec2(0.5));\n    return clamp(2.*r, 0., 1.);\n}\n\nfloat projectAnglePosition(vec2 pos, float angle) {\n    vec2 center = pos - vec2(0.5);\n    float polarAngle=atan(-center.y, center.x);\n    return mod(polarAngle + angle, PI_2) / PI_2;\n}\n\nfloat projectPosition(vec2 pos, int type, float angle) {\n    if (type == TYPE_LINEAR) {\n        return projectLinearPosition(pos, angle);\n    } else if (type == TYPE_RADIAL) {\n        return projectRadialPosition(pos);\n    } else if (type == TYPE_CONIC) {\n        return projectAnglePosition(pos, angle);\n    }\n\n    return pos.y;\n}\n\nvoid main(void) {\n    int uType = int(uOptions[0]);\n    float uAngle = uOptions[1];\n    float uAlpha = uOptions[2];\n    float uReplace = uOptions[3];\n\n    int uNumStops = int(uCounts[0]);\n    float uMaxColors = uCounts[1];\n\n    // current/original color\n    vec4 currentColor = texture(uTexture, vTextureCoord);\n\n    // skip calculations if gradient alpha is 0\n    if (0.0 == uAlpha) {\n        finalColor = currentColor;\n        return;\n    }\n\n    // project position\n    float y = projectPosition(vFilterCoord, int(uType), radians(uAngle));\n\n    // check gradient bounds\n    float offsetMin = uStops[0][0];\n    float offsetMax = 0.0;\n\n    int numStops = int(uNumStops);\n\n    for (int i = 0; i < MAX_STOPS; i++) {\n        if (i == numStops-1){ // last index\n            offsetMax = uStops[i][0];\n        }\n    }\n\n    if (y  < offsetMin || y > offsetMax) {\n        finalColor = currentColor;\n        return;\n    }\n\n    // limit colors\n    if (uMaxColors > 0.) {\n        float stepSize = 1./uMaxColors;\n        float stepNumber = float(floor(y/stepSize));\n        y = stepSize * (stepNumber + 0.5);// offset by 0.5 to use color from middle of segment\n    }\n\n    // find color stops\n    ColorStop from;\n    ColorStop to;\n\n    for (int i = 0; i < MAX_STOPS; i++) {\n        if (y >= uStops[i][0]) {\n            from = ColorStop(uStops[i][0], uColors[i], uStops[i][1]);\n            to = ColorStop(uStops[i+1][0], uColors[i+1], uStops[i+1][1]);\n        }\n\n        if (i == numStops-1){ // last index\n            break;\n        }\n    }\n\n    // mix colors from stops\n    vec4 colorFrom = vec4(from.color * from.alpha, from.alpha);\n    vec4 colorTo = vec4(to.color * to.alpha, to.alpha);\n\n    float segmentHeight = to.offset - from.offset;\n    float relativePos = y - from.offset;// position from 0 to [segmentHeight]\n    float relativePercent = relativePos / segmentHeight;// position in percent between [from.offset] and [to.offset].\n\n    float gradientAlpha = uAlpha * currentColor.a;\n    vec4 gradientColor = mix(colorFrom, colorTo, relativePercent) * gradientAlpha;\n\n    if (uReplace < 0.5) {\n        // mix resulting color with current color\n        finalColor = gradientColor + currentColor*(1.-gradientColor.a);\n    } else {\n        // replace with gradient color\n        finalColor = gradientColor;\n    }\n}\n",
              name: "color-gradient-filter",
            }),
            resources: {
              baseUniforms: {
                uOptions: {
                  value: [e.type, e.angle ?? 90, e.alpha, e.replace ? 1 : 0],
                  type: "vec4<f32>",
                },
                uCounts: {
                  value: [e.stops.length, e.maxColors],
                  type: "vec2<f32>",
                },
              },
              stopsUniforms: {
                uColors: {
                  value: new Float32Array(96),
                  type: "vec3<f32>",
                  size: 32,
                },
                uStops: {
                  value: new Float32Array(128),
                  type: "vec4<f32>",
                  size: 32,
                },
              },
            },
          }),
            wn(this, "baseUniforms"),
            wn(this, "stopsUniforms"),
            wn(this, "_stops", []),
            (this.baseUniforms = this.resources.baseUniforms.uniforms),
            (this.stopsUniforms = this.resources.stopsUniforms.uniforms),
            Object.assign(this, e);
        }
        get stops() {
          return this._stops;
        }
        set stops(t) {
          const e = (function (t) {
              return [...t].sort((t, e) => t.offset - e.offset);
            })(t),
            i = new at.Q();
          let n, s, r;
          for (let t = 0; t < e.length; t++) {
            i.setValue(e[t].color);
            const o = 3 * t;
            ([n, s, r] = i.toArray()),
              (this.stopsUniforms.uColors[o] = n),
              (this.stopsUniforms.uColors[o + 1] = s),
              (this.stopsUniforms.uColors[o + 2] = r),
              (this.stopsUniforms.uStops[4 * t] = e[t].offset),
              (this.stopsUniforms.uStops[4 * t + 1] = e[t].alpha);
          }
          (this.baseUniforms.uCounts[0] = e.length), (this._stops = e);
        }
        get type() {
          return this.baseUniforms.uOptions[0];
        }
        set type(t) {
          this.baseUniforms.uOptions[0] = t;
        }
        get angle() {
          return this.baseUniforms.uOptions[1] + 90;
        }
        set angle(t) {
          this.baseUniforms.uOptions[1] = t - 90;
        }
        get alpha() {
          return this.baseUniforms.uOptions[2];
        }
        set alpha(t) {
          this.baseUniforms.uOptions[2] = t;
        }
        get maxColors() {
          return this.baseUniforms.uCounts[1];
        }
        set maxColors(t) {
          this.baseUniforms.uCounts[1] = t;
        }
        get replace() {
          return this.baseUniforms.uOptions[3] > 0.5;
        }
        set replace(t) {
          this.baseUniforms.uOptions[3] = t ? 1 : 0;
        }
      };
      wn(Pn, "LINEAR", 0),
        wn(Pn, "RADIAL", 1),
        wn(Pn, "CONIC", 2),
        wn(Pn, "defaults", {
          type: Pn.LINEAR,
          stops: [
            { offset: 0, color: 16711680, alpha: 1 },
            { offset: 1, color: 255, alpha: 1 },
          ],
          alpha: 1,
          angle: 90,
          maxColors: 0,
          replace: !1,
        });
      var An = Object.defineProperty,
        kn = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? An(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Mn = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          if (
            ((i instanceof a.g || i instanceof Ut.v) &&
              ((0, yt.t)(
                "6.0.0",
                "ColorMapFilter constructor params are now options object. See params: { colorMap, nearest, mix }"
              ),
              (i = { colorMap: i }),
              void 0 !== e[1] && (i.nearest = e[1]),
              void 0 !== e[2] && (i.mix = e[2])),
            (i = { ...t.DEFAULT_OPTIONS, ...i }),
            !i.colorMap)
          )
            throw Error(
              "No color map texture source was provided to ColorMapFilter"
            );
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct ColorMapUniforms {\n  uMix: f32,\n  uSize: f32,\n  uSliceSize: f32,\n  uSlicePixelSize: f32,\n  uSliceInnerSize: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> colorMapUniforms : ColorMapUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler: sampler;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color:vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  var adjusted: vec4<f32>;\n\n  var altColor: vec4<f32> = vec4<f32>(color.rgb / color.a, color.a);\n  let innerWidth: f32 = colorMapUniforms.uSize - 1.0;\n  let zSlice0: f32 = min(floor(color.b * innerWidth), innerWidth);\n  let zSlice1: f32 = min(zSlice0 + 1.0, innerWidth);\n  let xOffset: f32 = colorMapUniforms.uSlicePixelSize * 0.5 + color.r * colorMapUniforms.uSliceInnerSize;\n  let s0: f32 = xOffset + (zSlice0 * colorMapUniforms.uSliceSize);\n  let s1: f32 = xOffset + (zSlice1 * colorMapUniforms.uSliceSize);\n  let yOffset: f32 = colorMapUniforms.uSliceSize * 0.5 + color.g * (1.0 - colorMapUniforms.uSliceSize);\n  let slice0Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s0,yOffset));\n  let slice1Color: vec4<f32> = textureSample(uMapTexture, uMapSampler, vec2(s1,yOffset));\n  let zOffset: f32 = fract(color.b * innerWidth);\n  adjusted = mix(slice0Color, slice1Color, zOffset);\n  altColor = vec4<f32>(color.rgb * color.a, color.a);\n\n  let realColor: vec4<f32> = select(color, altColor, color.a > 0.0);\n\n  return vec4<f32>(mix(realColor, adjusted, colorMapUniforms.uMix).rgb, realColor.a);\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\nuniform float uMix;\nuniform float uSize;\nuniform float uSliceSize;\nuniform float uSlicePixelSize;\nuniform float uSliceInnerSize;\n\nvoid main() {\n    vec4 color = texture(uTexture, vTextureCoord.xy);\n    vec4 adjusted;\n\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n        float innerWidth = uSize - 1.0;\n        float zSlice0 = min(floor(color.b * innerWidth), innerWidth);\n        float zSlice1 = min(zSlice0 + 1.0, innerWidth);\n        float xOffset = uSlicePixelSize * 0.5 + color.r * uSliceInnerSize;\n        float s0 = xOffset + (zSlice0 * uSliceSize);\n        float s1 = xOffset + (zSlice1 * uSliceSize);\n        float yOffset = uSliceSize * 0.5 + color.g * (1.0 - uSliceSize);\n        vec4 slice0Color = texture(uMapTexture, vec2(s0,yOffset));\n        vec4 slice1Color = texture(uMapTexture, vec2(s1,yOffset));\n        float zOffset = fract(color.b * innerWidth);\n        adjusted = mix(slice0Color, slice1Color, zOffset);\n\n        color.rgb *= color.a;\n    }\n\n    finalColor = vec4(mix(color, adjusted, uMix).rgb, color.a);\n\n}",
              name: "color-map-filter",
            }),
            resources: {
              colorMapUniforms: {
                uMix: { value: i.mix, type: "f32" },
                uSize: { value: 0, type: "f32" },
                uSliceSize: { value: 0, type: "f32" },
                uSlicePixelSize: { value: 0, type: "f32" },
                uSliceInnerSize: { value: 0, type: "f32" },
              },
              uMapTexture: i.colorMap.source,
              uMapSampler: i.colorMap.source.style,
            },
          }),
            kn(this, "uniforms"),
            kn(this, "_size", 0),
            kn(this, "_sliceSize", 0),
            kn(this, "_slicePixelSize", 0),
            kn(this, "_sliceInnerSize", 0),
            kn(this, "_nearest", !1),
            kn(this, "_scaleMode", "linear"),
            kn(this, "_colorMap"),
            (this.uniforms = this.resources.colorMapUniforms.uniforms),
            Object.assign(this, i);
        }
        get mix() {
          return this.uniforms.uMix;
        }
        set mix(t) {
          this.uniforms.uMix = t;
        }
        get colorSize() {
          return this._size;
        }
        get colorMap() {
          return this._colorMap;
        }
        set colorMap(t) {
          if (!t || t === this.colorMap) return;
          const e = t instanceof a.g ? t.source : t;
          (e.style.scaleMode = this._scaleMode),
            (e.autoGenerateMipmaps = !1),
            (this._size = e.height),
            (this._sliceSize = 1 / this._size),
            (this._slicePixelSize = this._sliceSize / this._size),
            (this._sliceInnerSize = this._slicePixelSize * (this._size - 1)),
            (this.uniforms.uSize = this._size),
            (this.uniforms.uSliceSize = this._sliceSize),
            (this.uniforms.uSlicePixelSize = this._slicePixelSize),
            (this.uniforms.uSliceInnerSize = this._sliceInnerSize),
            (this.resources.uMapTexture = e),
            (this._colorMap = t);
        }
        get nearest() {
          return this._nearest;
        }
        set nearest(t) {
          (this._nearest = t), (this._scaleMode = t ? "nearest" : "linear");
          const e = this._colorMap;
          e &&
            e.source &&
            ((e.source.scaleMode = this._scaleMode),
            (e.source.autoGenerateMipmaps = !1),
            e.source.style.update(),
            e.source.update());
        }
        updateColorMap() {
          const t = this._colorMap;
          t?.source && (t.source.update(), (this.colorMap = t));
        }
        destroy() {
          this._colorMap?.destroy(), super.destroy();
        }
      };
      kn(Mn, "DEFAULT_OPTIONS", { colorMap: a.g.WHITE, nearest: !1, mix: 1 });
      var En = Object.defineProperty,
        In = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? En(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Dn = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          ("number" == typeof i ||
            Array.isArray(i) ||
            i instanceof Float32Array) &&
            ((0, yt.t)(
              "6.0.0",
              "ColorOverlayFilter constructor params are now options object. See params: { color, alpha }"
            ),
            (i = { color: i }),
            void 0 !== e[1] && (i.alpha = e[1])),
            (i = { ...t.DEFAULT_OPTIONS, ...i });
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct ColorOverlayUniforms {\n    uColor: vec3<f32>,\n    uAlpha: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> colorOverlayUniforms : ColorOverlayUniforms;\n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n    let c = textureSample(uTexture, uSampler, uv);\n    return vec4<f32>(mix(c.rgb, colorOverlayUniforms.uColor.rgb, c.a * colorOverlayUniforms.uAlpha), c.a);\n}\n",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec3 uColor;\nuniform float uAlpha;\n\nvoid main(void) {\n    vec4 c = texture(uTexture, vTextureCoord);\n    finalColor = vec4(mix(c.rgb, uColor.rgb, c.a * uAlpha), c.a);\n}\n",
              name: "color-overlay-filter",
            }),
            resources: {
              colorOverlayUniforms: {
                uColor: { value: new Float32Array(3), type: "vec3<f32>" },
                uAlpha: { value: i.alpha, type: "f32" },
              },
            },
          }),
            In(this, "uniforms"),
            In(this, "_color"),
            (this.uniforms = this.resources.colorOverlayUniforms.uniforms),
            (this._color = new at.Q()),
            (this.color = i.color ?? 0);
        }
        get color() {
          return this._color.value;
        }
        set color(t) {
          this._color.setValue(t);
          const [e, i, n] = this._color.toArray();
          (this.uniforms.uColor[0] = e),
            (this.uniforms.uColor[1] = i),
            (this.uniforms.uColor[2] = n);
        }
        get alpha() {
          return this.uniforms.uAlpha;
        }
        set alpha(t) {
          this.uniforms.uAlpha = t;
        }
      };
      In(Dn, "DEFAULT_OPTIONS", { color: 0, alpha: 1 });
      var Rn = Object.defineProperty,
        Bn = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? Rn(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Fn = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          ("number" == typeof i ||
            Array.isArray(i) ||
            i instanceof Float32Array) &&
            ((0, yt.t)(
              "6.0.0",
              "ColorReplaceFilter constructor params are now options object. See params: { originalColor, targetColor, tolerance }"
            ),
            (i = { originalColor: i }),
            void 0 !== e[1] && (i.targetColor = e[1]),
            void 0 !== e[2] && (i.tolerance = e[2])),
            (i = { ...t.DEFAULT_OPTIONS, ...i });
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct ColorReplaceUniforms {\n  uOriginalColor: vec3<f32>,\n  uTargetColor: vec3<f32>,\n  uTolerance: f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> colorReplaceUniforms : ColorReplaceUniforms;\n\n@fragment\nfn mainFragment(\n   @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let sample: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  let colorDiff: vec3<f32> = colorReplaceUniforms.uOriginalColor - (sample.rgb / max(sample.a, 0.0000000001));\n  let colorDistance: f32 = length(colorDiff);\n  let doReplace: f32 = step(colorDistance, colorReplaceUniforms.uTolerance);\n\n  return vec4<f32>(mix(sample.rgb, (colorReplaceUniforms.uTargetColor + colorDiff) * sample.a, doReplace), sample.a);\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec3 uOriginalColor;\nuniform vec3 uTargetColor;\nuniform float uTolerance;\n\nvoid main(void) {\n    vec4 c = texture(uTexture, vTextureCoord);\n    vec3 colorDiff = uOriginalColor - (c.rgb / max(c.a, 0.0000000001));\n    float colorDistance = length(colorDiff);\n    float doReplace = step(colorDistance, uTolerance);\n    finalColor = vec4(mix(c.rgb, (uTargetColor + colorDiff) * c.a, doReplace), c.a);\n}\n",
              name: "color-replace-filter",
            }),
            resources: {
              colorReplaceUniforms: {
                uOriginalColor: {
                  value: new Float32Array(3),
                  type: "vec3<f32>",
                },
                uTargetColor: { value: new Float32Array(3), type: "vec3<f32>" },
                uTolerance: { value: i.tolerance, type: "f32" },
              },
            },
          }),
            Bn(this, "uniforms"),
            Bn(this, "_originalColor"),
            Bn(this, "_targetColor"),
            (this.uniforms = this.resources.colorReplaceUniforms.uniforms),
            (this._originalColor = new at.Q()),
            (this._targetColor = new at.Q()),
            (this.originalColor = i.originalColor ?? 16711680),
            (this.targetColor = i.targetColor ?? 0),
            Object.assign(this, i);
        }
        get originalColor() {
          return this._originalColor.value;
        }
        set originalColor(t) {
          this._originalColor.setValue(t);
          const [e, i, n] = this._originalColor.toArray();
          (this.uniforms.uOriginalColor[0] = e),
            (this.uniforms.uOriginalColor[1] = i),
            (this.uniforms.uOriginalColor[2] = n);
        }
        get targetColor() {
          return this._targetColor.value;
        }
        set targetColor(t) {
          this._targetColor.setValue(t);
          const [e, i, n] = this._targetColor.toArray();
          (this.uniforms.uTargetColor[0] = e),
            (this.uniforms.uTargetColor[1] = i),
            (this.uniforms.uTargetColor[2] = n);
        }
        get tolerance() {
          return this.uniforms.uTolerance;
        }
        set tolerance(t) {
          this.uniforms.uTolerance = t;
        }
        set newColor(t) {
          (0, yt.t)(
            "6.0.0",
            "ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead"
          ),
            (this.targetColor = t);
        }
        get newColor() {
          return (
            (0, yt.t)(
              "6.0.0",
              "ColorReplaceFilter.newColor is deprecated, please use ColorReplaceFilter.targetColor instead"
            ),
            this.targetColor
          );
        }
        set epsilon(t) {
          (0, yt.t)(
            "6.0.0",
            "ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead"
          ),
            (this.tolerance = t);
        }
        get epsilon() {
          return (
            (0, yt.t)(
              "6.0.0",
              "ColorReplaceFilter.epsilon is deprecated, please use ColorReplaceFilter.tolerance instead"
            ),
            this.tolerance
          );
        }
      };
      Bn(Fn, "DEFAULT_OPTIONS", {
        originalColor: 16711680,
        targetColor: 0,
        tolerance: 0.4,
      });
      var On = Object.defineProperty,
        zn = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? On(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Ln = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          Array.isArray(i) &&
            ((0, yt.t)(
              "6.0.0",
              "ConvolutionFilter constructor params are now options object. See params: { matrix, width, height }"
            ),
            (i = { matrix: i }),
            void 0 !== e[1] && (i.width = e[1]),
            void 0 !== e[2] && (i.height = e[2])),
            (i = { ...t.DEFAULT_OPTIONS, ...i });
          const n = i.width ?? 200,
            s = i.height ?? 200;
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct ConvolutionUniforms {\n    uMatrix: mat3x3<f32>,\n    uTexelSize: vec2<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> convolutionUniforms : ConvolutionUniforms;\n\n@fragment\nfn mainFragment(\n    @location(0) uv: vec2<f32>,\n    @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n    let texelSize = convolutionUniforms.uTexelSize;\n    let matrix = convolutionUniforms.uMatrix;\n\n    let c11: vec4<f32> = textureSample(uTexture, uSampler, uv - texelSize); // top left\n    let c12: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y - texelSize.y)); // top center\n    let c13: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y - texelSize.y)); // top right\n\n    let c21: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y)); // mid left\n    let c22: vec4<f32> = textureSample(uTexture, uSampler, uv); // mid center\n    let c23: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x + texelSize.x, uv.y)); // mid right\n\n    let c31: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x - texelSize.x, uv.y + texelSize.y)); // bottom left\n    let c32: vec4<f32> = textureSample(uTexture, uSampler, vec2<f32>(uv.x, uv.y + texelSize.y)); // bottom center\n    let c33: vec4<f32> = textureSample(uTexture, uSampler, uv + texelSize); // bottom right\n\n    var finalColor: vec4<f32> = vec4<f32>(\n        c11 * matrix[0][0] + c12 * matrix[0][1] + c13 * matrix[0][2] +\n        c21 * matrix[1][0] + c22 * matrix[1][1] + c23 * matrix[1][2] +\n        c31 * matrix[2][0] + c32 * matrix[2][1] + c33 * matrix[2][2]\n    );\n\n    finalColor.a = c22.a;\n\n    return finalColor;\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uTexelSize;\nuniform mat3 uMatrix;\n\nvoid main(void)\n{\n    vec4 c11 = texture(uTexture, vTextureCoord - uTexelSize); // top left\n    vec4 c12 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y - uTexelSize.y)); // top center\n    vec4 c13 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y - uTexelSize.y)); // top right\n\n    vec4 c21 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y)); // mid left\n    vec4 c22 = texture(uTexture, vTextureCoord); // mid center\n    vec4 c23 = texture(uTexture, vec2(vTextureCoord.x + uTexelSize.x, vTextureCoord.y)); // mid right\n\n    vec4 c31 = texture(uTexture, vec2(vTextureCoord.x - uTexelSize.x, vTextureCoord.y + uTexelSize.y)); // bottom left\n    vec4 c32 = texture(uTexture, vec2(vTextureCoord.x, vTextureCoord.y + uTexelSize.y)); // bottom center\n    vec4 c33 = texture(uTexture, vTextureCoord + uTexelSize); // bottom right\n\n    finalColor =\n        c11 * uMatrix[0][0] + c12 * uMatrix[0][1] + c13 * uMatrix[0][2] +\n        c21 * uMatrix[1][0] + c22 * uMatrix[1][1] + c23 * uMatrix[1][2] +\n        c31 * uMatrix[2][0] + c32 * uMatrix[2][1] + c33 * uMatrix[2][2];\n\n    finalColor.a = c22.a;\n}",
              name: "convolution-filter",
            }),
            resources: {
              convolutionUniforms: {
                uMatrix: { value: i.matrix, type: "mat3x3<f32>" },
                uTexelSize: {
                  value: { x: 1 / n, y: 1 / s },
                  type: "vec2<f32>",
                },
              },
            },
          }),
            zn(this, "uniforms"),
            (this.uniforms = this.resources.convolutionUniforms.uniforms),
            (this.width = n),
            (this.height = s);
        }
        get matrix() {
          return this.uniforms.uMatrix;
        }
        set matrix(t) {
          t.forEach((t, e) => {
            this.uniforms.uMatrix[e] = t;
          });
        }
        get width() {
          return 1 / this.uniforms.uTexelSize.x;
        }
        set width(t) {
          this.uniforms.uTexelSize.x = 1 / t;
        }
        get height() {
          return 1 / this.uniforms.uTexelSize.y;
        }
        set height(t) {
          this.uniforms.uTexelSize.y = 1 / t;
        }
      };
      zn(Ln, "DEFAULT_OPTIONS", {
        matrix: new Float32Array(9),
        width: 200,
        height: 200,
      });
      ct.d;
      var Hn = Object.defineProperty,
        Un = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? Hn(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Nn = class t extends ct.d {
        constructor(e) {
          e = { ...t.DEFAULT_OPTIONS, ...e };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct CRTUniforms {\n    uLine: vec4<f32>,\n    uNoise: vec2<f32>,\n    uVignette: vec3<f32>,\n    uSeed: f32,\n    uTime: f32,\n    uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> crtUniforms : CRTUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n    \n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / crtUniforms.uDimensions;\n\n  let uNoise = crtUniforms.uNoise;\n\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\n  {\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\n  }\n\n  if (crtUniforms.uVignette[0] > 0.)\n  {\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\n  }\n\n  if (crtUniforms.uLine[1] > 0.0)\n  {\n    color = vec4<f32>(vec3<f32>(interlaceLines(color.rgb, uv)), color.a);  \n  }\n\n  return color;\n}\n\nconst SQRT_2: f32 = 1.414213;\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}\n\nfn rand(co: vec2<f32>) -> f32\n{\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\n}\n\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\n{\n  let uVignette = crtUniforms.uVignette;\n  let uDimensions = crtUniforms.uDimensions;\n  \n  let outter: f32 = SQRT_2 - uVignette[0] * SQRT_2;\n  var dir: vec2<f32> = vec2<f32>(0.5) - coord;\n  dir.y *= uDimensions.y / uDimensions.x;\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\n  return darker + (1.0 - darker) * (1.0 - uVignette[1]);\n}\n\nfn noise(coord: vec2<f32>) -> f32\n{\n  let uNoise = crtUniforms.uNoise;\n  let uSeed = crtUniforms.uSeed;\n\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\n}\n\nfn interlaceLines(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\n{\n  var color = co;\n\n  let uDimensions = crtUniforms.uDimensions;\n\n  let curvature: f32 = crtUniforms.uLine[0];\n  let lineWidth: f32 = crtUniforms.uLine[1];\n  let lineContrast: f32 = crtUniforms.uLine[2];\n  let verticalLine: f32 = crtUniforms.uLine[3];\n\n  let dir: vec2<f32> = vec2<f32>(coord * gfu.uInputSize.xy / uDimensions - 0.5);\n\n  let _c: f32 = select(1., curvature, curvature > 0.);\n  let k: f32 = select(1., (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c), curvature > 0.);\n  let uv: vec2<f32> = dir * k;\n  let v: f32 = select(uv.y * uDimensions.y, uv.x * uDimensions.x, verticalLine > 0.5) * min(1.0, 2.0 / lineWidth ) / _c;\n  let j: f32 = 1. + cos(v * 1.2 - crtUniforms.uTime) * 0.5 * lineContrast;\n  color *= j;\n\n  let segment: f32 = select(modulo((dir.y + .5) * uDimensions.y, 4.), modulo((dir.x + .5) * uDimensions.x, 4.), verticalLine > 0.5);\n  color *= 0.99 + ceil(segment) * 0.015;\n\n  return color;\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec4 uLine;\nuniform vec2 uNoise;\nuniform vec3 uVignette;\nuniform float uSeed;\nuniform float uTime;\nuniform vec2 uDimensions;\n\nuniform vec4 uInputSize;\n\nconst float SQRT_2 = 1.414213;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat vignette(vec3 co, vec2 coord)\n{\n    float outter = SQRT_2 - uVignette[0] * SQRT_2;\n    vec2 dir = vec2(0.5) - coord;\n    dir.y *= uDimensions.y / uDimensions.x;\n    float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignette[2] * SQRT_2), 0.0, 1.0);\n    return darker + (1.0 - darker) * (1.0 - uVignette[1]);\n}\n\nfloat noise(vec2 coord)\n{\n    vec2 pixelCoord = coord * uInputSize.xy;\n    pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\n    pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\n    return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\n}\n\nvec3 interlaceLines(vec3 co, vec2 coord)\n{\n    vec3 color = co;\n\n    float curvature = uLine[0];\n    float lineWidth = uLine[1];\n    float lineContrast = uLine[2];\n    float verticalLine = uLine[3];\n\n    vec2 dir = vec2(coord * uInputSize.xy / uDimensions - 0.5);\n\n    float _c = curvature > 0. ? curvature : 1.;\n    float k = curvature > 0. ? (length(dir * dir) * 0.25 * _c * _c + 0.935 * _c) : 1.;\n    vec2 uv = dir * k;\n    float v = verticalLine > 0.5 ? uv.x * uDimensions.x : uv.y * uDimensions.y;\n    v *= min(1.0, 2.0 / lineWidth ) / _c;\n    float j = 1. + cos(v * 1.2 - uTime) * 0.5 * lineContrast;\n    color *= j;\n\n    float segment = verticalLine > 0.5 ? mod((dir.x + .5) * uDimensions.x, 4.) : mod((dir.y + .5) * uDimensions.y, 4.);\n    color *= 0.99 + ceil(segment) * 0.015;\n\n    return color;\n}\n\nvoid main(void)\n{\n    finalColor = texture(uTexture, vTextureCoord);\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;\n\n    if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\n    {\n        float n = noise(vTextureCoord);\n        finalColor += vec4(n, n, n, finalColor.a);\n    }\n\n    if (uVignette[0] > 0.)\n    {\n        float v = vignette(finalColor.rgb, coord);\n        finalColor *= vec4(v, v, v, finalColor.a);\n    }\n\n    if (uLine[1] > 0.0)\n    {\n        finalColor = vec4(interlaceLines(finalColor.rgb, vTextureCoord), finalColor.a);  \n    }\n}\n",
              name: "crt-filter",
            }),
            resources: {
              crtUniforms: {
                uLine: { value: new Float32Array(4), type: "vec4<f32>" },
                uNoise: { value: new Float32Array(2), type: "vec2<f32>" },
                uVignette: { value: new Float32Array(3), type: "vec3<f32>" },
                uSeed: { value: e.seed, type: "f32" },
                uTime: { value: e.time, type: "f32" },
                uDimensions: { value: new Float32Array(2), type: "vec2<f32>" },
              },
            },
          }),
            Un(this, "uniforms"),
            Un(this, "seed"),
            Un(this, "time"),
            (this.uniforms = this.resources.crtUniforms.uniforms),
            Object.assign(this, e);
        }
        apply(t, e, i, n) {
          (this.uniforms.uDimensions[0] = e.frame.width),
            (this.uniforms.uDimensions[1] = e.frame.height),
            (this.uniforms.uSeed = this.seed),
            (this.uniforms.uTime = this.time),
            t.applyFilter(this, e, i, n);
        }
        get curvature() {
          return this.uniforms.uLine[0];
        }
        set curvature(t) {
          this.uniforms.uLine[0] = t;
        }
        get lineWidth() {
          return this.uniforms.uLine[1];
        }
        set lineWidth(t) {
          this.uniforms.uLine[1] = t;
        }
        get lineContrast() {
          return this.uniforms.uLine[2];
        }
        set lineContrast(t) {
          this.uniforms.uLine[2] = t;
        }
        get verticalLine() {
          return this.uniforms.uLine[3] > 0.5;
        }
        set verticalLine(t) {
          this.uniforms.uLine[3] = t ? 1 : 0;
        }
        get noise() {
          return this.uniforms.uNoise[0];
        }
        set noise(t) {
          this.uniforms.uNoise[0] = t;
        }
        get noiseSize() {
          return this.uniforms.uNoise[1];
        }
        set noiseSize(t) {
          this.uniforms.uNoise[1] = t;
        }
        get vignetting() {
          return this.uniforms.uVignette[0];
        }
        set vignetting(t) {
          this.uniforms.uVignette[0] = t;
        }
        get vignettingAlpha() {
          return this.uniforms.uVignette[1];
        }
        set vignettingAlpha(t) {
          this.uniforms.uVignette[1] = t;
        }
        get vignettingBlur() {
          return this.uniforms.uVignette[2];
        }
        set vignettingBlur(t) {
          this.uniforms.uVignette[2] = t;
        }
      };
      Un(Nn, "DEFAULT_OPTIONS", {
        curvature: 1,
        lineWidth: 1,
        lineContrast: 0.25,
        verticalLine: !1,
        noise: 0,
        noiseSize: 1,
        vignetting: 0.3,
        vignettingAlpha: 1,
        vignettingBlur: 0.3,
        time: 0,
        seed: 0,
      });
      var Gn = Object.defineProperty;
      const Vn = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          "number" == typeof i &&
            ((0, yt.t)(
              "6.0.0",
              "DotFilter constructor params are now options object. See params: { scale, angle, grayscale }"
            ),
            (i = { scale: i }),
            void 0 !== e[1] && (i.angle = e[1]),
            void 0 !== e[2] && (i.grayscale = e[2])),
            (i = { ...t.DEFAULT_OPTIONS, ...i });
          const n = {
            uScale: { value: i.scale, type: "f32" },
            uAngle: { value: i.angle, type: "f32" },
            uGrayScale: { value: i.grayscale ? 1 : 0, type: "f32" },
          };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct DotUniforms {\n  uScale:f32,\n  uAngle:f32,\n  uGrayScale:f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> dotUniforms : DotUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let gray: vec3<f32> = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)));\n  // dotUniforms.uGrayScale == 1 doesn't ever pass so it is converted to a float and compared to 0.5 instead \n  let finalColor: vec3<f32> = select(color.rgb, gray, f32(dotUniforms.uGrayScale) >= 0.5);\n\n  return vec4<f32>(finalColor * 10.0 - 5.0 + pattern(uv), color.a);\n}\n\nfn pattern(uv: vec2<f32>) -> f32\n{\n  let s: f32 = sin(dotUniforms.uAngle);\n  let c: f32 = cos(dotUniforms.uAngle);\n  \n  let tex: vec2<f32> = uv * gfu.uInputSize.xy;\n  \n  let p: vec2<f32> = vec2<f32>(\n      c * tex.x - s * tex.y,\n      s * tex.x + c * tex.y\n  ) * dotUniforms.uScale;\n\n  return (sin(p.x) * sin(p.y)) * 4.0;\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uAngle;\nuniform float uScale;\nuniform bool uGrayScale;\n\nuniform vec4 uInputSize;\n\nfloat pattern()\n{\n    float s = sin(uAngle), c = cos(uAngle);\n    vec2 tex = vTextureCoord * uInputSize.xy;\n    vec2 point = vec2(\n        c * tex.x - s * tex.y,\n        s * tex.x + c * tex.y\n    ) * uScale;\n    return (sin(point.x) * sin(point.y)) * 4.0;\n    }\n\n    void main()\n    {\n    vec4 color = texture(uTexture, vTextureCoord);\n    vec3 colorRGB = vec3(color);\n\n    if (uGrayScale)\n    {\n        colorRGB = vec3(color.r + color.g + color.b) / 3.0;\n    }\n\n    finalColor = vec4(colorRGB * 10.0 - 5.0 + pattern(), color.a);\n}\n",
              name: "dot-filter",
            }),
            resources: { dotUniforms: n },
          });
        }
        get scale() {
          return this.resources.dotUniforms.uniforms.uScale;
        }
        set scale(t) {
          this.resources.dotUniforms.uniforms.uScale = t;
        }
        get angle() {
          return this.resources.dotUniforms.uniforms.uAngle;
        }
        set angle(t) {
          this.resources.dotUniforms.uniforms.uAngle = t;
        }
        get grayscale() {
          return 1 === this.resources.dotUniforms.uniforms.uGrayScale;
        }
        set grayscale(t) {
          this.resources.dotUniforms.uniforms.uGrayScale = t ? 1 : 0;
        }
      };
      var jn;
      ((t, e, i) => {
        e in t
          ? Gn(t, e, {
              enumerable: !0,
              configurable: !0,
              writable: !0,
              value: i,
            })
          : (t[e] = i);
      })(Vn, "symbol" != typeof (jn = "DEFAULT_OPTIONS") ? jn + "" : jn, {
        scale: 1,
        angle: 5,
        grayscale: !0,
      });
      var $n = Object.defineProperty,
        qn = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? $n(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Wn = class t extends ct.d {
        constructor(e) {
          e = { ...t.DEFAULT_OPTIONS, ...e };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct DropShadowUniforms {\n  uAlpha: f32,\n  uColor: vec3<f32>,\n  uOffset: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> dropShadowUniforms : DropShadowUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv - dropShadowUniforms.uOffset * gfu.uInputSize.zw);\n\n  // Premultiply alpha\n  color = vec4<f32>(vec3<f32>(dropShadowUniforms.uColor.rgb * color.a), color.a);\n  // alpha user alpha\n  color *= dropShadowUniforms.uAlpha;\n\n  return color;\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uAlpha;\nuniform vec3 uColor;\nuniform vec2 uOffset;\n\nuniform vec4 uInputSize;\n\nvoid main(void){\n    vec4 sample = texture(uTexture, vTextureCoord - uOffset * uInputSize.zw);\n\n    // Premultiply alpha\n    sample.rgb = uColor.rgb * sample.a;\n\n    // alpha user alpha\n    sample *= uAlpha;\n\n    finalColor = sample;\n}",
              name: "drop-shadow-filter",
            }),
            resources: {
              dropShadowUniforms: {
                uAlpha: { value: e.alpha, type: "f32" },
                uColor: { value: new Float32Array(3), type: "vec3<f32>" },
                uOffset: { value: e.offset, type: "vec2<f32>" },
              },
            },
            resolution: e.resolution,
          }),
            qn(this, "uniforms"),
            qn(this, "shadowOnly", !1),
            qn(this, "_color"),
            qn(this, "_blurFilter"),
            qn(this, "_basePass"),
            (this.uniforms = this.resources.dropShadowUniforms.uniforms),
            (this._color = new at.Q()),
            (this.color = e.color ?? 0),
            (this._blurFilter = new Ki({
              strength: e.kernels ?? e.blur,
              quality: e.kernels ? void 0 : e.quality,
            })),
            (this._basePass = new ct.d({
              gpuProgram: ut.B.from({
                vertex: { source: Vi, entryPoint: "mainVertex" },
                fragment: {
                  source:
                    "\n                    @group(0) @binding(1) var uTexture: texture_2d<f32>; \n                    @group(0) @binding(2) var uSampler: sampler;\n                    @fragment\n                    fn mainFragment(\n                        @builtin(position) position: vec4<f32>,\n                        @location(0) uv : vec2<f32>\n                    ) -> @location(0) vec4<f32> {\n                        return textureSample(uTexture, uSampler, uv);\n                    }\n                    ",
                  entryPoint: "mainFragment",
                },
              }),
              glProgram: lt.M.from({
                vertex: Gi,
                fragment:
                  "\n                in vec2 vTextureCoord;\n                out vec4 finalColor;\n                uniform sampler2D uTexture;\n\n                void main(void){\n                    finalColor = texture(uTexture, vTextureCoord);\n                }\n                ",
                name: "drop-shadow-filter",
              }),
              resources: {},
            })),
            Object.assign(this, e);
        }
        apply(t, e, i, n) {
          const s = gt.W.getSameSizeTexture(e);
          t.applyFilter(this, e, s, !0),
            this._blurFilter.apply(t, s, i, n),
            this.shadowOnly || t.applyFilter(this._basePass, e, i, !1),
            gt.W.returnTexture(s);
        }
        get offset() {
          return this.uniforms.uOffset;
        }
        set offset(t) {
          (this.uniforms.uOffset = t), this._updatePadding();
        }
        get offsetX() {
          return this.offset.x;
        }
        set offsetX(t) {
          (this.offset.x = t), this._updatePadding();
        }
        get offsetY() {
          return this.offset.y;
        }
        set offsetY(t) {
          (this.offset.y = t), this._updatePadding();
        }
        get color() {
          return this._color.value;
        }
        set color(t) {
          this._color.setValue(t);
          const [e, i, n] = this._color.toArray();
          (this.uniforms.uColor[0] = e),
            (this.uniforms.uColor[1] = i),
            (this.uniforms.uColor[2] = n);
        }
        get alpha() {
          return this.uniforms.uAlpha;
        }
        set alpha(t) {
          this.uniforms.uAlpha = t;
        }
        get blur() {
          return this._blurFilter.strength;
        }
        set blur(t) {
          (this._blurFilter.strength = t), this._updatePadding();
        }
        get quality() {
          return this._blurFilter.quality;
        }
        set quality(t) {
          (this._blurFilter.quality = t), this._updatePadding();
        }
        get kernels() {
          return this._blurFilter.kernels;
        }
        set kernels(t) {
          this._blurFilter.kernels = t;
        }
        get pixelSize() {
          return this._blurFilter.pixelSize;
        }
        set pixelSize(t) {
          "number" == typeof t && (t = { x: t, y: t }),
            Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this._blurFilter.pixelSize = t);
        }
        get pixelSizeX() {
          return this._blurFilter.pixelSizeX;
        }
        set pixelSizeX(t) {
          this._blurFilter.pixelSizeX = t;
        }
        get pixelSizeY() {
          return this._blurFilter.pixelSizeY;
        }
        set pixelSizeY(t) {
          this._blurFilter.pixelSizeY = t;
        }
        _updatePadding() {
          const t = Math.max(Math.abs(this.offsetX), Math.abs(this.offsetY));
          this.padding = t + 2 * this.blur + 4 * this.quality;
        }
      };
      qn(Wn, "DEFAULT_OPTIONS", {
        offset: { x: 4, y: 4 },
        color: 0,
        alpha: 0.5,
        shadowOnly: !1,
        kernels: void 0,
        blur: 2,
        quality: 3,
        pixelSize: { x: 1, y: 1 },
        resolution: 1,
      });
      Object.defineProperty;
      ct.d;
      var Xn = Object.defineProperty,
        Yn = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? Xn(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Kn = class t extends ct.d {
        constructor(e) {
          e = { ...t.defaults, ...e };
          const i = ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct GlitchUniforms {\n  uSeed: f32,\n  uDimensions: vec2<f32>,\n  uAspect: f32,\n  uFillMode: f32,\n  uOffset: f32,\n  uDirection: f32,\n  uRed: vec2<f32>,\n  uGreen: vec2<f32>,\n  uBlue: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> glitchUniforms : GlitchUniforms;\n@group(1) @binding(1) var uDisplacementMap: texture_2d<f32>; \n@group(1) @binding(2) var uDisplacementSampler: sampler; \n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uSeed: f32 = glitchUniforms.uSeed;\n  let uDimensions: vec2<f32> = glitchUniforms.uDimensions;\n  let uAspect: f32 = glitchUniforms.uAspect;\n  let uOffset: f32 = glitchUniforms.uOffset;\n  let uDirection: f32 = glitchUniforms.uDirection;\n  let uRed: vec2<f32> = glitchUniforms.uRed;\n  let uGreen: vec2<f32> = glitchUniforms.uGreen;\n  let uBlue: vec2<f32> = glitchUniforms.uBlue;\n\n  let uInputSize: vec4<f32> = gfu.uInputSize;\n  let uInputClamp: vec4<f32> = gfu.uInputClamp;\n\n  var discarded: bool = false;\n  var coord: vec2<f32> = (uv * uInputSize.xy) / uDimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n      discarded = true;\n    }\n\n    let sinDir: f32 = sin(uDirection);\n    let cosDir: f32 = cos(uDirection);\n\n    let cx: f32 = coord.x - 0.5;\n    let cy: f32 = (coord.y - 0.5) * uAspect;\n    var ny: f32 = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\n\n    ny = select(select(ny, -ny, ny < 0.0), 2.0 - ny, ny > 1.0);\n\n    let dc: vec4<f32> = textureSample(uDisplacementMap, uDisplacementSampler, vec2<f32>(0.5, ny));\n\n    let displacement: f32 = (dc.r - dc.g) * (uOffset / uInputSize.x);\n\n    coord = uv + vec2<f32>(cosDir * displacement, sinDir * displacement * uAspect);\n\n    let fillMode: i32 = i32(glitchUniforms.uFillMode);\n\n    if (fillMode == CLAMP) {\n      coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\n    } else {\n      if (coord.x > uInputClamp.z) {\n        if (fillMode == TRANSPARENT) {\n          discarded = true;\n        } else if (fillMode == LOOP) {\n          coord.x = coord.x - uInputClamp.z;\n        } else if (fillMode == MIRROR) {\n          coord.x = uInputClamp.z * 2.0 - coord.x;\n        }\n      } else if (coord.x < uInputClamp.x) {\n        if (fillMode == TRANSPARENT) {\n          discarded = true;\n        } else if (fillMode == LOOP) {\n          coord.x = coord.x + uInputClamp.z;\n        } else if (fillMode == MIRROR) {\n          coord.x = coord.x * -uInputClamp.z;\n        }\n      }\n\n      if (coord.y > uInputClamp.w) {\n        if (fillMode == TRANSPARENT) {\n          discarded = true;\n        } else if (fillMode == LOOP) {\n          coord.y = coord.y - uInputClamp.w;\n        } else if (fillMode == MIRROR) {\n          coord.y = uInputClamp.w * 2.0 - coord.y;\n        }\n      } else if (coord.y < uInputClamp.y) {\n        if (fillMode == TRANSPARENT) {\n          discarded = true;\n        } else if (fillMode == LOOP) {\n          coord.y = coord.y + uInputClamp.w;\n        } else if (fillMode == MIRROR) {\n          coord.y = coord.y * -uInputClamp.w;\n        }\n      }\n    }\n\n    let seedR: f32 = 1.0 - uSeed * 0.4;\n    let seedG: f32 = 1.0 - uSeed * 0.3;\n    let seedB: f32 = 1.0 - uSeed * 0.2;\n\n    let offsetR: vec2<f32> = vec2(uRed.x * seedR / uInputSize.x, uRed.y * seedR / uInputSize.y);\n    let offsetG: vec2<f32> = vec2(uGreen.x * seedG / uInputSize.x, uGreen.y * seedG / uInputSize.y);\n    let offsetB: vec2<f32> = vec2(uBlue.x * seedB / uInputSize.x, uBlue.y * seedB / uInputSize.y);\n\n    let r = textureSample(uTexture, uSampler, coord + offsetR).r;\n    let g = textureSample(uTexture, uSampler, coord + offsetG).g;\n    let b = textureSample(uTexture, uSampler, coord + offsetB).b;\n    let a = textureSample(uTexture, uSampler, coord).a;\n\n    return select(vec4<f32>(r, g, b, a), vec4<f32>(0.0,0.0,0.0,0.0), discarded);\n}\n\nconst TRANSPARENT: i32 = 0;\nconst ORIGINAL: i32 = 1;\nconst LOOP: i32 = 2;\nconst CLAMP: i32 = 3;\nconst MIRROR: i32 = 4;",
                entryPoint: "mainFragment",
              },
            }),
            n = lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uDisplacementMap;\nuniform float uSeed;\nuniform vec2 uDimensions;\nuniform float uAspect;\nuniform float uFillMode;\nuniform float uOffset;\nuniform float uDirection;\nuniform vec2 uRed;\nuniform vec2 uGreen;\nuniform vec2 uBlue;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nconst int TRANSPARENT = 0;\nconst int ORIGINAL = 1;\nconst int LOOP = 2;\nconst int CLAMP = 3;\nconst int MIRROR = 4;\n\nvoid main(void)\n{\n    vec2 coord = (vTextureCoord * uInputSize.xy) / uDimensions;\n\n    if (coord.x > 1.0 || coord.y > 1.0) {\n        return;\n    }\n\n    float sinDir = sin(uDirection);\n    float cosDir = cos(uDirection);\n\n    float cx = coord.x - 0.5;\n    float cy = (coord.y - 0.5) * uAspect;\n    float ny = (-sinDir * cx + cosDir * cy) / uAspect + 0.5;\n\n    // displacementMap: repeat\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\n\n    // displacementMap: mirror\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\n\n    vec4 dc = texture(uDisplacementMap, vec2(0.5, ny));\n\n    float displacement = (dc.r - dc.g) * (uOffset / uInputSize.x);\n\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * uAspect);\n\n    int fillMode = int(uFillMode);\n\n    if (fillMode == CLAMP) {\n        coord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\n    } else {\n        if( coord.x > uInputClamp.z ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x -= uInputClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x = uInputClamp.z * 2.0 - coord.x;\n            }\n        } else if( coord.x < uInputClamp.x ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.x += uInputClamp.z;\n            } else if (fillMode == MIRROR) {\n                coord.x *= -uInputClamp.z;\n            }\n        }\n\n        if( coord.y > uInputClamp.w ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y -= uInputClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y = uInputClamp.w * 2.0 - coord.y;\n            }\n        } else if( coord.y < uInputClamp.y ) {\n            if (fillMode == TRANSPARENT) {\n                discard;\n            } else if (fillMode == LOOP) {\n                coord.y += uInputClamp.w;\n            } else if (fillMode == MIRROR) {\n                coord.y *= -uInputClamp.w;\n            }\n        }\n    }\n\n    finalColor.r = texture(uTexture, coord + uRed * (1.0 - uSeed * 0.4) / uInputSize.xy).r;\n    finalColor.g = texture(uTexture, coord + uGreen * (1.0 - uSeed * 0.3) / uInputSize.xy).g;\n    finalColor.b = texture(uTexture, coord + uBlue * (1.0 - uSeed * 0.2) / uInputSize.xy).b;\n    finalColor.a = texture(uTexture, coord).a;\n}\n",
              name: "glitch-filter",
            }),
            s = document.createElement("canvas");
          (s.width = 4), (s.height = e.sampleSize ?? 512);
          const r = new a.g({ source: new F.b({ resource: s }) });
          super({
            gpuProgram: i,
            glProgram: n,
            resources: {
              glitchUniforms: {
                uSeed: { value: e?.seed ?? 0, type: "f32" },
                uDimensions: { value: new Float32Array(2), type: "vec2<f32>" },
                uAspect: { value: 1, type: "f32" },
                uFillMode: { value: e?.fillMode ?? 0, type: "f32" },
                uOffset: { value: e?.offset ?? 100, type: "f32" },
                uDirection: { value: e?.direction ?? 0, type: "f32" },
                uRed: { value: e.red, type: "vec2<f32>" },
                uGreen: { value: e.green, type: "vec2<f32>" },
                uBlue: { value: e.blue, type: "vec2<f32>" },
              },
              uDisplacementMap: r.source,
              uDisplacementSampler: r.source.style,
            },
          }),
            Yn(this, "uniforms"),
            Yn(this, "average", !1),
            Yn(this, "minSize", 8),
            Yn(this, "sampleSize", 512),
            Yn(this, "_canvas"),
            Yn(this, "texture"),
            Yn(this, "_slices", 0),
            Yn(this, "_sizes", new Float32Array(1)),
            Yn(this, "_offsets", new Float32Array(1)),
            (this.uniforms = this.resources.glitchUniforms.uniforms),
            (this._canvas = s),
            (this.texture = r),
            Object.assign(this, e);
        }
        apply(t, e, i, n) {
          const { width: s, height: r } = e.frame;
          (this.uniforms.uDimensions[0] = s),
            (this.uniforms.uDimensions[1] = r),
            (this.uniforms.uAspect = r / s),
            t.applyFilter(this, e, i, n);
        }
        _randomizeSizes() {
          const t = this._sizes,
            e = this._slices - 1,
            i = this.sampleSize,
            n = Math.min(this.minSize / i, 0.9 / this._slices);
          if (this.average) {
            const i = this._slices;
            let s = 1;
            for (let r = 0; r < e; r++) {
              const e = s / (i - r),
                o = Math.max(e * (1 - 0.6 * Math.random()), n);
              (t[r] = o), (s -= o);
            }
            t[e] = s;
          } else {
            let i = 1;
            const s = Math.sqrt(1 / this._slices);
            for (let r = 0; r < e; r++) {
              const e = Math.max(s * i * Math.random(), n);
              (t[r] = e), (i -= e);
            }
            t[e] = i;
          }
          this.shuffle();
        }
        shuffle() {
          const t = this._sizes;
          for (let e = this._slices - 1; e > 0; e--) {
            const i = (Math.random() * e) | 0,
              n = t[e];
            (t[e] = t[i]), (t[i] = n);
          }
        }
        _randomizeOffsets() {
          for (let t = 0; t < this._slices; t++)
            this._offsets[t] = Math.random() * (Math.random() < 0.5 ? -1 : 1);
        }
        refresh() {
          this._randomizeSizes(), this._randomizeOffsets(), this.redraw();
        }
        redraw() {
          const t = this.sampleSize,
            e = this.texture,
            i = this._canvas.getContext("2d");
          let n;
          i.clearRect(0, 0, 8, t);
          let s = 0;
          for (let e = 0; e < this._slices; e++) {
            n = Math.floor(256 * this._offsets[e]);
            const r = this._sizes[e] * t,
              o = n > 0 ? n : 0,
              a = n < 0 ? -n : 0;
            (i.fillStyle = `rgba(${o}, ${a}, 0, 1)`),
              i.fillRect(0, s | 0, t, (r + 1) | 0),
              (s += r);
          }
          e.source.update();
        }
        set sizes(t) {
          const e = Math.min(this._slices, t.length);
          for (let i = 0; i < e; i++) this._sizes[i] = t[i];
        }
        get sizes() {
          return this._sizes;
        }
        set offsets(t) {
          const e = Math.min(this._slices, t.length);
          for (let i = 0; i < e; i++) this._offsets[i] = t[i];
        }
        get offsets() {
          return this._offsets;
        }
        get slices() {
          return this._slices;
        }
        set slices(t) {
          this._slices !== t &&
            ((this._slices = t),
            (this._sizes = new Float32Array(t)),
            (this._offsets = new Float32Array(t)),
            this.refresh());
        }
        get offset() {
          return this.uniforms.uOffset;
        }
        set offset(t) {
          this.uniforms.uOffset = t;
        }
        get seed() {
          return this.uniforms.uSeed;
        }
        set seed(t) {
          this.uniforms.uSeed = t;
        }
        get fillMode() {
          return this.uniforms.uFillMode;
        }
        set fillMode(t) {
          this.uniforms.uFillMode = t;
        }
        get direction() {
          return this.uniforms.uDirection / kt.Td;
        }
        set direction(t) {
          this.uniforms.uDirection = t * kt.Td;
        }
        get red() {
          return this.uniforms.uRed;
        }
        set red(t) {
          Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this.uniforms.uRed = t);
        }
        get green() {
          return this.uniforms.uGreen;
        }
        set green(t) {
          Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this.uniforms.uGreen = t);
        }
        get blue() {
          return this.uniforms.uBlue;
        }
        set blue(t) {
          Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this.uniforms.uBlue = t);
        }
        destroy() {
          this.texture?.destroy(!0),
            (this.texture =
              this._canvas =
              this.red =
              this.green =
              this.blue =
              this._sizes =
              this._offsets =
                null);
        }
      };
      Yn(Kn, "defaults", {
        slices: 5,
        offset: 100,
        direction: 0,
        fillMode: 0,
        average: !1,
        seed: 0,
        red: { x: 0, y: 0 },
        green: { x: 0, y: 0 },
        blue: { x: 0, y: 0 },
        minSize: 8,
        sampleSize: 512,
      });
      var Zn = Object.defineProperty,
        Qn = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? Zn(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Jn = class t extends ct.d {
        constructor(e) {
          const i = (e = { ...t.DEFAULT_OPTIONS, ...e }).distance ?? 10,
            n = e.quality ?? 0.1;
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct GlowUniforms {\n  uDistance: f32,\n  uStrength: vec2<f32>,\n  uColor: vec3<f32>,\n  uAlpha: f32,\n  uQuality: f32,\n  uKnockout: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> glowUniforms : GlowUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let quality = glowUniforms.uQuality;\n  let distance = glowUniforms.uDistance;\n\n  let dist: f32 = glowUniforms.uDistance;\n  let angleStepSize: f32 = min(1. / quality / distance, PI * 2.0);\n  let angleStepNum: f32 = ceil(PI * 2.0 / angleStepSize);\n\n  let px: vec2<f32> = vec2<f32>(1.0 / gfu.uInputSize.xy);\n\n  var totalAlpha: f32 = 0.0;\n\n  var direction: vec2<f32>;\n  var displaced: vec2<f32>;\n  var curColor: vec4<f32>;\n\n  for (var angle = 0.0; angle < PI * 2.0; angle += angleStepSize) {\n    direction = vec2<f32>(cos(angle), sin(angle)) * px;\n    for (var curDistance = 0.0; curDistance < dist; curDistance+=1) {\n      displaced = vec2<f32>(clamp(uv + direction * (curDistance + 1.0), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n      curColor = textureSample(uTexture, uSampler, displaced);\n      totalAlpha += (dist - curDistance) * curColor.a;\n    }\n  }\n    \n  curColor = textureSample(uTexture, uSampler, uv);\n\n  let glowColorRGB = glowUniforms.uColor;\n  let glowAlpha = glowUniforms.uAlpha;\n  let glowColor = vec4<f32>(glowColorRGB, glowAlpha);\n  let knockout: bool = glowUniforms.uKnockout > 0.5;\n  let innerStrength = glowUniforms.uStrength[0];\n  let outerStrength = glowUniforms.uStrength[1];\n\n  let alphaRatio: f32 = (totalAlpha / (angleStepNum * dist * (dist + 1.0) / 2.0));\n  let innerGlowAlpha: f32 = (1.0 - alphaRatio) * innerStrength * curColor.a * glowAlpha;\n  let innerGlowStrength: f32 = min(1.0, innerGlowAlpha);\n  \n  let innerColor: vec4<f32> = mix(curColor, glowColor, innerGlowStrength);\n  let outerGlowAlpha: f32 = alphaRatio * outerStrength * (1. - curColor.a) * glowAlpha;\n  let outerGlowStrength: f32 = min(1.0 - innerColor.a, outerGlowAlpha);\n  let outerGlowColor: vec4<f32> = outerGlowStrength * glowColor.rgba;\n  \n  if (knockout) {\n    let resultAlpha: f32 = outerGlowAlpha + innerGlowAlpha;\n    return vec4<f32>(glowColor.rgb * resultAlpha, resultAlpha);\n  }\n  else {\n    return innerColor + outerGlowColor;\n  }\n}\n\nconst PI: f32 = 3.14159265358979323846264;",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uStrength;\nuniform vec3 uColor;\nuniform float uKnockout;\nuniform float uAlpha;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nconst float PI = 3.14159265358979323846264;\n\n// Hard-assignment of DIST and ANGLE_STEP_SIZE instead of using uDistance and uQuality to allow them to be use on GLSL loop conditions\nconst float DIST = __DIST__;\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.);\nconst float ANGLE_STEP_NUM = ceil(PI * 2. / ANGLE_STEP_SIZE);\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.) / 2.;\n\nvoid main(void) {\n    vec2 px = vec2(1.) / uInputSize.xy;\n\n    float totalAlpha = 0.;\n\n    vec2 direction;\n    vec2 displaced;\n    vec4 curColor;\n\n    for (float angle = 0.; angle < PI * 2.; angle += ANGLE_STEP_SIZE) {\n      direction = vec2(cos(angle), sin(angle)) * px;\n\n      for (float curDistance = 0.; curDistance < DIST; curDistance++) {\n          displaced = clamp(vTextureCoord + direction * (curDistance + 1.), uInputClamp.xy, uInputClamp.zw);\n          curColor = texture(uTexture, displaced);\n          totalAlpha += (DIST - curDistance) * curColor.a;\n      }\n    }\n    \n    curColor = texture(uTexture, vTextureCoord);\n\n    vec4 glowColor = vec4(uColor, uAlpha);\n    bool knockout = uKnockout > .5;\n    float innerStrength = uStrength[0];\n    float outerStrength = uStrength[1];\n\n    float alphaRatio = totalAlpha / MAX_TOTAL_ALPHA;\n    float innerGlowAlpha = (1. - alphaRatio) * innerStrength * curColor.a * uAlpha;\n    float innerGlowStrength = min(1., innerGlowAlpha);\n    \n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a) * uAlpha;\n    float outerGlowStrength = min(1. - innerColor.a, outerGlowAlpha);\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\n\n    if (knockout) {\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\n      finalColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\n    }\n    else {\n      finalColor = innerColor + outerGlowColor;\n    }\n}\n"
                  .replace(/__ANGLE_STEP_SIZE__/gi, `${(1 / n / i).toFixed(7)}`)
                  .replace(/__DIST__/gi, `${i.toFixed(0)}.0`),
              name: "glow-filter",
            }),
            resources: {
              glowUniforms: {
                uDistance: { value: i, type: "f32" },
                uStrength: {
                  value: [e.innerStrength, e.outerStrength],
                  type: "vec2<f32>",
                },
                uColor: { value: new Float32Array(3), type: "vec3<f32>" },
                uAlpha: { value: e.alpha, type: "f32" },
                uQuality: { value: n, type: "f32" },
                uKnockout: { value: e?.knockout ? 1 : 0, type: "f32" },
              },
            },
            padding: i,
          }),
            Qn(this, "uniforms"),
            Qn(this, "_color"),
            (this.uniforms = this.resources.glowUniforms.uniforms),
            (this._color = new at.Q()),
            (this.color = e.color ?? 16777215);
        }
        get distance() {
          return this.uniforms.uDistance;
        }
        set distance(t) {
          this.uniforms.uDistance = this.padding = t;
        }
        get innerStrength() {
          return this.uniforms.uStrength[0];
        }
        set innerStrength(t) {
          this.uniforms.uStrength[0] = t;
        }
        get outerStrength() {
          return this.uniforms.uStrength[1];
        }
        set outerStrength(t) {
          this.uniforms.uStrength[1] = t;
        }
        get color() {
          return this._color.value;
        }
        set color(t) {
          this._color.setValue(t);
          const [e, i, n] = this._color.toArray();
          (this.uniforms.uColor[0] = e),
            (this.uniforms.uColor[1] = i),
            (this.uniforms.uColor[2] = n);
        }
        get alpha() {
          return this.uniforms.uAlpha;
        }
        set alpha(t) {
          this.uniforms.uAlpha = t;
        }
        get quality() {
          return this.uniforms.uQuality;
        }
        set quality(t) {
          this.uniforms.uQuality = t;
        }
        get knockout() {
          return 1 === this.uniforms.uKnockout;
        }
        set knockout(t) {
          this.uniforms.uKnockout = t ? 1 : 0;
        }
      };
      Qn(Jn, "DEFAULT_OPTIONS", {
        distance: 10,
        outerStrength: 4,
        innerStrength: 0,
        color: 16777215,
        alpha: 1,
        quality: 0.1,
        knockout: !1,
      });
      var ts = Object.defineProperty,
        es = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? ts(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const is = class t extends ct.d {
        constructor(e) {
          e = { ...t.DEFAULT_OPTIONS, ...e };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct GodrayUniforms {\n  uLight: vec2<f32>,\n  uParallel: f32,\n  uAspect: f32,\n  uTime: f32,\n  uRay: vec3<f32>,\n  uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> godrayUniforms : GodrayUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uDimensions: vec2<f32> = godrayUniforms.uDimensions;\n  let uParallel: bool = godrayUniforms.uParallel > 0.5;\n  let uLight: vec2<f32> = godrayUniforms.uLight;\n  let uAspect: f32 = godrayUniforms.uAspect;\n\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / uDimensions;\n\n  var d: f32;\n\n  if (uParallel) {\n    let _cos: f32 = uLight.x;\n    let _sin: f32 = uLight.y;\n    d = (_cos * coord.x) + (_sin * coord.y * uAspect);\n  } else {\n    let dx: f32 = coord.x - uLight.x / uDimensions.x;\n    let dy: f32 = (coord.y - uLight.y / uDimensions.y) * uAspect;\n    let dis: f32 = sqrt(dx * dx + dy * dy) + 0.00001;\n    d = dy / dis;\n  }\n\n  let uTime: f32 = godrayUniforms.uTime;\n  let uRay: vec3<f32> = godrayUniforms.uRay;\n  \n  let gain = uRay[0];\n  let lacunarity = uRay[1];\n  let alpha = uRay[2];\n\n  let dir: vec3<f32> = vec3<f32>(d, d, 0.0);\n  var noise: f32 = turb(dir + vec3<f32>(uTime, 0.0, 62.1 + uTime) * 0.05, vec3<f32>(480.0, 320.0, 480.0), lacunarity, gain);\n  noise = mix(noise, 0.0, 0.3);\n  //fade vertically.\n  var mist: vec4<f32> = vec4<f32>(vec3<f32>(noise), 1.0) * (1.0 - coord.y);\n  mist.a = 1.0;\n  // apply user alpha\n  mist *= alpha;\n  return textureSample(uTexture, uSampler, uv) + mist;\n}\n\n${PERLIN}".replace(
                    "${PERLIN}",
                    "// Taken from https://gist.github.com/munrocket/236ed5ba7e409b8bdf1ff6eca5dcdc39\n\nfn moduloVec3(x: vec3<f32>, y: vec3<f32>) -> vec3<f32>\n{\n  return x - y * floor(x/y);\n}\nfn mod289Vec3(x: vec3<f32>) -> vec3<f32>\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nfn mod289Vec4(x: vec4<f32>) -> vec4<f32>\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nfn permute4(x: vec4<f32>) -> vec4<f32>\n{\n    return mod289Vec4(((x * 34.0) + 1.0) * x);\n}\nfn taylorInvSqrt(r: vec4<f32>) -> vec4<f32>\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nfn fade3(t: vec3<f32>) -> vec3<f32>\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\nfn fade2(t: vec2<f32>) -> vec2<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }\n\nfn perlinNoise2(P: vec2<f32>) -> f32 {\n  var Pi: vec4<f32> = floor(P.xyxy) + vec4<f32>(0., 0., 1., 1.);\n  let Pf = fract(P.xyxy) - vec4<f32>(0., 0., 1., 1.);\n  Pi = Pi % vec4<f32>(289.); // To avoid truncation effects in permutation\n  let ix = Pi.xzxz;\n  let iy = Pi.yyww;\n  let fx = Pf.xzxz;\n  let fy = Pf.yyww;\n  let i = permute4(permute4(ix) + iy);\n  var gx: vec4<f32> = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...\n  let gy = abs(gx) - 0.5;\n  let tx = floor(gx + 0.5);\n  gx = gx - tx;\n  var g00: vec2<f32> = vec2<f32>(gx.x, gy.x);\n  var g10: vec2<f32> = vec2<f32>(gx.y, gy.y);\n  var g01: vec2<f32> = vec2<f32>(gx.z, gy.z);\n  var g11: vec2<f32> = vec2<f32>(gx.w, gy.w);\n  let norm = 1.79284291400159 - 0.85373472095314 *\n      vec4<f32>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 = g00 * norm.x;\n  g01 = g01 * norm.y;\n  g10 = g10 * norm.z;\n  g11 = g11 * norm.w;\n  let n00 = dot(g00, vec2<f32>(fx.x, fy.x));\n  let n10 = dot(g10, vec2<f32>(fx.y, fy.y));\n  let n01 = dot(g01, vec2<f32>(fx.z, fy.z));\n  let n11 = dot(g11, vec2<f32>(fx.w, fy.w));\n  let fade_xy = fade2(Pf.xy);\n  let n_x = mix(vec2<f32>(n00, n01), vec2<f32>(n10, n11), vec2<f32>(fade_xy.x));\n  let n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfn perlinNoise3(P: vec3<f32>, rep: vec3<f32>) -> f32\n{\n    var Pi0: vec3<f32> = moduloVec3(floor(P), rep); // Integer part, modulo period\n    var Pi1: vec3<f32> = moduloVec3(Pi0 + vec3<f32>(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289Vec3(Pi0);\n    Pi1 = mod289Vec3(Pi1);\n    let Pf0: vec3<f32> = fract(P); // Fractional part for interpolation\n    let Pf1: vec3<f32> = Pf0 - vec3<f32>(1.0); // Fractional part - 1.0\n    let ix: vec4<f32> = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    let iy: vec4<f32> = vec4<f32>(Pi0.yy, Pi1.yy);\n    let iz0: vec4<f32> = Pi0.zzzz;\n    let iz1: vec4<f32> = Pi1.zzzz;\n    let ixy: vec4<f32> = permute4(permute4(ix) + iy);\n    let ixy0: vec4<f32> = permute4(ixy + iz0);\n    let ixy1: vec4<f32> = permute4(ixy + iz1);\n    var gx0: vec4<f32> = ixy0 * (1.0 / 7.0);\n    var gy0: vec4<f32> = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    let gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);\n    let sz0: vec4<f32> = step(gz0, vec4<f32>(0.0));\n    gx0 -= sz0 * (step(vec4<f32>(0.0), gx0) - 0.5);\n    gy0 -= sz0 * (step(vec4<f32>(0.0), gy0) - 0.5);\n    var gx1: vec4<f32> = ixy1 * (1.0 / 7.0);\n    var gy1: vec4<f32> = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    let gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);\n    let sz1: vec4<f32> = step(gz1, vec4<f32>(0.0));\n    gx1 -= sz1 * (step(vec4<f32>(0.0), gx1) - 0.5);\n    gy1 -= sz1 * (step(vec4<f32>(0.0), gy1) - 0.5);\n    var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);\n    var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);\n    var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);\n    var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);\n    var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);\n    var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);\n    var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);\n    var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);\n    let norm0: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    let norm1: vec4<f32> = taylorInvSqrt(vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    let n000: f32 = dot(g000, Pf0);\n    let n100: f32 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));\n    let n010: f32 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));\n    let n110: f32 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));\n    let n001: f32 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));\n    let n101: f32 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));\n    let n011: f32 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));\n    let n111: f32 = dot(g111, Pf1);\n    let fade_xyz: vec3<f32> = fade3(Pf0);\n    let n_z: vec4<f32> = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), fade_xyz.z);\n    let n_yz: vec2<f32> = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    let n_xyz: f32 = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfn turb(P: vec3<f32>, rep: vec3<f32>, lacunarity: f32, gain: f32) -> f32\n{\n    var sum: f32 = 0.0;\n    var sc: f32 = 1.0;\n    var totalgain: f32 = 1.0;\n    for (var i = 0.0; i < 6.0; i += 1)\n    {\n        sum += totalgain * perlinNoise3(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}"
                  ),
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uDimensions;\nuniform float uParallel;\nuniform vec2 uLight;\nuniform float uAspect;\nuniform float uTime;\nuniform vec3 uRay;\n\nuniform vec4 uInputSize;\n\n${PERLIN}\n\nvoid main(void) {\n    vec2 uDimensions = uDimensions;\n    bool uParallel = uParallel > 0.5;\n    vec2 uLight = uLight;\n    float uAspect = uAspect;\n\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions;\n\n    float d;\n\n    if (uParallel) {\n        float _cos = uLight.x;\n        float _sin = uLight.y;\n        d = (_cos * coord.x) + (_sin * coord.y * uAspect);\n    } else {\n        float dx = coord.x - uLight.x / uDimensions.x;\n        float dy = (coord.y - uLight.y / uDimensions.y) * uAspect;\n        float dis = sqrt(dx * dx + dy * dy) + 0.00001;\n        d = dy / dis;\n    }\n\n    float uTime = uTime;\n    vec3 uRay = uRay;\n\n    float gain = uRay[0];\n    float lacunarity = uRay[1];\n    float alpha = uRay[2];\n\n    vec3 dir = vec3(d, d, 0.0);\n    float noise = turb(dir + vec3(uTime, 0.0, 62.1 + uTime) * 0.05, vec3(480.0, 320.0, 480.0), lacunarity, gain);\n    noise = mix(noise, 0.0, 0.3);\n    //fade vertically.\n    vec4 mist = vec4(vec3(noise), 1.0) * (1.0 - coord.y);\n    mist.a = 1.0;\n    // apply user alpha\n    mist *= alpha;\n\n    finalColor = texture(uTexture, vTextureCoord) + mist;\n}\n".replace(
                  "${PERLIN}",
                  "vec3 mod289(vec3 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n    vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n    vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n    vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);\n    vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);\n    vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);\n    vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);\n    vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);\n    vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);\n    vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);\n    vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 2.2 * n_xyz;\n}\nfloat turb(vec3 P, vec3 rep, float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float sc = 1.0;\n    float totalgain = 1.0;\n    for (float i = 0.0; i < 6.0; i++)\n    {\n        sum += totalgain * pnoise(P * sc, rep);\n        sc *= lacunarity;\n        totalgain *= gain;\n    }\n    return abs(sum);\n}\n"
                ),
              name: "god-ray-filter",
            }),
            resources: {
              godrayUniforms: {
                uLight: { value: new Float32Array(2), type: "vec2<f32>" },
                uParallel: { value: 0, type: "f32" },
                uAspect: { value: 0, type: "f32" },
                uTime: { value: e.time, type: "f32" },
                uRay: { value: new Float32Array(3), type: "vec3<f32>" },
                uDimensions: { value: new Float32Array(2), type: "vec2<f32>" },
              },
            },
          }),
            es(this, "uniforms"),
            es(this, "time", 0),
            es(this, "_angleLight", [0, 0]),
            es(this, "_angle", 0),
            es(this, "_center"),
            (this.uniforms = this.resources.godrayUniforms.uniforms),
            Object.assign(this, e);
        }
        apply(t, e, i, n) {
          const s = e.frame.width,
            r = e.frame.height;
          (this.uniforms.uLight[0] = this.parallel
            ? this._angleLight[0]
            : this._center.x),
            (this.uniforms.uLight[1] = this.parallel
              ? this._angleLight[1]
              : this._center.y),
            (this.uniforms.uDimensions[0] = s),
            (this.uniforms.uDimensions[1] = r),
            (this.uniforms.uAspect = r / s),
            (this.uniforms.uTime = this.time),
            t.applyFilter(this, e, i, n);
        }
        get angle() {
          return this._angle;
        }
        set angle(t) {
          this._angle = t;
          const e = t * kt.Td;
          (this._angleLight[0] = Math.cos(e)),
            (this._angleLight[1] = Math.sin(e));
        }
        get parallel() {
          return this.uniforms.uParallel > 0.5;
        }
        set parallel(t) {
          this.uniforms.uParallel = t ? 1 : 0;
        }
        get center() {
          return this._center;
        }
        set center(t) {
          Array.isArray(t) && (t = { x: t[0], y: t[1] }), (this._center = t);
        }
        get centerX() {
          return this.center.x;
        }
        set centerX(t) {
          this.center.x = t;
        }
        get centerY() {
          return this.center.y;
        }
        set centerY(t) {
          this.center.y = t;
        }
        get gain() {
          return this.uniforms.uRay[0];
        }
        set gain(t) {
          this.uniforms.uRay[0] = t;
        }
        get lacunarity() {
          return this.uniforms.uRay[1];
        }
        set lacunarity(t) {
          this.uniforms.uRay[1] = t;
        }
        get alpha() {
          return this.uniforms.uRay[2];
        }
        set alpha(t) {
          this.uniforms.uRay[2] = t;
        }
      };
      es(is, "DEFAULT_OPTIONS", {
        angle: 30,
        gain: 0.5,
        lacunarity: 2.5,
        parallel: !0,
        time: 0,
        center: { x: 0, y: 0 },
        alpha: 1,
      });
      ct.d;
      var ns = Object.defineProperty,
        ss = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? ns(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const rs = class t extends ct.d {
        constructor(e) {
          e = { ...t.DEFAULT_OPTIONS, ...e };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct HslUniforms {\n  uHsl:vec3<f32>,\n  uColorize:f32,\n  uAlpha:f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> hslUniforms : HslUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n    let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n    var resultRGB: vec3<f32> = color.rgb;\n\n    let hue: f32 = hslUniforms.uHsl[0];\n    let saturation: f32 = hslUniforms.uHsl[1];\n    let lightness: f32 = hslUniforms.uHsl[2];\n\n    // colorize\n    if (hslUniforms.uColorize > 0.5) {\n        resultRGB = vec3<f32>(dot(color.rgb, vec3<f32>(0.299, 0.587, 0.114)), 0., 0.);\n    }\n\n    // hue\n    resultRGB = hueShift(resultRGB, hue);\n\n    // saturation\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\n    let average: f32 = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;\n\n    if (saturation > 0.) {\n        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));\n    } else {\n        resultRGB -= (average - resultRGB) * saturation;\n    }\n\n    // lightness\n    resultRGB = mix(resultRGB, vec3<f32>(ceil(lightness)) * color.a, abs(lightness));\n\n    // alpha\n    return mix(color, vec4<f32>(resultRGB, color.a), hslUniforms.uAlpha);\n}\n\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\nconst k: vec3<f32> = vec3(0.57735, 0.57735, 0.57735);\n\nfn hueShift(color: vec3<f32>, angle: f32) -> vec3<f32> \n{\n    let cosAngle: f32 = cos(angle);\n    return vec3<f32>(\n    color * cosAngle +\n    cross(k, color) * sin(angle) +\n    k * dot(k, color) * (1.0 - cosAngle)\n    );\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec3 uHsl;\nuniform float uAlpha;\nuniform float uColorize;\n\n// https://en.wikipedia.org/wiki/Luma_(video)\nconst vec3 weight = vec3(0.299, 0.587, 0.114);\n\nfloat getWeightedAverage(vec3 rgb) {\n    return rgb.r * weight.r + rgb.g * weight.g + rgb.b * weight.b;\n}\n\n// https://gist.github.com/mairod/a75e7b44f68110e1576d77419d608786?permalink_comment_id=3195243#gistcomment-3195243\nconst vec3 k = vec3(0.57735, 0.57735, 0.57735);\n\nvec3 hueShift(vec3 color, float angle) {\n    float cosAngle = cos(angle);\n    return vec3(\n    color * cosAngle +\n    cross(k, color) * sin(angle) +\n    k * dot(k, color) * (1.0 - cosAngle)\n    );\n}\n\nvoid main()\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n    vec3 resultRGB = color.rgb;\n\n    float hue = uHsl[0];\n    float saturation = uHsl[1];\n    float lightness = uHsl[2];\n\n    // colorize\n    if (uColorize > 0.5) {\n        resultRGB = vec3(getWeightedAverage(resultRGB), 0., 0.);\n    }\n\n    // hue\n    resultRGB = hueShift(resultRGB, hue);\n\n    // saturation\n    // https://github.com/evanw/glfx.js/blob/master/src/filters/adjust/huesaturation.js\n    float average = (resultRGB.r + resultRGB.g + resultRGB.b) / 3.0;\n\n    if (saturation > 0.) {\n        resultRGB += (average - resultRGB) * (1. - 1. / (1.001 - saturation));\n    } else {\n        resultRGB -= (average - resultRGB) * saturation;\n    }\n\n    // lightness\n    resultRGB = mix(resultRGB, vec3(ceil(lightness)) * color.a, abs(lightness));\n\n    // alpha\n    finalColor = mix(color, vec4(resultRGB, color.a), uAlpha);\n}\n",
              name: "hsl-adjustment-filter",
            }),
            resources: {
              hslUniforms: {
                uHsl: { value: new Float32Array(3), type: "vec3<f32>" },
                uColorize: { value: e.colorize ? 1 : 0, type: "f32" },
                uAlpha: { value: e.alpha, type: "f32" },
              },
            },
          }),
            ss(this, "uniforms"),
            ss(this, "_hue"),
            (this.uniforms = this.resources.hslUniforms.uniforms),
            (this.hue = e.hue);
        }
        get hue() {
          return this._hue;
        }
        set hue(t) {
          (this._hue = t),
            (this.resources.hslUniforms.uniforms.uHsl[0] = t * (Math.PI / 180));
        }
        get saturation() {
          return this.resources.hslUniforms.uniforms.uHsl[1];
        }
        set saturation(t) {
          this.resources.hslUniforms.uniforms.uHsl[1] = t;
        }
        get lightness() {
          return this.resources.hslUniforms.uniforms.uHsl[2];
        }
        set lightness(t) {
          this.resources.hslUniforms.uniforms.uHsl[2] = t;
        }
        get colorize() {
          return 1 === this.resources.hslUniforms.uniforms.uColorize;
        }
        set colorize(t) {
          this.resources.hslUniforms.uniforms.uColorize = t ? 1 : 0;
        }
        get alpha() {
          return this.resources.hslUniforms.uniforms.uAlpha;
        }
        set alpha(t) {
          this.resources.hslUniforms.uniforms.uAlpha = t;
        }
      };
      ss(rs, "DEFAULT_OPTIONS", {
        hue: 0,
        saturation: 0,
        lightness: 0,
        colorize: !1,
        alpha: 1,
      });
      var os = Object.defineProperty,
        as = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? os(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const ls = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          if (Array.isArray(i) || ("x" in i && "y" in i) || i instanceof Mt.o) {
            (0, yt.t)(
              "6.0.0",
              "MotionBlurFilter constructor params are now options object. See params: { velocity, kernelSize, offset }"
            );
            (i = {
              velocity: { x: "x" in i ? i.x : i[0], y: "y" in i ? i.y : i[1] },
            }),
              void 0 !== e[1] && (i.kernelSize = e[1]),
              void 0 !== e[2] && (i.offset = e[2]);
          }
          i = { ...t.DEFAULT_OPTIONS, ...i };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct MotionBlurUniforms {\n  uVelocity: vec2<f32>,\n  uKernelSize: f32,\n  uOffset: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> motionBlurUniforms : MotionBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uVelocity = motionBlurUniforms.uVelocity;\n  let uKernelSize = motionBlurUniforms.uKernelSize;\n  let uOffset = motionBlurUniforms.uOffset;\n\n  let velocity: vec2<f32> = uVelocity / gfu.uInputSize.xy;\n  let offset: f32 = -uOffset / length(uVelocity) - 0.5;\n  let k: i32 = i32(min(uKernelSize - 1, MAX_KERNEL_SIZE - 1));\n\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  for(var i: i32 = 0; i < k; i += 1) {\n    let bias: vec2<f32> = velocity * (f32(i) / f32(k) + offset);\n    color += textureSample(uTexture, uSampler, uv + bias);\n  }\n  \n  return select(color / f32(uKernelSize), textureSample(uTexture, uSampler, uv), uKernelSize == 0);\n}\n\nconst MAX_KERNEL_SIZE: f32 = 2048;",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uVelocity;\nuniform int uKernelSize;\nuniform float uOffset;\n\nuniform vec4 uInputSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\n// Notice:\n// the perfect way:\n//    int kernelSize = min(uKernelSize, MAX_KERNELSIZE);\n// BUT in real use-case , uKernelSize < MAX_KERNELSIZE almost always.\n// So use uKernelSize directly.\n\nvoid main(void)\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        finalColor = color;\n        return;\n    }\n\n    vec2 velocity = uVelocity / uInputSize.xy;\n    float offset = -uOffset / length(uVelocity) - 0.5;\n    int k = uKernelSize - 1;\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n        vec2 bias = velocity * (float(i) / float(k) + offset);\n        color += texture(uTexture, vTextureCoord + bias);\n    }\n    finalColor = color / float(uKernelSize);\n}\n",
              name: "motion-blur-filter",
            }),
            resources: {
              motionBlurUniforms: {
                uVelocity: { value: i.velocity, type: "vec2<f32>" },
                uKernelSize: {
                  value: Math.trunc(i.kernelSize ?? 5),
                  type: "f32",
                },
                uOffset: { value: i.offset, type: "f32" },
              },
            },
          }),
            as(this, "uniforms"),
            as(this, "_kernelSize"),
            (this.uniforms = this.resources.motionBlurUniforms.uniforms),
            Object.assign(this, i);
        }
        get velocity() {
          return this.uniforms.uVelocity;
        }
        set velocity(t) {
          Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this.uniforms.uVelocity = t),
            this._updateDirty();
        }
        get velocityX() {
          return this.velocity.x;
        }
        set velocityX(t) {
          (this.velocity.x = t), this._updateDirty();
        }
        get velocityY() {
          return this.velocity.y;
        }
        set velocityY(t) {
          (this.velocity.y = t), this._updateDirty();
        }
        get kernelSize() {
          return this._kernelSize;
        }
        set kernelSize(t) {
          (this._kernelSize = t), this._updateDirty();
        }
        get offset() {
          return this.uniforms.uOffset;
        }
        set offset(t) {
          this.uniforms.uOffset = t;
        }
        _updateDirty() {
          (this.padding =
            1 +
            (Math.max(Math.abs(this.velocityX), Math.abs(this.velocityY)) | 0)),
            (this.uniforms.uKernelSize =
              0 !== this.velocityX || 0 !== this.velocityY
                ? this._kernelSize
                : 0);
        }
      };
      as(ls, "DEFAULT_OPTIONS", {
        velocity: { x: 0, y: 0 },
        kernelSize: 5,
        offset: 0,
      });
      var us = Object.defineProperty,
        hs = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? us(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const cs = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          Array.isArray(i) &&
            ((0, yt.t)(
              "6.0.0",
              "MultiColorReplaceFilter constructor params are now options object. See params: { replacements, tolerance, maxColors }"
            ),
            (i = { replacements: i }),
            e[1] && (i.tolerance = e[1]),
            e[2] && (i.maxColors = e[2])),
            (i = { ...t.DEFAULT_OPTIONS, ...i });
          const n = i.maxColors ?? i.replacements.length;
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct MultiColorReplaceUniforms {\n  uOriginalColors: array<vec3<f32>, MAX_COLORS>,\n  uTargetColors: array<vec3<f32>, MAX_COLORS>,\n  uTolerance:f32,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> multiColorReplaceUniforms : MultiColorReplaceUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uOriginalColors = multiColorReplaceUniforms.uOriginalColors;\n  let uTargetColors = multiColorReplaceUniforms.uTargetColors;\n  let uTolerance = multiColorReplaceUniforms.uTolerance;\n\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  let alpha: f32 = color.a;\n\n  if (alpha > 0.0001)\n  {\n    var modColor: vec3<f32> = vec3<f32>(color.rgb) / alpha;\n\n    for(var i: i32 = 0; i < MAX_COLORS; i += 1)\n    {\n      let origColor: vec3<f32> = uOriginalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      let colorDiff: vec3<f32> = origColor - modColor;\n      \n      if (length(colorDiff) < uTolerance)\n      {\n        let targetColor: vec3<f32> = uTargetColors[i];\n        color = vec4((targetColor + colorDiff) * alpha, alpha);\n        return color;\n      }\n    }\n  }\n\n  return color;\n}\n\nconst MAX_COLORS: i32 = ${MAX_COLORS};".replace(
                    /\$\{MAX_COLORS\}/g,
                    n.toFixed(0)
                  ),
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nconst int MAX_COLORS = ${MAX_COLORS};\n\nuniform sampler2D uTexture;\nuniform vec3 uOriginalColors[MAX_COLORS];\nuniform vec3 uTargetColors[MAX_COLORS];\nuniform float uTolerance;\n\nvoid main(void)\n{\n    finalColor = texture(uTexture, vTextureCoord);\n\n    float alpha = finalColor.a;\n    if (alpha < 0.0001)\n    {\n      return;\n    }\n\n    vec3 color = finalColor.rgb / alpha;\n\n    for(int i = 0; i < MAX_COLORS; i++)\n    {\n      vec3 origColor = uOriginalColors[i];\n      if (origColor.r < 0.0)\n      {\n        break;\n      }\n      vec3 colorDiff = origColor - color;\n      if (length(colorDiff) < uTolerance)\n      {\n        vec3 targetColor = uTargetColors[i];\n        finalColor = vec4((targetColor + colorDiff) * alpha, alpha);\n        return;\n      }\n    }\n}\n".replace(
                  /\$\{MAX_COLORS\}/g,
                  n.toFixed(0)
                ),
              name: "multi-color-replace-filter",
            }),
            resources: {
              multiColorReplaceUniforms: {
                uOriginalColors: {
                  value: new Float32Array(3 * n),
                  type: "vec3<f32>",
                  size: n,
                },
                uTargetColors: {
                  value: new Float32Array(3 * n),
                  type: "vec3<f32>",
                  size: n,
                },
                uTolerance: { value: i.tolerance, type: "f32" },
              },
            },
          }),
            hs(this, "uniforms"),
            hs(this, "_replacements", []),
            hs(this, "_maxColors"),
            (this._maxColors = n),
            (this.uniforms = this.resources.multiColorReplaceUniforms.uniforms),
            (this.replacements = i.replacements);
        }
        set replacements(t) {
          const e = this.uniforms.uOriginalColors,
            i = this.uniforms.uTargetColors,
            n = t.length,
            s = new at.Q();
          if (n > this._maxColors)
            throw new Error(
              `Length of replacements (${n}) exceeds the maximum colors length (${this._maxColors})`
            );
          let r, o, a;
          e[3 * n] = -1;
          for (let l = 0; l < n; l++) {
            const n = t[l];
            s.setValue(n[0]),
              ([r, o, a] = s.toArray()),
              (e[3 * l] = r),
              (e[3 * l + 1] = o),
              (e[3 * l + 2] = a),
              s.setValue(n[1]),
              ([r, o, a] = s.toArray()),
              (i[3 * l] = r),
              (i[3 * l + 1] = o),
              (i[3 * l + 2] = a);
          }
          this._replacements = t;
        }
        get replacements() {
          return this._replacements;
        }
        refresh() {
          this.replacements = this._replacements;
        }
        get maxColors() {
          return this._maxColors;
        }
        get tolerance() {
          return this.uniforms.uTolerance;
        }
        set tolerance(t) {
          this.uniforms.uTolerance = t;
        }
        set epsilon(t) {
          (0, yt.t)(
            "6.0.0",
            "MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead"
          ),
            (this.tolerance = t);
        }
        get epsilon() {
          return (
            (0, yt.t)(
              "6.0.0",
              "MultiColorReplaceFilter.epsilon is deprecated, please use MultiColorReplaceFilter.tolerance instead"
            ),
            this.tolerance
          );
        }
      };
      hs(cs, "DEFAULT_OPTIONS", {
        replacements: [[16711680, 255]],
        tolerance: 0.05,
        maxColors: void 0,
      });
      var ds = Object.defineProperty,
        ps = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? ds(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const fs = class t extends ct.d {
        constructor(e) {
          e = { ...t.DEFAULT_OPTIONS, ...e };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct OldFilmUniforms {\n    uSepia: f32,\n    uNoise: vec2<f32>,\n    uScratch: vec3<f32>,\n    uVignetting: vec3<f32>,\n    uSeed: f32,\n    uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> oldFilmUniforms : OldFilmUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n\n  if (oldFilmUniforms.uSepia > 0.)\n  {\n    color = vec4<f32>(sepia(color.rgb), color.a);\n  }\n\n  let coord: vec2<f32> = uv * gfu.uInputSize.xy / oldFilmUniforms.uDimensions;\n\n  if (oldFilmUniforms.uVignetting[0] > 0.)\n  {\n    color *= vec4<f32>(vec3<f32>(vignette(color.rgb, coord)), color.a);\n  }\n\n  let uScratch = oldFilmUniforms.uScratch; \n\n  if (uScratch[1] > oldFilmUniforms.uSeed && uScratch[0] != 0.)\n  {\n    color = vec4<f32>(scratch(color.rgb, coord), color.a);\n  }\n\n  let uNoise = oldFilmUniforms.uNoise;\n\n  if (uNoise[0] > 0.0 && uNoise[1] > 0.0)\n  {\n    color += vec4<f32>(vec3<f32>(noise(uv)), color.a);\n  }\n\n  return color;\n}\n\nconst SQRT_2: f32 = 1.414213;\nconst SEPIA_RGB: vec3<f32> = vec3<f32>(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}\n\nfn rand(co: vec2<f32>) -> f32\n{\n  return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);\n}\n\nfn overlay(src: vec3<f32>, dst: vec3<f32>) -> vec3<f32>\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n\n    return vec3<f32>(\n      select((1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (2.0 * src.x * dst.x), (dst.x <= 0.5)), \n      select((1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (2.0 * src.y * dst.y), (dst.y <= 0.5)),\n      select((1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)), (2.0 * src.z * dst.z), (dst.z <= 0.5))\n    );\n}\n\nfn sepia(co: vec3<f32>) -> vec3<f32>\n{\n  let gray: f32 = (co.x + co.y + co.z) / 3.0;\n  let grayscale: vec3<f32> = vec3<f32>(gray);\n  let color = overlay(SEPIA_RGB, grayscale);\n  return grayscale + oldFilmUniforms.uSepia * (color - grayscale);\n}\n\nfn vignette(co: vec3<f32>, coord: vec2<f32>) -> f32\n{\n  let uVignetting = oldFilmUniforms.uVignetting;\n  let uDimensions = oldFilmUniforms.uDimensions;\n  \n  let outter: f32 = SQRT_2 - uVignetting[0] * SQRT_2;\n  var dir: vec2<f32> = vec2<f32>(vec2<f32>(0.5) - coord);\n  dir.y *= uDimensions.y / uDimensions.x;\n  let darker: f32 = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + uVignetting[2] * SQRT_2), 0.0, 1.0);\n  return darker + (1.0 - darker) * (1.0 - uVignetting[1]);\n}\n\nfn scratch(co: vec3<f32>, coord: vec2<f32>) -> vec3<f32>\n{\n  var color = co;\n  let uScratch = oldFilmUniforms.uScratch;\n  let uSeed = oldFilmUniforms.uSeed;\n  let uDimensions = oldFilmUniforms.uDimensions;\n\n  let phase: f32 = uSeed * 256.0;\n  let s: f32 = modulo(floor(phase), 2.0);\n  let dist: f32 = 1.0 / uScratch[1];\n  let d: f32 = distance(coord, vec2<f32>(uSeed * dist, abs(s - uSeed * dist)));\n\n  if (d < uSeed * 0.6 + 0.4)\n  {\n    let period: f32 = uScratch[1] * 10.0;\n\n    let xx: f32 = coord.x * period + phase;\n    let aa: f32 = abs(modulo(xx, 0.5) * 4.0);\n    let bb: f32 = modulo(floor(xx / 0.5), 2.0);\n    let yy: f32 = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n    let kk: f32 = 2.0 * period;\n    let dw: f32 = uScratch[2] / uDimensions.x * (0.75 + uSeed);\n    let dh: f32 = dw * kk;\n\n    var tine: f32 = (yy - (2.0 - dh));\n\n    if (tine > 0.0) {\n        let _sign: f32 = sign(uScratch[0]);\n\n        tine = s * tine / period + uScratch[0] + 0.1;\n        tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n        color *= tine;\n    }\n  }\n\n  return color;\n}\n\nfn noise(coord: vec2<f32>) -> f32\n{\n  let uNoise = oldFilmUniforms.uNoise;\n  let uSeed = oldFilmUniforms.uSeed;\n\n  var pixelCoord: vec2<f32> = coord * gfu.uInputSize.xy;\n  pixelCoord.x = floor(pixelCoord.x / uNoise[1]);\n  pixelCoord.y = floor(pixelCoord.y / uNoise[1]);\n  return (rand(pixelCoord * uNoise[1] * uSeed) - 0.5) * uNoise[0];\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uSepia;\nuniform vec2 uNoise;\nuniform vec3 uScratch;\nuniform vec3 uVignetting;\nuniform float uSeed;\nuniform vec2 uDimensions;\n\nuniform vec4 uInputSize;\n\nconst float SQRT_2 = 1.414213;\nconst vec3 SEPIA_RGB = vec3(112.0 / 255.0, 66.0 / 255.0, 20.0 / 255.0);\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 Overlay(vec3 src, vec3 dst)\n{\n    // if (dst <= 0.5) then: 2 * src * dst\n    // if (dst > 0.5) then: 1 - 2 * (1 - dst) * (1 - src)\n    return vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)),\n                (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)),\n                (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\n\n\nvoid main()\n{\n    finalColor = texture(uTexture, vTextureCoord);\n    vec3 color = finalColor.rgb;\n\n    if (uSepia > 0.0)\n    {\n        float gray = (color.x + color.y + color.z) / 3.0;\n        vec3 grayscale = vec3(gray);\n\n        color = Overlay(SEPIA_RGB, grayscale);\n\n        color = grayscale + uSepia * (color - grayscale);\n    }\n\n    vec2 coord = vTextureCoord * uInputSize.xy / uDimensions.xy;\n\n    float vignette = uVignetting[0];\n    float vignetteAlpha = uVignetting[1];\n    float vignetteBlur = uVignetting[2];\n\n    if (vignette > 0.0)\n    {\n        float outter = SQRT_2 - vignette * SQRT_2;\n        vec2 dir = vec2(vec2(0.5, 0.5) - coord);\n        dir.y *= uDimensions.y / uDimensions.x;\n        float darker = clamp((outter - length(dir) * SQRT_2) / ( 0.00001 + vignetteBlur * SQRT_2), 0.0, 1.0);\n        color.rgb *= darker + (1.0 - darker) * (1.0 - vignetteAlpha);\n    }\n\n    float scratch = uScratch[0];\n    float scratchDensity = uScratch[1];\n    float scratchWidth = uScratch[2];\n\n    if (scratchDensity > uSeed && scratch != 0.0)\n    {\n        float phase = uSeed * 256.0;\n        float s = mod(floor(phase), 2.0);\n        float dist = 1.0 / scratchDensity;\n        float d = distance(coord, vec2(uSeed * dist, abs(s - uSeed * dist)));\n        if (d < uSeed * 0.6 + 0.4)\n        {\n            highp float period = scratchDensity * 10.0;\n\n            float xx = coord.x * period + phase;\n            float aa = abs(mod(xx, 0.5) * 4.0);\n            float bb = mod(floor(xx / 0.5), 2.0);\n            float yy = (1.0 - bb) * aa + bb * (2.0 - aa);\n\n            float kk = 2.0 * period;\n            float dw = scratchWidth / uDimensions.x * (0.75 + uSeed);\n            float dh = dw * kk;\n\n            float tine = (yy - (2.0 - dh));\n\n            if (tine > 0.0) {\n                float _sign = sign(scratch);\n\n                tine = s * tine / period + scratch + 0.1;\n                tine = clamp(tine + 1.0, 0.5 + _sign * 0.5, 1.5 + _sign * 0.5);\n\n                color.rgb *= tine;\n            }\n        }\n    }\n\n    float noise = uNoise[0];\n    float noiseSize = uNoise[1];\n\n    if (noise > 0.0 && noiseSize > 0.0)\n    {\n        vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;\n        pixelCoord.x = floor(pixelCoord.x / noiseSize);\n        pixelCoord.y = floor(pixelCoord.y / noiseSize);\n        // vec2 d = pixelCoord * noiseSize * vec2(1024.0 + uSeed * 512.0, 1024.0 - uSeed * 512.0);\n        // float _noise = snoise(d) * 0.5;\n        float _noise = rand(pixelCoord * noiseSize * uSeed) - 0.5;\n        color += _noise * noise;\n    }\n\n    finalColor.rgb = color;\n}",
              name: "old-film-filter",
            }),
            resources: {
              oldFilmUniforms: {
                uSepia: { value: e.sepia, type: "f32" },
                uNoise: { value: new Float32Array(2), type: "vec2<f32>" },
                uScratch: { value: new Float32Array(3), type: "vec3<f32>" },
                uVignetting: { value: new Float32Array(3), type: "vec3<f32>" },
                uSeed: { value: e.seed, type: "f32" },
                uDimensions: { value: new Float32Array(2), type: "vec2<f32>" },
              },
            },
          }),
            ps(this, "uniforms"),
            ps(this, "seed"),
            (this.uniforms = this.resources.oldFilmUniforms.uniforms),
            Object.assign(this, e);
        }
        apply(t, e, i, n) {
          (this.uniforms.uDimensions[0] = e.frame.width),
            (this.uniforms.uDimensions[1] = e.frame.height),
            (this.uniforms.uSeed = this.seed),
            t.applyFilter(this, e, i, n);
        }
        get sepia() {
          return this.uniforms.uSepia;
        }
        set sepia(t) {
          this.uniforms.uSepia = t;
        }
        get noise() {
          return this.uniforms.uNoise[0];
        }
        set noise(t) {
          this.uniforms.uNoise[0] = t;
        }
        get noiseSize() {
          return this.uniforms.uNoise[1];
        }
        set noiseSize(t) {
          this.uniforms.uNoise[1] = t;
        }
        get scratch() {
          return this.uniforms.uScratch[0];
        }
        set scratch(t) {
          this.uniforms.uScratch[0] = t;
        }
        get scratchDensity() {
          return this.uniforms.uScratch[1];
        }
        set scratchDensity(t) {
          this.uniforms.uScratch[1] = t;
        }
        get scratchWidth() {
          return this.uniforms.uScratch[2];
        }
        set scratchWidth(t) {
          this.uniforms.uScratch[2] = t;
        }
        get vignetting() {
          return this.uniforms.uVignetting[0];
        }
        set vignetting(t) {
          this.uniforms.uVignetting[0] = t;
        }
        get vignettingAlpha() {
          return this.uniforms.uVignetting[1];
        }
        set vignettingAlpha(t) {
          this.uniforms.uVignetting[1] = t;
        }
        get vignettingBlur() {
          return this.uniforms.uVignetting[2];
        }
        set vignettingBlur(t) {
          this.uniforms.uVignetting[2] = t;
        }
      };
      ps(fs, "DEFAULT_OPTIONS", {
        sepia: 0.3,
        noise: 0.3,
        noiseSize: 1,
        scratch: 0.5,
        scratchDensity: 0.3,
        scratchWidth: 1,
        vignetting: 0.3,
        vignettingAlpha: 1,
        vignettingBlur: 0.3,
        seed: 0,
      });
      var ms = Object.defineProperty,
        gs = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? ms(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const vs = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          "number" == typeof i &&
            ((0, yt.t)(
              "6.0.0",
              "OutlineFilter constructor params are now options object. See params: { thickness, color, quality, alpha, knockout }"
            ),
            (i = { thickness: i }),
            void 0 !== e[1] && (i.color = e[1]),
            void 0 !== e[2] && (i.quality = e[2]),
            void 0 !== e[3] && (i.alpha = e[3]),
            void 0 !== e[4] && (i.knockout = e[4])),
            (i = { ...t.DEFAULT_OPTIONS, ...i });
          const n = i.quality ?? 0.1;
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct OutlineUniforms {\n  uThickness:vec2<f32>,\n  uColor:vec3<f32>,\n  uAlpha:f32,\n  uAngleStep:f32,\n  uKnockout:f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> outlineUniforms : OutlineUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let sourceColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let contentColor: vec4<f32> = sourceColor * (1. - outlineUniforms.uKnockout);\n  \n  let outlineAlpha: f32 = outlineUniforms.uAlpha * outlineMaxAlphaAtPos(uv) * (1. - sourceColor.a);\n  let outlineColor: vec4<f32> = vec4<f32>(vec3<f32>(outlineUniforms.uColor) * outlineAlpha, outlineAlpha);\n  \n  return contentColor + outlineColor;\n}\n\nfn outlineMaxAlphaAtPos(uv: vec2<f32>) -> f32 {\n  let thickness = outlineUniforms.uThickness;\n\n  if (thickness.x == 0. || thickness.y == 0.) {\n    return 0.;\n  }\n  \n  let angleStep = outlineUniforms.uAngleStep;\n\n  var displacedColor: vec4<f32>;\n  var displacedPos: vec2<f32>;\n\n  var maxAlpha: f32 = 0.;\n  var displaced: vec2<f32>;\n  var curColor: vec4<f32>;\n\n  for (var angle = 0.; angle <= DOUBLE_PI; angle += angleStep)\n  {\n    displaced.x = uv.x + thickness.x * cos(angle);\n    displaced.y = uv.y + thickness.y * sin(angle);\n    curColor = textureSample(uTexture, uSampler, clamp(displaced, gfu.uInputClamp.xy, gfu.uInputClamp.zw));\n    maxAlpha = max(maxAlpha, curColor.a);\n  }\n\n  return maxAlpha;\n}\n\nconst DOUBLE_PI: f32 = 3.14159265358979323846264 * 2.;",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uThickness;\nuniform vec3 uColor;\nuniform float uAlpha;\nuniform float uKnockout;\n\nuniform vec4 uInputClamp;\n\nconst float DOUBLE_PI = 2. * 3.14159265358979323846264;\nconst float ANGLE_STEP = ${ANGLE_STEP};\n\nfloat outlineMaxAlphaAtPos(vec2 pos) {\n    if (uThickness.x == 0. || uThickness.y == 0.) {\n        return 0.;\n    }\n\n    vec4 displacedColor;\n    vec2 displacedPos;\n    float maxAlpha = 0.;\n\n    for (float angle = 0.; angle <= DOUBLE_PI; angle += ANGLE_STEP) {\n        displacedPos.x = vTextureCoord.x + uThickness.x * cos(angle);\n        displacedPos.y = vTextureCoord.y + uThickness.y * sin(angle);\n        displacedColor = texture(uTexture, clamp(displacedPos, uInputClamp.xy, uInputClamp.zw));\n        maxAlpha = max(maxAlpha, displacedColor.a);\n    }\n\n    return maxAlpha;\n}\n\nvoid main(void) {\n    vec4 sourceColor = texture(uTexture, vTextureCoord);\n    vec4 contentColor = sourceColor * float(uKnockout < 0.5);\n    float outlineAlpha = uAlpha * outlineMaxAlphaAtPos(vTextureCoord.xy) * (1.-sourceColor.a);\n    vec4 outlineColor = vec4(vec3(uColor) * outlineAlpha, outlineAlpha);\n    finalColor = contentColor + outlineColor;\n}\n".replace(
                  /\$\{ANGLE_STEP\}/,
                  t.getAngleStep(n).toFixed(7)
                ),
              name: "outline-filter",
            }),
            resources: {
              outlineUniforms: {
                uThickness: { value: new Float32Array(2), type: "vec2<f32>" },
                uColor: { value: new Float32Array(3), type: "vec3<f32>" },
                uAlpha: { value: i.alpha, type: "f32" },
                uAngleStep: { value: 0, type: "f32" },
                uKnockout: { value: i.knockout ? 1 : 0, type: "f32" },
              },
            },
          }),
            gs(this, "uniforms"),
            gs(this, "_thickness"),
            gs(this, "_quality"),
            gs(this, "_color"),
            (this.uniforms = this.resources.outlineUniforms.uniforms),
            (this.uniforms.uAngleStep = t.getAngleStep(n)),
            (this._color = new at.Q()),
            (this.color = i.color ?? 0),
            Object.assign(this, i);
        }
        apply(t, e, i, n) {
          (this.uniforms.uThickness[0] = this.thickness / e.source.width),
            (this.uniforms.uThickness[1] = this.thickness / e.source.height),
            t.applyFilter(this, e, i, n);
        }
        static getAngleStep(e) {
          return parseFloat(
            (
              (2 * Math.PI) /
              Math.max(e * t.MAX_SAMPLES, t.MIN_SAMPLES)
            ).toFixed(7)
          );
        }
        get thickness() {
          return this._thickness;
        }
        set thickness(t) {
          this._thickness = this.padding = t;
        }
        get color() {
          return this._color.value;
        }
        set color(t) {
          this._color.setValue(t);
          const [e, i, n] = this._color.toArray();
          (this.uniforms.uColor[0] = e),
            (this.uniforms.uColor[1] = i),
            (this.uniforms.uColor[2] = n);
        }
        get alpha() {
          return this.uniforms.uAlpha;
        }
        set alpha(t) {
          this.uniforms.uAlpha = t;
        }
        get quality() {
          return this._quality;
        }
        set quality(e) {
          (this._quality = e), (this.uniforms.uAngleStep = t.getAngleStep(e));
        }
        get knockout() {
          return 1 === this.uniforms.uKnockout;
        }
        set knockout(t) {
          this.uniforms.uKnockout = t ? 1 : 0;
        }
      };
      gs(vs, "DEFAULT_OPTIONS", {
        thickness: 1,
        color: 0,
        alpha: 1,
        quality: 0.1,
        knockout: !1,
      }),
        gs(vs, "MIN_SAMPLES", 1),
        gs(vs, "MAX_SAMPLES", 100);
      let ys = vs;
      ct.d;
      var xs = Object.defineProperty,
        bs = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? xs(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Ss = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          if ("number" == typeof i) {
            if (
              ((0, yt.t)(
                "6.0.0",
                "RadialBlurFilter constructor params are now options object. See params: { angle, center, kernelSize, radius }"
              ),
              (i = { angle: i }),
              e[1])
            ) {
              const t = "x" in e[1] ? e[1].x : e[1][0],
                n = "y" in e[1] ? e[1].y : e[1][1];
              i.center = { x: t, y: n };
            }
            e[2] && (i.kernelSize = e[2]), e[3] && (i.radius = e[3]);
          }
          i = { ...t.DEFAULT_OPTIONS, ...i };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct RadialBlurUniforms {\n  uRadian: f32,\n  uCenter: vec2<f32>,\n  uKernelSize: f32,\n  uRadius: f32,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> radialBlurUniforms : RadialBlurUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uRadian = radialBlurUniforms.uRadian;\n  let uCenter = radialBlurUniforms.uCenter;\n  let uKernelSize = radialBlurUniforms.uKernelSize;\n  let uRadius = radialBlurUniforms.uRadius;\n  \n  var returnColorOnly = false;\n\n  if (uKernelSize == 0)\n  {\n    returnColorOnly = true;\n  }\n\n  let aspect: f32 = gfu.uInputSize.y / gfu.uInputSize.x;\n  let center: vec2<f32> = uCenter.xy / gfu.uInputSize.xy;\n  let gradient: f32 = uRadius / gfu.uInputSize.x * 0.3;\n  let radius: f32 = uRadius / gfu.uInputSize.x - gradient * 0.5;\n  let k: i32 = i32(uKernelSize - 1);\n\n  var coord: vec2<f32> = uv;\n  let dir: vec2<f32> = vec2<f32>(center - coord);\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * aspect));\n\n  var radianStep: f32 = uRadian;\n  \n  if (radius >= 0.0 && dist > radius)\n  {\n    let delta: f32 = dist - radius;\n    let gap: f32 = gradient;\n    let scale: f32 = 1.0 - abs(delta / gap);\n    if (scale <= 0.0) {\n      returnColorOnly = true;\n    }\n    radianStep *= scale;\n  }\n\n  radianStep /= f32(k);\n\n  let s: f32 = sin(radianStep);\n  let c: f32 = cos(radianStep);\n  let rotationMatrix: mat2x2<f32> = mat2x2<f32>(vec2<f32>(c, -s), vec2<f32>(s, c));\n  \n  var color: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let baseColor = vec4<f32>(color);\n\n  let minK: i32 = min(i32(uKernelSize) - 1, MAX_KERNEL_SIZE - 1);\n\n  for(var i: i32 = 0; i < minK; i += 1) \n  {\n    coord -= center;\n    coord.y *= aspect;\n    coord = rotationMatrix * coord;\n    coord.y /= aspect;\n    coord += center;\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, coord);\n    // switch to pre-multiplied alpha to correctly blur transparent images\n    // sample.rgb *= sample.a;\n    color += sample;\n  }\n\n  return select(color / f32(uKernelSize), baseColor, returnColorOnly);\n}\n\nconst MAX_KERNEL_SIZE: i32 = 2048;",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uRadian;\nuniform vec2 uCenter;\nuniform float uRadius;\nuniform int uKernelSize;\n\nuniform vec4 uInputSize;\n\nconst int MAX_KERNEL_SIZE = 2048;\n\nvoid main(void)\n{\n    vec4 color = texture(uTexture, vTextureCoord);\n\n    if (uKernelSize == 0)\n    {\n        finalColor = color;\n        return;\n    }\n\n    float aspect = uInputSize.y / uInputSize.x;\n    vec2 center = uCenter.xy / uInputSize.xy;\n    float gradient = uRadius / uInputSize.x * 0.3;\n    float radius = uRadius / uInputSize.x - gradient * 0.5;\n    int k = uKernelSize - 1;\n\n    vec2 coord = vTextureCoord;\n    vec2 dir = vec2(center - coord);\n    float dist = length(vec2(dir.x, dir.y * aspect));\n\n    float radianStep = uRadian;\n    if (radius >= 0.0 && dist > radius) {\n        float delta = dist - radius;\n        float gap = gradient;\n        float scale = 1.0 - abs(delta / gap);\n        if (scale <= 0.0) {\n            finalColor = color;\n            return;\n        }\n        radianStep *= scale;\n    }\n    radianStep /= float(k);\n\n    float s = sin(radianStep);\n    float c = cos(radianStep);\n    mat2 rotationMatrix = mat2(vec2(c, -s), vec2(s, c));\n\n    for(int i = 0; i < MAX_KERNEL_SIZE - 1; i++) {\n        if (i == k) {\n            break;\n        }\n\n        coord -= center;\n        coord.y *= aspect;\n        coord = rotationMatrix * coord;\n        coord.y /= aspect;\n        coord += center;\n\n        vec4 sample = texture(uTexture, coord);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample;\n    }\n\n    finalColor = color / float(uKernelSize);\n}\n",
              name: "radial-blur-filter",
            }),
            resources: {
              radialBlurUniforms: {
                uRadian: { value: 0, type: "f32" },
                uCenter: { value: i.center, type: "vec2<f32>" },
                uKernelSize: { value: i.kernelSize, type: "i32" },
                uRadius: { value: i.radius, type: "f32" },
              },
            },
          }),
            bs(this, "uniforms"),
            bs(this, "_angle"),
            bs(this, "_kernelSize"),
            (this.uniforms = this.resources.radialBlurUniforms.uniforms),
            Object.assign(this, i);
        }
        _updateKernelSize() {
          this.uniforms.uKernelSize = 0 !== this._angle ? this.kernelSize : 0;
        }
        get angle() {
          return this._angle;
        }
        set angle(t) {
          (this._angle = t),
            (this.uniforms.uRadian = (t * Math.PI) / 180),
            this._updateKernelSize();
        }
        get center() {
          return this.uniforms.uCenter;
        }
        set center(t) {
          Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this.uniforms.uCenter = t);
        }
        get centerX() {
          return this.center.x;
        }
        set centerX(t) {
          this.center.x = t;
        }
        get centerY() {
          return this.center.y;
        }
        set centerY(t) {
          this.center.y = t;
        }
        get kernelSize() {
          return this._kernelSize;
        }
        set kernelSize(t) {
          (this._kernelSize = t), this._updateKernelSize();
        }
        get radius() {
          return this.uniforms.uRadius;
        }
        set radius(t) {
          this.uniforms.uRadius = t < 0 || t === 1 / 0 ? -1 : t;
        }
      };
      bs(Ss, "DEFAULT_OPTIONS", {
        angle: 0,
        center: { x: 0, y: 0 },
        kernelSize: 5,
        radius: -1,
      });
      var Cs = Object.defineProperty,
        _s = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? Cs(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Ts = class t extends ct.d {
        constructor(e) {
          e = { ...t.DEFAULT_OPTIONS, ...e };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct ReflectionUniforms {\n  uMirror: f32,\n  uBoundary: f32,\n  uAmplitude: vec2<f32>,\n  uWavelength: vec2<f32>,\n  uAlpha: vec2<f32>,\n  uTime: f32,\n  uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> reflectionUniforms : ReflectionUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uDimensions: vec2<f32> = reflectionUniforms.uDimensions;\n  let uBoundary: f32 = reflectionUniforms.uBoundary;\n  let uMirror: bool = reflectionUniforms.uMirror > 0.5;\n  let uAmplitude: vec2<f32> = reflectionUniforms.uAmplitude;\n  let uWavelength: vec2<f32> = reflectionUniforms.uWavelength;\n  let uAlpha: vec2<f32> = reflectionUniforms.uAlpha;\n  let uTime: f32 = reflectionUniforms.uTime;\n\n  let pixelCoord: vec2<f32> = uv * gfu.uInputSize.xy;\n  let coord: vec2<f32> = pixelCoord /uDimensions;\n  var returnColorOnly: bool = false;\n\n  if (coord.y < uBoundary) {\n    returnColorOnly = true;\n  }\n\n  let k: f32 = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\n  let areaY: f32 = uBoundary * uDimensions.y / gfu.uInputSize.y;\n  let v: f32 = areaY + areaY - uv.y;\n  let y: f32 = select(uv.y, v, uMirror);\n\n  let amplitude: f32 = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / gfu.uInputSize.x;\n  let waveLength: f32 = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / gfu.uInputSize.y;\n  let alpha: f32 = select((uAlpha.y - uAlpha.x) * k + uAlpha.x, 1., returnColorOnly);\n\n  var x: f32 = uv.x + cos(v * 6.28 / waveLength - uTime) * amplitude;\n  x = clamp(x, gfu.uInputClamp.x, gfu.uInputClamp.z);\n  \n  return textureSample(uTexture, uSampler, select(vec2<f32>(x, y), uv, returnColorOnly)) * alpha;\n}\n\nfn rand(co: vec2<f32>) -> f32 \n{\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uMirror;\nuniform float uBoundary;\nuniform vec2 uAmplitude;\nuniform vec2 uWavelength;\nuniform vec2 uAlpha;\nuniform float uTime;\nuniform vec2 uDimensions;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main(void)\n{\n    vec2 pixelCoord = vTextureCoord.xy * uInputSize.xy;\n    vec2 coord = pixelCoord / uDimensions;\n\n    if (coord.y < uBoundary) {\n        finalColor = texture(uTexture, vTextureCoord);\n        return;\n    }\n\n    float k = (coord.y - uBoundary) / (1. - uBoundary + 0.0001);\n    float areaY = uBoundary * uDimensions.y / uInputSize.y;\n    float v = areaY + areaY - vTextureCoord.y;\n    float y = uMirror > 0.5 ? v : vTextureCoord.y;\n\n    float _amplitude = ((uAmplitude.y - uAmplitude.x) * k + uAmplitude.x ) / uInputSize.x;\n    float _waveLength = ((uWavelength.y - uWavelength.x) * k + uWavelength.x) / uInputSize.y;\n    float _alpha = (uAlpha.y - uAlpha.x) * k + uAlpha.x;\n\n    float x = vTextureCoord.x + cos(v * 6.28 / _waveLength - uTime) * _amplitude;\n    x = clamp(x, uInputClamp.x, uInputClamp.z);\n\n    vec4 color = texture(uTexture, vec2(x, y));\n\n    finalColor = color * _alpha;\n}\n",
              name: "reflection-filter",
            }),
            resources: {
              reflectionUniforms: {
                uMirror: { value: e.mirror ? 1 : 0, type: "f32" },
                uBoundary: { value: e.boundary, type: "f32" },
                uAmplitude: { value: e.amplitude, type: "vec2<f32>" },
                uWavelength: { value: e.waveLength, type: "vec2<f32>" },
                uAlpha: { value: e.alpha, type: "vec2<f32>" },
                uTime: { value: e.time, type: "f32" },
                uDimensions: { value: new Float32Array(2), type: "vec2<f32>" },
              },
            },
          }),
            _s(this, "uniforms"),
            _s(this, "time", 0),
            (this.uniforms = this.resources.reflectionUniforms.uniforms),
            Object.assign(this, e);
        }
        apply(t, e, i, n) {
          (this.uniforms.uDimensions[0] = e.frame.width),
            (this.uniforms.uDimensions[1] = e.frame.height),
            (this.uniforms.uTime = this.time),
            t.applyFilter(this, e, i, n);
        }
        get mirror() {
          return this.uniforms.uMirror > 0.5;
        }
        set mirror(t) {
          this.uniforms.uMirror = t ? 1 : 0;
        }
        get boundary() {
          return this.uniforms.uBoundary;
        }
        set boundary(t) {
          this.uniforms.uBoundary = t;
        }
        get amplitude() {
          return Array.from(this.uniforms.uAmplitude);
        }
        set amplitude(t) {
          (this.uniforms.uAmplitude[0] = t[0]),
            (this.uniforms.uAmplitude[1] = t[1]);
        }
        get amplitudeStart() {
          return this.uniforms.uAmplitude[0];
        }
        set amplitudeStart(t) {
          this.uniforms.uAmplitude[0] = t;
        }
        get amplitudeEnd() {
          return this.uniforms.uAmplitude[1];
        }
        set amplitudeEnd(t) {
          this.uniforms.uAmplitude[1] = t;
        }
        get waveLength() {
          return Array.from(this.uniforms.uWavelength);
        }
        set waveLength(t) {
          (this.uniforms.uWavelength[0] = t[0]),
            (this.uniforms.uWavelength[1] = t[1]);
        }
        get wavelengthStart() {
          return this.uniforms.uWavelength[0];
        }
        set wavelengthStart(t) {
          this.uniforms.uWavelength[0] = t;
        }
        get wavelengthEnd() {
          return this.uniforms.uWavelength[1];
        }
        set wavelengthEnd(t) {
          this.uniforms.uWavelength[1] = t;
        }
        get alpha() {
          return Array.from(this.uniforms.uAlpha);
        }
        set alpha(t) {
          (this.uniforms.uAlpha[0] = t[0]), (this.uniforms.uAlpha[1] = t[1]);
        }
        get alphaStart() {
          return this.uniforms.uAlpha[0];
        }
        set alphaStart(t) {
          this.uniforms.uAlpha[0] = t;
        }
        get alphaEnd() {
          return this.uniforms.uAlpha[1];
        }
        set alphaEnd(t) {
          this.uniforms.uAlpha[1] = t;
        }
      };
      _s(Ts, "DEFAULT_OPTIONS", {
        mirror: !0,
        boundary: 0.5,
        amplitude: [0, 20],
        waveLength: [30, 100],
        alpha: [1, 1],
        time: 0,
      });
      var ws = Object.defineProperty,
        Ps = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? ws(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const As = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          (Array.isArray(i) || ("x" in i && "y" in i)) &&
            ((0, yt.t)(
              "6.0.0",
              "RGBSplitFilter constructor params are now options object. See params: { red, green, blue }"
            ),
            (i = { red: i }),
            void 0 !== e[1] && (i.green = e[1]),
            void 0 !== e[2] && (i.blue = e[2])),
            (i = { ...t.DEFAULT_OPTIONS, ...i });
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct RgbSplitUniforms {\n    uRed: vec2<f32>,\n    uGreen: vec2<f32>,\n    uBlue: vec3<f32>,\n};\n\nstruct GlobalFilterUniforms {\n    uInputSize:vec4<f32>,\n    uInputPixel:vec4<f32>,\n    uInputClamp:vec4<f32>,\n    uOutputFrame:vec4<f32>,\n    uGlobalFrame:vec4<f32>,\n    uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> rgbSplitUniforms : RgbSplitUniforms;\n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n    let r = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uRed.x / gfu.uInputSize.x, rgbSplitUniforms.uRed.y / gfu.uInputSize.y)).r;\n    let g = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uGreen.x / gfu.uInputSize.x, rgbSplitUniforms.uGreen.y / gfu.uInputSize.y)).g;\n    let b = textureSample(uTexture, uSampler, uv + vec2<f32>(rgbSplitUniforms.uBlue.x / gfu.uInputSize.x, rgbSplitUniforms.uBlue.y / gfu.uInputSize.y)).b;\n    let a = textureSample(uTexture, uSampler, uv).a;\n    return vec4<f32>(r, g, b, a);\n}\n",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec4 uInputSize;\nuniform vec2 uRed;\nuniform vec2 uGreen;\nuniform vec2 uBlue;\n\nvoid main(void)\n{\n   float r = texture(uTexture, vTextureCoord + uRed/uInputSize.xy).r;\n   float g = texture(uTexture, vTextureCoord + uGreen/uInputSize.xy).g;\n   float b = texture(uTexture, vTextureCoord + uBlue/uInputSize.xy).b;\n   float a = texture(uTexture, vTextureCoord).a;\n   finalColor = vec4(r, g, b, a);\n}\n",
              name: "rgb-split-filter",
            }),
            resources: {
              rgbSplitUniforms: {
                uRed: { value: i.red, type: "vec2<f32>" },
                uGreen: { value: i.green, type: "vec2<f32>" },
                uBlue: { value: i.blue, type: "vec2<f32>" },
              },
            },
          }),
            Ps(this, "uniforms"),
            (this.uniforms = this.resources.rgbSplitUniforms.uniforms),
            Object.assign(this, i);
        }
        get red() {
          return this.uniforms.uRed;
        }
        set red(t) {
          Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this.uniforms.uRed = t);
        }
        get redX() {
          return this.red.x;
        }
        set redX(t) {
          this.red.x = t;
        }
        get redY() {
          return this.red.y;
        }
        set redY(t) {
          this.red.y = t;
        }
        get green() {
          return this.uniforms.uGreen;
        }
        set green(t) {
          Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this.uniforms.uGreen = t);
        }
        get greenX() {
          return this.green.x;
        }
        set greenX(t) {
          this.green.x = t;
        }
        get greenY() {
          return this.green.y;
        }
        set greenY(t) {
          this.green.y = t;
        }
        get blue() {
          return this.uniforms.uBlue;
        }
        set blue(t) {
          Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this.uniforms.uBlue = t);
        }
        get blueX() {
          return this.blue.x;
        }
        set blueX(t) {
          this.blue.x = t;
        }
        get blueY() {
          return this.blue.y;
        }
        set blueY(t) {
          this.blue.y = t;
        }
      };
      Ps(As, "DEFAULT_OPTIONS", {
        red: { x: -10, y: 0 },
        green: { x: 0, y: 10 },
        blue: { x: 0, y: 0 },
      });
      var ks = Object.defineProperty,
        Ms = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? ks(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Es = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          (Array.isArray(i) || ("x" in i && "y" in i)) &&
            ((0, yt.t)(
              "6.0.0",
              "ShockwaveFilter constructor params are now options object. See params: { center, speed, amplitude, wavelength, brightness, radius, time }"
            ),
            (i = { center: i, ...e[1] }),
            void 0 !== e[2] && (i.time = e[2])),
            (i = { ...t.DEFAULT_OPTIONS, ...i });
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "\nstruct ShockWaveUniforms {\n    uTime: f32,\n    uOffset: vec2<f32>,\n    uSpeed: f32,\n    uWave: vec4<f32>,\n};\n\nstruct GlobalFilterUniforms {\n    uInputSize:vec4<f32>,\n    uInputPixel:vec4<f32>,\n    uInputClamp:vec4<f32>,\n    uOutputFrame:vec4<f32>,\n    uGlobalFrame:vec4<f32>,\n    uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> shockwaveUniforms : ShockWaveUniforms;\n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n\n    let uTime = shockwaveUniforms.uTime;\n    let uOffset = shockwaveUniforms.uOffset;\n    let uSpeed = shockwaveUniforms.uSpeed;\n    let uAmplitude = shockwaveUniforms.uWave[0];\n    let uWavelength = shockwaveUniforms.uWave[1];\n    let uBrightness = shockwaveUniforms.uWave[2];\n    let uRadius = shockwaveUniforms.uWave[3];\n    let halfWavelength: f32 = uWavelength * 0.5 / gfu.uInputSize.x;\n    let maxRadius: f32 = uRadius / gfu.uInputSize.x;\n    let currentRadius: f32 = uTime * uSpeed / gfu.uInputSize.x;\n    var fade: f32 = 1.0;\n    var returnColorOnly: bool = false;\n    \n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            returnColorOnly = true;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n    var dir: vec2<f32> = vec2<f32>(uv - uOffset / gfu.uInputSize.xy);\n    dir.y *= gfu.uInputSize.y / gfu.uInputSize.x;\n\n    let dist:f32 = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        returnColorOnly = true;\n    }\n\n    let diffUV: vec2<f32> = normalize(dir);\n    let diff: f32 = (dist - currentRadius) / halfWavelength;\n    let p: f32 = 1.0 - pow(abs(diff), 2.0);\n    let powDiff: f32 = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\n    let offset: vec2<f32> = diffUV * powDiff / gfu.uInputSize.xy;\n    // Do clamp :\n    let coord: vec2<f32> = uv + offset;\n    let clampedCoord: vec2<f32> = clamp(coord, gfu.uInputClamp.xy, gfu.uInputClamp.zw);\n\n    var clampedColor: vec4<f32> = textureSample(uTexture, uSampler, clampedCoord);\n    \n    if (boolVec2(coord, clampedCoord)) \n    {\n        clampedColor *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n    // No clamp :\n    var finalColor = clampedColor;\n\n    return select(finalColor, textureSample(uTexture, uSampler, uv), returnColorOnly);\n}\n\nfn boolVec2(x: vec2<f32>, y: vec2<f32>) -> bool\n{\n    if (x.x == y.x && x.y == y.y)\n    {\n        return true;\n    }\n    \n    return false;\n}\n\nconst PI: f32 = 3.14159265358979323846264;\n",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "\nprecision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uCenter;\nuniform float uTime;\nuniform float uSpeed;\nuniform vec4 uWave;\n\nuniform vec4 uInputSize;\nuniform vec4 uInputClamp;\n\nconst float PI = 3.14159;\n\nvoid main()\n{\n    float uAmplitude = uWave[0];\n    float uWavelength = uWave[1];\n    float uBrightness = uWave[2];\n    float uRadius = uWave[3];\n\n    float halfWavelength = uWavelength * 0.5 / uInputSize.x;\n    float maxRadius = uRadius / uInputSize.x;\n    float currentRadius = uTime * uSpeed / uInputSize.x;\n\n    float fade = 1.0;\n\n    if (maxRadius > 0.0) {\n        if (currentRadius > maxRadius) {\n            finalColor = texture(uTexture, vTextureCoord);\n            return;\n        }\n        fade = 1.0 - pow(currentRadius / maxRadius, 2.0);\n    }\n\n    vec2 dir = vec2(vTextureCoord - uCenter / uInputSize.xy);\n    dir.y *= uInputSize.y / uInputSize.x;\n    float dist = length(dir);\n\n    if (dist <= 0.0 || dist < currentRadius - halfWavelength || dist > currentRadius + halfWavelength) {\n        finalColor = texture(uTexture, vTextureCoord);\n        return;\n    }\n\n    vec2 diffUV = normalize(dir);\n\n    float diff = (dist - currentRadius) / halfWavelength;\n\n    float p = 1.0 - pow(abs(diff), 2.0);\n\n    // float powDiff = diff * pow(p, 2.0) * ( amplitude * fade );\n    float powDiff = 1.25 * sin(diff * PI) * p * ( uAmplitude * fade );\n\n    vec2 offset = diffUV * powDiff / uInputSize.xy;\n\n    // Do clamp :\n    vec2 coord = vTextureCoord + offset;\n    vec2 clampedCoord = clamp(coord, uInputClamp.xy, uInputClamp.zw);\n    vec4 color = texture(uTexture, clampedCoord);\n    if (coord != clampedCoord) {\n        color *= max(0.0, 1.0 - length(coord - clampedCoord));\n    }\n\n    // No clamp :\n    // finalColor = texture(uTexture, vTextureCoord + offset);\n\n    color.rgb *= 1.0 + (uBrightness - 1.0) * p * fade;\n\n    finalColor = color;\n}\n",
              name: "shockwave-filter",
            }),
            resources: {
              shockwaveUniforms: {
                uTime: { value: i.time, type: "f32" },
                uCenter: { value: i.center, type: "vec2<f32>" },
                uSpeed: { value: i.speed, type: "f32" },
                uWave: { value: new Float32Array(4), type: "vec4<f32>" },
              },
            },
          }),
            Ms(this, "uniforms"),
            Ms(this, "time"),
            (this.time = 0),
            (this.uniforms = this.resources.shockwaveUniforms.uniforms),
            Object.assign(this, i);
        }
        apply(t, e, i, n) {
          (this.uniforms.uTime = this.time), t.applyFilter(this, e, i, n);
        }
        get center() {
          return this.uniforms.uCenter;
        }
        set center(t) {
          Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this.uniforms.uCenter = t);
        }
        get centerX() {
          return this.uniforms.uCenter.x;
        }
        set centerX(t) {
          this.uniforms.uCenter.x = t;
        }
        get centerY() {
          return this.uniforms.uCenter.y;
        }
        set centerY(t) {
          this.uniforms.uCenter.y = t;
        }
        get speed() {
          return this.uniforms.uSpeed;
        }
        set speed(t) {
          this.uniforms.uSpeed = t;
        }
        get amplitude() {
          return this.uniforms.uWave[0];
        }
        set amplitude(t) {
          this.uniforms.uWave[0] = t;
        }
        get wavelength() {
          return this.uniforms.uWave[1];
        }
        set wavelength(t) {
          this.uniforms.uWave[1] = t;
        }
        get brightness() {
          return this.uniforms.uWave[2];
        }
        set brightness(t) {
          this.uniforms.uWave[2] = t;
        }
        get radius() {
          return this.uniforms.uWave[3];
        }
        set radius(t) {
          this.uniforms.uWave[3] = t;
        }
      };
      Ms(Es, "DEFAULT_OPTIONS", {
        center: { x: 0, y: 0 },
        speed: 500,
        amplitude: 30,
        wavelength: 160,
        brightness: 1,
        radius: -1,
      });
      var Is = Object.defineProperty,
        Ds = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? Is(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Rs = class t extends ct.d {
        constructor(...e) {
          let i = e[0] ?? {};
          if (
            (i instanceof a.g &&
              ((0, yt.t)(
                "6.0.0",
                "SimpleLightmapFilter constructor params are now options object. See params: { lightMap, color, alpha }"
              ),
              (i = { lightMap: i }),
              void 0 !== e[1] && (i.color = e[1]),
              void 0 !== e[2] && (i.alpha = e[2])),
            (i = { ...t.DEFAULT_OPTIONS, ...i }),
            !i.lightMap)
          )
            throw Error(
              "No light map texture source was provided to SimpleLightmapFilter"
            );
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct SimpleLightmapUniforms {\n  uColor: vec3<f32>,\n  uAlpha: f32,\n  uDimensions: vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> simpleLightmapUniforms : SimpleLightmapUniforms;\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\n@group(1) @binding(2) var uMapSampler: sampler;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>,\n) -> @location(0) vec4<f32> {\n  let uColor = simpleLightmapUniforms.uColor;\n  let uAlpha = simpleLightmapUniforms.uAlpha;\n  let uDimensions = simpleLightmapUniforms.uDimensions;\n\n  let diffuseColor: vec4<f32> = textureSample(uTexture, uSampler, uv);\n  let lightCoord: vec2<f32> = (uv * gfu.uInputSize.xy) / simpleLightmapUniforms.uDimensions;\n  let light: vec4<f32> = textureSample(uMapTexture, uMapSampler, lightCoord);\n  let ambient: vec3<f32> = uColor * uAlpha;\n  let intensity: vec3<f32> = ambient + light.rgb;\n  let finalColor: vec3<f32> = diffuseColor.rgb * intensity;\n  return vec4<f32>(finalColor, diffuseColor.a);\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform sampler2D uMapTexture;\nuniform vec3 uColor;\nuniform float uAlpha;\nuniform vec2 uDimensions;\n\nuniform vec4 uInputSize;\n\nvoid main() {\n    vec4 diffuseColor = texture(uTexture, vTextureCoord);\n    vec2 lightCoord = (vTextureCoord * uInputSize.xy) / uDimensions;\n    vec4 light = texture(uMapTexture, lightCoord);\n    vec3 ambient = uColor.rgb * uAlpha;\n    vec3 intensity = ambient + light.rgb;\n    vec3 color = diffuseColor.rgb * intensity;\n    finalColor = vec4(color, diffuseColor.a);\n}\n",
              name: "simple-lightmap-filter",
            }),
            resources: {
              simpleLightmapUniforms: {
                uColor: { value: new Float32Array(3), type: "vec3<f32>" },
                uAlpha: { value: i.alpha, type: "f32" },
                uDimensions: { value: new Float32Array(2), type: "vec2<f32>" },
              },
              uMapTexture: i.lightMap.source,
              uMapSampler: i.lightMap.source.style,
            },
          }),
            Ds(this, "uniforms"),
            Ds(this, "_color"),
            Ds(this, "_lightMap"),
            (this.uniforms = this.resources.simpleLightmapUniforms.uniforms),
            (this._color = new at.Q()),
            (this.color = i.color ?? 0),
            Object.assign(this, i);
        }
        apply(t, e, i, n) {
          (this.uniforms.uDimensions[0] = e.frame.width),
            (this.uniforms.uDimensions[1] = e.frame.height),
            t.applyFilter(this, e, i, n);
        }
        get lightMap() {
          return this._lightMap;
        }
        set lightMap(t) {
          (this._lightMap = t),
            (this.resources.uMapTexture = t.source),
            (this.resources.uMapSampler = t.source.style);
        }
        get color() {
          return this._color.value;
        }
        set color(t) {
          this._color.setValue(t);
          const [e, i, n] = this._color.toArray();
          (this.uniforms.uColor[0] = e),
            (this.uniforms.uColor[1] = i),
            (this.uniforms.uColor[2] = n);
        }
        get alpha() {
          return this.uniforms.uAlpha;
        }
        set alpha(t) {
          this.uniforms.uAlpha = t;
        }
      };
      Ds(Rs, "DEFAULT_OPTIONS", { lightMap: a.g.WHITE, color: 0, alpha: 1 });
      var Bs = Object.defineProperty,
        Fs = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? Bs(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Os = class t extends ct.d {
        constructor(e) {
          e = { ...t.DEFAULT_OPTIONS, ...e };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct TiltShiftUniforms {\n  uBlur: vec2<f32>,\n  uStart: vec2<f32>,\n  uEnd: vec2<f32>,\n  uDelta: vec2<f32>,\n  uTexSize: vec2<f32>,\n};\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> tiltShiftUniforms : TiltShiftUniforms;\n\n@fragment\nfn mainFragment(\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uBlur = tiltShiftUniforms.uBlur[0];\n  let uBlurGradient = tiltShiftUniforms.uBlur[1];\n  let uStart = tiltShiftUniforms.uStart;\n  let uEnd = tiltShiftUniforms.uEnd;\n  let uDelta = tiltShiftUniforms.uDelta;\n  let uTexSize = tiltShiftUniforms.uTexSize;\n\n  var color: vec4<f32> = vec4<f32>(0.0);\n  var total: f32 = 0.0;\n\n  let offset: f32 = random(position, vec3<f32>(12.9898, 78.233, 151.7182), 0.0);\n  let normal: vec2<f32> = normalize(vec2<f32>(uStart.y - uEnd.y, uEnd.x - uStart.x));\n  let radius: f32 = smoothstep(0.0, 1.0, abs(dot(uv * uTexSize - uStart, normal)) / uBlurGradient) * uBlur;\n\n  for (var t: f32 = -30.0; t <= 30.0; t += 1.0)\n  {\n    var percent: f32 = (t + offset - 0.5) / 30.0;\n    var weight: f32 = 1.0 - abs(percent);\n    var sample: vec4<f32> = textureSample(uTexture, uSampler, uv + uDelta / uTexSize * percent * radius);\n    sample = vec4<f32>(sample.xyz * sample.a, sample.a); // multiply sample.rgb with sample.a\n    color += sample * weight;\n    total += weight;\n  }\n\n  color /= total;\n  color = vec4<f32>(color.xyz / (color.a + 0.00001), color.a); // divide color.rgb by color.a + 0.00001\n\n  return color;\n}\n\n\nfn random(position: vec4<f32>, scale: vec3<f32>, seed: f32) -> f32\n{\n  return fract(sin(dot(position.xyz + seed, scale)) * 43758.5453 + seed);\n}",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "in vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uBlur;\nuniform vec2 uStart;\nuniform vec2 uEnd;\nuniform vec2 uDelta;\nuniform vec2 uTexSize;\n\nfloat random(vec3 scale, float seed)\n{\n    return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    float total = 0.0;\n\n    float blur = uBlur[0];\n    float gradientBlur = uBlur[1];\n\n    float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n    vec2 normal = normalize(vec2(uStart.y - uEnd.y, uEnd.x - uStart.x));\n    float radius = smoothstep(0.0, 1.0, abs(dot(vTextureCoord * uTexSize - uStart, normal)) / gradientBlur) * blur;\n\n    for (float t = -30.0; t <= 30.0; t++)\n    {\n        float percent = (t + offset - 0.5) / 30.0;\n        float weight = 1.0 - abs(percent);\n        vec4 sample = texture(uTexture, vTextureCoord + uDelta / uTexSize * percent * radius);\n        sample.rgb *= sample.a;\n        color += sample * weight;\n        total += weight;\n    }\n\n    color /= total;\n    color.rgb /= color.a + 0.00001;\n\n    finalColor = color;\n}\n",
              name: "tilt-shift-axis-filter",
            }),
            resources: {
              tiltShiftUniforms: {
                uBlur: {
                  value: new Float32Array([
                    e.blur ?? 100,
                    e.gradientBlur ?? 600,
                  ]),
                  type: "vec2<f32>",
                },
                uStart: { value: e.start, type: "vec2<f32>" },
                uEnd: { value: e.end, type: "vec2<f32>" },
                uDelta: {
                  value: new Float32Array([30, 30]),
                  type: "vec2<f32>",
                },
                uTexSize: {
                  value: new Float32Array([
                    window.innerWidth,
                    window.innerHeight,
                  ]),
                  type: "vec2<f32>",
                },
              },
            },
          }),
            Fs(this, "uniforms"),
            Fs(this, "_tiltAxis"),
            (this.uniforms = this.resources.tiltShiftUniforms.uniforms),
            (this._tiltAxis = e.axis),
            this.updateDelta();
        }
        updateDelta() {
          if (
            ((this.uniforms.uDelta[0] = 0),
            (this.uniforms.uDelta[1] = 0),
            void 0 === this._tiltAxis)
          )
            return;
          const t = this.uniforms.uEnd,
            e = this.uniforms.uStart,
            i = t.x - e.x,
            n = t.y - e.y,
            s = Math.sqrt(i * i + n * n),
            r = "vertical" === this._tiltAxis;
          (this.uniforms.uDelta[0] = r ? -n / s : i / s),
            (this.uniforms.uDelta[1] = r ? i / s : n / s);
        }
      };
      Fs(Os, "DEFAULT_OPTIONS", {
        blur: 100,
        gradientBlur: 600,
        start: { x: 0, y: window.innerHeight / 2 },
        end: { x: 600, y: window.innerHeight / 2 },
      });
      Object.defineProperty;
      var zs = Object.defineProperty,
        Ls = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? zs(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Hs = class t extends ct.d {
        constructor(e) {
          e = { ...t.DEFAULT_OPTIONS, ...e };
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct TwistUniforms {\n  uTwist:vec2<f32>,\n  uOffset:vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> twistUniforms : TwistUniforms;\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2<f32>,\n  @builtin(position) position: vec4<f32>\n) -> @location(0) vec4<f32> {\n  return textureSample(uTexture, uSampler, unmapCoord(twist(mapCoord(uv))));\n}\n\nfn mapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n  var mappedCoord: vec2<f32> = coord;\n  mappedCoord *= gfu.uInputSize.xy;\n  mappedCoord += gfu.uOutputFrame.xy;\n  return mappedCoord;\n}\n\nfn unmapCoord(coord: vec2<f32> ) -> vec2<f32>\n{\n  var mappedCoord: vec2<f32> = coord;\n  mappedCoord -= gfu.uOutputFrame.xy;\n  mappedCoord /= gfu.uInputSize.xy;\n  return mappedCoord;\n}\n\nfn twist(coord: vec2<f32>) -> vec2<f32>\n{\n  var twistedCoord: vec2<f32> = coord;\n  let uRadius = twistUniforms.uTwist[0];\n  let uAngle = twistUniforms.uTwist[1];\n  let uOffset = twistUniforms.uOffset;\n\n  twistedCoord -= uOffset;\n  \n  let dist = length(twistedCoord);\n\n  if (dist < uRadius)\n  {\n    let ratioDist: f32 = (uRadius - dist) / uRadius;\n    let angleMod: f32 = ratioDist * ratioDist * uAngle;\n    let s: f32 = sin(angleMod);\n    let c: f32 = cos(angleMod);\n    twistedCoord = vec2<f32>(twistedCoord.x * c - twistedCoord.y * s, twistedCoord.x * s + twistedCoord.y * c);\n  }\n\n  twistedCoord += uOffset;\n  return twistedCoord;\n}\n",
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform vec2 uTwist;\nuniform vec2 uOffset;\nuniform vec4 uInputSize;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= uInputSize.xy;\n    coord += uInputSize.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= uInputSize.zw;\n    coord /= uInputSize.xy;\n\n    return coord;\n}\n\nvec2 twist(vec2 coord)\n{\n    coord -= uOffset;\n\n    float dist = length(coord);\n    float uRadius = uTwist[0];\n    float uAngle = uTwist[1];\n\n    if (dist < uRadius)\n    {\n        float ratioDist = (uRadius - dist) / uRadius;\n        float angleMod = ratioDist * ratioDist * uAngle;\n        float s = sin(angleMod);\n        float c = cos(angleMod);\n        coord = vec2(coord.x * c - coord.y * s, coord.x * s + coord.y * c);\n    }\n\n    coord += uOffset;\n\n    return coord;\n}\n\nvoid main(void)\n{\n    vec2 coord = mapCoord(vTextureCoord);\n    coord = twist(coord);\n    coord = unmapCoord(coord);\n    finalColor = texture(uTexture, coord);\n}\n",
              name: "twist-filter",
            }),
            resources: {
              twistUniforms: {
                uTwist: {
                  value: [e.radius ?? 0, e.angle ?? 0],
                  type: "vec2<f32>",
                },
                uOffset: { value: e.offset, type: "vec2<f32>" },
              },
            },
            ...e,
          }),
            Ls(this, "uniforms"),
            (this.uniforms = this.resources.twistUniforms.uniforms);
        }
        get radius() {
          return this.uniforms.uTwist[0];
        }
        set radius(t) {
          this.uniforms.uTwist[0] = t;
        }
        get angle() {
          return this.uniforms.uTwist[1];
        }
        set angle(t) {
          this.uniforms.uTwist[1] = t;
        }
        get offset() {
          return this.uniforms.uOffset;
        }
        set offset(t) {
          this.uniforms.uOffset = t;
        }
        get offsetX() {
          return this.offset.x;
        }
        set offsetX(t) {
          this.offset.x = t;
        }
        get offsetY() {
          return this.offset.y;
        }
        set offsetY(t) {
          this.offset.y = t;
        }
      };
      Ls(Hs, "DEFAULT_OPTIONS", {
        padding: 20,
        radius: 200,
        angle: 4,
        offset: { x: 0, y: 0 },
      });
      var Us = Object.defineProperty,
        Ns = (t, e, i) => (
          ((t, e, i) => {
            e in t
              ? Us(t, e, {
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                  value: i,
                })
              : (t[e] = i);
          })(t, "symbol" != typeof e ? e + "" : e, i),
          i
        );
      const Gs = class t extends ct.d {
        constructor(e) {
          const i = (e = { ...t.DEFAULT_OPTIONS, ...e }).maxKernelSize ?? 32;
          super({
            gpuProgram: ut.B.from({
              vertex: { source: Vi, entryPoint: "mainVertex" },
              fragment: {
                source:
                  "struct ZoomBlurUniforms {\n    uStrength:f32,\n    uCenter:vec2<f32>,\n    uRadii:vec2<f32>,\n};\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4<f32>,\n  uInputPixel:vec4<f32>,\n  uInputClamp:vec4<f32>,\n  uOutputFrame:vec4<f32>,\n  uGlobalFrame:vec4<f32>,\n  uOutputTexture:vec4<f32>,\n};\n\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\n\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \n@group(0) @binding(2) var uSampler: sampler;\n@group(1) @binding(0) var<uniform> zoomBlurUniforms : ZoomBlurUniforms;\n\n@fragment\nfn mainFragment(\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv : vec2<f32>\n) -> @location(0) vec4<f32> {\n  let uStrength = zoomBlurUniforms.uStrength;\n  let uCenter = zoomBlurUniforms.uCenter;\n  let uRadii = zoomBlurUniforms.uRadii;\n\n  let minGradient: f32 = uRadii[0] * 0.3;\n  let innerRadius: f32 = (uRadii[0] + minGradient * 0.5) / gfu.uInputSize.x;\n\n  let gradient: f32 = uRadii[1] * 0.3;\n  let radius: f32 = (uRadii[1] - gradient * 0.5) / gfu.uInputSize.x;\n\n  let MAX_KERNEL_SIZE: f32 = ${MAX_KERNEL_SIZE};\n\n  var countLimit: f32 = MAX_KERNEL_SIZE;\n\n  var dir: vec2<f32> = vec2<f32>(uCenter / gfu.uInputSize.xy - uv);\n  let dist: f32 = length(vec2<f32>(dir.x, dir.y * gfu.uInputSize.y / gfu.uInputSize.x));\n\n  var strength: f32 = uStrength;\n\n  var delta: f32 = 0.0;\n  var gap: f32;\n\n  if (dist < innerRadius) {\n      delta = innerRadius - dist;\n      gap = minGradient;\n  } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n      delta = dist - radius;\n      gap = gradient;\n  }\n\n  var returnColorOnly: bool = false;\n\n  if (delta > 0.0) {\n    let normalCount: f32 = gap / gfu.uInputSize.x;\n    delta = (normalCount - delta) / normalCount;\n    countLimit *= delta;\n    strength *= delta;\n    \n    if (countLimit < 1.0)\n    {\n      returnColorOnly = true;;\n    }\n  }\n\n  // randomize the lookup values to hide the fixed number of samples\n  let offset: f32 = rand(uv, 0.0);\n\n  var total: f32 = 0.0;\n  var color: vec4<f32> = vec4<f32>(0.);\n\n  dir *= strength;\n\n  for (var t = 0.0; t < MAX_KERNEL_SIZE; t += 1.0) {\n    let percent: f32 = (t + offset) / MAX_KERNEL_SIZE;\n    let weight: f32 = 4.0 * (percent - percent * percent);\n    let p: vec2<f32> = uv + dir * percent;\n    let sample: vec4<f32> = textureSample(uTexture, uSampler, p);\n    \n    if (t < countLimit)\n    {\n      color += sample * weight;\n      total += weight;\n    }\n  }\n\n  color /= total;\n\n  return select(color, textureSample(uTexture, uSampler, uv), returnColorOnly);\n}\n\nfn modulo(x: f32, y: f32) -> f32\n{\n  return x - y * floor(x/y);\n}\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nfn rand(co: vec2<f32>, seed: f32) -> f32\n{\n  let a: f32 = 12.9898;\n  let b: f32 = 78.233;\n  let c: f32 = 43758.5453;\n  let dt: f32 = dot(co + seed, vec2<f32>(a, b));\n  let sn: f32 = modulo(dt, 3.14159);\n  return fract(sin(sn) * c + seed);\n}".replace(
                    "${MAX_KERNEL_SIZE}",
                    i.toFixed(1)
                  ),
                entryPoint: "mainFragment",
              },
            }),
            glProgram: lt.M.from({
              vertex: Gi,
              fragment:
                "precision highp float;\nin vec2 vTextureCoord;\nout vec4 finalColor;\n\nuniform sampler2D uTexture;\nuniform float uStrength;\nuniform vec2 uCenter;\nuniform vec2 uRadii;\n\nuniform vec4 uInputSize;\n\nconst float MAX_KERNEL_SIZE = ${MAX_KERNEL_SIZE};\n\n// author: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand(vec2 co, float seed) {\n    const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n    highp float dt = dot(co + seed, vec2(a, b)), sn = mod(dt, 3.14159);\n    return fract(sin(sn) * c + seed);\n}\n\nvoid main() {\n    float minGradient = uRadii[0] * 0.3;\n    float innerRadius = (uRadii[0] + minGradient * 0.5) / uInputSize.x;\n\n    float gradient = uRadii[1] * 0.3;\n    float radius = (uRadii[1] - gradient * 0.5) / uInputSize.x;\n\n    float countLimit = MAX_KERNEL_SIZE;\n\n    vec2 dir = vec2(uCenter.xy / uInputSize.xy - vTextureCoord);\n    float dist = length(vec2(dir.x, dir.y * uInputSize.y / uInputSize.x));\n\n    float strength = uStrength;\n\n    float delta = 0.0;\n    float gap;\n    if (dist < innerRadius) {\n        delta = innerRadius - dist;\n        gap = minGradient;\n    } else if (radius >= 0.0 && dist > radius) { // radius < 0 means it's infinity\n        delta = dist - radius;\n        gap = gradient;\n    }\n\n    if (delta > 0.0) {\n        float normalCount = gap / uInputSize.x;\n        delta = (normalCount - delta) / normalCount;\n        countLimit *= delta;\n        strength *= delta;\n        if (countLimit < 1.0)\n        {\n            gl_FragColor = texture(uTexture, vTextureCoord);\n            return;\n        }\n    }\n\n    // randomize the lookup values to hide the fixed number of samples\n    float offset = rand(vTextureCoord, 0.0);\n\n    float total = 0.0;\n    vec4 color = vec4(0.0);\n\n    dir *= strength;\n\n    for (float t = 0.0; t < MAX_KERNEL_SIZE; t++) {\n        float percent = (t + offset) / MAX_KERNEL_SIZE;\n        float weight = 4.0 * (percent - percent * percent);\n        vec2 p = vTextureCoord + dir * percent;\n        vec4 sample = texture(uTexture, p);\n\n        // switch to pre-multiplied alpha to correctly blur transparent images\n        // sample.rgb *= sample.a;\n\n        color += sample * weight;\n        total += weight;\n\n        if (t > countLimit){\n            break;\n        }\n    }\n\n    color /= total;\n    // switch back from pre-multiplied alpha\n    // color.rgb /= color.a + 0.00001;\n\n    gl_FragColor = color;\n}\n".replace(
                  "${MAX_KERNEL_SIZE}",
                  i.toFixed(1)
                ),
              name: "zoom-blur-filter",
            }),
            resources: {
              zoomBlurUniforms: {
                uStrength: { value: e.strength, type: "f32" },
                uCenter: { value: e.center, type: "vec2<f32>" },
                uRadii: { value: new Float32Array(2), type: "vec2<f32>" },
              },
            },
          }),
            Ns(this, "uniforms"),
            (this.uniforms = this.resources.zoomBlurUniforms.uniforms),
            Object.assign(this, e);
        }
        get strength() {
          return this.uniforms.uStrength;
        }
        set strength(t) {
          this.uniforms.uStrength = t;
        }
        get center() {
          return this.uniforms.uCenter;
        }
        set center(t) {
          Array.isArray(t) && (t = { x: t[0], y: t[1] }),
            (this.uniforms.uCenter = t);
        }
        get centerX() {
          return this.uniforms.uCenter.x;
        }
        set centerX(t) {
          this.uniforms.uCenter.x = t;
        }
        get centerY() {
          return this.uniforms.uCenter.y;
        }
        set centerY(t) {
          this.uniforms.uCenter.y = t;
        }
        get innerRadius() {
          return this.uniforms.uRadii[0];
        }
        set innerRadius(t) {
          this.uniforms.uRadii[0] = t;
        }
        get radius() {
          return this.uniforms.uRadii[1];
        }
        set radius(t) {
          this.uniforms.uRadii[1] = t < 0 || t === 1 / 0 ? -1 : t;
        }
      };
      Ns(Gs, "DEFAULT_OPTIONS", {
        strength: 0.1,
        center: { x: 0, y: 0 },
        innerRadius: 0,
        radius: -1,
        maxKernelSize: 32,
      });
      var Vs = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class js extends Xt.k {
        constructor(t) {
          super(),
            (this.ui = t),
            (this.baseScale = 1),
            (this.userScale = 1),
            (this.mirrored = !1),
            (this.lastDataString = ""),
            (this.isShinyAnimationPlaying = !1);
        }
        onMouseEnter(t) {}
        onMouseLeave(t) {}
        setScale(t) {
          (this.userScale = t), this.updateScale();
        }
        updateScale() {
          this.scale.set(
            (1 == this.mirrored ? -1 : 1) * this.baseScale * this.userScale,
            this.baseScale * this.userScale
          );
        }
        compareDataString(t, e = 0, i = 0) {
          const n = `${t};${e};${i}`;
          return this.lastDataString == n || ((this.lastDataString = n), !1);
        }
        createEgg(t) {
          return Vs(this, void 0, void 0, function* () {
            if (this.compareDataString("egg", t)) return;
            const e = this.ui.app.dataHandler.petFamiliesData.get(t);
            if (void 0 === e) return Promise.reject("Pet family is undefined.");
            if (void 0 === e.texture)
              return Promise.reject("Character texture is undefined.");
            const i = yield this.ui.app.dataHandler.getStaticTexture(e.texture);
            if (void 0 === i) return Promise.reject("Texture is undefined.");
            (this.texture = i), this.updateScale();
          });
        }
        playAnimation() {
          if (void 0 === this.shinyFilter || void 0 === this.shinyUniformGroup)
            return;
          this.shinyUniformGroup.uniforms.uTime = 0;
          const t = ((e) => {
            if (
              void 0 === this.shinyUniformGroup ||
              void 0 === this.shinyFilter
            )
              return;
            const i = this.shinyUniformGroup.uniforms.uTime + 0.002 * e.deltaMS;
            (this.shinyUniformGroup.uniforms.uTime = i),
              this.shinyUniformGroup.update(),
              i > 1 &&
                (te.R.shared.remove(t),
                (this.isShinyAnimationPlaying = !1),
                (this.filters = []));
          }).bind(this);
          0 == this.isShinyAnimationPlaying &&
            ((this.isShinyAnimationPlaying = !0),
            (this.filters = [this.shinyFilter]),
            te.R.shared.add(t));
        }
        createEquipment(t, e) {
          return Vs(this, arguments, void 0, function* (t, e, i = !1) {
            if (this.compareDataString("equipment", t, e) && !i) return;
            if (0 == t) return;
            const n = yield this.ui.app.dataHandler.getEquipmentData(t, e);
            if (void 0 === n)
              return Promise.reject(`Item 0x${t.toString(16)} is undefined.`);
            if (void 0 === n.texture)
              return Promise.reject("Item texture is undefined.");
            if (1 == n.isShiny) {
              if (void 0 === this.shinyFilter) {
                const t = yield this.ui.getTexture("masks/shiny_mask"),
                  e = yield this.ui.getShaderSource("frag", "shiny"),
                  i = lt.M.from({ vertex: Gi, fragment: e });
                this.shinyUniformGroup = new ht.k({
                  uTime: { type: "f32", value: 0 },
                });
                const n = {
                  glProgram: i,
                  resources: {
                    uMaskTexture: t.source,
                    uniforms: this.shinyUniformGroup,
                  },
                };
                this.shinyFilter = new ct.d(n);
              }
              this.playAnimation();
            } else void 0 !== this.shinyUniformGroup && ((this.shinyUniformGroup.uniforms.uTime = 2), this.shinyUniformGroup.update());
            const s = yield this.ui.app.dataHandler.getStaticTexture(n.texture);
            return void 0 === s
              ? Promise.reject("Texture is undefined.")
              : ((this.texture = s),
                (this.visible = !0),
                this.pivot.set(5 * -n.texture.offsetX, 5 * n.texture.offsetY),
                Promise.resolve(n));
          });
        }
        createPlayerSkin(t, e) {
          return Vs(this, void 0, void 0, function* () {
            var i, n;
            if (this.compareDataString("playerskin", t, e)) return;
            const s =
              null === (i = this.ui.app.dataHandler.skinsData.get(e)) ||
              void 0 === i
                ? void 0
                : i.get(t);
            if (void 0 === s)
              return Promise.reject(
                `Player skin is undefined: 0x${t.toString(16)}`
              );
            const r = {
                fileName: s.fileName,
                index: s.index,
                offsetX: 0,
                offsetY: 0,
              },
              o = yield this.ui.app.dataHandler.getStaticTexture(r);
            if (void 0 === o) return Promise.reject("Texture is undefined.");
            this.texture = o;
            const a =
              null !== (n = this.ui.app.dataHandler.getTextureCoords(r)) &&
              void 0 !== n
                ? n
                : { x: 0, y: 0, width: 8, height: 8 };
            return (
              (this.baseScale = 8 != a.width ? 0.8 : 1),
              this.updateScale(),
              Promise.resolve(s)
            );
          });
        }
        createPetSkin(t, e) {
          return Vs(this, void 0, void 0, function* () {
            var i, n;
            if (this.compareDataString("petskin", t, e)) return;
            const s =
              null === (i = this.ui.app.dataHandler.petFamiliesData.get(e)) ||
              void 0 === i
                ? void 0
                : i.skins.get(t);
            if (void 0 === s)
              return Promise.reject(`Pet skin is undefined: ${t.toString(16)}`);
            const r = {
                fileName: s.fileName,
                index: s.index,
                offsetX: 0,
                offsetY: 0,
              },
              o = yield this.ui.app.dataHandler.getStaticTexture(r);
            if (void 0 === o) return Promise.reject("Texture is undefined.");
            this.texture = o;
            const a =
              null !== (n = this.ui.app.dataHandler.getTextureCoords(r)) &&
              void 0 !== n
                ? n
                : { x: 0, y: 0, width: 8, height: 8 };
            return (
              (this.baseScale = 8 != a.width ? 0.8 : 1),
              this.updateScale(),
              Promise.resolve(s)
            );
          });
        }
        createPortrait(t) {
          return Vs(this, arguments, void 0, function* (t, e = !1) {
            var i;
            if (this.compareDataString("portrait", t, Number(e))) return;
            const n = yield "string" == typeof t
              ? this.ui.app.dataHandler.enemiesData.get(t)
              : this.ui.app.dataHandler.getClass(t);
            if (void 0 === n) return Promise.reject("Character is undefined.");
            if (void 0 === n.portraitTexture)
              return Promise.reject("Character texture is undefined.");
            const s = yield this.ui.app.dataHandler.getStaticTexture(
              n.portraitTexture
            );
            if (void 0 === s) return Promise.reject("Texture is undefined.");
            (this.texture = s), (this.mirrored = e);
            const r =
              null !==
                (i = this.ui.app.dataHandler.getTextureCoords(
                  n.portraitTexture
                )) && void 0 !== i
                ? i
                : { x: 0, y: 0, width: 8, height: 8 };
            (this.baseScale = 8 != r.width ? 1 : 1.25), this.updateScale();
          });
        }
      }
      var $s = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class qs extends Ge {
        constructor(t, e) {
          super(t, e),
            (this.eventMode = "none"),
            (this.dragPositionDelta = new Et.b(0, 0)),
            (this.backgroundContainer.eventMode = "static"),
            this.backgroundContainer.addListener(
              "mousedown",
              this.onBackgroundMouseDown.bind(this)
            ),
            (this.frameTitleText = this.ui.text({
              anchor: Ve.CENTER_X,
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fontSize: 32 }
              ),
            })),
            this.frameTitleText.position.set(
              0,
              0.5 * -this.options.size.y + 26
            ),
            this.addElement(this.frameTitleText),
            (this.closeIcon = new oi(t, {
              iconTexture: "close_icon",
              anchor: Ve.CENTER,
              onClick: this.onCloseButtonClick.bind(this),
            })),
            this.closeIcon.create(),
            this.addElement(this.closeIcon),
            (this.visible = !1),
            (this.eventMode = "none"),
            (this.zIndex = 3),
            (this.onBackgroundMouseUpBinding =
              this.onBackgroundMouseUp.bind(this)),
            (this.onBackgroundMouseMoveBinding =
              this.onBackgroundMouseMove.bind(this));
        }
        setTitleColor(t) {
          this.frameTitleText.style.fill = t;
        }
        setTitleText(t) {
          this.frameTitleText.text = t;
          const [e, i] = Ve.getBoundsReminder(this.frameTitleText);
          this.frameTitleText.pivot.set(e, i);
        }
        create() {
          return $s(this, void 0, void 0, function* () {
            this.closeIcon.position.set(
              0.5 * this.options.size.x - 40,
              0.5 * -this.options.size.y + 40
            );
          });
        }
        switch() {
          1 == this.visible ? this.hide() : this.show();
        }
        onCloseButtonClick(t) {
          this.ui.playClickSound(), this.hide();
        }
        onBackgroundMouseDown(t) {
          (this.dragPositionDelta = new Et.b(
            t.clientX - this.position.x,
            t.clientY - this.position.y
          )),
            window.addEventListener("mouseup", this.onBackgroundMouseUpBinding),
            window.addEventListener(
              "mousemove",
              this.onBackgroundMouseMoveBinding
            );
        }
        onBackgroundMouseUp(t) {
          window.removeEventListener(
            "mouseup",
            this.onBackgroundMouseUpBinding
          ),
            window.removeEventListener(
              "mousemove",
              this.onBackgroundMouseMoveBinding
            );
        }
        onBackgroundMouseMove(t) {
          (this.position.x = Ve.clamp(
            t.clientX - this.dragPositionDelta.x,
            0.5 * this.options.size.x,
            window.innerWidth - 0.5 * this.options.size.x
          )),
            (this.position.y = Ve.clamp(
              t.clientY - this.dragPositionDelta.y,
              0.5 * this.options.size.y,
              window.innerHeight - 0.5 * this.options.size.y
            )),
            (this.dragPositionDelta.x = t.clientX - this.position.x),
            (this.dragPositionDelta.y = t.clientY - this.position.y);
        }
      }
      var Ws = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Xs extends qs {
        constructor(t, e) {
          super(t, e),
            (this.selectedClassType = Di.None),
            (this.classPortraits = new Map()),
            (this.classSelectionContainer = new Gt.mc()),
            this.addChild(this.classSelectionContainer);
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return Ws(this, void 0, void 0, function* () {
            t.create.call(this), this.setTitleText("Change Class");
            const e = Array.from(this.ui.app.dataHandler.classesData.values()),
              i = new Et.b(85, 100),
              n = new Et.b(90, 80);
            for (let t = 0; t < e.length; t++) {
              const s = e[t],
                r = new Gt.mc();
              (r.eventMode = "static"),
                (r.cursor = "pointer"),
                (r.alpha = 0.3),
                this.classSelectionContainer.addChild(r);
              const o = new Xt.k();
              o.anchor.set(0.5, 0.5),
                (o.width = n.x),
                (o.height = n.y),
                r.addChild(o);
              const a = new js(this.ui);
              a.createPortrait(s.type),
                a.anchor.set(0.5, 0.5),
                (a.eventMode = "none"),
                r.addChild(a);
              const l = yield this.ui.themedText({
                text: Di[s.type],
                anchor: Ve.CENTER_X,
                style: Object.assign({}, this.ui.outlineTextStyle),
              });
              l.position.set(0, 30), r.addChild(l);
              const u = i.x + (t % 6) * n.x - 0.5 * this.options.size.x,
                h = i.y + Math.floor(t / 6) * n.y - 0.5 * this.options.size.y;
              r.position.set(u, h),
                r.addListener("click", () => this.onClassPortaitClick(s.type)),
                r.addListener("touchend", () =>
                  this.onClassPortaitClick(s.type)
                ),
                r.addListener("mouseenter", () =>
                  this.onClassPortraitMouseEnter(a)
                ),
                r.addListener("mouseleave", () =>
                  this.onClassPortraitMouseLeave(s.type, a)
                ),
                yield this.classPortraits.set(s.type, a);
            }
          });
        }
        onRemoveCharacter(t) {
          this.editedCharacterContainer == t && this.hide();
        }
        onClassPortaitClick(t) {
          var e;
          this.selectedClassType !== t &&
            (this.ui.playClickSound(),
            null === (e = this.editedCharacterContainer) ||
              void 0 === e ||
              e.changeClass(t),
            this.selectClass(t),
            this.hide());
        }
        onClassPortraitMouseEnter(t) {
          t.parent.alpha = 1;
        }
        onClassPortraitMouseLeave(t, e) {
          this.selectedClassType != t && (e.parent.alpha = 0.5);
        }
        selectClass(t) {
          if (this.selectedClassType === t) return;
          if (void 0 !== this.selectedClassType) {
            let t = this.classPortraits.get(this.selectedClassType);
            void 0 !== t && (t.parent.alpha = 0.5);
          }
          this.selectedClassType = t;
          const e = this.classPortraits.get(t);
          void 0 !== e && (e.parent.alpha = 1);
        }
        getEditedCharacterContainer() {
          return this.editedCharacterContainer;
        }
        switchData(t, e) {
          if (this.editedCharacterContainer != t)
            return (
              this.selectClass(e),
              (this.editedCharacterContainer = t),
              void this.show()
            );
          1 == this.visible ? this.hide() : this.show();
        }
      }
      var Ys,
        Ks = function (t, e, i, n) {
          return new (i || (i = Promise))(function (s, r) {
            function o(t) {
              try {
                l(n.next(t));
              } catch (t) {
                r(t);
              }
            }
            function a(t) {
              try {
                l(n.throw(t));
              } catch (t) {
                r(t);
              }
            }
            function l(t) {
              t.done
                ? s(t.value)
                : (function (t) {
                    return t instanceof i
                      ? t
                      : new i(function (e) {
                          e(t);
                        });
                  })(t.value).then(o, a);
            }
            l((n = n.apply(t, e || [])).next());
          });
        };
      class Zs extends Me {
        constructor(t) {
          super(t),
            (this.equipmentLabels = ""),
            (this.searchResult = !0),
            (this.equipmentSprite = new js(this.ui)),
            this.addChild(this.equipmentSprite),
            (this.tierText = this.ui.text({
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fontSize: 20 }
              ),
            })),
            this.addChild(this.tierText);
        }
        onMouseClick(t) {}
        onMouseEnter(t) {
          void 0 !== this.equipmentSprite &&
            this.equipmentSprite.onMouseEnter(t);
        }
        onMouseLeave(t) {
          void 0 !== this.equipmentSprite &&
            this.equipmentSprite.onMouseLeave(t);
        }
        setEquipmentScale(t) {
          this.equipmentSprite.scale.set(t, t);
        }
        setAbilityMode(t) {
          void 0 === this.abilityModeText &&
            ((this.abilityModeText = this.ui.text({
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fontSize: 20, fill: ti.lightgreen }
              ),
            })),
            this.abilityModeText.position.set(-20, 8),
            this.addChild(this.abilityModeText)),
            (this.abilityModeText.visible = 0 != t),
            (this.abilityModeText.text = t.toString());
        }
        playAnimation() {
          this.equipmentSprite.playAnimation();
        }
        create(t, e) {
          return Ks(this, void 0, void 0, function* () {
            const i = yield this.equipmentSprite.createEquipment(t, e, !0);
            if (void 0 === i) return this.hide(), Promise.resolve(i);
            (this.equipmentLabels = i.name + i.searchLabels),
              this.equipmentSprite.anchor.set(0.5, 0.5),
              (this.equipmentSprite.eventMode = "none");
            const [n, s] = Ve.itemTier(i.tier);
            return (
              this.tierText.position.set(4, 8),
              this.tierText.anchor.set(0, 0),
              (this.tierText.text = n),
              (this.tierText.style.fill = s),
              this.show(),
              Promise.resolve(i)
            );
          });
        }
      }
      !(function (t) {
        (t[(t.Top = 0)] = "Top"),
          (t[(t.Bottom = 1)] = "Bottom"),
          (t[(t.Stay = 2)] = "Stay"),
          (t[(t.AddElement = 3)] = "AddElement"),
          (t[(t.RemoveElement = 4)] = "RemoveElement");
      })(Ys || (Ys = {}));
      var Qs = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Js extends Me {
        constructor(t, e) {
          super(t),
            (this.removeElements = () => {
              this.elements.forEach((t) => {
                this.removeChild(t);
              }),
                (this.elements = new Array());
            }),
            (this.sortableChildren = !0),
            (this.options = e),
            (this.scrollDistance = 0),
            (this.maxScrollDistance = 0),
            (this.scrollPercent = 0),
            (this.elements = new Array()),
            (this.backgroundSprite = new Xt.k()),
            (this.backgroundSprite.width = this.options.size.x),
            (this.backgroundSprite.height = this.options.size.y),
            (this.backgroundSprite.eventMode = "static"),
            this.backgroundSprite.addListener(
              "mousedown",
              this.onMouseDown.bind(this)
            ),
            this.addChild(this.backgroundSprite),
            (this.maskSprite = new Xt.k(a.g.WHITE)),
            (this.maskSprite.width = this.options.size.x),
            (this.maskSprite.height = this.options.size.y),
            this.addChild(this.maskSprite),
            (this.mask = this.maskSprite),
            (this.eventMode = "static"),
            this.addListener("wheel", this.onMouseWheel.bind(this));
        }
        create() {
          return Qs(this, void 0, void 0, function* () {
            var t, e, i, n;
            this.scrollBar = yield this.ui.scrollbar(
              this,
              new Et.b(20, this.options.size.y),
              null !== (t = this.options.scrollSpeed) && void 0 !== t ? t : 40
            );
            const s =
              (null !==
                (i =
                  null === (e = this.options) || void 0 === e
                    ? void 0
                    : e.size.x) && void 0 !== i
                ? i
                : 0) -
              (null !== (n = this.scrollBar.width) && void 0 !== n ? n : 20);
            this.scrollBar.position.set(s, 0),
              (this.scrollBar.visible = !1),
              this.addChild(this.scrollBar);
          });
        }
        setItemsInRow(t) {
          this.options.itemsInRow = t;
        }
        setMaskSize(t) {
          if (
            ((this.options.size.x = t.x),
            (this.options.size.y = t.y),
            (this.backgroundSprite.width = t.x),
            (this.backgroundSprite.height = t.y),
            (this.maskSprite.width = t.x),
            (this.maskSprite.height = t.y),
            void 0 === this.scrollBar)
          )
            return;
          if (void 0 === this.options) return;
          const e =
            this.options.itemsInRow *
              (this.options.itemSize.x + this.options.itemSpacing.x) +
            this.options.itemOffset.x +
            4;
          this.scrollBar.position.set(e, 0), this.setScrollDistance(0);
        }
        isScrollbarVisible() {
          return (
            (this.elements.length / this.options.itemsInRow) *
              this.options.itemSize.y >
            this.options.size.y
          );
        }
        onMouseDown(t) {
          let e = 2,
            i = this,
            n = this.parent;
          for (; void 0 !== n && null != n && e >= 0; )
            n.children[0] != i && n.children[0].emit("mousedown", t),
              (i = n),
              (n = n.parent),
              e--;
        }
        onMouseWheel(t) {
          if (void 0 === this.scrollBar) return;
          const e = Math.sign(t.deltaY),
            i = this.scrollBar.getScrollSpeed() * e,
            n = Ve.clamp(this.scrollDistance + i, 0, this.maxScrollDistance);
          this.setScrollDistance(n, this.maxScrollDistance);
        }
        onScrollBarMoved(t) {
          (this.scrollDistance = t * this.maxScrollDistance),
            (this.scrollPercent = t),
            this.updateElements();
        }
        addElement(t, e) {
          this.addChild(t),
            void 0 !== e
              ? this.elements.splice(e, 0, t)
              : this.elements.push(t);
        }
        removeElement(t) {
          const e = this.elements.indexOf(t);
          e < 0 || this.elements.splice(e, 1);
        }
        getElementIndex(t) {
          for (let e = 0; e < this.elements.length; e++)
            if (this.elements[e] == t) return e;
          return -1;
        }
        getElementByIndex(t) {
          return this.elements[t];
        }
        swapElements(t, e) {
          const i = this.elements[t];
          (this.elements[t] = this.elements[e]),
            (this.elements[e] = i),
            this.updateElements();
        }
        getElementsHeight() {
          let t = 0,
            e = 0;
          return (
            this.elements.forEach((i) =>
              Qs(this, void 0, void 0, function* () {
                if (0 == i.visible) return;
                const n = i.renderable;
                i.renderable = !0;
                const s = i.getBounds();
                (e += s.height + this.options.itemSpacing.y),
                  (i.renderable = n),
                  t++;
              })
            ),
            0 != this.options.itemSize.y
              ? Math.ceil(t / this.options.itemsInRow) *
                (this.options.itemSize.y + this.options.itemSpacing.y)
              : e
          );
        }
        calculateMaxScrollDistance() {
          const t = this.getElementsHeight();
          return Math.max(t - this.options.size.y, 0);
        }
        setScrollDistance(t = this.scrollDistance, e) {
          var i;
          (this.maxScrollDistance =
            void 0 === e ? this.calculateMaxScrollDistance() : e),
            (this.scrollDistance = Ve.clamp(
              -1 == t ? this.maxScrollDistance : t,
              0,
              this.maxScrollDistance
            )),
            (this.scrollPercent =
              0 == this.maxScrollDistance
                ? this.scrollPercent
                : this.scrollDistance / this.maxScrollDistance),
            null === (i = this.scrollBar) ||
              void 0 === i ||
              i.updateThumb(
                this.options.size.y,
                this.scrollDistance,
                this.maxScrollDistance
              ),
            this.updateElements();
        }
        updateScrollDistance() {
          const t = this.calculateMaxScrollDistance(),
            e = t * this.scrollPercent;
          this.setScrollDistance(e, t);
        }
        updateHeight() {
          return Qs(
            this,
            arguments,
            void 0,
            function* (t = this.options.size.y, e = Ys.Top) {
              var i, n;
              const s =
                null !==
                  (n =
                    null === (i = this.options.itemSize) || void 0 === i
                      ? void 0
                      : i.y) && void 0 !== n
                  ? n
                  : 0;
              switch (
                (t < s && (t = s),
                (this.options.size.y = t),
                (this.maskSprite.height = t),
                e)
              ) {
                case Ys.Top:
                  this.setScrollDistance(0);
                  break;
                case Ys.Bottom:
                  this.setScrollDistance(-1);
                  break;
                case Ys.Stay:
                  this.updateScrollDistance();
                  break;
                case Ys.AddElement:
                  this.setScrollDistance(
                    this.scrollDistance +
                      this.options.itemSize.y +
                      this.options.itemSpacing.y
                  );
                  break;
                case Ys.RemoveElement:
                  this.setScrollDistance(
                    this.scrollDistance -
                      this.options.itemSize.y -
                      this.options.itemSpacing.y
                  );
              }
            }
          );
        }
        updateElements() {
          let t = 0,
            e = 0,
            i = 0;
          this.elements.forEach((n) =>
            Qs(this, void 0, void 0, function* () {
              if (0 == n.visible) return void (n.renderable = !1);
              n.renderable = !0;
              const s = n.getBounds(),
                r = this.options.itemSize.x || s.width,
                o = this.options.itemSize.y || s.height;
              t % this.options.itemsInRow == 0 &&
                (i += o + this.options.itemSpacing.y);
              const a =
                  this.options.itemAnchor.x * r +
                  this.options.itemOffset.x +
                  this.options.itemSpacing.x,
                l =
                  this.options.itemAnchor.y * o +
                  this.options.itemOffset.y +
                  this.options.itemSpacing.y,
                u = Math.floor((t % this.options.itemsInRow) * r + a),
                h = Math.floor(e + l - this.scrollDistance);
              (++t - 1) % this.options.itemsInRow ==
                this.options.itemsInRow - 1 &&
                (e += o + this.options.itemSpacing.y),
                h > this.options.size.y + l || h < -o
                  ? (n.renderable = !1)
                  : n.position.set(u, h);
            })
          );
        }
        getElementsCount() {
          return this.elements.length;
        }
      }
      var tr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class er extends qs {
        constructor(t, e) {
          super(t, e),
            (this.onSearchBarMouseEnter = () => {
              this.ui.app.tooltipHandler.showInformation([
                ["Item Filter", ti.white],
                ["Available search tags:", ti.orange],
                ['"st", "ut", "tiered", "tradeable", "reskin"', ti.lightyellow],
                ['"maxhp", "att", "dex", "vit", "wis", ...', ti.lightyellow],
                ['"easter", "slurp", "swoll", "twilight", ...', ti.lightyellow],
              ]);
            }),
            (this.visible = !1),
            (this.eventMode = "static"),
            (this.selectedSlotType = 0),
            (this.selectedItemId = 0),
            (this.equipmentElements = new Array()),
            (this.spacingPixels = new Et.b(60, 60)),
            (this.onMouseLeaveBinding = this.onMouseLeave.bind(this));
        }
        updateWindowLabelText() {
          var t;
          const e = `Select ${
            Re[
              null !== (t = Ve.slotMetaType(this.selectedSlotType)) &&
              void 0 !== t
                ? t
                : 0
            ]
          }`;
          this.setTitleText(e);
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return tr(this, void 0, void 0, function* () {
            var e, i;
            t.create.call(this), this.setTitleText("Change Equipment");
            const n = {
              maxLength: 20,
              placeholder: "Search Item",
              anchor: Ve.TOP_LEFT,
              clearOnClick: !0,
            };
            (this.searchBarInput = yield this.ui.searchbar(n)),
              this.searchBarInput.create(),
              this.searchBarInput.position.set(
                0.5 * -this.options.size.x + 40,
                0.5 * -this.options.size.y + 26
              ),
              (this.searchBarInput.eventMode = "static"),
              this.searchBarInput.on(
                "change",
                this.onSearchBarInput.bind(this)
              ),
              this.searchBarInput.addListener(
                "mouseenter",
                this.onSearchBarMouseEnter.bind(this)
              ),
              this.searchBarInput.addListener(
                "mouseleave",
                this.onMouseLeaveBinding
              ),
              this.addElement(this.searchBarInput),
              (this.emptySlotButton = new js(this.ui)),
              (this.emptySlotButton.texture = yield this.ui.getTexture(
                "ui/icons/cross_big_icon"
              )),
              this.emptySlotButton.anchor.set(0.5, 0.5),
              this.emptySlotButton.scale.set(2, 2),
              (this.emptySlotButton.eventMode = "static"),
              (this.emptySlotButton.cursor = "pointer"),
              this.emptySlotButton.addListener(
                "click",
                this.onEmptySlotButtonClick.bind(this)
              ),
              this.emptySlotButton.addListener(
                "mouseenter",
                this.onEmptySlotButtonMouseEnter.bind(this)
              ),
              this.emptySlotButton.addListener(
                "mouseleave",
                this.onMouseLeaveBinding
              ),
              (this.scrollContainer = new Js(this.ui, {
                size: new Et.b(this.options.size.x - 60, 360),
                itemSize: new Et.b(60, 60),
                itemSpacing: new Et.b(0, 0),
                itemAnchor: new Et.b(0, 0),
                itemOffset: new Et.b(24, 24),
                itemsInRow: 9,
                scrollSpeed: 60,
              })),
              this.scrollContainer.create(),
              this.scrollContainer.position.set(
                0.5 * -this.options.size.x + 30,
                0.5 * -this.options.size.y + 70
              ),
              this.addChild(this.scrollContainer);
            const s = Object.keys(De);
            for (let t = 0; t < s.length; t++) {
              this.equipmentElements[t] = new Array();
              const n =
                null === (e = this.ui.app.dataHandler.equipmentData.get(t)) ||
                void 0 === e
                  ? void 0
                  : e.values();
              if (void 0 !== n) {
                for (const e of n) {
                  const n = new Gt.mc();
                  (n.eventMode = "static"),
                    (n.cursor = "pointer"),
                    (n.alpha = 1),
                    null === (i = this.scrollContainer) ||
                      void 0 === i ||
                      i.addElement(n);
                  const s = new Xt.k();
                  s.anchor.set(0.5, 0.5),
                    (s.width = this.spacingPixels.x),
                    (s.height = this.spacingPixels.y),
                    n.addChild(s);
                  const r = new Zs(this.ui);
                  r.create(e.id, e.slotType),
                    (r.eventMode = "none"),
                    n.addChild(r),
                    n.addListener("click", (t) => this.onEquipmentClick(t, e)),
                    n.addListener("mouseenter", (t) =>
                      this.onEquipmentMouseEnter(t, e)
                    ),
                    n.addListener("mouseleave", (t) =>
                      this.onEquipmentMouseLeave(t, e)
                    ),
                    this.equipmentElements[t].push([r, e]);
                }
                this.equipmentElements[t].sort((t, e) =>
                  t[1].tier == e[1].tier ? 0 : t[1].tier < e[1].tier ? 1 : -1
                ),
                  this.equipmentElements[t].sort((t, e) =>
                    t[1].tier != e[1].tier
                      ? 0
                      : t[1].feedPower < e[1].feedPower
                      ? 1
                      : -1
                  );
              }
            }
          });
        }
        onRemoveCharacter(t) {
          this.editedCharacterContainer == t && this.hide();
        }
        onEmptySlotButtonClick(t) {
          return tr(this, void 0, void 0, function* () {
            void 0 !== this.editedCharacterContainer &&
              (yield this.editedCharacterContainer.equip(
                this.selectedSlotType,
                0,
                []
              ),
              this.ui.app.charactersHandler.updateCharacter(
                this.editedCharacterContainer
              ),
              this.hide(),
              this.ui.playClickSound());
          });
        }
        onEmptySlotButtonMouseEnter(t) {
          this.ui.app.tooltipHandler.showInformation([["No Item", ti.white]]);
        }
        onMouseLeave(t) {
          this.ui.app.tooltipHandler.hide();
        }
        filterEquipment(t) {
          const e = this.equipmentElements[this.selectedSlotType];
          if (void 0 !== e) {
            for (let i = 0; i < e.length; i++) {
              const n = e[i],
                s = n[0].equipmentLabels;
              n[0].searchResult = s.includes(t);
            }
            this.updateEquipment();
          }
        }
        onSearchBarInput(t) {
          (t = t.toLowerCase()), this.filterEquipment(t);
        }
        clearEquipment() {
          var t;
          null === (t = this.scrollContainer) ||
            void 0 === t ||
            t.removeElements();
        }
        updateEquipment() {
          var t;
          this.equipmentElements[this.selectedSlotType].forEach((t) => {
            t[0].parent.visible = t[0].searchResult;
          }),
            null === (t = this.scrollContainer) ||
              void 0 === t ||
              t.setScrollDistance(0);
        }
        createEquipment() {
          return tr(this, void 0, void 0, function* () {
            if (void 0 === this.scrollContainer) return;
            this.clearEquipment();
            const t = this.equipmentElements[this.selectedSlotType];
            void 0 !== this.emptySlotButton &&
              this.scrollContainer.addElement(this.emptySlotButton);
            for (let e = 0; e < t.length; e++)
              this.scrollContainer.addElement(t[e][0].parent);
            yield this.updateBounds(),
              yield this.scrollContainer.setScrollDistance(0);
          });
        }
        clearSearchResults() {
          void 0 !== this.searchBarInput &&
            ((this.searchBarInput.value = ""), this.filterEquipment(""));
        }
        onEquipmentClick(t, e) {
          return tr(this, void 0, void 0, function* () {
            void 0 !== this.editedCharacterContainer &&
              this.selectedItemId !== e.id &&
              (yield this.editedCharacterContainer.equip(e.slotType, e.id, []),
              this.ui.app.charactersHandler.updateCharacter(
                this.editedCharacterContainer
              ),
              this.hide(),
              this.ui.playClickSound());
          });
        }
        onEquipmentMouseEnter(t, e) {
          var i;
          this.ui.app.tooltipHandler.showEquipmentDescription(
            e,
            new Array(),
            null === (i = this.editedCharacterContainer) || void 0 === i
              ? void 0
              : i.characterInstance,
            !1
          );
        }
        onEquipmentMouseLeave(t, e) {
          this.ui.app.tooltipHandler.hide();
        }
        switchData(t, e) {
          void 0 !== this.searchBarInput && this.clearSearchResults(),
            this.editedCharacterContainer != t || this.selectedSlotType != e
              ? ((this.editedCharacterContainer = t),
                (this.selectedSlotType = e),
                this.updateWindowLabelText(),
                this.createEquipment(),
                this.show())
              : 1 == this.visible
              ? this.hide()
              : this.show();
        }
      }
      var ir = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class nr extends Ke {
        constructor(t, e, i, n, s, r) {
          super(t, e),
            (this.prefix = null != s ? s : ""),
            (this.suffix = null != r ? r : ""),
            (this.numberValue = 0),
            (this.minValue = null != i ? i : -999),
            (this.maxValue = null != n ? n : 999),
            (this.signed = this.minValue < 0 || this.maxValue < 0),
            (this.sign = this.signed ? "+" : ""),
            (this.lastValidInputValue = `${s}${this.sign}0${r}`);
        }
        onElementClick(t) {
          if (1 == t.shiftKey)
            return (
              this.ui.playClickSound(),
              this.emit("shiftClick", this.numberValue),
              void this.stopEditing()
            );
          super.onElementClick(t);
        }
        push(t) {
          if (!this.isActive) return;
          if (
            this.options.maxLength &&
            this.value.length >= this.options.maxLength
          )
            return;
          const e = this.prefix.length,
            i = this.value.length - this.suffix.length;
          let n = this.value.substring(e, i);
          (n += t), this.onInput(n);
        }
        delete() {
          if (!this.isActive || 0 === this.value.length) return;
          const t = this.value.substring(
            this.prefix.length,
            this.value.length - this.suffix.length - 1
          );
          this.onInput(t);
        }
        setInputColor(t) {
          (this.inputText.style.fill = t), (this.cursorSprite.tint = t);
        }
        appendData(t) {
          this.setValue(t);
        }
        setValue(t) {
          const e =
            0 == t ? `${this.sign}0` : 1 == this.signed ? Ve.signed(t) : t;
          (this.numberValue = t),
            (this.value = `${this.prefix}${e}${this.suffix}`),
            (this.lastValidInputValue = this.value);
        }
        getValue() {
          return this.numberValue;
        }
        stopEditing() {
          if (
            (super.stopEditing(), 1 == this.options.checkBoundaryAfterwards)
          ) {
            const t = Ve.clamp(this.numberValue, this.minValue, this.maxValue);
            this.setValue(t), this.onValueChanged(t);
          }
        }
        createLabel() {}
        onInputChange(t) {}
        updateCursorPosition() {}
        createCursor() {
          return ir(this, void 0, void 0, function* () {
            const t = this.background.getBounds(),
              e = yield this.ui.getTexture("ui/icons/stat_input_cursor");
            (this.cursorSprite.texture = e),
              this.cursorSprite.anchor.set(0.5, 0.5),
              this.cursorSprite.position.set(t.width - 12, 0.5 * t.height),
              (this.cursorSprite.width = 16),
              (this.cursorSprite.height = 16),
              (this.cursorSprite.alpha = 0);
          });
        }
        createInputField() {
          return ir(this, void 0, void 0, function* () {
            const t = this.background.getBounds();
            this.inputText.anchor.set(0.5, 0),
              (this.inputText.position.x = 0.5 * t.width),
              (this.inputText.position.y = 0.5 * t.height - 9);
          });
        }
        create() {
          this.createLabel(), this.createCursor(), this.createInputField();
        }
        onValueChanged(t) {
          this.emit("change", t);
        }
        onInput(t) {
          var e;
          if ((this.ui.playKeyboardSound(), 1 == this.signed)) {
            const e = t.lastIndexOf("-"),
              i = t.lastIndexOf("+");
            if (1 == t.length)
              return (
                (this.sign = "+"), this.onValueChanged(0), void this.setValue(0)
              );
            if (e > i) {
              if (0 != e)
                return (
                  (this.sign = "-"),
                  this.onValueChanged(0),
                  void this.setValue(0)
                );
            } else {
              if (!(i > e)) return (this.sign = "+"), void this.setValue(0);
              if (0 != i)
                return (
                  (this.sign = "+"),
                  this.onValueChanged(0),
                  void this.setValue(0)
                );
              t = t.substring(i);
            }
          }
          let i = Number(t);
          1 != isNaN(i)
            ? (0 ==
                (null !== (e = this.options.checkBoundaryAfterwards) &&
                  void 0 !== e &&
                  e) &&
                ((i = Ve.clamp(i, this.minValue, this.maxValue)),
                this.onValueChanged(i)),
              this.setValue(i))
            : (this.value = this.lastValidInputValue);
        }
      }
      var sr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class rr extends Ke {
        constructor(t, e, i, n) {
          super(t, e),
            (this.prefix = null != i ? i : ""),
            (this.suffix = null != n ? n : ""),
            (this.lastValidInputValue = `${i}0${n}`);
        }
        onElementClick(t) {
          if (1 == t.shiftKey)
            return (
              this.ui.playClickSound(),
              this.emit("shiftClick", this.value),
              void this.stopEditing()
            );
          super.onElementClick(t);
        }
        push(t) {
          if (!this.isActive) return;
          if (
            this.options.maxLength &&
            this.value.length >= this.options.maxLength
          )
            return;
          const e = this.prefix.length,
            i = this.value.length - this.suffix.length;
          let n = this.value.substring(e, i);
          (n += t), this.onInput(n);
        }
        delete() {
          if (!this.isActive || 0 === this.value.length) return;
          const t = this.value.substring(
            this.prefix.length,
            this.value.length - this.suffix.length - 1
          );
          this.onInput(t);
        }
        setInputColor(t) {
          (this.inputText.style.fill = t), (this.cursorSprite.tint = t);
        }
        appendData(t) {
          this.setValue(t);
        }
        setValue(t) {
          (this.value = `${this.prefix}${t}${this.suffix}`),
            (this.lastValidInputValue = this.value);
        }
        getValue() {
          return this.value;
        }
        stopEditing() {
          super.stopEditing();
        }
        createLabel() {}
        onInputChange(t) {}
        updateCursorPosition() {}
        createCursor() {
          return sr(this, void 0, void 0, function* () {
            const t = this.background.getBounds(),
              e = yield this.ui.getTexture("ui/icons/stat_input_cursor");
            (this.cursorSprite.texture = e),
              this.cursorSprite.anchor.set(0.5, 0.5),
              this.cursorSprite.position.set(t.width - 12, 0.5 * t.height),
              (this.cursorSprite.width = 16),
              (this.cursorSprite.height = 16),
              (this.cursorSprite.alpha = 0);
          });
        }
        createInputField() {
          return sr(this, void 0, void 0, function* () {
            const t = this.background.getBounds();
            this.inputText.anchor.set(0.5, 0),
              (this.inputText.position.x = 0.5 * t.width),
              (this.inputText.position.y = 0.5 * t.height - 9);
          });
        }
        create() {
          this.createLabel(), this.createCursor(), this.createInputField();
        }
        emitEvent(t) {
          this.emit("change", t);
        }
        onInput(t) {
          this.ui.playKeyboardSound(), this.emitEvent(t), this.setValue(t);
        }
      }
      var or = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class ar extends Me {
        constructor(t) {
          super(t),
            (this.eventMode = "static"),
            (this.hsvBoxSize = { x: 360, y: 100 }),
            (this.hueSliderSize = { x: 360, y: 24 }),
            (this.hue = 0),
            (this.hsvBoxUniformGroup = new ht.k({})),
            (this.hueSliderUniformGroup = new ht.k({})),
            (this.hsvBoxSprite = new Xt.k(a.g.WHITE)),
            (this.hsvBoxSprite.width = this.hsvBoxSize.x),
            (this.hsvBoxSprite.height = this.hsvBoxSize.y),
            (this.hsvBoxSprite.eventMode = "static"),
            this.addChild(this.hsvBoxSprite),
            (this.hueSliderSprite = new Xt.k(a.g.WHITE)),
            (this.hueSliderSprite.width = this.hueSliderSize.x),
            (this.hueSliderSprite.height = this.hueSliderSize.y),
            this.hueSliderSprite.position.set(0, this.hsvBoxSize.y + 10),
            (this.hueSliderSprite.eventMode = "static"),
            this.addChild(this.hueSliderSprite),
            (this.lastValidRedChannelInput = ""),
            (this.lastValidGreenChannelInput = ""),
            (this.lastValidBlueChannelInput = ""),
            (this.lastValidHexValueInput = ""),
            (this.onHSVBoxMouseMoveBinding = this.onHSVBoxMouseMove.bind(this)),
            (this.onHSVBoxMouseUpBinding = this.onHSVBoxMouseUp.bind(this)),
            (this.onHueSliderMouseMoveBinding =
              this.onHueSliderMouseMove.bind(this)),
            (this.onHueSliderMouseUpBinding =
              this.onHueSliderMouseUp.bind(this));
        }
        create() {
          this.loadShaders(),
            this.updateHSVBoxFilter(),
            this.createPointers(),
            this.createInputs();
        }
        onThemeUpdate(t) {
          const e = new at.Q(t.labeledFrameBorderColor).toArray();
          (this.hueSliderUniformGroup.uniforms.uBorderColor = e),
            this.hueSliderUniformGroup.update(),
            (this.hsvBoxUniformGroup.uniforms.uBorderColor = e),
            this.hsvBoxUniformGroup.update();
        }
        loadShaders() {
          return or(this, void 0, void 0, function* () {
            var t, e;
            const i = new at.Q(
                null !==
                  (e =
                    null === (t = this.ui.theme) || void 0 === t
                      ? void 0
                      : t.labeledFrameBorderColor) && void 0 !== e
                  ? e
                  : ti.gray
              ).toArray(),
              n = yield this.ui.getShaderSource("vert", "picker"),
              s = yield this.ui.getShaderSource("frag", "hsv_box"),
              r = lt.M.from({ vertex: n, fragment: s });
            this.hsvBoxUniformGroup = new ht.k({
              uHue: { type: "f32", value: this.hue },
              uDimensions: {
                type: "vec2<f32>",
                value: [this.hsvBoxSize.x, this.hsvBoxSize.y],
              },
              uBorderColor: { type: "vec3<f32>", value: i },
            });
            const o = {
              glProgram: r,
              resources: { uniforms: this.hsvBoxUniformGroup },
            };
            (this.hsvBoxFilter = new ct.d(o)),
              (this.hsvBoxSprite.filters = [this.hsvBoxFilter]);
            const a = yield this.ui.getShaderSource("frag", "hue_slider"),
              l = lt.M.from({ vertex: n, fragment: a });
            this.hueSliderUniformGroup = new ht.k({
              uDimensions: {
                type: "vec2<f32>",
                value: [this.hueSliderSize.x, this.hueSliderSize.y],
              },
              uBorderColor: { type: "vec3<f32>", value: i },
            });
            const u = {
              glProgram: l,
              resources: { uniforms: this.hueSliderUniformGroup },
            };
            (this.hueSliderFilter = new ct.d(u)),
              (this.hueSliderSprite.filters = [this.hueSliderFilter]);
          });
        }
        createInputs() {
          return or(this, void 0, void 0, function* () {
            const t = this.hsvBoxSize.y + this.hueSliderSprite.height + 26,
              e = { x: 80, y: 32 },
              i = {
                anchor: Ve.CENTER,
                maxLength: 4,
                textStyle: Object.assign({}, this.ui.baseTextStyle),
              },
              n = yield this.ui.thickLabeledFrame({
                labelText: "Red",
                size: e,
              });
            (this.redChannelInput = new nr(
              this.ui,
              Object.assign(Object.assign({}, i), { background: n }),
              0,
              255
            )),
              this.redChannelInput.create(),
              this.redChannelInput.setTextColor(ti.red),
              this.redChannelInput.on(
                "change",
                this.onRedChannelValueInput.bind(this)
              ),
              this.redChannelInput.position.set(0, t),
              this.addChild(this.redChannelInput);
            const s = yield this.ui.thickLabeledFrame({
              labelText: "Green",
              size: e,
            });
            (this.greenChannelInput = new nr(
              this.ui,
              Object.assign(Object.assign({}, i), { background: s }),
              0,
              255
            )),
              this.greenChannelInput.create(),
              this.greenChannelInput.setTextColor(ti.green),
              this.greenChannelInput.on(
                "change",
                this.onGreenChannelValueInput.bind(this)
              ),
              this.greenChannelInput.position.set(e.x + 8, t),
              this.addChild(this.greenChannelInput);
            const r = yield this.ui.thickLabeledFrame({
              labelText: "Blue",
              size: e,
            });
            (this.blueChannelInput = new nr(
              this.ui,
              Object.assign(Object.assign({}, i), { background: r }),
              0,
              255
            )),
              this.blueChannelInput.create(),
              this.blueChannelInput.setTextColor(ti.blue),
              this.blueChannelInput.on(
                "change",
                this.onBlueChannelValueInput.bind(this)
              ),
              this.blueChannelInput.position.set(2 * e.x + 16, t),
              this.addChild(this.blueChannelInput);
            const o = yield this.ui.thickLabeledFrame({
              labelText: "Hexa",
              size: { x: e.x + 16, y: e.y },
            });
            (this.hexColorInput = new rr(
              this.ui,
              Object.assign(Object.assign({}, i), {
                maxLength: 6,
                background: o,
              })
            )),
              this.hexColorInput.create(),
              this.hexColorInput.setTextColor(ti.lightyellow),
              this.hexColorInput.on("change", this.onHexValueInput.bind(this)),
              this.hexColorInput.position.set(3 * e.x + 24, t),
              this.addChild(this.hexColorInput);
          });
        }
        onRedChannelValueInput(t) {
          if (void 0 === this.redChannelInput) return;
          let e = Number(t);
          0 != t.length && isNaN(e)
            ? (this.redChannelInput.value = this.lastValidRedChannelInput)
            : ((e = Ve.clamp(e, 0, 255)),
              (t = e.toString()),
              (this.redChannelInput.value = t),
              (this.lastValidRedChannelInput = t),
              this.setColorFromInput());
        }
        onBlueChannelValueInput(t) {
          if (void 0 === this.blueChannelInput) return;
          let e = Number(t);
          0 != t.length && isNaN(e)
            ? (this.blueChannelInput.value = this.lastValidBlueChannelInput)
            : ((e = Ve.clamp(e, 0, 255)),
              (t = e.toString()),
              (this.blueChannelInput.value = t),
              (this.lastValidBlueChannelInput = t),
              this.setColorFromInput());
        }
        onGreenChannelValueInput(t) {
          if (void 0 === this.greenChannelInput) return;
          let e = Number(t);
          0 != t.length && isNaN(e)
            ? (this.greenChannelInput.value = this.lastValidGreenChannelInput)
            : ((e = Ve.clamp(e, 0, 255)),
              (t = e.toString()),
              (this.greenChannelInput.value = t),
              (this.lastValidGreenChannelInput = t),
              this.setColorFromInput());
        }
        onHexValueInput(t) {
          if (void 0 === this.hexColorInput) return;
          let e = Number(`0x${t}`);
          6 != t.length ||
            isNaN(e) ||
            ((t = new at.Q(e).toHex().substring(1)),
            (this.hexColorInput.value = t),
            (this.lastValidHexValueInput = t),
            this.setColorFromHexInput());
        }
        createPointers() {
          return or(this, void 0, void 0, function* () {
            (this.hsvBoxPointerGraphics = yield this.ui.circle({
              radius: 8,
              fillColor: 16777215,
              borderWidth: 1,
              borderColor: 0,
            })),
              (this.hsvBoxPointerGraphics.eventMode = "none"),
              this.addChild(this.hsvBoxPointerGraphics),
              this.hsvBoxSprite.addListener(
                "mousedown",
                this.onHSVBoxMouseDown.bind(this)
              ),
              (this.hueSliderPointerGraphics = yield this.ui.rectangle({
                width: 8,
                height: this.hueSliderSize.y + 8,
                fillColor: 16777215,
                borderWidth: 1,
                borderColor: 0,
              })),
              this.hueSliderPointerGraphics.position.set(
                this.hueSliderSize.x * this.hue,
                this.hueSliderSprite.position.y
              ),
              this.hueSliderPointerGraphics.pivot.set(4, 4),
              (this.hueSliderPointerGraphics.eventMode = "none"),
              this.addChild(this.hueSliderPointerGraphics),
              this.hueSliderSprite.addListener(
                "mousedown",
                this.onHueSliderMouseDown.bind(this)
              );
          });
        }
        onHSVBoxMouseDown(t) {
          this.onHSVBoxMouseMove(t),
            window.addEventListener("mousemove", this.onHSVBoxMouseMoveBinding),
            window.addEventListener("mouseup", this.onHSVBoxMouseUpBinding);
        }
        onHSVBoxMouseUp(t) {
          window.removeEventListener(
            "mousemove",
            this.onHSVBoxMouseMoveBinding
          ),
            window.removeEventListener("mouseup", this.onHSVBoxMouseUpBinding);
        }
        onHSVBoxMouseMove(t) {
          if (void 0 === this.hsvBoxPointerGraphics) return;
          let e = this.hsvBoxSprite.getBounds(),
            i = Ve.clamp(t.clientX - e.left, 0, this.hsvBoxSprite.width),
            n = Ve.clamp(t.clientY - e.top, 0, this.hsvBoxSprite.height);
          this.hsvBoxPointerGraphics.position.set(i, n),
            this.updateHSVBoxPointerColor(),
            this.emit("change", this.hsvBoxPointerGraphics.tint),
            this.updateInputValues(new at.Q(this.hsvBoxPointerGraphics.tint));
        }
        onHueSliderMouseDown(t) {
          window.addEventListener(
            "mousemove",
            this.onHueSliderMouseMoveBinding
          ),
            window.addEventListener("mouseup", this.onHueSliderMouseUpBinding);
        }
        onHueSliderMouseUp(t) {
          window.removeEventListener(
            "mousemove",
            this.onHueSliderMouseMoveBinding
          ),
            window.removeEventListener(
              "mouseup",
              this.onHueSliderMouseUpBinding
            );
        }
        onHueSliderMouseMove(t) {
          if (void 0 === this.hueSliderPointerGraphics) return;
          let e = this.hueSliderSprite.getBounds(),
            i =
              Ve.clamp(t.clientX - e.left, 0, this.hueSliderSprite.width) /
              this.hueSliderSize.x;
          this.setHue(i),
            this.updateHueSliderPointerPosition(i),
            void 0 !== this.hsvBoxPointerGraphics &&
              (this.emit("change", this.hsvBoxPointerGraphics.tint),
              this.updateInputValues(
                new at.Q(this.hsvBoxPointerGraphics.tint)
              ));
        }
        setHue(t) {
          (this.hue = t),
            this.updateHSVBoxFilter(),
            this.updateHSVBoxPointerColor(),
            this.updateHueSliderPointerColor();
        }
        setColor(t) {
          const e = new at.Q(t),
            [i, n, s] = Ve.rgb2hsv(e.red, e.green, e.blue);
          this.updateHSVBoxPointerPosition(n, s),
            this.updateHueSliderPointerPosition(i),
            this.setHue(i),
            this.updateInputValues(e);
        }
        setColorFromCharacterContainer(t) {
          this.setColor(t);
        }
        setColorFromInput() {
          const t = Number(this.lastValidRedChannelInput) / 255,
            e = Number(this.lastValidGreenChannelInput) / 255,
            i = Number(this.lastValidBlueChannelInput) / 255,
            n = new at.Q([t, e, i]).toNumber();
          this.setColor(n), this.emit("change", n);
        }
        setColorFromHexInput() {
          const t = new at.Q(
            Number(`0x${this.lastValidHexValueInput}`)
          ).toNumber();
          this.setColor(t), this.emit("change", t);
        }
        updateInputValues(t) {
          void 0 !== this.redChannelInput &&
            ((this.redChannelInput.value = Math.floor(255 * t.red).toString()),
            (this.lastValidRedChannelInput = this.redChannelInput.value)),
            void 0 !== this.greenChannelInput &&
              ((this.greenChannelInput.value = Math.floor(
                255 * t.green
              ).toString()),
              (this.lastValidGreenChannelInput = this.greenChannelInput.value)),
            void 0 !== this.blueChannelInput &&
              ((this.blueChannelInput.value = Math.floor(
                255 * t.blue
              ).toString()),
              (this.lastValidBlueChannelInput = this.blueChannelInput.value)),
            void 0 !== this.hexColorInput &&
              ((this.hexColorInput.value = t.toHex().substring(1)),
              (this.lastValidHexValueInput = this.hexColorInput.value));
        }
        updateHueSliderPointerPosition(t) {
          void 0 !== this.hueSliderPointerGraphics &&
            this.hueSliderPointerGraphics.position.set(
              t * this.hueSliderSize.x,
              this.hueSliderSprite.position.y
            );
        }
        updateHSVBoxPointerPosition(t, e) {
          void 0 !== this.hsvBoxPointerGraphics &&
            this.hsvBoxPointerGraphics.position.set(
              t * this.hsvBoxSize.x,
              (1 - e) * this.hsvBoxSize.y
            );
        }
        updateHSVBoxPointerColor() {
          if (void 0 === this.hsvBoxPointerGraphics) return;
          let t = this.hsvBoxPointerGraphics.position.x / this.hsvBoxSize.x,
            e = 1 - this.hsvBoxPointerGraphics.position.y / this.hsvBoxSize.y,
            i = Ve.hsv2rgb(this.hue, t, e);
          this.hsvBoxPointerGraphics.tint = new at.Q(i).toNumber();
        }
        updateHueSliderPointerColor() {
          if (void 0 === this.hueSliderPointerGraphics) return;
          let t = Ve.hsv2rgb(this.hue, 1, 1);
          this.hueSliderPointerGraphics.tint = new at.Q(t).toNumber();
        }
        updateHSVBoxFilter() {
          (this.hsvBoxUniformGroup.uniforms.uHue = this.hue),
            this.hsvBoxUniformGroup.update();
        }
      }
      var lr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class ur extends qs {
        constructor(t, e) {
          super(t, e), (this.colorPicker = new ar(this.ui));
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return lr(this, void 0, void 0, function* () {
            t.create.call(this),
              this.setTitleText("Edit Line Color"),
              this.colorPicker.position.set(
                0.5 * -this.options.size.x + 30,
                0.5 * -this.options.size.y + 64
              ),
              yield this.colorPicker.create(),
              this.addChild(this.colorPicker),
              this.colorPicker.on(
                "change",
                this.onColorPickerColorChange.bind(this)
              ),
              this.updateBackground();
          });
        }
        onThemeUpdate(t) {
          this.colorPicker.onThemeUpdate(t);
        }
        onRemoveCharacter(t) {
          this.editedCharacterContainer == t && this.hide();
        }
        setColorFromCharacterContainer(t, e) {
          this.editedCharacterContainer == t &&
            this.colorPicker.setColorFromCharacterContainer(e);
        }
        onColorPickerColorChange(t) {
          void 0 !== this.editedCharacterContainer &&
            this.ui.app.charactersHandler.setCharacterPropertyValue(
              this.editedCharacterContainer,
              "lineColor",
              t,
              !1
            );
        }
        getEditedCharacterContainer() {
          return this.editedCharacterContainer;
        }
        show() {
          super.show(),
            void 0 !== this.ui.app.mainPanelHandler &&
              this.ui.app.cacheHandler.saveCharactersToCache();
        }
        hide() {
          super.hide(),
            void 0 !== this.ui.app.mainPanelHandler &&
              this.ui.app.cacheHandler.saveCharactersToCache();
        }
        switchData(t) {
          var e;
          if (this.editedCharacterContainer != t)
            return (
              (this.editedCharacterContainer = t),
              this.show(),
              void (
                null === (e = this.colorPicker) ||
                void 0 === e ||
                e.setColor(t.getColor())
              )
            );
          1 == this.visible ? this.hide() : this.show();
        }
      }
      var hr,
        cr = function (t, e, i, n) {
          return new (i || (i = Promise))(function (s, r) {
            function o(t) {
              try {
                l(n.next(t));
              } catch (t) {
                r(t);
              }
            }
            function a(t) {
              try {
                l(n.throw(t));
              } catch (t) {
                r(t);
              }
            }
            function l(t) {
              t.done
                ? s(t.value)
                : (function (t) {
                    return t instanceof i
                      ? t
                      : new i(function (e) {
                          e(t);
                        });
                  })(t.value).then(o, a);
            }
            l((n = n.apply(t, e || [])).next());
          });
        };
      class dr extends Me {
        constructor(t) {
          super(t),
            (this.eventMode = "static"),
            (this.cursor = "pointer"),
            (this.exaltationStage = 0),
            (this.backgroundSprite = new Xt.k()),
            this.backgroundSprite.anchor.set(0.5, 0.5),
            this.backgroundSprite.scale.set(2),
            this.addChild(this.backgroundSprite),
            (this.percentText = this.ui.text({
              anchor: Ve.CENTER_X,
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fontSize: 16 }
              ),
            })),
            (this.percentText.position.y = Math.floor(
              0.5 * this.backgroundSprite.height - 16
            )),
            this.addChild(this.percentText),
            (this.statText = this.ui.text({
              text: "DMG",
              anchor: Ve.CENTER_X,
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fontSize: 16, fill: ti.yellow }
              ),
            })),
            (this.statText.position.y = Math.floor(
              0.5 * this.backgroundSprite.height - 4
            )),
            this.addChild(this.statText);
        }
        setExaltationStage(t) {
          (this.exaltationStage = t), this.update();
        }
        update() {
          return cr(this, void 0, void 0, function* () {
            const t = (yield this.ui.getTexture("ui/icons/exaltation_4"))
                .source,
              e = t.height,
              i = { x: this.exaltationStage * e, y: 0, width: e, height: e };
            (this.backgroundSprite.texture = new a.g({ source: t, frame: i })),
              (this.percentText.text = `+${2.5 * this.exaltationStage}%`);
          });
        }
      }
      !(function (t) {
        (t[(t.Mode1 = 0)] = "Mode1"),
          (t[(t.Mode2 = 1)] = "Mode2"),
          (t[(t.Mode3 = 2)] = "Mode3");
      })(hr || (hr = {}));
      var pr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class fr extends nr {
        constructor(t, e, i, n, s, r, o) {
          super(t, e, s, r, "(", ")"),
            (this.sortableChildren = !0),
            (this.stat = { type: n }),
            (this.barSprite = new Xt.k()),
            (this.barPercent = null != o ? o : 1),
            (this.labelText = t.text({
              text: i,
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fill: ti.white }
              ),
            })),
            (this.totalValueText = t.text({
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fill: ti.yellow }
              ),
            })),
            this.setInputColor(ti.blue);
        }
        updateBarPercent(t) {
          (this.barPercent = t),
            this.updateBarTexture(),
            this.updateTotalValueText(),
            this.updateElementsPositions();
        }
        onElementClick(t) {
          if (1 == t.shiftKey)
            return (
              this.ui.playClickSound(),
              void this.emit(
                "shiftClick",
                this.stat.type,
                this.stat.exaltationValue
              )
            );
          super.onElementClick(t);
        }
        updateBarTexture() {
          return pr(this, void 0, void 0, function* () {
            if (void 0 === this.barSprite) return;
            const t = 232 * this.barPercent;
            if (t < 1) return void (this.barSprite.visible = !1);
            const e = yield this.ui.frameTexture({
              frameTexture: "bar_frame",
              size: new Et.b(t, 24),
            });
            (this.barSprite.visible = !0),
              (this.barSprite.texture = e),
              (this.barSprite.eventMode = "none"),
              (this.barSprite.tint =
                this.stat.type == Ee.MAXHP ? ti.maxHp : ti.maxMp);
          });
        }
        updateTotalValueText() {
          void 0 !== this.stat &&
            (this.totalValueText.text = `${Math.ceil(
              this.stat.totalValue * this.barPercent
            )}/${this.stat.totalValue}${
              0 != this.stat.totalEquipmentValue
                ? ` (${Ve.signed(this.stat.totalEquipmentValue)})`
                : ""
            }`);
        }
        updateElementsPositions() {
          const t = this.background.width;
          (this.totalValueText.position.x = 0.5 * (t - this.inputText.width)),
            (this.inputText.position.x =
              0.5 * (t + this.totalValueText.width) + 2);
        }
        appendData(t) {
          if (void 0 === t) return;
          this.stat = (0, Ue.cloneDeep)(t);
          const e = this.stat.exaltationValue;
          this.setValue(e),
            this.updateTotalValueText(),
            this.updateElementsPositions();
        }
        createLabel() {
          return pr(this, void 0, void 0, function* () {
            const t = this.background.height;
            this.labelText.anchor.set(0.5, 0),
              this.labelText.position.set(16, 0.5 * t - 9),
              this.addChild(this.labelText);
          });
        }
        createCursor() {
          const t = Object.create(null, {
            createCursor: { get: () => super.createCursor },
          });
          return pr(this, void 0, void 0, function* () {
            yield t.createCursor.call(this);
            const e = this.background.height;
            this.cursorSprite.position.y = 0.5 * e;
          });
        }
        createInputField() {
          return pr(this, void 0, void 0, function* () {
            const t = 0.5 * this.background.height;
            this.totalValueText.anchor.set(0.5, 0),
              (this.totalValueText.position.y = t - 9),
              this.addChild(this.totalValueText),
              this.inputText.anchor.set(0.5, 0),
              (this.inputText.position.y = t - 9),
              this.updateElementsPositions(),
              (this.background.zIndex = -2),
              (this.barSprite = new Xt.k()),
              this.addChild(this.barSprite),
              (this.barSprite.zIndex = -1);
          });
        }
        onValueChanged(t) {
          this.emit("change", this.stat.type, t);
        }
      }
      var mr,
        gr = function (t, e, i, n) {
          return new (i || (i = Promise))(function (s, r) {
            function o(t) {
              try {
                l(n.next(t));
              } catch (t) {
                r(t);
              }
            }
            function a(t) {
              try {
                l(n.throw(t));
              } catch (t) {
                r(t);
              }
            }
            function l(t) {
              t.done
                ? s(t.value)
                : (function (t) {
                    return t instanceof i
                      ? t
                      : new i(function (e) {
                          e(t);
                        });
                  })(t.value).then(o, a);
            }
            l((n = n.apply(t, e || [])).next());
          });
        };
      class vr extends nr {
        constructor(t, e, i, n, s) {
          super(t, e, n, s, "(", ")"),
            (this.sortableChildren = !0),
            (this.stat = { type: i }),
            (this.totalValueText = t.text({
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fill: ti.yellow }
              ),
            })),
            this.setInputColor(ti.blue);
        }
        onElementClick(t) {
          if (1 == t.shiftKey)
            return (
              this.ui.playClickSound(),
              void this.emit(
                "shiftClick",
                this.stat.type,
                this.stat.exaltationValue
              )
            );
          super.onElementClick(t);
        }
        createCursor() {
          const t = Object.create(null, {
            createCursor: { get: () => super.createCursor },
          });
          return gr(this, void 0, void 0, function* () {
            yield t.createCursor.call(this);
            const e = this.background.getBounds();
            this.cursorSprite.position.set(e.width - 12, 0.5 * e.height);
          });
        }
        updateTotalValueText() {
          void 0 !== this.stat &&
            (this.totalValueText.text = `${this.stat.totalValue} ${
              0 != this.stat.totalEquipmentValue
                ? `(${Ve.signed(this.stat.totalEquipmentValue)})`
                : ""
            }`);
        }
        updateElementsPositions() {
          const t = this.background.width;
          (this.totalValueText.position.x = 0.5 * (t - this.inputText.width)),
            (this.inputText.position.x = 0.5 * (t + this.totalValueText.width));
        }
        appendData(t) {
          if (void 0 === t) return;
          this.stat = t;
          const e = this.stat.exaltationValue;
          this.setValue(e),
            this.updateTotalValueText(),
            this.updateElementsPositions();
        }
        createInputField() {
          return gr(this, void 0, void 0, function* () {
            const t = 0.5 * this.background.height;
            this.inputText.anchor.set(0.5, 0),
              (this.inputText.position.y = t - 9),
              this.addChild(this.totalValueText),
              this.totalValueText.anchor.set(0.5, 0),
              (this.totalValueText.position.y = t - 9),
              this.updateElementsPositions();
          });
        }
        onValueChanged(t) {
          this.emit("change", this.stat.type, t);
        }
      }
      class yr extends Me {
        constructor(t, e, i, n, s) {
          super(t),
            (this.background = e),
            (this.contentText = t.text({
              style: Object.assign({}, t.outlineTextStyle),
            })),
            (this.minValue = i),
            (this.maxValue = n),
            (this.value = 0),
            (this.labels = s),
            (this.cursor = "pointer"),
            (this.eventMode = "static"),
            this.addListener("click", (t) => this.onElementClick(t, 1)),
            this.addListener("rightclick", (t) => this.onElementClick(t, -1));
        }
        appendData(t) {
          this.setValue(t);
        }
        onElementClick(t, e) {
          if (1 == t.shiftKey)
            return (
              this.ui.playClickSound(), void this.emit("shiftClick", this.value)
            );
          let i = Number(this.value) + e;
          i < this.minValue && (i = this.maxValue),
            i > this.maxValue && (i = this.minValue),
            this.ui.playClickSound(),
            this.setValue(i),
            this.onValueChanged(i);
        }
        setValue(t) {
          var e;
          this.value = t;
          const [i, n] =
            null !== (e = this.labels.get(t)) && void 0 !== e
              ? e
              : ["Error!", ti.red];
          (this.contentText.text = i), (this.contentText.tint = n);
        }
        getValue() {
          return this.value;
        }
        create() {
          this.addChild(this.background);
          const t = this.background.getBounds();
          this.contentText.anchor.set(0.5, 0),
            this.contentText.position.set(0.5 * t.width, 0.5 * t.height - 10),
            this.addChild(this.contentText);
        }
        onValueChanged(t) {
          this.emit("change", t);
        }
      }
      !(function (t) {
        (t[(t.False = 0)] = "False"), (t[(t.True = 1)] = "True");
      })(mr || (mr = {}));
      var xr,
        br = function (t, e, i, n) {
          return new (i || (i = Promise))(function (s, r) {
            function o(t) {
              try {
                l(n.next(t));
              } catch (t) {
                r(t);
              }
            }
            function a(t) {
              try {
                l(n.throw(t));
              } catch (t) {
                r(t);
              }
            }
            function l(t) {
              t.done
                ? s(t.value)
                : (function (t) {
                    return t instanceof i
                      ? t
                      : new i(function (e) {
                          e(t);
                        });
                  })(t.value).then(o, a);
            }
            l((n = n.apply(t, e || [])).next());
          });
        };
      class Sr extends Me {
        constructor(t) {
          super(t),
            (this.eventMode = "static"),
            (this.cursor = "pointer"),
            (this.exaltationStage = 0),
            (this.backgroundSprite = new Xt.k()),
            this.backgroundSprite.anchor.set(0.5, 0.5),
            this.backgroundSprite.scale.set(2),
            this.addChild(this.backgroundSprite),
            (this.timeValueText = this.ui.text({
              anchor: Ve.CENTER_X,
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fontSize: 16 }
              ),
            })),
            (this.timeValueText.position.y = Math.floor(
              0.5 * this.backgroundSprite.height - 16
            )),
            this.addChild(this.timeValueText),
            (this.statText = this.ui.text({
              text: "IC",
              anchor: Ve.CENTER_X,
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fontSize: 16, fill: ti.yellow }
              ),
            })),
            (this.statText.position.y = Math.floor(
              0.5 * this.backgroundSprite.height - 4
            )),
            this.addChild(this.statText);
        }
        setExaltationStage(t) {
          (this.exaltationStage = t), this.update();
        }
        update() {
          return br(this, void 0, void 0, function* () {
            const t = (yield this.ui.getTexture("ui/icons/exaltation_5"))
                .source,
              e = t.height,
              i = { x: this.exaltationStage * e, y: 0, width: e, height: e };
            (this.backgroundSprite.texture = new a.g({ source: t, frame: i })),
              (this.timeValueText.text = `-${(
                0.2 * this.exaltationStage
              ).toFixed(1)}s`);
          });
        }
      }
      !(function (t) {
        (t[(t.Keep = 0)] = "Keep"),
          (t[(t.Propagate = 1)] = "Propagate"),
          (t[(t.Change = 2)] = "Change");
      })(xr || (xr = {}));
      var Cr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class _r extends qs {
        constructor(t, e) {
          super(t, e),
            (this.playerStatusEffectTogglesMap = new Map()),
            (this.targetStatusEffectTogglesMap = new Map()),
            (this.classPortraitSprite = new js(this.ui)),
            (this.targetPortraitSprite = new js(this.ui)),
            (this.damageExaltationBar = new dr(this.ui)),
            (this.inCombatExaltationBar = new Sr(this.ui)),
            (this.playerStatusEffectsArray = [
              Ie.Curse,
              Ie.Exposed,
              Ie.ArmorBroken,
              Ie.Armored,
              Ie.Berserk,
              Ie.Damaging,
              Ie.Inspired,
              Ie.Invulnerable,
              Ie.Weak,
              Ie.Dazed,
              Ie.Stunned,
              Ie.Unstable,
              Ie.Healing,
              Ie.Energized,
              Ie.Sick,
              Ie.Bleeding,
              Ie.Quiet,
              Ie.Silenced,
              Ie.Speedy,
              Ie.Slowed,
              Ie.None,
              Ie.Invisible,
              Ie.PetStasis,
            ]),
            (this.targetStatusEffectsArray = [
              Ie.Curse,
              Ie.Exposed,
              Ie.ArmorBroken,
              Ie.Armored,
            ]),
            (this.onInputMouseLeaveBinding = this.onInputMouseLeave.bind(this)),
            (this.onExaltationStatValueInputBinding =
              this.onExaltationStatValueInput.bind(this)),
            (this.broadcastExaltationStatValueBinding =
              this.broadcastExaltationStatValue.bind(this));
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return Cr(this, void 0, void 0, function* () {
            t.create.call(this), this.setTitleText("Edit Character Stats");
            const e = yield this.ui.text({
              text: "Note: Click on stat to edit its value",
              anchor: Ve.CENTER_X,
              style: { fill: ti.gray },
            });
            e.position.set(0, 56 - Math.floor(0.5 * this.options.size.y)),
              this.addChild(e),
              (this.classPortraitSprite.eventMode = "static"),
              this.classPortraitSprite.addListener(
                "mouseenter",
                this.onClassPortraitMouseEnter.bind(this)
              ),
              this.classPortraitSprite.addListener(
                "mouseleave",
                this.onInputMouseLeaveBinding
              ),
              this.classPortraitSprite.position.set(
                58 - 0.5 * this.options.size.x,
                254 - 0.5 * this.options.size.y
              ),
              this.classPortraitSprite.anchor.set(0.5, 0.5),
              this.addChild(this.classPortraitSprite),
              (this.targetPortraitSprite.cursor = "pointer"),
              (this.targetPortraitSprite.eventMode = "static"),
              this.targetPortraitSprite.addListener(
                "click",
                this.onEnemyPortraitClick.bind(this)
              ),
              this.targetPortraitSprite.addListener(
                "mouseenter",
                this.ontargetPortraitMouseEnter.bind(this)
              ),
              this.targetPortraitSprite.addListener(
                "mouseleave",
                this.onInputMouseLeaveBinding
              ),
              this.targetPortraitSprite.position.set(
                0.5 * this.options.size.x - 58,
                280 - 0.5 * this.options.size.y
              ),
              this.targetPortraitSprite.anchor.set(0.5, 1),
              this.addChild(this.targetPortraitSprite),
              this.damageExaltationBar.position.set(
                0.5 * this.options.size.x - 58,
                110 - 0.5 * this.options.size.y
              ),
              this.damageExaltationBar.addListener("click", (t) =>
                this.onDamageExaltationBarClick(t, 1)
              ),
              this.damageExaltationBar.addListener("rightclick", (t) =>
                this.onDamageExaltationBarClick(t, -1)
              ),
              this.damageExaltationBar.addListener(
                "mouseenter",
                this.onDamageExaltationBarMouseEnter.bind(this)
              ),
              this.damageExaltationBar.addListener(
                "mouseleave",
                this.onInputMouseLeaveBinding
              ),
              this.addChild(this.damageExaltationBar),
              this.inCombatExaltationBar.position.set(
                0.5 * this.options.size.x - 58,
                170 - 0.5 * this.options.size.y
              ),
              this.inCombatExaltationBar.addListener("click", (t) =>
                this.onInCombatExaltationBarClick(t, 1)
              ),
              this.inCombatExaltationBar.addListener("rightclick", (t) =>
                this.onInCombatExaltationBarClick(t, -1)
              ),
              this.inCombatExaltationBar.addListener(
                "mouseenter",
                this.onInCombatExaltationBarMouseEnter.bind(this)
              ),
              this.inCombatExaltationBar.addListener(
                "mouseleave",
                this.onInputMouseLeaveBinding
              ),
              this.addChild(this.inCombatExaltationBar);
            const i = new Et.b(232, 24),
              n = new Et.b(106, 84),
              s = new Et.b(112, 36),
              r = 16,
              o = yield this.ui.frameTexture({
                frameTexture: "bar_frame",
                size: i,
              }),
              a = new Xt.k(o);
            a.tint = ti.darkgray;
            const l = { background: a };
            (this.hpStatInput = new fr(this.ui, l, "HP", Ee.MAXHP)),
              this.hpStatInput.position.set(
                0.5 * -this.options.size.x + n.x,
                0.5 * -this.options.size.y + n.y
              ),
              this.hpStatInput.on(
                "change",
                this.onExaltationStatValueInputBinding
              ),
              this.hpStatInput.on(
                "shiftClick",
                this.broadcastExaltationStatValueBinding
              ),
              this.hpStatInput.create(),
              this.addChild(this.hpStatInput);
            const u = yield this.ui.frameTexture({
                frameTexture: "bar_frame",
                size: i,
              }),
              h = new Xt.k(u);
            h.tint = ti.darkgray;
            const c = { background: h };
            (this.mpStatInput = new fr(this.ui, c, "MP", Ee.MAXMP)),
              this.mpStatInput.position.set(
                0.5 * -this.options.size.x + n.x,
                0.5 * -this.options.size.y + n.y + 28
              ),
              this.mpStatInput.on(
                "change",
                this.onExaltationStatValueInputBinding
              ),
              this.mpStatInput.on(
                "shiftClick",
                this.broadcastExaltationStatValueBinding
              ),
              this.mpStatInput.create(),
              this.addChild(this.mpStatInput);
            const d = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "ATT",
                size: s,
                labelPaddingX: r,
              }),
            };
            (this.attStatInput = new vr(this.ui, d, Ee.ATT)),
              this.attStatInput.position.set(
                0.5 * -this.options.size.x + n.x,
                0.5 * -this.options.size.y + n.y + 64
              ),
              (this.attStatInput.eventMode = "static"),
              this.attStatInput.addListener("mouseenter", () =>
                this.onBaseStatInputMouseEnter(Ee.ATT)
              ),
              this.attStatInput.addListener(
                "mouseleave",
                this.ui.app.tooltipHandler.onMouseLeaveBinding
              ),
              this.attStatInput.on(
                "change",
                this.onExaltationStatValueInputBinding
              ),
              this.attStatInput.on(
                "shiftClick",
                this.broadcastExaltationStatValueBinding
              ),
              this.attStatInput.create(),
              this.addChild(this.attStatInput);
            const p = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "DEF",
                size: s,
                labelPaddingX: r,
              }),
            };
            (this.defStatInput = new vr(this.ui, p, Ee.DEF)),
              this.defStatInput.position.set(
                0.5 * -this.options.size.x + n.x + 120,
                0.5 * -this.options.size.y + n.y + 64
              ),
              (this.defStatInput.eventMode = "static"),
              this.defStatInput.addListener("mouseenter", () =>
                this.onBaseStatInputMouseEnter(Ee.DEF)
              ),
              this.defStatInput.addListener(
                "mouseleave",
                this.ui.app.tooltipHandler.onMouseLeaveBinding
              ),
              this.defStatInput.on(
                "change",
                this.onExaltationStatValueInputBinding
              ),
              this.defStatInput.on(
                "shiftClick",
                this.broadcastExaltationStatValueBinding
              ),
              this.defStatInput.create(),
              this.addChild(this.defStatInput);
            const f = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "SPD",
                size: s,
                labelPaddingX: r,
              }),
            };
            (this.spdStatInput = new vr(this.ui, f, Ee.SPD)),
              this.spdStatInput.position.set(
                0.5 * -this.options.size.x + n.x,
                0.5 * -this.options.size.y + n.y + 110
              ),
              (this.spdStatInput.eventMode = "static"),
              this.spdStatInput.addListener("mouseenter", () =>
                this.onBaseStatInputMouseEnter(Ee.SPD)
              ),
              this.spdStatInput.addListener(
                "mouseleave",
                this.ui.app.tooltipHandler.onMouseLeaveBinding
              ),
              this.spdStatInput.on(
                "change",
                this.onExaltationStatValueInputBinding
              ),
              this.spdStatInput.on(
                "shiftClick",
                this.broadcastExaltationStatValueBinding
              ),
              this.spdStatInput.create(),
              this.addChild(this.spdStatInput);
            const m = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "DEX",
                size: s,
                labelPaddingX: r,
              }),
            };
            (this.dexStatInput = new vr(this.ui, m, Ee.DEX)),
              this.dexStatInput.position.set(
                0.5 * -this.options.size.x + n.x + 120,
                0.5 * -this.options.size.y + n.y + 110
              ),
              (this.dexStatInput.eventMode = "static"),
              this.dexStatInput.addListener("mouseenter", () =>
                this.onBaseStatInputMouseEnter(Ee.DEX)
              ),
              this.dexStatInput.addListener(
                "mouseleave",
                this.ui.app.tooltipHandler.onMouseLeaveBinding
              ),
              this.dexStatInput.on(
                "change",
                this.onExaltationStatValueInputBinding
              ),
              this.dexStatInput.on(
                "shiftClick",
                this.broadcastExaltationStatValueBinding
              ),
              this.dexStatInput.create(),
              this.addChild(this.dexStatInput);
            const g = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "VIT",
                size: s,
                labelPaddingX: r,
              }),
            };
            (this.vitStatInput = new vr(this.ui, g, Ee.VIT)),
              this.vitStatInput.position.set(
                0.5 * -this.options.size.x + n.x,
                0.5 * -this.options.size.y + n.y + 156
              ),
              (this.vitStatInput.eventMode = "static"),
              this.vitStatInput.addListener("mouseenter", () =>
                this.onBaseStatInputMouseEnter(Ee.VIT)
              ),
              this.vitStatInput.addListener(
                "mouseleave",
                this.ui.app.tooltipHandler.onMouseLeaveBinding
              ),
              this.vitStatInput.on(
                "change",
                this.onExaltationStatValueInputBinding
              ),
              this.vitStatInput.on(
                "shiftClick",
                this.broadcastExaltationStatValueBinding
              ),
              this.vitStatInput.create(),
              this.addChild(this.vitStatInput);
            const v = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "WIS",
                size: s,
                labelPaddingX: r,
              }),
            };
            (this.wisStatInput = new vr(this.ui, v, Ee.WIS)),
              this.wisStatInput.position.set(
                0.5 * -this.options.size.x + n.x + 120,
                0.5 * -this.options.size.y + n.y + 156
              ),
              (this.wisStatInput.eventMode = "static"),
              this.wisStatInput.addListener("mouseenter", () =>
                this.onBaseStatInputMouseEnter(Ee.WIS)
              ),
              this.wisStatInput.addListener(
                "mouseleave",
                this.ui.app.tooltipHandler.onMouseLeaveBinding
              ),
              this.wisStatInput.on(
                "change",
                this.onExaltationStatValueInputBinding
              ),
              this.wisStatInput.on(
                "shiftClick",
                this.broadcastExaltationStatValueBinding
              ),
              this.wisStatInput.create(),
              this.addChild(this.wisStatInput);
            const y = (yield this.ui.getTexture("ui/icons/status_effects"))
                .source,
              x = new Et.b(
                28 - 0.5 * this.options.size.x,
                214 - 0.5 * this.options.size.y
              ),
              b = new Et.b(
                0.5 * this.options.size.x - 88,
                214 - 0.5 * this.options.size.y
              );
            for (
              let t = this.playerStatusEffectsArray.length - 1;
              t >= 0;
              t--
            ) {
              const e = x.x + (t % 4) * 20,
                i = x.y - 20 * Math.floor(t / 4);
              yield this.createToggableStatusEffectTypeHelper(
                this.playerStatusEffectsArray[t],
                y,
                e,
                i,
                !0
              );
            }
            for (
              let t = this.targetStatusEffectsArray.length - 1;
              t >= 0;
              t--
            ) {
              const e = b.x + (t % 4) * 20,
                i = b.y - 20 * Math.floor(t / 4);
              yield this.createToggableStatusEffectTypeHelper(
                this.targetStatusEffectsArray[t],
                y,
                e,
                i,
                !1
              );
            }
            const S = new Et.b(124, 36),
              C = new Et.b(159, 36),
              _ = {
                background: yield this.ui.thickLabeledFrame({
                  labelText: "Pet Heal",
                  size: S,
                }),
                textStyle: { fill: ti.lightyellow },
              };
            (this.petHealLevelInput = new nr(this.ui, _, 0, 100, "Level ")),
              (this.petHealLevelInput.eventMode = "static"),
              this.petHealLevelInput.on("change", (t) =>
                this.onPropertyValueInput("petHealLevel", t)
              ),
              this.petHealLevelInput.on("shiftClick", (t) =>
                this.broadcastPropertyValue("petHealLevel", t)
              ),
              this.petHealLevelInput.addListener(
                "mouseenter",
                this.onPetHealLevelInputMouseEnter.bind(this)
              ),
              this.petHealLevelInput.addListener(
                "mouseleave",
                this.onInputMouseLeaveBinding
              ),
              this.petHealLevelInput.create(),
              this.addChild(this.petHealLevelInput);
            const T = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "Pet MP Heal",
                size: S,
              }),
              textStyle: { fill: ti.lightyellow },
            };
            (this.petMagicHealLevelInput = new nr(
              this.ui,
              T,
              0,
              100,
              "Level "
            )),
              (this.petMagicHealLevelInput.eventMode = "static"),
              this.petMagicHealLevelInput.on("change", (t) =>
                this.onPropertyValueInput("petMagicHealLevel", t)
              ),
              this.petMagicHealLevelInput.on("shiftClick", (t) =>
                this.broadcastPropertyValue("petMagicHealLevel", t)
              ),
              this.petMagicHealLevelInput.addListener(
                "mouseenter",
                this.onPetMagicHealLevelInputMouseEnter.bind(this)
              ),
              this.petMagicHealLevelInput.addListener(
                "mouseleave",
                this.onInputMouseLeaveBinding
              ),
              this.petMagicHealLevelInput.create(),
              this.addChild(this.petMagicHealLevelInput);
            const w = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "Starting HP",
                size: S,
              }),
              textStyle: { fill: ti.lightyellow },
            };
            (this.hpPercentInput = new nr(this.ui, w, 0, 100, "", "%")),
              this.hpPercentInput.on("change", (t) =>
                this.onPropertyValueInput("startingHpPercent", t)
              ),
              this.hpPercentInput.on("shiftClick", (t) =>
                this.broadcastPropertyValue("startingHpPercent", t)
              ),
              this.hpPercentInput.create(),
              this.addChild(this.hpPercentInput);
            const P = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "Starting MP",
                size: S,
              }),
              textStyle: { fill: ti.lightyellow },
            };
            (this.mpPercentInput = new nr(this.ui, P, 0, 100, "", "%")),
              this.mpPercentInput.on("change", (t) =>
                this.onPropertyValueInput("startingMpPercent", t)
              ),
              this.mpPercentInput.on("shiftClick", (t) =>
                this.broadcastPropertyValue("startingMpPercent", t)
              ),
              this.mpPercentInput.create(),
              this.addChild(this.mpPercentInput);
            const A = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "Weapon Acc.",
                size: S,
              }),
              textStyle: { fill: ti.lightyellow },
            };
            (this.weaponShotsAccuracyInput = new nr(
              this.ui,
              A,
              0,
              100,
              "",
              "%"
            )),
              this.weaponShotsAccuracyInput.on("change", (t) =>
                this.onPropertyValueInput("weaponShotsAccuracy", t)
              ),
              this.weaponShotsAccuracyInput.on("shiftClick", (t) =>
                this.broadcastPropertyValue("weaponShotsAccuracy", t)
              ),
              this.weaponShotsAccuracyInput.create(),
              this.addChild(this.weaponShotsAccuracyInput);
            const k = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "Ability Acc.",
                size: S,
              }),
              textStyle: { fill: ti.lightyellow },
            };
            (this.abilityShotsAccuracyInput = new nr(
              this.ui,
              k,
              0,
              100,
              "",
              "%"
            )),
              (this.abilityShotsAccuracyInput.eventMode = "static"),
              this.abilityShotsAccuracyInput.addListener(
                "mouseenter",
                this.onAbilityAccuracyMouseEnter.bind(this)
              ),
              this.abilityShotsAccuracyInput.addListener(
                "mouseleave",
                this.onInputMouseLeaveBinding
              ),
              this.abilityShotsAccuracyInput.on("change", (t) =>
                this.onPropertyValueInput("abilityShotsAccuracy", t)
              ),
              this.abilityShotsAccuracyInput.on("shiftClick", (t) =>
                this.broadcastPropertyValue("abilityShotsAccuracy", t)
              ),
              this.abilityShotsAccuracyInput.create(),
              this.addChild(this.abilityShotsAccuracyInput);
            const M = new Map([
                [bi.Never, ["Never", ti.red]],
                [bi.OffCooldown, ["When Ready", ti.lightyellow]],
                [bi.OffCooldownAndHold, ["Ready + Hold", ti.yellow]],
                [bi.HoldToEnd, ["Hold To End", ti.orange]],
                [bi.Summon, ["Summon", ti.lightgreen]],
              ]),
              E = yield this.ui.thickLabeledFrame({
                labelText: "Ability Use",
                size: S,
              });
            (this.abilityUseInput = new yr(this.ui, E, bi.Never, bi.Summon, M)),
              this.abilityUseInput.create(),
              this.abilityUseInput.addListener(
                "mouseenter",
                this.onAbilityUseMouseEnter.bind(this)
              ),
              this.abilityUseInput.addListener(
                "mouseleave",
                this.onInputMouseLeaveBinding
              ),
              this.abilityUseInput.on("change", (t) =>
                this.onPropertyValueInput("abilityUse", t)
              ),
              this.abilityUseInput.on("shiftClick", (t) =>
                this.broadcastPropertyValue("abilityUse", t)
              ),
              this.addChild(this.abilityUseInput);
            const I = new Map([
                [hr.Mode1, ["Mode 1", ti.lightyellow]],
                [hr.Mode2, ["Mode 2", ti.lightyellow]],
                [hr.Mode3, ["Mode 3", ti.lightyellow]],
              ]),
              D = yield this.ui.thickLabeledFrame({
                labelText: "Ability Mode",
                size: S,
              });
            (this.abilityModeInput = new yr(this.ui, D, hr.Mode1, hr.Mode3, I)),
              this.abilityModeInput.create(),
              this.abilityModeInput.on("change", (t) =>
                this.onPropertyValueInput("abilityMode", t)
              ),
              this.abilityModeInput.on("shiftClick", (t) =>
                this.broadcastPropertyValue("abilityMode", t)
              ),
              this.addChild(this.abilityModeInput);
            const R = new Map([
                [mr.False, ["Never Active", ti.red]],
                [mr.True, ["Always Active", ti.lightyellow]],
              ]),
              B = yield this.ui.thickLabeledFrame({
                labelText: "In-Combat State",
                size: C,
              });
            (this.inCombatTriggerInput = new yr(
              this.ui,
              B,
              mr.False,
              mr.True,
              R
            )),
              this.inCombatTriggerInput.create(),
              (this.inCombatTriggerInput.eventMode = "static"),
              this.inCombatTriggerInput.addListener(
                "mouseenter",
                this.onInCombatStateInputMouseEnter.bind(this)
              ),
              this.inCombatTriggerInput.addListener(
                "mouseleave",
                this.onInputMouseLeaveBinding
              ),
              this.inCombatTriggerInput.on("change", (t) =>
                this.onInCombatStateChange(t)
              ),
              this.inCombatTriggerInput.on("shiftClick", (t) =>
                this.broadcastStatusEffectValue(Ie.InCombat, !0)
              ),
              this.addChild(this.inCombatTriggerInput);
            const F = new Map([
                [_i.AllExcluded, ["All Excluded", ti.red]],
                [_i.ExcludeToggles, ["Exclude Toggles", ti.orange]],
                [_i.ExcludeEquipment, ["Exclude From Items", ti.orange]],
                [_i.AllIncluded, ["All Included", ti.lightyellow]],
              ]),
              O = yield this.ui.thickLabeledFrame({
                labelText: "Status Effects",
                size: C,
              });
            (this.applyStatusEffectsInput = new yr(
              this.ui,
              O,
              _i.AllExcluded,
              _i.AllIncluded,
              F
            )),
              this.applyStatusEffectsInput.create(),
              this.applyStatusEffectsInput.on("change", (t) =>
                this.onPropertyValueInput("applyStatusEffects", t)
              ),
              this.applyStatusEffectsInput.on("shiftClick", (t) =>
                this.broadcastPropertyValue("applyStatusEffects", t)
              ),
              this.addChild(this.applyStatusEffectsInput);
            const z = new Map([
                [Pi.Never, ["Never", ti.red]],
                [Pi.RespectValue, ["Respect Value", ti.lightyellow]],
                [Pi.AnyHit, ["Any Hit", ti.orange]],
              ]),
              L = yield this.ui.thickLabeledFrame({
                labelText: "Onhit Proc",
                size: S,
              });
            (this.onhitProcTriggerInput = new yr(
              this.ui,
              L,
              Pi.Never,
              Pi.AnyHit,
              z
            )),
              this.onhitProcTriggerInput.create(),
              this.onhitProcTriggerInput.addListener(
                "mouseenter",
                this.onGetHitInputMouseEnter.bind(this)
              ),
              this.onhitProcTriggerInput.addListener(
                "mouseleave",
                this.onInputMouseLeaveBinding
              ),
              this.onhitProcTriggerInput.on("change", (t) =>
                this.onPropertyValueInput("onhitProcTrigger", t)
              ),
              this.onhitProcTriggerInput.on("shiftClick", (t) =>
                this.broadcastPropertyValue("onhitProcTrigger", t)
              ),
              this.addChild(this.onhitProcTriggerInput);
            const H = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "Hit Damage",
                size: S,
              }),
              checkBoundaryAfterwards: !0,
              textStyle: { fill: ti.lightyellow },
            };
            (this.hitDamageInput = new nr(this.ui, H, 1, 999)),
              this.hitDamageInput.create(),
              (this.hitDamageInput.eventMode = "static"),
              this.hitDamageInput.addListener(
                "mouseenter",
                this.onHitDamageInputMouseEnter.bind(this)
              ),
              this.hitDamageInput.addListener(
                "mouseleave",
                this.onInputMouseLeaveBinding
              ),
              this.hitDamageInput.on("change", (t) =>
                this.onPropertyValueInput("hitDamage", t)
              ),
              this.hitDamageInput.on("shiftClick", (t) =>
                this.broadcastPropertyValue("hitDamage", t)
              ),
              this.addChild(this.hitDamageInput);
            const U = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "Hit Interval",
                size: S,
              }),
              textStyle: { fill: ti.lightyellow },
            };
            (this.hitIntervalInput = new nr(this.ui, U, 0, 1e4, "", " ms")),
              this.hitIntervalInput.create(),
              (this.hitIntervalInput.eventMode = "static"),
              this.hitIntervalInput.addListener(
                "mouseenter",
                this.onHitIntervalInputMouseEnter.bind(this)
              ),
              this.hitIntervalInput.addListener(
                "mouseleave",
                this.onInputMouseLeaveBinding
              ),
              this.hitIntervalInput.on("change", (t) =>
                this.onPropertyValueInput("hitIntervalMs", t)
              ),
              this.hitIntervalInput.on("shiftClick", (t) =>
                this.broadcastPropertyValue("hitIntervalMs", t)
              ),
              this.addChild(this.hitIntervalInput);
            const N = new Et.b(0, 290 - 0.5 * this.options.size.y),
              G = new Array(
                [
                  this.hpPercentInput,
                  this.mpPercentInput,
                  this.weaponShotsAccuracyInput,
                ],
                [
                  this.abilityUseInput,
                  this.abilityModeInput,
                  this.abilityShotsAccuracyInput,
                ],
                [
                  this.onhitProcTriggerInput,
                  this.hitDamageInput,
                  this.hitIntervalInput,
                ],
                [
                  this.inCombatTriggerInput,
                  this.applyStatusEffectsInput,
                  void 0,
                ],
                [this.petHealLevelInput, this.petMagicHealLevelInput, void 0]
              );
            for (let t = 0; t < G.length; t++) {
              const e =
                0 + G[t].map((t) => +(void 0 === t)).reduce((t, e) => t + e);
              for (let i = 0; i < G[t].length; i++) {
                const n = G[t][i];
                if (void 0 === n) continue;
                const s = new Et.b(3 == t ? C.x : S.x, S.y + 10),
                  r =
                    8 * (i - 0.5 * (3 - e - 1)) +
                    N.x +
                    (i - 0.5 * (3 - e)) * s.x,
                  o = N.y + t * s.y;
                n.position.set(r, o), this.addChild(n);
              }
            }
          });
        }
        appendData(t) {
          var e, i, n, s, r, o, a, l, u, h, c, d, p, f;
          this.editedCharacterContainer = t;
          const m = t.characterInstance,
            g = m.stats;
          if (
            (this.classPortraitSprite.createPortrait(m.classData.type),
            this.damageExaltationBar.setExaltationStage(
              m.damageExaltationLevel
            ),
            this.inCombatExaltationBar.setExaltationStage(
              m.inCombatExaltationLevel
            ),
            void 0 === g)
          )
            return;
          null === (e = this.hpStatInput) ||
            void 0 === e ||
            e.appendData(g.getStat(Ee.MAXHP)),
            null === (i = this.mpStatInput) ||
              void 0 === i ||
              i.appendData(g.getStat(Ee.MAXMP)),
            null === (n = this.attStatInput) ||
              void 0 === n ||
              n.appendData(g.getStat(Ee.ATT)),
            null === (s = this.defStatInput) ||
              void 0 === s ||
              s.appendData(g.getStat(Ee.DEF)),
            null === (r = this.spdStatInput) ||
              void 0 === r ||
              r.appendData(g.getStat(Ee.SPD)),
            null === (o = this.dexStatInput) ||
              void 0 === o ||
              o.appendData(g.getStat(Ee.DEX)),
            null === (a = this.vitStatInput) ||
              void 0 === a ||
              a.appendData(g.getStat(Ee.VIT)),
            null === (l = this.wisStatInput) ||
              void 0 === l ||
              l.appendData(g.getStat(Ee.WIS));
          for (let e = 0; e < this.playerStatusEffectsArray.length; e++) {
            const i = this.playerStatusEffectsArray[e];
            if (i == Ie.None) continue;
            const n =
              null !== (u = m.playerPermaStatusEffects.get(i)) &&
              void 0 !== u &&
              u;
            this.updateStatusEffectToggleSprite(t, i, n, !0);
          }
          for (let e = 0; e < this.targetStatusEffectsArray.length; e++) {
            const i = this.targetStatusEffectsArray[e],
              n =
                null !== (h = m.targetPermaStatusEffects.get(i)) &&
                void 0 !== h &&
                h;
            this.updateStatusEffectToggleSprite(t, i, n, !1);
          }
          (m.abilityUse = Ve.clamp(m.abilityUse, bi.Never, bi.Summon)),
            (m.abilityMode = Ve.clamp(m.abilityMode, hr.Mode1, hr.Mode3)),
            (m.applyStatusEffects = Ve.clamp(
              m.applyStatusEffects,
              _i.AllExcluded,
              _i.AllIncluded
            )),
            this.updatePetMagicHealLevelInputContent(m.petMagicHealLevel),
            this.updatePetHealLevelInputContent(m.petHealLevel),
            this.updateHpPercentInputContent(m.startingHpPercent),
            this.updateMpPercentInputContent(m.startingMpPercent),
            this.updateWeaponShotsAccuracyInputContent(m.weaponShotsAccuracy),
            this.updateAbilityShotsAccuracyInputContent(m.abilityShotsAccuracy),
            this.updateAbilityUseInputContent(m.abilityUse),
            this.updateAbilityModeInputContent(m.abilityMode);
          const v = +(
            null !== (c = m.playerPermaStatusEffects.get(Ie.InCombat)) &&
            void 0 !== c &&
            c
          );
          this.updateInCombatInputContent(v),
            this.updateApplyStatusEffectsContent(m.applyStatusEffects),
            this.updateOnhitProcTriggerInputContent(m.onhitProcTrigger),
            this.updateHitDamageInputContent(m.hitDamage),
            this.updateHitsIntervalInputContent(m.hitIntervalMs);
          const y =
              null === (d = this.editedCharacterContainer) || void 0 === d
                ? void 0
                : d.characterInstance.targetData,
            x =
              null !== (p = y.name) && void 0 !== p ? p : "Oryx the Mad God 3";
          this.targetPortraitSprite.createPortrait(
            x,
            null === (f = y.mirrorable) || void 0 === f || f
          );
        }
        updateData(t) {
          this.editedCharacterContainer === t && this.appendData(t);
        }
        createToggableStatusEffectTypeHelper(t, e, i, n, s) {
          return Cr(this, void 0, void 0, function* () {
            const r = { x: 10 * t, y: 0, width: 10, height: 10 },
              o = new a.g({ source: e, frame: r }),
              l = new Gt.mc();
            (l.alpha = 0.2), l.position.set(i, n);
            const u = new Xt.k();
            u.anchor.set(0.5, 0.5),
              (u.width = 20),
              (u.height = 20),
              (u.eventMode = "static"),
              (u.cursor = "pointer"),
              u.addListener("mouseenter", () =>
                this.onStatusEffectToggleMouseEnter(t, s)
              ),
              u.addListener("mousedown", (e) =>
                this.onStatusEffectToggleClick(e, t, s)
              ),
              u.addListener("mouseleave", () =>
                this.onStatusEffectToggleMouseLeave(t, s)
              ),
              l.addChild(u);
            const h = new Xt.k(o);
            h.anchor.set(0.5, 0.5),
              h.scale.set(2, 2),
              (h.eventMode = "none"),
              l.addChild(h);
            return (
              (1 == s
                ? this.playerStatusEffectTogglesMap
                : this.targetStatusEffectTogglesMap
              ).set(t, h),
              this.addChild(l),
              Promise.resolve(l)
            );
          });
        }
        onRemoveCharacter(t) {
          this.editedCharacterContainer == t && this.hide();
        }
        onExaltationStatValueInput(t, e) {
          void 0 !== this.editedCharacterContainer &&
            this.ui.app.charactersHandler.setCharacterExaltationStatValue(
              this.editedCharacterContainer,
              t,
              e
            );
        }
        broadcastExaltationStatValue(t, e) {
          void 0 !== this.editedCharacterContainer &&
            this.ui.app.charactersHandler.setAllCharactersExaltationStatValue(
              t,
              e
            );
        }
        onStatusEffectToggleClick(t, e, i) {
          var n;
          if (
            (this.ui.playClickSound(), void 0 === this.editedCharacterContainer)
          )
            return;
          const s = this.editedCharacterContainer.characterInstance,
            r = !(
              null !==
                (n = (
                  1 == i
                    ? s.playerPermaStatusEffects
                    : s.targetPermaStatusEffects
                ).get(e)) &&
              void 0 !== n &&
              n
            );
          1 != t.shiftKey
            ? this.ui.app.charactersHandler.setCharacterStatusEffect(
                this.editedCharacterContainer,
                e,
                r,
                i
              )
            : this.ui.app.charactersHandler.setAllCharactersStatusEffect(
                e,
                r,
                i
              );
        }
        broadcastStatusEffectValue(t, e) {
          var i;
          if (void 0 === this.editedCharacterContainer) return;
          const n =
            null !==
              (i =
                this.editedCharacterContainer.characterInstance.playerPermaStatusEffects.get(
                  t
                )) &&
            void 0 !== i &&
            i;
          this.ui.app.charactersHandler.setAllCharactersStatusEffect(t, n, e);
        }
        onPropertyValueInput(t, e) {
          if (void 0 !== this.editedCharacterContainer) {
            switch (t) {
              case "startingHpPercent":
              case "startingMpPercent":
              case "weaponShotsAccuracy":
              case "abilityShotsAccuracy":
                e *= 0.01;
            }
            this.ui.app.charactersHandler.setCharacterPropertyValue(
              this.editedCharacterContainer,
              t,
              e
            );
          }
        }
        broadcastPropertyValue(t, e) {
          if (void 0 !== this.editedCharacterContainer) {
            switch (t) {
              case "startingHpPercent":
              case "startingMpPercent":
              case "weaponShotsAccuracy":
              case "abilityShotsAccuracy":
                e *= 0.01;
            }
            this.ui.app.charactersHandler.setAllCharactersPropertyValue(t, e);
          }
        }
        updatePropertyValue(t, e, i) {
          var n, s, r, o, a, l, u, h, c, d, p, f, m, g;
          if (this.editedCharacterContainer == t)
            switch (e) {
              case "startingHpPercent":
                null === (n = this.hpStatInput) ||
                  void 0 === n ||
                  n.updateBarPercent(i),
                  null === (s = this.hpPercentInput) ||
                    void 0 === s ||
                    s.setValue(Math.round(100 * i));
                break;
              case "startingMpPercent":
                null === (r = this.mpStatInput) ||
                  void 0 === r ||
                  r.updateBarPercent(i),
                  null === (o = this.mpPercentInput) ||
                    void 0 === o ||
                    o.setValue(Math.round(100 * i));
                break;
              case "petHealLevel":
                null === (a = this.petHealLevelInput) ||
                  void 0 === a ||
                  a.setValue(i);
                break;
              case "petMagicHealLevel":
                null === (l = this.petMagicHealLevelInput) ||
                  void 0 === l ||
                  l.setValue(i);
                break;
              case "weaponShotsAccuracy":
                null === (u = this.weaponShotsAccuracyInput) ||
                  void 0 === u ||
                  u.setValue(Math.round(100 * i));
                break;
              case "abilityShotsAccuracy":
                null === (h = this.abilityShotsAccuracyInput) ||
                  void 0 === h ||
                  h.setValue(Math.round(100 * i));
                break;
              case "abilityUse":
                null === (c = this.abilityUseInput) ||
                  void 0 === c ||
                  c.setValue(i);
                break;
              case "abilityMode":
                null === (d = this.abilityModeInput) ||
                  void 0 === d ||
                  d.setValue(i);
                break;
              case "applyStatusEffects":
                null === (p = this.applyStatusEffectsInput) ||
                  void 0 === p ||
                  p.setValue(i);
                break;
              case "damageExaltationLevel":
                this.damageExaltationBar.setExaltationStage(i);
                break;
              case "inCombatExaltationLevel":
                this.inCombatExaltationBar.setExaltationStage(i);
                break;
              case "onhitProcTrigger":
                null === (f = this.onhitProcTriggerInput) ||
                  void 0 === f ||
                  f.setValue(i);
                break;
              case "hitDamage":
                null === (m = this.hitDamageInput) ||
                  void 0 === m ||
                  m.setValue(i);
                break;
              case "hitIntervalMs":
                null === (g = this.hitIntervalInput) ||
                  void 0 === g ||
                  g.setValue(i);
            }
        }
        updateStatusEffectToggleSprite(t, e, i, n) {
          if (this.editedCharacterContainer !== t) return;
          if (e === Ie.InCombat)
            return void this.updateInCombatInputContent(+i);
          const s =
            1 == n
              ? this.playerStatusEffectTogglesMap.get(e)
              : this.targetStatusEffectTogglesMap.get(e);
          void 0 !== s && (s.parent.alpha = 1 == i ? 1 : 0.2);
        }
        updateInCombatStateOuter(t, e) {
          this.editedCharacterContainer == t &&
            this.updateInCombatInputContent(+e);
        }
        onInputMouseLeave(t) {
          this.ui.app.tooltipHandler.hide();
        }
        updatePetHealLevelInputContent(t) {
          void 0 !== this.petHealLevelInput &&
            this.petHealLevelInput.setValue(t);
        }
        updatePetMagicHealLevelInputContent(t) {
          void 0 !== this.petMagicHealLevelInput &&
            this.petMagicHealLevelInput.setValue(t);
        }
        updateWeaponShotsAccuracyInputContent(t) {
          if (void 0 === this.weaponShotsAccuracyInput) return;
          const e = Math.floor(100 * t);
          this.weaponShotsAccuracyInput.setValue(e);
        }
        updateAbilityShotsAccuracyInputContent(t) {
          if (void 0 === this.abilityShotsAccuracyInput) return;
          const e = Math.floor(100 * t);
          this.abilityShotsAccuracyInput.setValue(e);
        }
        updateHpPercentInputContent(t) {
          return Cr(this, void 0, void 0, function* () {
            var e;
            if (void 0 === this.hpPercentInput) return;
            const i = Math.floor(100 * t);
            this.hpPercentInput.setValue(i),
              null === (e = this.hpStatInput) ||
                void 0 === e ||
                e.updateBarPercent(t);
          });
        }
        updateMpPercentInputContent(t) {
          return Cr(this, void 0, void 0, function* () {
            var e;
            if (void 0 === this.mpPercentInput) return;
            const i = Math.floor(100 * t);
            this.mpPercentInput.setValue(i),
              null === (e = this.mpStatInput) ||
                void 0 === e ||
                e.updateBarPercent(t);
          });
        }
        updateAbilityModeInputContent(t) {
          void 0 !== this.abilityModeInput && this.abilityModeInput.setValue(t);
        }
        updateAbilityUseInputContent(t) {
          void 0 !== this.abilityUseInput && this.abilityUseInput.setValue(t);
        }
        updateApplyStatusEffectsContent(t) {
          void 0 !== this.applyStatusEffectsInput &&
            this.applyStatusEffectsInput.setValue(t);
        }
        updateInCombatInputContent(t) {
          void 0 !== this.inCombatTriggerInput &&
            this.inCombatTriggerInput.setValue(t);
        }
        updateOnhitProcTriggerInputContent(t) {
          void 0 !== this.onhitProcTriggerInput &&
            this.onhitProcTriggerInput.setValue(t);
        }
        updateHitDamageInputContent(t) {
          void 0 !== this.hitDamageInput && this.hitDamageInput.setValue(t);
        }
        updateHitsIntervalInputContent(t) {
          void 0 !== this.hitIntervalInput && this.hitIntervalInput.setValue(t);
        }
        onInCombatStateInputMouseEnter(t) {
          var e;
          if (
            this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllDisabled
          )
            return;
          const i =
            null === (e = this.editedCharacterContainer) || void 0 === e
              ? void 0
              : e.characterInstance;
          if (void 0 === i) return;
          let n = i.stats.getStatValue(Ee.DEF);
          const s = i.stats.getStatValue(Ee.VIT);
          0 ==
            (i.applyStatusEffects == _i.AllExcluded ||
              i.applyStatusEffects == _i.ExcludeToggles) &&
            (1 == i.playerPermaStatusEffects.get(Ie.ArmorBroken)
              ? (n = 0)
              : 1 == i.playerPermaStatusEffects.get(Ie.Armored) &&
                (n = Math.floor(1.5 * n)),
            1 == i.playerPermaStatusEffects.get(Ie.Exposed) && (n -= 20));
          const r = Math.max(n - 65, 0),
            o = Ve.clamp(n - 35, 0, 30),
            a = Ve.clamp(n - 15, 0, 20),
            l = Ve.clamp(n, 0, 15) + 0.75 * a + 0.5 * o + 0.25 * r,
            u = Math.min(0.05 * s, 6),
            h = Math.max(7 - u - 0.2 * i.inCombatExaltationLevel, 1),
            c = new Array(
              ["In-Combat State Trigger", ti.white],
              [
                `${n} DEF = ${Math.floor(l)} DMG Triggers In-Combat State`,
                ti.lightyellow,
              ],
              [
                `${s} VIT = In-Combat State Is Shorter by ${u} Seconds`,
                ti.lightyellow,
              ],
              [`In-Combat State Lasts ${Ve.time(h)}`, ti.orange]
            );
          this.ui.app.tooltipHandler.showInformation(c);
        }
        onPetHealLevelInputMouseEnter(t) {
          var e, i;
          if (
            this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllDisabled
          )
            return;
          const n =
            null !==
              (i =
                null === (e = this.petHealLevelInput) || void 0 === e
                  ? void 0
                  : e.getValue()) && void 0 !== i
              ? i
              : 0;
          if (0 == n) return;
          const s = this.ui.app.dataHandler.getPetHeal(n, !1),
            r = s[0] / s[1],
            o = s[0] / (s[1] + 2),
            a = new Array(
              ["Pet Heal Level", ti.white],
              [
                `${s[0].toFixed(1)} HP every ${s[1].toFixed(1)}s = ${r.toFixed(
                  1
                )} HP/s`,
                ti.lightyellow,
              ],
              ["In-Combat State", ti.orange],
              [
                `${s[0].toFixed(1)} HP every ${(s[1] + 2).toFixed(
                  1
                )}s = ${o.toFixed(1)} HP/s`,
                ti.orange,
              ]
            );
          this.ui.app.tooltipHandler.showInformation(a);
        }
        onPetMagicHealLevelInputMouseEnter(t) {
          var e, i;
          if (
            this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllDisabled
          )
            return;
          const n =
            null !==
              (i =
                null === (e = this.petMagicHealLevelInput) || void 0 === e
                  ? void 0
                  : e.getValue()) && void 0 !== i
              ? i
              : 0;
          if (0 == n) return;
          const s = this.ui.app.dataHandler.getPetMagicHeal(n, !1),
            r = s[0] / s[1],
            o = s[0] / (s[1] + 2),
            a = new Array(
              ["Pet Magic Heal Level", ti.white],
              [
                `${s[0].toFixed(1)} MP every ${s[1].toFixed(1)}s = ${r.toFixed(
                  1
                )} MP/s`,
                ti.lightyellow,
              ],
              ["In-Combat State", ti.orange],
              [
                `${s[0].toFixed(1)} MP every ${(s[1] + 2).toFixed(
                  1
                )}s = ${o.toFixed(1)} MP/s`,
                ti.orange,
              ]
            );
          this.ui.app.tooltipHandler.showInformation(a);
        }
        onAbilityAccuracyMouseEnter(t) {
          if (this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
            return;
          const e = new Array(
            ["Ability Shots Accuracy", ti.white],
            ["Note: The simulation does not check", ti.orange],
            ["if a certain shot can hit the target.", ti.orange]
          );
          this.ui.app.tooltipHandler.showInformation(e);
        }
        onBaseStatInputMouseEnter(t) {
          var e, i;
          const n =
            null !==
              (i =
                null ===
                  (e =
                    this.ui.app.dataHandler.baseStatDescriptionData.get(t)) ||
                void 0 === e
                  ? void 0
                  : e.map((t) => [t, ti.lightyellow])) && void 0 !== i
              ? i
              : [];
          if (this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
            return;
          const s = new Array(
            [`${Ve.baseStatName(t)} Stat`, ti.white],
            ...n,
            ["Left Click to Change Value", ti.orange],
            ["Shift-Click to Share to All Characters", ti.yellow]
          );
          this.ui.app.tooltipHandler.showInformation(s);
        }
        onStatusEffectToggleMouseEnter(t, e) {
          var i, n;
          const s =
            1 == e
              ? this.playerStatusEffectTogglesMap.get(t)
              : this.targetStatusEffectTogglesMap.get(t);
          if (void 0 === s) return;
          s.scale.set(3, 3);
          const r =
            null !==
              (n =
                null ===
                  (i =
                    this.ui.app.dataHandler.statusEffectDescriptionData.get(
                      t
                    )) || void 0 === i
                  ? void 0
                  : i.map((t) => [t, ti.lightyellow])) && void 0 !== n
              ? n
              : [];
          if (this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
            return;
          const o = new Array(
            [`Permanent ${Ve.statusEffectToString(t)} Toggle`, ti.white],
            ...r,
            ["Left Click to Toggle", ti.orange],
            [
              "Shift-Click to Toggle On All " + (e ? "Characters" : "Enemies"),
              ti.yellow,
            ]
          );
          this.ui.app.tooltipHandler.showInformation(o);
        }
        onGetHitInputMouseEnter() {
          if (this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
            return;
          const t = new Array(
            ["Onhit Proc Trigger", ti.white],
            [
              "Respect Value - checks if damage value meets proc condition,",
              ti.lightyellow,
            ],
            [
              "after character's defense and status effects calculations.",
              ti.lightyellow,
            ],
            ["Any hit - any hit will trigger all onhit procs.", ti.orange]
          );
          this.ui.app.tooltipHandler.showInformation(t);
        }
        onHitDamageInputMouseEnter() {
          var t, e, i;
          if (
            this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllDisabled
          )
            return;
          const n =
            null === (t = this.editedCharacterContainer) || void 0 === t
              ? void 0
              : t.characterInstance;
          if (void 0 === n) return;
          const s =
            null !==
              (i =
                null === (e = this.hitDamageInput) || void 0 === e
                  ? void 0
                  : e.getValue()) && void 0 !== i
              ? i
              : 1;
          let r = n.stats.getStatValue(Ee.DEF);
          const o =
            n.applyStatusEffects == _i.AllExcluded ||
            n.applyStatusEffects == _i.ExcludeToggles;
          0 == o &&
            (1 == n.playerPermaStatusEffects.get(Ie.ArmorBroken)
              ? (r = 0)
              : 1 == n.playerPermaStatusEffects.get(Ie.Armored) &&
                (r = Math.floor(1.5 * r)),
            1 == n.playerPermaStatusEffects.get(Ie.Exposed) && (r -= 20));
          const a = Math.max(s - r, Math.floor(0.1 * s));
          let l = a;
          o ||
            1 != n.playerPermaStatusEffects.get(Ie.Curse) ||
            (l = Math.floor(1.25 * l));
          const u = 0 == s ? 0 : 1 - l / s,
            h = new Array(
              ["Incoming Hit Damage", ti.white],
              [
                `${Ve.separators(s)} DMG - ${
                  r >= 0
                    ? `${Ve.separators(r)} DEF`
                    : `(${Ve.separators(r)} DEF)`
                } = ${a} DMG`,
                ti.lightyellow,
              ],
              [
                `(${Ve.percent(Math.abs(u), 1)} ${
                  u < 0 ? "Increased" : "Reduced"
                } Damage)`,
                ti.orange,
              ]
            );
          o ||
            1 != n.playerPermaStatusEffects.get(Ie.Curse) ||
            h.splice(2, 0, [`+25% DMG (Curse) = ${l} DMG`, ti.lightyellow]),
            this.ui.app.tooltipHandler.showInformation(h);
        }
        onHitIntervalInputMouseEnter() {
          var t, e, i, n, s;
          if (
            this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllDisabled
          )
            return;
          const r =
            null === (t = this.editedCharacterContainer) || void 0 === t
              ? void 0
              : t.characterInstance;
          if (void 0 === r) return;
          const o = Math.max(
              Number(
                null !==
                  (i =
                    null === (e = this.hitIntervalInput) || void 0 === e
                      ? void 0
                      : e.getValue()) && void 0 !== i
                  ? i
                  : 1
              ),
              1
            ),
            a = 1e3 / o,
            l =
              null !==
                (s =
                  null === (n = this.hitDamageInput) || void 0 === n
                    ? void 0
                    : n.getValue()) && void 0 !== s
                ? s
                : 1;
          let u = r.stats.getStatValue(Ee.DEF);
          const h =
            r.applyStatusEffects == _i.AllExcluded ||
            r.applyStatusEffects == _i.ExcludeToggles;
          0 == h &&
            (1 == r.playerPermaStatusEffects.get(Ie.ArmorBroken)
              ? (u = 0)
              : 1 == r.playerPermaStatusEffects.get(Ie.Armored) &&
                (u = Math.floor(1.5 * u)),
            1 == r.playerPermaStatusEffects.get(Ie.Exposed) && (u -= 20));
          let c = Math.max(l - u, Math.floor(0.1 * l));
          h ||
            1 != r.playerPermaStatusEffects.get(Ie.Curse) ||
            (c = Math.floor(1.25 * c));
          const d = c * a,
            p = new Array(
              ["Incoming Hit Interval", ti.white],
              [
                `${Ve.separators(o)} ms = ${Ve.separators(a, 1)} hit${
                  1 == a ? "" : "s"
                }/s`,
                ti.lightyellow,
              ],
              [
                `x ${Ve.separators(c)} DMG = ${Ve.separators(d, 1)} DPS`,
                ti.orange,
              ]
            );
          this.ui.app.tooltipHandler.showInformation(p);
        }
        onStatusEffectToggleMouseLeave(t, e) {
          this.ui.app.tooltipHandler.hide();
          const i =
            1 == e
              ? this.playerStatusEffectTogglesMap.get(t)
              : this.targetStatusEffectTogglesMap.get(t);
          void 0 !== i && i.scale.set(2, 2);
        }
        onEnemyPortraitClick(t) {
          void 0 !== this.editedCharacterContainer &&
            (this.ui.playClickSound(),
            1 != t.shiftKey
              ? this.ui.app.mainPanelHandler.switchEnemyTargetEditor(
                  this.editedCharacterContainer
                )
              : this.ui.app.charactersHandler.setAllCharacterTargetData(
                  this.editedCharacterContainer,
                  this.editedCharacterContainer.characterInstance.targetData,
                  xr.Propagate
                ));
        }
        onClassPortraitMouseEnter() {
          this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllEnabled &&
            void 0 !== this.editedCharacterContainer &&
            this.ui.app.tooltipHandler.showInformation([
              [
                Di[
                  this.editedCharacterContainer.characterInstance.classData.type
                ].toString(),
                ti.white,
              ],
              ["Player Character", ti.lightgreen],
            ]);
        }
        ontargetPortraitMouseEnter() {
          var t, e, i, n, s, r, o, a, l;
          if (
            this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllDisabled
          )
            return;
          const u =
            null === (t = this.editedCharacterContainer) || void 0 === t
              ? void 0
              : t.characterInstance;
          if (void 0 === u) return;
          const h =
            null === (e = this.editedCharacterContainer) || void 0 === e
              ? void 0
              : e.characterInstance.targetData;
          if (void 0 === h) return;
          const c = null !== (i = h.hitpoints) && void 0 !== i ? i : 0;
          let d = null !== (n = h.defense) && void 0 !== n ? n : 0;
          (null !== (s = u.targetImmunities.get(Ie.ArmorBroken)) &&
            void 0 !== s &&
            s) ||
          null === (r = u.targetPermaStatusEffects.get(Ie.ArmorBroken)) ||
          void 0 === r ||
          !r
            ? 1 == u.targetPermaStatusEffects.get(Ie.Armored) &&
              (d = Math.floor(1.5 * d))
            : (d = 0),
            (null !== (o = u.targetImmunities.get(Ie.Exposed)) &&
              void 0 !== o &&
              o) ||
              null === (a = u.targetPermaStatusEffects.get(Ie.Exposed)) ||
              void 0 === a ||
              !a ||
              (d -= 20);
          const p = new Array(
            [null !== (l = h.name) && void 0 !== l ? l : "Enemy", ti.white],
            ["Enemy Target", ti.red],
            [`${Ve.separators(c)} HP`, ti.lightyellow],
            [`${Ve.separators(d)} DEF`, ti.lightyellow]
          );
          if (
            (h.heal > 0 &&
              p.push([
                `+${Ve.separators(h.heal)} HP every 5 seconds`,
                ti.lightyellow,
              ]),
            0 != u.targetImmunities.size)
          )
            for (const [t, e] of u.targetImmunities.entries())
              e &&
                p.push([
                  `${Ve.statusEffectToString(t)} Immunity`,
                  ti.lightyellow,
                ]);
          this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllEnabled &&
            p.push(
              ["Left Click to Edit Target", ti.orange],
              ["Shift-Click to Share to All Characters", ti.yellow]
            ),
            this.ui.app.tooltipHandler.showInformation(p);
        }
        getEditedCharacterContainer() {
          return this.editedCharacterContainer;
        }
        onAbilityUseMouseEnter() {
          this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllEnabled &&
            this.ui.app.tooltipHandler.showInformation([
              ["Ability Use Behaviour Types", ti.white],
              [
                "When Ready - press ability key down whenever it's off cooldown.",
                ti.lightyellow,
              ],
              [
                "Ready + Hold - additionally hold ability key down until the ability",
                ti.yellow,
              ],
              [
                "cooldown has passed or the MP is lower than the ability MP cost.",
                ti.yellow,
              ],
              [
                "Hold To End - hold ability key down until MP reaches 0. Then wait",
                ti.orange,
              ],
              [
                "for the MP to fully regenerate and hold the key down again.",
                ti.orange,
              ],
              [
                "Summon - press ability key if you have less than 3 minions alive.",
                ti.lightgreen,
              ],
            ]);
        }
        onDamageExaltationBarClick(t, e) {
          if (void 0 === this.editedCharacterContainer) return;
          const i = this.editedCharacterContainer.characterInstance;
          this.ui.playClickSound(),
            1 != t.shiftKey
              ? ((i.damageExaltationLevel = i.damageExaltationLevel + e),
                i.damageExaltationLevel < 0 && (i.damageExaltationLevel = 4),
                i.damageExaltationLevel > 4 && (i.damageExaltationLevel = 0),
                this.ui.app.charactersHandler.setCharacterPropertyValue(
                  this.editedCharacterContainer,
                  "damageExaltationLevel",
                  i.damageExaltationLevel
                ))
              : this.ui.app.charactersHandler.setAllCharactersPropertyValue(
                  "damageExaltationLevel",
                  i.damageExaltationLevel
                );
        }
        onDamageExaltationBarMouseEnter(t) {
          if (this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
            return;
          const e = new Array(
            ["Weapon Damage Bonus", ti.white],
            ["Left Click to Change Value", ti.orange],
            ["Shift-Click to Share to All Characters", ti.yellow]
          );
          this.ui.app.tooltipHandler.showInformation(e);
        }
        onInCombatExaltationBarClick(t, e) {
          if (void 0 === this.editedCharacterContainer) return;
          const i = this.editedCharacterContainer.characterInstance;
          this.ui.playClickSound(),
            1 != t.shiftKey
              ? ((i.inCombatExaltationLevel = i.inCombatExaltationLevel + e),
                i.inCombatExaltationLevel < 0 &&
                  (i.inCombatExaltationLevel = 5),
                i.inCombatExaltationLevel > 5 &&
                  (i.inCombatExaltationLevel = 0),
                this.ui.app.charactersHandler.setCharacterPropertyValue(
                  this.editedCharacterContainer,
                  "inCombatExaltationLevel",
                  i.inCombatExaltationLevel
                ))
              : this.ui.app.charactersHandler.setAllCharactersPropertyValue(
                  "inCombatExaltationLevel",
                  i.inCombatExaltationLevel
                );
        }
        onInCombatExaltationBarMouseEnter(t) {
          if (this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
            return;
          const e = new Array(
            ["In-Combat State Duration Reduction", ti.white],
            ["Left Click to Change Value", ti.orange],
            ["Shift-Click to Share to All Characters", ti.yellow]
          );
          this.ui.app.tooltipHandler.showInformation(e);
        }
        onInCombatStateChange(t) {
          void 0 !== this.editedCharacterContainer &&
            this.ui.app.charactersHandler.setCharacterStatusEffect(
              this.editedCharacterContainer,
              Ie.InCombat,
              t,
              !0
            );
        }
        switchData(t) {
          return Cr(this, void 0, void 0, function* () {
            const e = this.editedCharacterContainer == t;
            this.appendData(t),
              e && 1 == this.visible ? this.hide() : this.show();
          });
        }
      }
      class Tr extends Ge {
        constructor(t, e) {
          super(t, e),
            (this.isActive = !1),
            (this.slotId = -1),
            (this.slotIdText = t.themedText({})),
            this.addChild(this.slotIdText),
            (this.nameText = t.text({})),
            this.addChild(this.nameText);
        }
        create() {
          var t, e;
          this.slotIdText.position.set(10, 8),
            this.nameText.position.set(58, 8),
            this.updateBackground();
          const i =
            null !==
              (e =
                null === (t = this.ui.theme) || void 0 === t
                  ? void 0
                  : t.enchantmentBackgroundColor) && void 0 !== e
              ? e
              : ti.darkgray;
          this.setBackgroundColor(i);
        }
        onMouseClick(t) {
          this.ui.playClickSound();
        }
        setActive(t) {
          (this.isActive = t),
            (this.alpha = t ? 1 : 0.2),
            (this.cursor = t ? "pointer" : "normal"),
            (this.eventMode = t ? "static" : "none");
        }
        appendEnchant(t) {
          var e;
          const i =
            1 == this.isActive &&
            null !== (e = null == t ? void 0 : t.name) &&
            void 0 !== e
              ? e
              : "empty";
          (this.nameText.text = i),
            (this.nameText.tint = "empty" == i ? ti.gray : ti.lightgreen);
        }
        appendData(t, e, i) {
          (this.slotId = t),
            (this.slotIdText.text = `Slot ${t + 1}:`),
            this.setActive(i),
            this.appendEnchant(e);
        }
      }
      var wr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Pr extends Ge {
        constructor(t, e) {
          super(t, e),
            (this.isActive = !0),
            (this.nameText = t.text({})),
            this.addElement(this.nameText),
            (this.descriptionText = t.text({
              style: {
                fill: ti.lightyellow,
                wordWrap: !0,
                wordWrapWidth: this.options.size.x - 16,
              },
            })),
            this.addElement(this.descriptionText),
            (this.equipmentMatch = !1),
            this.backgroundContainer.addListener(
              "click",
              this.onMouseClick.bind(this)
            );
        }
        create() {
          var t, e;
          this.nameText.position.set(10, 10),
            this.descriptionText.position.set(10, 30);
          const i =
            null !==
              (e =
                null === (t = this.ui.theme) || void 0 === t
                  ? void 0
                  : t.enchantmentBackgroundColor) && void 0 !== e
              ? e
              : ti.darkgray;
          this.setBackgroundColor(i);
        }
        setActive(t) {
          (this.isActive = t),
            (this.alpha = t ? 1 : 0.2),
            (this.cursor = t ? "pointer" : "normal"),
            (this.eventMode = t ? "static" : "none");
        }
        onMouseClick(t) {
          this.ui.playClickSound();
        }
        appendData(t) {
          return wr(this, void 0, void 0, function* () {
            var e, i, n;
            (this.nameText.text =
              null !== (e = null == t ? void 0 : t.name) && void 0 !== e
                ? e
                : "empty"),
              (this.nameText.tint =
                "empty" == this.nameText.text ? ti.gray : ti.lightgreen),
              (this.descriptionText.text =
                null !== (i = null == t ? void 0 : t.description) &&
                void 0 !== i
                  ? i
                  : ""),
              (this.enchantData = t),
              !1 ===
              (null === (n = this.enchantData) || void 0 === n
                ? void 0
                : n.isComplete)
                ? void 0 === this.alertIcon &&
                  ((this.alertIcon = new oi(this.ui, {
                    iconTexture: "alert_icon",
                    scale: 2,
                  })),
                  this.alertIcon.create(),
                  this.alertIcon.on("mouseenter", () =>
                    this.ui.app.tooltipHandler.showMissingDataInformation(
                      "Enchantment"
                    )
                  ),
                  this.alertIcon.on(
                    "mouseleave",
                    this.ui.app.tooltipHandler.onMouseLeaveBinding
                  ),
                  this.alertIcon.position.set(this.options.size.x - 32, 0),
                  this.addChild(this.alertIcon))
                : void 0 !== this.alertIcon && (this.alertIcon.alpha = 0),
              yield this.updateBounds();
          });
        }
      }
      var Ar = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class kr extends qs {
        constructor(t, e) {
          super(t, e),
            (this.MAX_ENCHANTS = 120),
            (this.onSearchBarMouseEnter = () => {
              this.ui.app.tooltipHandler.showInformation([
                ["Effect Filter", ti.white],
                ["Available search tags:", ti.orange],
                ['"hp", "mp", "att", "def", "spd",', ti.lightyellow],
                ['"dex", "wis", "vit", "rel", "onhit"', ti.lightyellow],
              ]);
            }),
            (this.enchantSlotFrameOptions = {
              frameTexture: "white_frame",
              size: new Et.b(286, 36),
            }),
            (this.enchantFrameOptions = {
              frameTexture: "white_frame",
              size: new Et.b(this.options.size.x - 78, 0),
              autoHeight: !0,
              padding: new Et.b(0, 20),
            }),
            (this.equipmentPreview = new Zs(t)),
            (this.enchantSlots = new Array()),
            (this.enchants = new Array()),
            (this.selectedSlot = 0),
            (this.scrollContainer = new Js(t, {
              size: new Et.b(this.options.size.x - 50, 288),
              itemsInRow: 1,
              itemSize: new Et.b(),
              itemSpacing: new Et.b(0, 4),
              itemOffset: new Et.b(0, -4),
              itemAnchor: new Et.b(),
              scrollSpeed: 36,
            }));
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return Ar(this, void 0, void 0, function* () {
            t.create.call(this), this.setTitleText("Enchant Item");
            const e = 52 - 0.5 * this.options.size.x,
              i = 90 - 0.5 * this.options.size.y;
            this.equipmentPreview.position.set(e, i),
              this.addChild(this.equipmentPreview);
            const n = new Xt.k();
            (n.width = 60),
              (n.height = 60),
              n.anchor.set(0.5, 0.5),
              n.position.set(e, i),
              (n.eventMode = "static"),
              n.addListener(
                "mouseenter",
                this.onEquipmentPreviewMouseEnter.bind(this)
              ),
              n.addListener(
                "mouseleave",
                this.onEquipmentPreviewMouseLeave.bind(this)
              ),
              this.addChild(n);
            const s = new Gt.mc();
            s.position.set(
              96 - 0.5 * this.options.size.x,
              72 - 0.5 * this.options.size.y
            ),
              this.addChild(s);
            for (let t = 0; t < 4; t++) {
              const e = new Tr(this.ui, this.enchantSlotFrameOptions);
              e.create(),
                (e.position.y = 40 * t),
                e.addListener("click", () => (this.selectedSlot = t)),
                s.addChild(e),
                this.enchantSlots.push(e);
            }
            const r = this.ui.themedText({
              text: "Select Effect",
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fontSize: 28 }
              ),
            });
            (r.anchor.x = 0.5),
              r.position.set(0, 240 - Math.floor(0.5 * this.options.size.y)),
              this.addChild(r);
            const o = {
              maxLength: 20,
              placeholder: "Search",
              anchor: Ve.TOP_LEFT,
              clearOnClick: !0,
            };
            (this.searchBarInput = yield this.ui.searchbar(o)),
              this.searchBarInput.position.set(
                0.5 * -this.searchBarInput.width - 144,
                -62
              ),
              (this.searchBarInput.eventMode = "static"),
              this.searchBarInput.on(
                "change",
                this.onSearchBarInput.bind(this)
              ),
              this.searchBarInput.addListener(
                "mouseenter",
                this.onSearchBarMouseEnter.bind(this)
              ),
              this.searchBarInput.addListener(
                "mouseleave",
                this.ui.app.tooltipHandler.onMouseLeaveBinding
              ),
              this.addElement(this.searchBarInput),
              this.scrollContainer.create(),
              this.scrollContainer.position.set(
                32 - 0.5 * this.options.size.x,
                272 - 0.5 * this.options.size.y
              ),
              this.addChild(this.scrollContainer),
              (this.enchants = new Array());
            for (let t = 0; t < this.MAX_ENCHANTS; t++) {
              const e = new Pr(this.ui, this.enchantFrameOptions);
              e.create(),
                e.addListener("click", () => this.onEnchantClick(e)),
                this.scrollContainer.addElement(e),
                e.hide(),
                (this.enchants[t] = e);
            }
          });
        }
        onRemoveCharacter(t) {
          this.editedCharacterContainer == t && this.hide();
        }
        onThemeUpdate(t) {
          var e;
          const i =
            null !== (e = null == t ? void 0 : t.enchantmentBackgroundColor) &&
            void 0 !== e
              ? e
              : ti.darkgray;
          for (const t of this.enchantSlots) t.setBackgroundColor(i);
          for (const t of this.enchants) t.setBackgroundColor(i);
        }
        onSearchBarInput(t) {
          (t = t.toLowerCase()), this.filterEnchants(t);
        }
        filterEnchants(t) {
          var e, i, n, s, r;
          if (void 0 !== this.enchants) {
            for (let r = 0; r < this.enchants.length; r++) {
              const o = this.enchants[r],
                a =
                  null !==
                    (i =
                      null === (e = o.enchantData) || void 0 === e
                        ? void 0
                        : e.searchLabels) && void 0 !== i
                    ? i
                    : "";
              o.visible =
                0 == r ||
                (o.equipmentMatch &&
                  (null !==
                    (s =
                      null === (n = o.enchantData) || void 0 === n
                        ? void 0
                        : n.id) && void 0 !== s
                    ? s
                    : -1) >= 0 &&
                  a.includes(t));
            }
            this.updateEnchants(),
              null === (r = this.scrollContainer) ||
                void 0 === r ||
                r.setScrollDistance(0);
          }
        }
        onEquipmentPreviewMouseEnter() {
          if (void 0 === this.equipment) return;
          if (void 0 === this.equipment.base) return;
          if (void 0 === this.editedCharacterContainer) return;
          const t = this.editedCharacterContainer.characterInstance;
          this.ui.app.tooltipHandler.showEquipmentDescription(
            this.equipment.base,
            this.equipment.enchants,
            t,
            !1
          );
        }
        onEquipmentPreviewMouseLeave() {
          this.ui.app.tooltipHandler.hide();
        }
        appendData(t, e) {
          return Ar(this, void 0, void 0, function* () {
            var i, n, s, r;
            if (
              ((this.equipment = t),
              (this.editedCharacterContainer = e),
              this.equipmentPreview.create(
                null !==
                  (n = null === (i = t.base) || void 0 === i ? void 0 : i.id) &&
                  void 0 !== n
                  ? n
                  : 0,
                null !==
                  (r =
                    null === (s = t.base) || void 0 === s
                      ? void 0
                      : s.slotType) && void 0 !== r
                  ? r
                  : 0
              ),
              void 0 === this.equipment)
            )
              return;
            if (void 0 === this.equipment.base) return;
            for (let e = 0; e < this.enchantSlots.length; e++) {
              const i = this.enchantSlots[e],
                n = e < this.equipment.base.enchantSlots;
              i.appendData(e, t.enchants[e], n);
            }
            const o = this.ui.app.dataHandler.getEnchants(this.equipment.base);
            for (let t = -1; t < this.MAX_ENCHANTS - 1; t++) {
              const e = o[t],
                i = this.enchants[t + 1];
              t < o.length
                ? (yield i.appendData(e),
                  i.show(),
                  (i.visible = !0),
                  (i.equipmentMatch = !0))
                : (i.hide(), (i.visible = !1), (i.equipmentMatch = !1));
            }
            this.updateEnchants(), this.scrollContainer.setScrollDistance(0);
          });
        }
        updateEnchants() {
          var t;
          if (void 0 !== this.equipment)
            t: for (let e = 0; e < this.enchants.length; e++) {
              const i = this.enchants[e];
              for (let e = 0; e < this.equipment.enchants.length; e++) {
                if (
                  this.equipment.enchants[e].id ==
                  (null === (t = i.enchantData) || void 0 === t ? void 0 : t.id)
                ) {
                  i.setActive(!1);
                  continue t;
                }
              }
              i.setActive(!0);
            }
        }
        onEnchantClick(t) {
          const e = null == t ? void 0 : t.enchantData;
          this.setEnchant(e), this.ui.playClickSound(), this.updateEnchants();
        }
        setEnchant(t) {
          void 0 !== this.equipment &&
            (void 0 === t && (t = { id: -1 }),
            (this.equipment.enchants[this.selectedSlot] = t),
            this.enchantSlots[this.selectedSlot].appendEnchant(t),
            this.ui.app.charactersHandler.updateCharacter(
              this.editedCharacterContainer
            ));
        }
        clearSearchResults() {
          void 0 !== this.searchBarInput &&
            ((this.searchBarInput.value = ""), this.filterEnchants(""));
        }
        switchData(t, e) {
          void 0 !== this.searchBarInput && this.clearSearchResults(),
            this.equipment !== t
              ? this.show()
              : 1 == this.visible
              ? this.hide()
              : this.show(),
            this.scrollContainer.setScrollDistance(0),
            this.appendData(t, e);
        }
      }
      class Mr {
        constructor() {
          (this.count = Object.keys(Ee).length / 2), (this.stats = new Array());
          for (let t = 0; t < this.count; t++)
            (this.stats[t] = {
              type: t,
              exaltationValue: t <= Ee.MAXMP ? 25 : t <= Ee.WIS ? 5 : 0,
            }),
              this.clearStat(t);
        }
        addXpBonus(t) {
          this.stats[Ee.XPBONUS].equipmentValue += t;
        }
        recalculateStat(t) {
          const e = this.stats[t];
          (e.preRelativeValue =
            e.baseValue + e.exaltationValue + e.equipmentValue),
            (e.totalEquipmentValue = e.equipmentValue + e.relativeValue),
            (e.totalValue =
              e.baseValue + e.exaltationValue + e.totalEquipmentValue);
        }
        recalculate() {
          for (let t = 0; t < this.count; t++) this.recalculateStat(t);
        }
        appendData(t, e) {
          this.stats[t].exaltationValue = e;
        }
        getStat(t) {
          return this.stats[t];
        }
        getStatValue(t) {
          return this.stats[t].totalValue;
        }
        setBaseValue(t, e) {
          this.stats[t].baseValue = e;
        }
        setBaseValues(t) {
          for (let e = 0; e < 8; e++) this.stats[e].baseValue = t[e];
        }
        setExaltationValue(t, e) {
          this.stats[t].exaltationValue = e;
        }
        setExaltationValues(t) {
          for (let e = 0; e < 8; e++) this.stats[e].exaltationValue = t[e];
        }
        clearStat(t) {
          const e = this.stats[t];
          (e.baseValue = 0),
            (e.equipmentValue = +(t == Ee.MPMULTIPLIER)),
            (e.equipmentValueInSlot = new Array(0, 0, 0, 0)),
            (e.preRelativeValue = 0),
            (e.relativeValue = 0),
            (e.totalEquipmentValue = 0),
            (e.totalValue = 0);
        }
        clear() {
          for (let t = 0; t < this.count; t++) this.clearStat(t);
        }
      }
      var Er = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Ir {
        constructor(t, e) {
          (this.classData = Object.assign({}, t)),
            (this.damageExaltationLevel = 4),
            (this.inCombatExaltationLevel = 5),
            (this.stats = new Mr()),
            (this.playerPermaStatusEffects = new Map()),
            (this.targetPermaStatusEffects = new Map()),
            (this.targetImmunities = new Map()),
            (this.equipment = new Array()),
            (this.equipmentSets = new Map()),
            (this.lineColor = 0),
            (this.targetData = e),
            (this.petMagicHealLevel = 100),
            (this.petHealLevel = 100),
            (this.startingHpPercent = 1),
            (this.startingMpPercent = 1),
            (this.weaponShotsAccuracy = 1),
            (this.abilityShotsAccuracy = 1),
            (this.abilityUse = bi.OffCooldownAndHold),
            (this.abilityMode = hr.Mode1),
            (this.applyStatusEffects = _i.AllIncluded),
            (this.onhitProcTrigger = Pi.RespectValue),
            (this.hitDamage = 120),
            (this.hitIntervalMs = 3e3);
        }
        xpBonusHelper(t) {
          void 0 !== t && this.stats.addXpBonus(t.xpBonus);
        }
        recalculateStats(t) {
          return Er(this, void 0, void 0, function* () {
            this.stats.clear(),
              this.stats.setBaseValues(this.classData.maxedBaseStats),
              (this.equipmentSets = new Map());
            const e = new Array();
            for (let i = 0; i < 4; i++) {
              const n = this.equipment[i];
              if (void 0 === n) continue;
              const s = n.base;
              if (void 0 !== s) {
                this.xpBonusHelper(s),
                  this.setPieceHelper(t, i, s.id, s.setId),
                  s.statsOnEquip.forEach((t) => {
                    t.relativeTo == Ee.None
                      ? this.addStatsFromEquipmentHelper(t, i)
                      : e.push(t);
                  });
                for (let t = 0; t < n.enchants.length; t++) {
                  const s = n.enchants[t];
                  if (!(s.id < 0))
                    for (let t = 0; t < s.statsOnEquip.length; t++) {
                      const n = s.statsOnEquip[t];
                      n.relativeTo == Ee.None
                        ? yield this.addStatsFromEquipmentHelper(n, i)
                        : e.push(n);
                    }
                }
              }
            }
            for (let [e, i] of this.equipmentSets.entries()) {
              if (0 == i[0]) continue;
              const n = t.equipmentSetsData.get(e);
              if (void 0 !== n)
                for (let t = 2; t <= 4 && t <= i[1]; t++) {
                  const e = n.statsOnEquip.get(t);
                  void 0 !== e &&
                    e.forEach((e) => {
                      this.addStatsFromEquipmentHelper(e, t);
                    });
                }
            }
            this.stats.recalculate();
            const i = [];
            for (const t of e) {
              const e = this.addRelativeBaseStatsFromEquipmentHelper(t);
              i.push(e);
            }
            yield Promise.all(i);
          });
        }
        setPieceHelper(t, e, i, n) {
          const s = t.equipmentSetsData.values();
          for (let t of s) {
            const s = t.equipmentIds.get(e);
            if (void 0 !== s && s.includes(i)) {
              const e = t.id == n,
                i = this.equipmentSets.get(t.id),
                s = void 0 !== i ? i[1] + 1 : 1;
              this.equipmentSets.set(t.id, [e, s]);
            }
          }
        }
        addRelativeBaseStatsFromEquipmentHelper(t) {
          const e = this.stats.getStat(t.type);
          if (void 0 === e) return;
          const i = this.stats.getStat(t.relativeTo);
          if (void 0 === i) return;
          const n = Math.ceil(i.preRelativeValue * t.value * 0.01);
          (e.relativeValue += n), this.stats.recalculateStat(e.type);
        }
        addStatsFromEquipmentHelper(t, e) {
          if (void 0 === t) return;
          const i = this.stats.getStat(t.type);
          t.type !== Ee.MPMULTIPLIER
            ? ((i.preRelativeValue += t.value),
              (i.equipmentValue += t.value),
              (i.equipmentValueInSlot[e] += t.value))
            : (i.equipmentValue *= t.value);
        }
        setEquipment(t, e) {
          this.equipment[t] = e;
        }
      }
      var Dr,
        Rr,
        Br = function (t, e, i, n) {
          return new (i || (i = Promise))(function (s, r) {
            function o(t) {
              try {
                l(n.next(t));
              } catch (t) {
                r(t);
              }
            }
            function a(t) {
              try {
                l(n.throw(t));
              } catch (t) {
                r(t);
              }
            }
            function l(t) {
              t.done
                ? s(t.value)
                : (function (t) {
                    return t instanceof i
                      ? t
                      : new i(function (e) {
                          e(t);
                        });
                  })(t.value).then(o, a);
            }
            l((n = n.apply(t, e || [])).next());
          });
        };
      class Fr extends qs {
        constructor(t, e) {
          super(t, e);
          const i = { x: e.size.x - 44, y: e.size.y - 100 };
          this.scrollContainer = new Js(t, {
            size: i,
            itemSize: { x: 0, y: 0 },
            itemsInRow: 1,
            itemAnchor: { x: 0, y: 0 },
            itemOffset: { x: 0, y: 8 },
            itemSpacing: { x: 0, y: 0 },
          });
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return Br(this, void 0, void 0, function* () {
            t.create.call(this),
              this.setTitleText("Changelog"),
              this.scrollContainer.create(),
              this.scrollContainer.position.set(
                14 - Math.floor(0.5 * this.options.size.x),
                64 - Math.floor(0.5 * this.options.size.y)
              ),
              this.addChild(this.scrollContainer);
            const e = yield this.ui.app.dataHandler.getClass(
                Ve.randomInt(0, Di.Kensei)
              ),
              i = yield this.ui.app.dataHandler.getEnemyData("Training Dummy");
            void 0 !== e &&
              ((this.templateCharacter = new Ir(e, i)),
              this.templateCharacter.recalculateStats(this.ui.app.dataHandler));
            const n = this.ui.app.dataHandler.changelogData,
              s = Array.from(n.keys());
            for (let t = 0; t < s.length; t++) {
              const e = n.get(s[t]);
              if (0 == e.visible) continue;
              const i = 12;
              let r = 0,
                o = 0;
              const a = new Gt.mc();
              if (
                (this.scrollContainer.addElement(a),
                (a.pivot.x = -i),
                void 0 !== e.icon && 0 != e.icon.length)
              ) {
                const t = yield this.ui.getTexture(`ui/icons/${e.icon}`),
                  i = new Xt.k(t);
                (i.eventMode = "none"),
                  i.anchor.set(0.5),
                  i.scale.set(2),
                  i.position.set(0.5 * i.width - 8, r + 8),
                  a.addChild(i),
                  (o += i.width - 2);
              }
              const l = this.ui.text({
                text: e.title,
                style: { fontSize: 28, fill: e.color },
              });
              if (
                ((l.position.x = o),
                a.addChild(l),
                (r += Math.floor(l.height + 2)),
                void 0 !== e.date && 0 != e.date.length)
              ) {
                const t = this.ui.text({
                  text: e.date,
                  style: { fill: ti.gray },
                });
                (t.position.y = r), a.addChild(t), (r += Math.floor(t.height));
              }
              const u = this.ui.themedText({
                style: {
                  wordWrap: !0,
                  wordWrapWidth: this.options.size.x - 64,
                },
              });
              (u.position.y = r), a.addChild(u);
              let h = "";
              for (let t = 0; t < e.changes.length; t++)
                h += `${e.changes[t]}${t < e.changes.length - 1 ? "\n" : ""}`;
              (u.text = h), (r += Math.floor(u.height));
              const c = 9,
                d = 44;
              if (0 != e.equipment.length) {
                r += 20;
                const t = this.ui.themedText({ text: "New items added:" });
                (t.position.y = r),
                  a.addChild(t),
                  (r += Math.floor(t.height + 2));
                for (let t = 0; t < e.equipment.length; t++) {
                  const i = e.equipment[t].id,
                    n = e.equipment[t].slotType,
                    s = ((t % c) + 0.5) * d,
                    o = (Math.floor(t / c) + 0.5) * d,
                    l = new Zs(this.ui),
                    u = yield l.create(i, n);
                  l.position.set(s, r + o),
                    l.setEquipmentScale(0.8),
                    (l.eventMode = "none"),
                    a.addChild(l);
                  const h = new Xt.k();
                  h.position.set(s, r + o),
                    h.anchor.set(0.5, 0.5),
                    (h.width = d),
                    (h.height = d),
                    (h.eventMode = "static"),
                    (h.zIndex = 2),
                    a.addChild(h),
                    void 0 !== u &&
                      (h.addListener("mouseenter", () =>
                        this.ui.app.tooltipHandler.showEquipmentDescription(
                          u,
                          [],
                          this.templateCharacter,
                          !1
                        )
                      ),
                      h.addListener("mouseleave", () =>
                        this.ui.app.tooltipHandler.hide()
                      ));
                }
                r += Math.floor(e.equipment.length / (c + 1)) * d;
                const i = new Xt.k();
                (i.width = this.width),
                  (i.height = 36),
                  (i.position.y = r),
                  (r += i.height);
              }
              if (0 != e.playerSkins.length) {
                r += 20;
                const t = this.ui.themedText({
                  text: "New player skins added:",
                });
                (t.position.y = r), a.addChild(t), (r += 20);
                for (let t = 0; t < e.playerSkins.length; t++) {
                  const i = e.playerSkins[t].id,
                    n = e.playerSkins[t].type,
                    s = ((t % c) + 0.5) * d,
                    o = (Math.floor(t / c) + 0.5) * d,
                    l = new js(this.ui);
                  l.anchor.set(0.5, 0.5),
                    l.position.set(s, r + o),
                    (l.eventMode = "none"),
                    a.addChild(l);
                  const u = yield l.createPlayerSkin(i, n);
                  if (void 0 === u) continue;
                  const h = new Xt.k();
                  h.position.set(s, r + o),
                    h.anchor.set(0.5, 0.5),
                    (h.width = d),
                    (h.height = d),
                    (h.eventMode = "static"),
                    (h.zIndex = 2),
                    a.addChild(h),
                    h.addListener("mouseenter", () =>
                      this.ui.app.tooltipHandler.showSkinDescription(u)
                    ),
                    h.addListener("mouseleave", () =>
                      this.ui.app.tooltipHandler.hide()
                    );
                }
                r += Math.floor(e.playerSkins.length / (c + 1)) * d;
                const i = new Xt.k();
                (i.width = this.width),
                  (i.height = 36),
                  (i.position.y = r),
                  (r += i.height);
              }
              if (0 != e.petSkins.length) {
                r += 20;
                const t = this.ui.themedText({ text: "New pet skins added:" });
                (t.position.y = r), a.addChild(t), (r += 20);
                for (let t = 0; t < e.petSkins.length; t++) {
                  const i = e.petSkins[t].id,
                    n = e.petSkins[t].type,
                    s = ((t % c) + 0.5) * d,
                    o = (Math.floor(t / c) + 0.5) * d,
                    l = new js(this.ui);
                  l.anchor.set(0.5, 0.5),
                    l.position.set(s, r + o),
                    (l.eventMode = "none"),
                    a.addChild(l);
                  const u = yield l.createPetSkin(i, n);
                  if (void 0 === u) continue;
                  const h = new Xt.k();
                  h.position.set(s, r + o),
                    h.anchor.set(0.5, 0.5),
                    (h.width = d),
                    (h.height = d),
                    (h.eventMode = "static"),
                    (h.zIndex = 2),
                    a.addChild(h),
                    h.addListener("mouseenter", () =>
                      this.ui.app.tooltipHandler.showSkinDescription(u, !0)
                    ),
                    h.addListener("mouseleave", () =>
                      this.ui.app.tooltipHandler.hide()
                    );
                }
                r += Math.floor(e.petSkins.length / (c + 1)) * d;
                const i = new Xt.k();
                (i.width = this.width),
                  (i.height = 36),
                  (i.position.y = r),
                  (r += i.height);
              }
              const p = new Xt.k();
              (p.width = 16),
                (p.height = 24),
                (p.position.y = r),
                a.addChild(p);
            }
            this.scrollContainer.setScrollDistance(0);
          });
        }
        switch() {
          1 == this.visible ? this.hide() : this.show();
        }
      }
      !(function (t) {
        (t[(t.NoEquipment = -1)] = "NoEquipment"),
          (t[(t.StarterEquipment = 0)] = "StarterEquipment"),
          (t[(t.STierEquipment = 1)] = "STierEquipment"),
          (t[(t.RandomEquipment = 2)] = "RandomEquipment");
      })(Dr || (Dr = {})),
        (function (t) {
          (t[(t.Default = 0)] = "Default"),
            (t[(t.Void = 1)] = "Void"),
            (t[(t.Abyss = 2)] = "Abyss"),
            (t[(t.RealmEye = 3)] = "RealmEye");
        })(Rr || (Rr = {}));
      var Or = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class zr extends qs {
        constructor(t, e) {
          super(t, e),
            (this.exportCallbackText = t.text({ style: { align: "center" } })),
            (this.onMouseLeaveBinding = this.onMouseLeave.bind(this));
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return Or(this, void 0, void 0, function* () {
            t.create.call(this), this.setTitleText("Settings");
            const e = new Et.b(160, 36),
              i = new Et.b(160, 40);
            let n = 60;
            const s = this.ui.themedText({
              text: "General Settings",
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fontSize: 28 }
              ),
            });
            s.anchor.set(0.5, 0),
              (s.position.y = n - 0.5 * this.options.size.y);
            const [r, o] = Ve.getBoundsReminder(s);
            s.pivot.set(r, o), this.addChild(s), (n += 36);
            const a = yield this.ui.thickLabeledFrame({
              labelText: "Guidance Tooltips",
              size: e,
            });
            (this.showGuidanceTooltipsInput = new yr(
              this.ui,
              a,
              ei.AllDisabled,
              ei.CalculationsOnly,
              new Map([
                [ei.AllDisabled, ["All Disabled", ti.red]],
                [ei.AllEnabled, ["All Enabled", ti.lightyellow]],
                [ei.CalculationsOnly, ["Calculations Only", ti.orange]],
              ])
            )),
              this.showGuidanceTooltipsInput.create(),
              this.showGuidanceTooltipsInput.position.set(
                18 - 0.5 * this.options.size.x,
                n - 0.5 * this.options.size.y
              ),
              this.showGuidanceTooltipsInput.on(
                "change",
                this.onShowGuidanceTooltipsInputChange.bind(this)
              ),
              this.addChild(this.showGuidanceTooltipsInput);
            const l = yield this.ui.thickLabeledFrame({
              labelText: "UI Theme",
              size: e,
            });
            (this.themeInput = new yr(
              this.ui,
              l,
              Rr.Default,
              Rr.RealmEye,
              new Map([
                [Rr.Default, ["Classic", ti.lightyellow]],
                [Rr.Void, ["Void", ti.yellow]],
                [Rr.Abyss, ["Abyss", ti.yellow]],
                [Rr.RealmEye, ["RealmEye", ti.yellow]],
              ])
            )),
              this.themeInput.create(),
              this.themeInput.position.set(
                186 - 0.5 * this.options.size.x,
                n - 0.5 * this.options.size.y
              ),
              this.themeInput.on("change", this.onThemeInputChange.bind(this)),
              this.addChild(this.themeInput);
            const u = yield this.ui.thickLabeledFrame({
              labelText: "Sound",
              size: e,
            });
            (this.playSoundInput = new yr(
              this.ui,
              u,
              mr.False,
              mr.True,
              new Map([
                [mr.False, ["Disabled", ti.red]],
                [mr.True, ["Enabled", ti.lightyellow]],
              ])
            )),
              this.playSoundInput.create(),
              this.playSoundInput.position.set(
                0.5 * this.options.size.x - 178,
                n - 0.5 * this.options.size.y
              ),
              this.playSoundInput.on(
                "change",
                this.onPlaySoundInputChange.bind(this)
              ),
              this.addChild(this.playSoundInput),
              (n += 44);
            const h = yield this.ui.thickLabeledFrame({
              labelText: "Detailed Reports",
              size: e,
            });
            (this.showReportDetailsInput = new yr(
              this.ui,
              h,
              mr.False,
              mr.True,
              new Map([
                [mr.False, ["Disabled", ti.red]],
                [mr.True, ["Enabled", ti.lightyellow]],
              ])
            )),
              this.showReportDetailsInput.create(),
              this.showReportDetailsInput.position.set(
                18 - 0.5 * this.options.size.x,
                n - 0.5 * this.options.size.y
              ),
              this.showReportDetailsInput.on(
                "change",
                this.onShowReportDetailsInputChange.bind(this)
              ),
              this.addChild(this.showReportDetailsInput);
            const c = yield this.ui.thickLabeledFrame({
              labelText: "Starter Items",
              size: e,
            });
            (this.starterEquipmentInput = new yr(
              this.ui,
              c,
              Dr.NoEquipment,
              Dr.RandomEquipment,
              new Map([
                [Dr.NoEquipment, ["None", ti.red]],
                [Dr.StarterEquipment, ["Default", ti.lightyellow]],
                [Dr.STierEquipment, ["S-Tier", ti.yellow]],
                [Dr.RandomEquipment, ["Random", ti.orange]],
              ])
            )),
              this.starterEquipmentInput.create(),
              this.starterEquipmentInput.position.set(
                186 - 0.5 * this.options.size.x,
                n - 0.5 * this.options.size.y
              ),
              this.starterEquipmentInput.on(
                "change",
                this.onStarterEquipmentInputChange.bind(this)
              ),
              this.addChild(this.starterEquipmentInput);
            const d = yield this.ui.thickLabeledFrame({
              labelText: "Startup Tool",
              size: e,
            });
            (this.startupToolInput = new yr(
              this.ui,
              d,
              He.Calculator,
              He.ItemChecklist,
              new Map([
                [He.Calculator, ["Calculator", ti.lightyellow]],
                [He.SkinViewer, ["Skin Viewer", ti.lightyellow]],
                [He.ItemSandbox, ["Item Sandbox", ti.lightyellow]],
                [He.ItemEditor, ["Item Editor", ti.lightyellow]],
                [He.ItemChecklist, ["Item Checklist", ti.lightyellow]],
              ])
            )),
              this.startupToolInput.create(),
              this.startupToolInput.position.set(
                0.5 * this.options.size.x - 178,
                n - 0.5 * this.options.size.y
              ),
              this.startupToolInput.on(
                "change",
                this.onStartupToolInputChange.bind(this)
              ),
              this.addChild(this.startupToolInput),
              (n += 44),
              (this.resetSettingsButton = yield this.ui.smallButton({
                text: "Reset Settings",
                size: i,
                anchor: Ve.CENTER,
                onClick: this.onResetSettingsClick.bind(this),
              })),
              this.resetSettingsButton.position.set(
                0,
                n + 0.5 * e.y - 0.5 * this.options.size.y
              ),
              this.addChild(this.resetSettingsButton),
              (n += 50);
            const p = this.ui.themedText({
              text: "Simulation Settings",
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fontSize: 28 }
              ),
            });
            p.anchor.set(0.5, 0),
              (p.position.y = n - 0.5 * this.options.size.y);
            const [f, m] = Ve.getBoundsReminder(p);
            p.pivot.set(f, m), this.addChild(p), (n += 36);
            const g = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "Simulation Time",
                size: e,
              }),
              checkBoundaryAfterwards: !0,
              maxLength: 11,
              textStyle: { fill: ti.lightyellow },
            };
            (this.simulationTimeSecondsInput = new nr(
              this.ui,
              g,
              5,
              60,
              "",
              " seconds"
            )),
              this.simulationTimeSecondsInput.create(),
              this.simulationTimeSecondsInput.position.set(
                -e.x - 4,
                n - 0.5 * this.options.size.y
              ),
              this.simulationTimeSecondsInput.on(
                "change",
                this.onSimulationTimeSecondsInputChange.bind(this)
              ),
              this.addChild(this.simulationTimeSecondsInput);
            const v = yield this.ui.thickLabeledFrame({
              labelText: "In-Game Ping",
              size: e,
            });
            (this.inGamePingMsInput = new yr(
              this.ui,
              v,
              Ti.Ping20Ms,
              Ti.Ping200Ms,
              new Map([
                [Ti.Ping20Ms, ["20 ms", ti.lightyellow]],
                [Ti.Ping50Ms, ["51 ms", ti.lightyellow]],
                [Ti.Ping100Ms, ["101 ms", ti.orange]],
                [Ti.Ping200Ms, ["201 ms", ti.red]],
              ])
            )),
              this.inGamePingMsInput.create(),
              this.inGamePingMsInput.position.set(
                4,
                n - 0.5 * this.options.size.y
              ),
              this.inGamePingMsInput.on(
                "change",
                this.onInGamePingInputChange.bind(this)
              ),
              this.inGamePingMsInput.addListener(
                "mouseenter",
                this.onInGamePingInputMouseEnter.bind(this)
              ),
              this.inGamePingMsInput.addListener(
                "mouseleave",
                this.onMouseLeaveBinding
              ),
              this.addChild(this.inGamePingMsInput),
              (n += 50);
            const y = this.ui.themedText({
              text: "Data Settings",
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fontSize: 28 }
              ),
            });
            y.anchor.set(0.5, 0),
              (y.position.y = n - 0.5 * this.options.size.y);
            const [x, b] = Ve.getBoundsReminder(y);
            y.pivot.set(x, b), this.addChild(y), (n += 36);
            const S = yield this.ui.thickLabeledFrame({
              labelText: "Save Chars",
              size: e,
            });
            (this.saveCharactersInput = new yr(
              this.ui,
              S,
              mr.False,
              mr.True,
              new Map([
                [mr.False, ["Don't Save", ti.red]],
                [mr.True, ["Last Session", ti.lightyellow]],
              ])
            )),
              this.saveCharactersInput.create(),
              this.saveCharactersInput.position.set(
                -e.x - 4,
                n - 0.5 * this.options.size.y
              ),
              this.saveCharactersInput.on(
                "change",
                this.onSaveCharactersInputChange.bind(this)
              ),
              this.addChild(this.saveCharactersInput);
            const C = {
              background: yield this.ui.thickLabeledFrame({
                labelText: "Import Data",
                size: e,
              }),
              placeholder: "Paste Here",
              clearOnClick: !0,
              anchor: Ve.CENTER,
              textStyle: { fill: ti.lightyellow },
            };
            (this.importCharactersInput = new Ke(this.ui, C)),
              this.importCharactersInput.create(),
              this.importCharactersInput.position.set(
                4,
                n - 0.5 * this.options.size.y
              ),
              this.addChild(this.importCharactersInput),
              (n += 46),
              (this.exportCharactersButton = yield this.ui.smallButton({
                text: "Export Chars",
                size: i,
                anchor: Ve.CENTER,
                onClick: this.onExportCharactersClick.bind(this),
              })),
              this.exportCharactersButton.position.set(
                -e.x - 6 + 0.5 * i.x,
                n + 0.5 * e.y - 0.5 * this.options.size.y
              ),
              this.addChild(this.exportCharactersButton),
              (this.importCharactersButton = yield this.ui.smallButton({
                text: "Import Chars",
                size: i,
                anchor: Ve.CENTER,
                onClick: this.onImportCharactersClick.bind(this),
              })),
              this.importCharactersButton.position.set(
                6 + 0.5 * i.x,
                n + 0.5 * e.y - 0.5 * this.options.size.y
              ),
              this.addChild(this.importCharactersButton),
              (n += 28),
              (this.exportCallbackText.alpha = 0),
              this.exportCallbackText.anchor.set(0.5, 0);
            const [_, T] = Ve.getBoundsReminder(this.exportCallbackText);
            this.exportCallbackText.pivot.set(_, T),
              this.exportCallbackText.position.set(
                0,
                n + 0.5 * e.y - 0.5 * this.options.size.y
              ),
              this.addChild(this.exportCallbackText),
              yield this.loadSettings();
          });
        }
        onStartupToolInputChange(t) {
          this.ui.app.settingsHandler.startupTool = t;
        }
        onResetSettingsClick() {
          this.ui.app.settingsHandler.resetSettings(), this.loadSettings();
        }
        onThemeInputChange(t) {
          this.ui.app.settingsHandler.uiTheme = t;
        }
        onInGamePingInputChange(t) {
          this.ui.app.settingsHandler.inGamePingMs = t;
        }
        onInGamePingInputMouseEnter() {
          this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllEnabled &&
            this.ui.app.tooltipHandler.showInformation([
              ["In-Game Ping", ti.white],
              ["Time added to cooldowns, due to", ti.orange],
              ["ability cooldowns being server-sided.", ti.orange],
            ]);
        }
        onMouseLeave() {
          this.ui.app.tooltipHandler.hide();
        }
        onSimulationTimeSecondsInputChange(t) {
          this.ui.app.settingsHandler.simulationTimeSeconds = t;
        }
        onSaveCharactersInputChange(t) {
          this.ui.app.settingsHandler.saveCharacters = Boolean(t);
        }
        onStarterEquipmentInputChange(t) {
          this.ui.app.settingsHandler.starterEquipment = t;
        }
        onShowGuidanceTooltipsInputChange(t) {
          this.ui.app.settingsHandler.showGuidanceTooltips = t;
        }
        onShowReportDetailsInputChange(t) {
          this.ui.app.settingsHandler.showReportDetails = Boolean(t);
        }
        onPlaySoundInputChange(t) {
          this.ui.app.settingsHandler.playSound = Boolean(t);
        }
        loadSettings() {
          var t, e, i, n, s, r, o, a, l, u, h, c, d, p, f, m, g, v;
          const y = this.ui.app.cacheHandler.loadSettingsFromCache(),
            x = this.ui.app.settingsHandler;
          null === (t = this.showGuidanceTooltipsInput) ||
            void 0 === t ||
            t.setValue(
              Number(
                null !== (e = null == y ? void 0 : y.showGuidanceTooltips) &&
                  void 0 !== e
                  ? e
                  : x.showGuidanceTooltipsDefaultValue
              )
            ),
            null === (i = this.themeInput) ||
              void 0 === i ||
              i.setValue(
                Number(
                  null !== (n = null == y ? void 0 : y.uiTheme) && void 0 !== n
                    ? n
                    : x.uiThemeDefaultValue
                )
              ),
            null === (s = this.playSoundInput) ||
              void 0 === s ||
              s.setValue(
                Number(
                  null !== (r = null == y ? void 0 : y.playSound) &&
                    void 0 !== r
                    ? r
                    : x.playSoundDefaultValue
                )
              ),
            null === (o = this.startupToolInput) ||
              void 0 === o ||
              o.setValue(
                Number(
                  null !== (a = null == y ? void 0 : y.startupTool) &&
                    void 0 !== a
                    ? a
                    : x.startupToolDefaultValue
                )
              ),
            null === (l = this.saveCharactersInput) ||
              void 0 === l ||
              l.setValue(
                Number(
                  null !== (u = null == y ? void 0 : y.saveCharacters) &&
                    void 0 !== u
                    ? u
                    : x.saveCharactersDefaultValue
                )
              ),
            null === (h = this.starterEquipmentInput) ||
              void 0 === h ||
              h.setValue(
                Number(
                  null !== (c = null == y ? void 0 : y.starterEquipment) &&
                    void 0 !== c
                    ? c
                    : x.starterEquipmentDefaultValue
                )
              ),
            null === (d = this.showReportDetailsInput) ||
              void 0 === d ||
              d.setValue(
                Number(
                  null !== (p = null == y ? void 0 : y.showReportDetails) &&
                    void 0 !== p
                    ? p
                    : x.showReportDetailsDefaultValue
                )
              ),
            null === (f = this.simulationTimeSecondsInput) ||
              void 0 === f ||
              f.setValue(
                Number(
                  null !== (m = null == y ? void 0 : y.simulationTimeSeconds) &&
                    void 0 !== m
                    ? m
                    : x.simulationTimeSecondsDefaultValue
                )
              ),
            null === (g = this.inGamePingMsInput) ||
              void 0 === g ||
              g.setValue(
                Number(
                  null !== (v = null == y ? void 0 : y.inGamePingMs) &&
                    void 0 !== v
                    ? v
                    : x.inGamePingMsDefaultValue
                )
              );
        }
        onImportCharactersClick() {
          return Or(this, void 0, void 0, function* () {
            if (void 0 === this.importCharactersInput) return;
            const t = yield this.ui.app.cacheHandler.importCharacters(
              this.importCharactersInput.value
            );
            (this.importCharactersInput.value = ""),
              (this.exportCallbackText.text = t);
          });
        }
        show() {
          super.show(), (this.exportCallbackText.alpha = 0);
        }
        onExportCharactersClick() {
          if (0 == this.ui.app.charactersHandler.characterContainers.length)
            return (
              (this.exportCallbackText.text = "No characters to export."),
              void (this.exportCallbackText.style.fill = ti.red)
            );
          (this.exportCallbackText.text = "Copied export code to clipboard."),
            (this.exportCallbackText.style.fill = ti.lightyellow);
          const t = this.ui.app.cacheHandler.getCharactersCode();
          navigator.clipboard.writeText(t), (this.exportCallbackText.alpha = 1);
        }
      }
      var Lr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Hr extends qs {
        constructor(t, e) {
          super(t, e),
            (this.targetPortrait = new js(t)),
            (this.targetNameLabel = t.themedText({ anchor: Ve.CENTER })),
            (this.statusEffectsToggleMap = new Map()),
            (this.statusEffectsArray = new Array(
              Ie.Curse,
              Ie.Exposed,
              Ie.ArmorBroken,
              Ie.Armored
            )),
            (this.immunityToggleMap = new Map()),
            (this.immunityArray = new Array(
              Ie.Curse,
              Ie.Exposed,
              Ie.ArmorBroken
            ));
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return Lr(this, void 0, void 0, function* () {
            t.create.call(this),
              this.setTitleText("Edit Target"),
              (this.editCharacterButton = yield this.ui.smallButton({
                text: "Back to Character",
                size: new Et.b(180, 40),
                anchor: Ve.CENTER,
                onClick: this.onEditCharacterClick.bind(this),
              })),
              this.editCharacterButton.position.set(
                0,
                0.5 * this.options.size.y - 40
              ),
              this.addChild(this.editCharacterButton);
            const e = new Et.b(124, 36),
              i = new Et.b(124, 48);
            this.targetPortrait.anchor.set(0.5, 1),
              this.targetPortrait.position.set(
                0,
                172 - 0.5 * this.options.size.y
              ),
              this.addChild(this.targetPortrait),
              this.targetNameLabel.position.set(
                0,
                182 - 0.5 * this.options.size.y
              ),
              this.addChild(this.targetNameLabel);
            const n = {
                checkBoundaryAfterwards: !0,
                maxLength: 12,
                textStyle: { fill: ti.lightyellow, align: "center" },
              },
              s = yield this.ui.thickLabeledFrame({
                labelText: "Max HP",
                size: e,
                contentColor: ti.lightyellow,
              });
            (this.hitpointsInput = new nr(
              this.ui,
              Object.assign(Object.assign({}, n), { background: s }),
              1e3,
              1e7
            )),
              this.hitpointsInput.position.set(
                0.5 * -this.options.size.x + 18,
                0.5 * -this.options.size.y + 68
              ),
              this.hitpointsInput.create(),
              (this.hitpointsInput.eventMode = "static"),
              this.hitpointsInput.on(
                "change",
                this.onHitpointsInputChange.bind(this)
              ),
              this.hitpointsInput.on(
                "shiftClick",
                this.onHitpointsInputShiftClick.bind(this)
              ),
              this.hitpointsInput.addListener(
                "mouseenter",
                this.onHitpointsInputMouseEnter
              ),
              this.hitpointsInput.addListener(
                "mouseleave",
                this.ui.app.tooltipHandler.onMouseLeaveBinding
              ),
              this.addChild(this.hitpointsInput);
            const r = yield this.ui.thickLabeledFrame({
              labelText: "Defense",
              size: e,
              contentColor: ti.lightyellow,
            });
            (this.defenseInput = new nr(
              this.ui,
              Object.assign(Object.assign({}, n), { background: r }),
              0,
              9999
            )),
              this.defenseInput.position.set(
                0.5 * -this.options.size.x + 150,
                0.5 * -this.options.size.y + 68
              ),
              this.defenseInput.create(),
              (this.defenseInput.eventMode = "static"),
              this.defenseInput.on(
                "change",
                this.onDefenseInputChange.bind(this)
              ),
              this.defenseInput.on(
                "shiftClick",
                this.onDefenseInputShiftClick.bind(this)
              ),
              this.defenseInput.addListener(
                "mouseenter",
                this.onDefenseInputMouseEnter
              ),
              this.defenseInput.addListener(
                "mouseleave",
                this.ui.app.tooltipHandler.onMouseLeaveBinding
              ),
              this.addChild(this.defenseInput);
            const o = yield this.ui.thickLabeledFrame({
              labelText: "Heal",
              size: e,
              contentColor: ti.lightyellow,
            });
            (this.healInput = new nr(
              this.ui,
              Object.assign(Object.assign({}, n), { background: o }),
              0,
              1e6
            )),
              this.healInput.position.set(
                0.5 * this.options.size.x - 142,
                0.5 * -this.options.size.y + 68
              ),
              this.healInput.create(),
              (this.healInput.eventMode = "static"),
              this.healInput.on("change", this.onHealInputChange.bind(this)),
              this.healInput.on(
                "shiftClick",
                this.onHealInputShiftClick.bind(this)
              ),
              this.healInput.addListener(
                "mouseenter",
                this.onHealInputMouseEnter
              ),
              this.healInput.addListener(
                "mouseleave",
                this.ui.app.tooltipHandler.onMouseLeaveBinding
              ),
              this.addChild(this.healInput),
              (this.conditionLabel = yield this.ui.thickLabeledFrame({
                labelText: "Conditions",
                size: i,
              })),
              this.conditionLabel.position.set(
                0.5 * -this.options.size.x + 18,
                0.5 * -this.options.size.y + 112
              ),
              this.addChild(this.conditionLabel),
              (this.immunityLabel = yield this.ui.thickLabeledFrame({
                labelText: "Immunities",
                size: i,
              })),
              this.immunityLabel.position.set(
                0.5 * this.options.size.x - 142,
                0.5 * -this.options.size.y + 112
              ),
              this.addChild(this.immunityLabel);
            const a = this.ui.themedText({
              text: "Target Presets",
              anchor: Ve.CENTER_X,
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fontSize: 28 }
              ),
            });
            a.position.set(0, 0.5 * -this.options.size.y + 200),
              this.addChild(a);
            const l = Array.from(this.ui.app.dataHandler.enemiesData).sort(
              (t, e) => t[1].defense - e[1].defense
            );
            for (let t = 0; t < l.length; t++) {
              const e = l[t][0],
                i = l[t][1],
                n = new js(this.ui);
              n.createPortrait(e, i.mirrorable),
                (n.cursor = "pointer"),
                (n.eventMode = "static"),
                n.addListener("click", (t) => this.onTargetPresetClick(i)),
                n.addListener("mouseenter", (t) =>
                  this.onTargetPresetMouseEnter(i)
                ),
                n.addListener(
                  "mouseleave",
                  this.ui.app.tooltipHandler.onMouseLeaveBinding
                ),
                n.anchor.set(0.5, 1);
              const s = 60 + (t % 6) * 60 - 0.5 * this.options.size.x,
                r = 48 + 60 * Math.floor(t / 6);
              n.position.set(s, r), this.addChild(n);
            }
            const u = new Et.b(
                0.5 * -this.options.size.x + 50,
                140 - 0.5 * this.options.size.y
              ),
              h = (yield this.ui.getTexture("ui/icons/status_effects")).source;
            for (let t = 0; t < this.statusEffectsArray.length; t++)
              this.createToggableStatusEffectTypeHelper(
                this.statusEffectsArray[t],
                h,
                u.x + 20 * t,
                u.y
              );
            const c = new Et.b(104, 140 - 0.5 * this.options.size.y),
              d = new Array(
                "curse_immunity_icon",
                "exposed_immunity_icon",
                "armor_broken_immunity_icon"
              );
            for (let t = 0; t < this.immunityArray.length; t++) {
              const e = (yield this.ui.getTexture(`ui/icons/${d[t]}`)).source;
              this.createToggableStatusEffectTypeHelper(
                this.immunityArray[t],
                e,
                c.x + 24 * t,
                c.y,
                !0
              );
            }
          });
        }
        onRemoveCharacter(t) {
          this.editedCharacterContainer == t && this.hide();
        }
        onHitpointsInputMouseEnter(t) {
          if (this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
            return;
          const e = new Array(
            ["Enemy's Base HP", ti.white],
            ["Shift-Click to Share To All Enemies", ti.yellow]
          );
          this.ui.app.tooltipHandler.showInformation(e);
        }
        onHitpointsInputChange(t) {
          if (void 0 === this.editedCharacterContainer) return;
          const e = { hitpoints: t };
          this.ui.app.charactersHandler.setCharacterTargetData(
            this.editedCharacterContainer,
            e
          );
        }
        onHitpointsInputShiftClick(t) {
          if (void 0 === this.editedCharacterContainer) return;
          const e = { hitpoints: t };
          this.ui.app.charactersHandler.setAllCharacterTargetData(
            this.editedCharacterContainer,
            e
          );
        }
        onDefenseInputMouseEnter(t) {
          if (this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
            return;
          const e = new Array(
            ["Enemy's Base Defense", ti.white],
            ["Shift-Click to Share To All Enemies", ti.yellow]
          );
          this.ui.app.tooltipHandler.showInformation(e);
        }
        onDefenseInputChange(t) {
          if (void 0 === this.editedCharacterContainer) return;
          const e = { defense: t };
          this.ui.app.charactersHandler.setCharacterTargetData(
            this.editedCharacterContainer,
            e
          );
        }
        onDefenseInputShiftClick(t) {
          if (void 0 === this.editedCharacterContainer) return;
          const e = { defense: t };
          this.ui.app.charactersHandler.setAllCharacterTargetData(
            this.editedCharacterContainer,
            e
          );
        }
        onHealInputMouseEnter(t) {
          if (this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
            return;
          const e = new Array(
            ["Enemy's Periodic Heal (every 5 seconds)", ti.white],
            ["Shift-Click to Share To All Enemies", ti.yellow]
          );
          this.ui.app.tooltipHandler.showInformation(e);
        }
        onHealInputChange(t) {
          if (void 0 === this.editedCharacterContainer) return;
          const e = { heal: t };
          this.ui.app.charactersHandler.setCharacterTargetData(
            this.editedCharacterContainer,
            e
          );
        }
        onHealInputShiftClick(t) {
          if (void 0 === this.editedCharacterContainer) return;
          const e = { heal: t };
          this.ui.app.charactersHandler.setAllCharacterTargetData(
            this.editedCharacterContainer,
            e
          );
        }
        onTargetPresetClick(t) {
          void 0 !== this.editedCharacterContainer &&
            (this.ui.playClickSound(),
            this.ui.app.charactersHandler.setCharacterTargetData(
              this.editedCharacterContainer,
              t,
              xr.Change
            ));
        }
        onEditCharacterClick(t) {
          void 0 !== this.editedCharacterContainer &&
            this.ui.app.mainPanelHandler.switchCharacterStatsEditor(
              this.editedCharacterContainer
            );
        }
        getEditedCharacterContainer() {
          return this.editedCharacterContainer;
        }
        appendData(t) {
          var e, i, n, s, r;
          const o = t.characterInstance,
            a = o.targetData;
          this.targetPortrait.createPortrait(a.name, a.mirrorable),
            (this.targetNameLabel.text = a.name);
          const l = o.targetData.hitpoints;
          null === (e = this.hitpointsInput) || void 0 === e || e.setValue(l);
          const u = o.targetData.defense;
          null === (i = this.defenseInput) || void 0 === i || i.setValue(u);
          const h = o.targetData.heal;
          null === (n = this.healInput) || void 0 === n || n.setValue(h);
          for (const e of this.statusEffectsArray) {
            const i =
              null !== (s = o.targetPermaStatusEffects.get(e)) &&
              void 0 !== s &&
              s;
            this.updateStatusEffectToggleSprite(t, e, i);
          }
          for (const e of this.immunityArray) {
            const i =
              null !== (r = o.targetImmunities.get(e)) && void 0 !== r && r;
            this.updateStatusEffectToggleSprite(t, e, i, !0);
          }
        }
        updateStatusEffectToggleSprite(t, e, i, n = !1) {
          if (this.editedCharacterContainer !== t) return;
          const s = (
            n ? this.immunityToggleMap : this.statusEffectsToggleMap
          ).get(e);
          void 0 !== s && (s.parent.alpha = 1 == i ? 1 : 0.2);
        }
        switchData(t) {
          if (this.editedCharacterContainer != t)
            return (
              (this.editedCharacterContainer = t),
              this.appendData(t),
              void this.show()
            );
          1 == this.visible ? this.hide() : this.show();
        }
        updateData(t) {
          this.editedCharacterContainer === t && this.appendData(t);
        }
        onTargetPresetMouseEnter(t) {
          const e = new Array(
            [t.name, ti.white],
            [`${Ve.separators(t.hitpoints)} HP`, ti.lightyellow],
            [`${Ve.separators(t.defense)} DEF`, ti.lightyellow]
          );
          if (
            (t.heal > 0 &&
              e.push([
                `+${Ve.separators(t.heal)} HP every 5 seconds`,
                ti.lightyellow,
              ]),
            t.statusEffectImmunities.length > 0)
          ) {
            let i = "";
            for (let e = 0; e < t.statusEffectImmunities.length; e++)
              (i += Ve.statusEffectToString(t.statusEffectImmunities[e])),
                e < t.statusEffectImmunities.length - 1 && (i += ", ");
            e.push([`${i} Immunity`, ti.lightyellow]);
          }
          this.ui.app.tooltipHandler.showInformation(e);
        }
        onImmunityToggleClick(t, e) {
          var i;
          if (
            (this.ui.playClickSound(), void 0 === this.editedCharacterContainer)
          )
            return;
          const n = !(
            null !==
              (i =
                this.editedCharacterContainer.characterInstance.targetImmunities.get(
                  e
                )) &&
            void 0 !== i &&
            i
          );
          1 != t.shiftKey
            ? this.ui.app.charactersHandler.setTargetImmunity(
                this.editedCharacterContainer,
                e,
                n
              )
            : this.ui.app.charactersHandler.setAllTargetsImmunity(e, n);
        }
        onImmunityToggleMouseEnter(t) {
          const e = this.immunityToggleMap.get(t);
          if (void 0 === e) return;
          if (
            (e.scale.set(3, 3),
            this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
          )
            return;
          const i = new Array(
            [`${Ve.statusEffectToString(t)} Immunity Toggle`, ti.white],
            ["Left Click to Toggle", ti.orange],
            ["Shift-Click to Toggle On All Enemies", ti.yellow]
          );
          this.ui.app.tooltipHandler.showInformation(i);
        }
        onImmunityToggleMouseLeave(t) {
          this.ui.app.tooltipHandler.hide();
          const e = this.immunityToggleMap.get(t);
          void 0 !== e && e.scale.set(2, 2);
        }
        createToggableStatusEffectTypeHelper(t, e, i, n) {
          return Lr(this, arguments, void 0, function* (t, e, i, n, s = !1) {
            const r = s ? void 0 : { x: 10 * t, y: 0, width: 10, height: 10 },
              o = new a.g({ source: e, frame: r }),
              l = new Gt.mc();
            (l.alpha = 0.2), l.position.set(i, n);
            const u = new Xt.k();
            u.anchor.set(0.5, 0.5),
              (u.width = 20 + 4 * +s),
              (u.height = 20 + 4 * +s),
              (u.eventMode = "static"),
              (u.cursor = "pointer"),
              s
                ? (u.addListener("mouseenter", () =>
                    this.onImmunityToggleMouseEnter(t)
                  ),
                  u.addListener("mousedown", (e) =>
                    this.onImmunityToggleClick(e, t)
                  ),
                  u.addListener("mouseleave", () =>
                    this.onImmunityToggleMouseLeave(t)
                  ))
                : (u.addListener("mouseenter", () =>
                    this.onStatusEffectToggleMouseEnter(t)
                  ),
                  u.addListener("mousedown", (e) =>
                    this.onStatusEffectToggleClick(e, t)
                  ),
                  u.addListener("mouseleave", () =>
                    this.onStatusEffectToggleMouseLeave(t)
                  )),
              l.addChild(u);
            const h = new Xt.k(o);
            return (
              h.anchor.set(0.5, 0.5),
              h.scale.set(2, 2),
              (h.eventMode = "none"),
              l.addChild(h),
              s
                ? this.immunityToggleMap.set(t, h)
                : this.statusEffectsToggleMap.set(t, h),
              this.addChild(l),
              Promise.resolve(l)
            );
          });
        }
        onStatusEffectToggleClick(t, e) {
          var i;
          if (
            (this.ui.playClickSound(), void 0 === this.editedCharacterContainer)
          )
            return;
          const n = !(
            null !==
              (i =
                this.editedCharacterContainer.characterInstance.targetPermaStatusEffects.get(
                  e
                )) &&
            void 0 !== i &&
            i
          );
          1 != t.shiftKey
            ? this.ui.app.charactersHandler.setCharacterStatusEffect(
                this.editedCharacterContainer,
                e,
                n,
                !1
              )
            : this.ui.app.charactersHandler.setAllCharactersStatusEffect(
                e,
                n,
                !1
              );
        }
        onStatusEffectToggleMouseEnter(t) {
          var e, i;
          const n = this.statusEffectsToggleMap.get(t);
          if (void 0 === n) return;
          n.scale.set(3, 3);
          const s =
            null !==
              (i =
                null ===
                  (e =
                    this.ui.app.dataHandler.statusEffectDescriptionData.get(
                      t
                    )) || void 0 === e
                  ? void 0
                  : e.map((t) => [t, ti.lightyellow])) && void 0 !== i
              ? i
              : [];
          if (this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
            return;
          const r = new Array(
            [`Permanent ${Ve.statusEffectToString(t)} Toggle`, ti.white],
            ...s,
            ["Left Click to Toggle", ti.orange],
            ["Shift-Click to Toggle On All Enemies", ti.yellow]
          );
          this.ui.app.tooltipHandler.showInformation(r);
        }
        onStatusEffectToggleMouseLeave(t) {
          this.ui.app.tooltipHandler.hide();
          const e = this.statusEffectsToggleMap.get(t);
          void 0 !== e && e.scale.set(2, 2);
        }
      }
      var Ur = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Nr extends qs {
        constructor(t, e) {
          super(t, e),
            (this.disclaimerTextContent = t.text({
              text: "Skin Viewer is fan-made tool and it may contain\nincorrect data and visual bugs. Please double-check\neverything inside the game before purchasing\nanything for real money. Click OK to proceed.",
            })),
            this.disclaimerTextContent.position.set(
              -Math.floor(0.5 * this.disclaimerTextContent.width),
              -42
            ),
            this.addChild(this.disclaimerTextContent);
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return Ur(this, void 0, void 0, function* () {
            t.create.call(this),
              this.setTitleText("Disclaimer"),
              (this.closeIcon.visible = !1),
              (this.haveReadButton = yield this.ui.smallButton({
                text: "OK",
                size: { x: 140, y: 32 },
                anchor: Ve.CENTER,
                onClick: this.onAccept.bind(this),
              })),
              this.haveReadButton.position.set(0, 60),
              this.addChild(this.haveReadButton);
          });
        }
        onAccept() {
          this.hide(), this.emit("disclaimer");
        }
      }
      var Gr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Vr extends ai {
        constructor(t) {
          super(t),
            (this.panelContainer = new Gt.mc()),
            (this.panelWidthPixels = 400),
            (this.lastTipId = 0),
            (this.titleColorHue = 0),
            (this.titleTextColorMatrixFilter = new At()),
            (this.toolIconList = new Array()),
            (this.appTitleText = new Jt({
              text: "RotMG Toolset",
              anchor: Ve.CENTER_X,
              style: { fontFamily: "ChronoType", fontSize: 32, fill: 16754688 },
            })),
            (this.versionText = this.app.ui.themedText({
              anchor: Ve.CENTER_X,
              style: { fontSize: 16, fill: ti.white },
            })),
            (this.chartIcon = this.addTool("Calculator Tool", He.Calculator)),
            (this.skinViewerIcon = this.addTool(
              "Skin Viewer Tool",
              He.SkinViewer
            )),
            (this.itemSandboxIcon = this.addTool(
              "Item Sandbox Tool",
              He.ItemSandbox
            )),
            (this.itemEditorIcon = this.addTool(
              "Item Editor Tool",
              He.ItemEditor
            )),
            (this.lootChecklistIcon = this.addTool(
              "Item Checklist Tool",
              He.ItemChecklist
            )),
            (this.backgroundSprite = new Xt.k()),
            (this.discordIcon = new oi(t.ui, {
              iconTexture: "discord_icon",
              guidanceTooltip: new Array(
                ["You found bug or have some ideas?", ti.white],
                ["https://discord.gg/uDK2EhJUtv", ti.orange]
              ),
              onClick: this.onDiscordIconClick.bind(this),
            })),
            (this.changelogIcon = new oi(t.ui, {
              iconTexture: "changelog_icon",
              guidanceTooltip: new Array(
                ["Changelog", ti.white],
                ["Left Click to Open", ti.orange]
              ),
              onClick: this.onChangelogIconClick.bind(this),
            })),
            (this.settingsIcon = new oi(t.ui, {
              iconTexture: "settings_icon",
              guidanceTooltip: new Array(
                ["Settings", ti.white],
                ["Left Click to Open", ti.orange]
              ),
              onClick: this.onSettingsIconClick.bind(this),
            })),
            (this.updateVersionTextContent = ""),
            (this.draggableFrames = new Array()),
            (this.currentToolType = He.None),
            window.addEventListener("keydown", this.onKeyDown.bind(this));
        }
        create(t) {
          const e = Object.create(null, {
            create: { get: () => super.create },
          });
          return Gr(this, void 0, void 0, function* () {
            var i, n;
            const s = new Gt.mc();
            this.app.canvas.addChild(s),
              this.createTools(s),
              this.app.canvas.addChild(this.panelContainer),
              (this.panelContainer.sortableChildren = !0),
              this.panelContainer.position.set(
                window.innerWidth - this.panelWidthPixels,
                0
              );
            const r = new Et.b(this.panelWidthPixels, window.innerHeight),
              o =
                null !==
                  (n =
                    null === (i = this.app.ui.theme) || void 0 === i
                      ? void 0
                      : i.mainPanel) && void 0 !== n
                  ? n
                  : "gray_main_panel_frame",
              a = yield this.app.ui.frameTexture({ frameTexture: o, size: r });
            (this.backgroundSprite = new Xt.k(a)),
              this.panelContainer.addChild(this.backgroundSprite);
            const l = this.app.dataHandler.getLatestUpdate(),
              u = this.app.cacheHandler.checkLastCheckedVersion(l.id)
                ? "changelog_icon"
                : "news_icon";
            this.changelogIcon.create(),
              this.changelogIcon.setIcon(u),
              this.changelogIcon.position.set(10, 18),
              this.panelContainer.addChild(this.changelogIcon),
              this.discordIcon.create(),
              this.discordIcon.position.set(this.panelWidthPixels - 40, 2),
              this.panelContainer.addChild(this.discordIcon),
              this.settingsIcon.create(),
              this.settingsIcon.position.set(this.panelWidthPixels - 40, 30),
              this.panelContainer.addChild(this.settingsIcon);
            const h = new Gt.mc();
            this.panelContainer.addChild(h),
              (this.appTitleText.filters = [this.titleTextColorMatrixFilter]),
              this.appTitleText.position.set(0.5 * this.panelWidthPixels, 14),
              h.addChild(this.appTitleText),
              (this.updateVersionTextContent = `updated ${l.date} @ Exalt ${l.exaltVersion}`),
              (this.versionText.text = this.updateVersionTextContent),
              this.versionText.position.set(0.5 * this.panelWidthPixels, 37),
              h.addChild(this.versionText);
            const c = new Xt.k();
            c.position.set(50, 2),
              (c.width = this.panelWidthPixels - 100),
              (c.height = 58),
              (c.eventMode = "static"),
              c.addListener(
                "mouseenter",
                this.onTitleTextMouseEnter.bind(this)
              ),
              c.addListener(
                "mouseleave",
                this.onTitleTextMouseLeave.bind(this)
              ),
              h.addChild(c),
              this.app.charactersHandler.create(t),
              this.app.charactersHandler.container.position.set(
                0,
                c.height + 8
              ),
              this.panelContainer.addChild(
                this.app.charactersHandler.container
              ),
              (this.changeClassFrame = yield this.app.ui.windowFrame(Xs, {
                size: new Et.b(640, 360),
                anchor: Ve.CENTER,
              })),
              this.app.canvas.addChild(this.changeClassFrame),
              (this.targetFrame = yield this.app.ui.windowFrame(Hr, {
                size: new Et.b(424, 480),
                anchor: Ve.CENTER,
              })),
              this.app.canvas.addChild(this.targetFrame),
              (this.changeEquipmentFrame = yield this.app.ui.windowFrame(er, {
                size: new Et.b(640, 460),
                anchor: Ve.CENTER,
              })),
              this.app.canvas.addChild(this.changeEquipmentFrame),
              (this.colorPickerFrame = yield this.app.ui.windowFrame(ur, {
                size: new Et.b(420, 276),
                anchor: Ve.CENTER,
              })),
              this.app.canvas.addChild(this.colorPickerFrame),
              (this.changeCharacterStatsFrame = yield this.app.ui.windowFrame(
                _r,
                { size: new Et.b(444, 540), anchor: Ve.CENTER }
              )),
              this.app.canvas.addChild(this.changeCharacterStatsFrame),
              (this.enchantEquipmentFrame = yield this.app.ui.windowFrame(kr, {
                size: new Et.b(480, 600),
                anchor: Ve.CENTER,
              })),
              this.app.canvas.addChild(this.enchantEquipmentFrame),
              (this.settingsFrame = yield this.app.ui.windowFrame(zr, {
                size: new Et.b(532, 476),
                anchor: Ve.CENTER,
              })),
              this.app.canvas.addChild(this.settingsFrame),
              (this.changelogFrame = yield this.app.ui.windowFrame(Fr, {
                size: new Et.b(500, 480),
                anchor: Ve.CENTER,
              })),
              this.app.canvas.addChild(this.changelogFrame),
              (this.skinViewerDisclaimerFrame = yield this.app.ui.windowFrame(
                Nr,
                { size: new Et.b(480, 200), anchor: Ve.CENTER }
              )),
              this.skinViewerDisclaimerFrame.addListener(
                "disclaimer",
                this.onSkinViewerDisclaimerRead.bind(this)
              ),
              this.app.canvas.addChild(this.skinViewerDisclaimerFrame),
              this.draggableFrames.push(
                this.changeClassFrame,
                this.changeEquipmentFrame,
                this.colorPickerFrame,
                this.changeCharacterStatsFrame,
                this.enchantEquipmentFrame,
                this.settingsFrame,
                this.changelogFrame,
                this.targetFrame,
                this.skinViewerDisclaimerFrame
              ),
              this.centerAllDraggableFrames(),
              yield this.loadCharacters(),
              this.changeToolType(t),
              e.create.call(this);
          });
        }
        onThemeUpdate(t) {
          return Gr(this, void 0, void 0, function* () {
            var e, i;
            null === (e = this.enchantEquipmentFrame) ||
              void 0 === e ||
              e.onThemeUpdate(t),
              null === (i = this.colorPickerFrame) ||
                void 0 === i ||
                i.onThemeUpdate(t),
              this.updateBackgroundSize(),
              void 0 !== this.chartIcon &&
                (this.chartIcon.setIcon(t.calculatorIcon),
                this.skinViewerIcon.setIcon(t.skinViewerIcon),
                this.itemSandboxIcon.setIcon(t.itemSandboxIcon),
                this.itemEditorIcon.setIcon(t.itemEditorIcon),
                this.lootChecklistIcon.setIcon(t.lootChecklistIcon));
          });
        }
        onSkinViewerDisclaimerRead() {
          (this.app.settingsHandler.skinViewerDisclaimerRead = !0),
            this.openSkinViewerTool();
        }
        openSkinViewerTool() {
          this.app.changeWindowTitle("Skin Viewer"),
            this.app.skinViewerHandler.show();
        }
        addTool(t, e) {
          const i = new oi(this.app.ui, {
            guidanceTooltip: [
              [t, ti.white],
              ["Left Click to Switch Tool", ti.orange],
              ["Right Click to Copy Link", ti.blue],
            ],
            onClick: (t) => this.onToolIconClick(e),
            onRightClick: (t) => this.onToolIconRightClick(e),
          });
          return (this.toolIconList[e] = i), i;
        }
        createTools(t) {
          for (let e = 0; e < this.toolIconList.length; e++) {
            const i = this.toolIconList[e];
            i.create(), i.position.set(28 * e, 0), t.addChild(i);
          }
        }
        onToolIconClick(t) {
          this.changeToolType(t), this.app.ui.playClickSound();
        }
        onToolIconRightClick(t) {
          this.copyToolLink(t), this.app.ui.playClickSound();
        }
        changeToolType(t) {
          var e, i, n, s, r;
          if (this.currentToolType == t) return;
          (this.currentToolType = t),
            this.app.chartHandler.hide(),
            this.app.skinViewerHandler.hide(),
            this.app.itemSandboxHandler.hide(),
            this.app.itemCreatorHandler.hide(),
            this.app.itemChecklistHandler.hide(),
            this.hideAllOtherDraggableFrames(void 0);
          const o =
            null !==
              (i =
                null === (e = this.app.ui.theme) || void 0 === e
                  ? void 0
                  : e.semitransparencyMultiplier) && void 0 !== i
              ? i
              : 1;
          switch (
            (this.toolIconList.forEach((t) => (t.alpha = 0.2 * o)),
            (this.toolIconList[t].alpha = 1),
            this.app.charactersHandler.onToolTypeChange(t),
            1 ==
              (null === (n = this.skinViewerDisclaimerFrame) || void 0 === n
                ? void 0
                : n.visible) &&
              (null === (s = this.skinViewerDisclaimerFrame) ||
                void 0 === s ||
                s.hide()),
            t)
          ) {
            case He.Calculator:
              this.app.chartHandler.changeSimulationType(),
                this.app.chartHandler.show();
              break;
            case He.SkinViewer:
              0 == this.app.settingsHandler.skinViewerDisclaimerRead
                ? null === (r = this.skinViewerDisclaimerFrame) ||
                  void 0 === r ||
                  r.show()
                : this.openSkinViewerTool();
              break;
            case He.ItemSandbox:
              this.app.changeWindowTitle("Item Sandbox"),
                this.app.itemSandboxHandler.show();
              break;
            case He.ItemEditor:
              this.app.changeWindowTitle("Item Editor"),
                this.app.itemCreatorHandler.show();
              break;
            case He.ItemChecklist:
              this.app.changeWindowTitle("Item Checklist"),
                this.app.itemChecklistHandler.show();
          }
        }
        copyToolLink(t) {
          const e = `https://rotmg_toolset.realmshark.cc/?tool=${Ve.toolTypeToString(
            t
          )}`;
          navigator.clipboard.writeText(e);
        }
        onKeyDown(t) {
          "Escape" === t.code &&
            void 0 !== this.openedFrame &&
            (0 != this.openedFrame.visible
              ? (this.app.ui.playClickSound(),
                this.openedFrame.hide(),
                (this.openedFrame = void 0))
              : (this.openedFrame = void 0));
        }
        loadCharacters() {
          return Gr(this, void 0, void 0, function* () {
            const t = yield this.app.cacheHandler.loadCharactersFromCache();
            0 != t.length
              ? yield this.app.charactersHandler.importCharacters(t, !1)
              : yield this.app.charactersHandler.createNewCharacter(!1);
          });
        }
        removeCharacter(t) {
          return Gr(this, void 0, void 0, function* () {
            var e, i, n, s, r, o;
            null === (e = this.changeClassFrame) ||
              void 0 === e ||
              e.onRemoveCharacter(t),
              null === (i = this.changeCharacterStatsFrame) ||
                void 0 === i ||
                i.onRemoveCharacter(t),
              null === (n = this.targetFrame) ||
                void 0 === n ||
                n.onRemoveCharacter(t),
              null === (s = this.colorPickerFrame) ||
                void 0 === s ||
                s.onRemoveCharacter(t),
              null === (r = this.changeEquipmentFrame) ||
                void 0 === r ||
                r.onRemoveCharacter(t),
              null === (o = this.enchantEquipmentFrame) ||
                void 0 === o ||
                o.onRemoveCharacter(t),
              yield this.app.charactersHandler.removeCharacter(t);
          });
        }
        hideAllOtherDraggableFrames(t) {
          this.draggableFrames.forEach((e) => {
            e != t && e.hide();
          }),
            (this.openedFrame = t);
        }
        centerAllDraggableFrames() {
          const t = Math.floor(0.5 * window.innerWidth),
            e = Math.floor(0.5 * window.innerHeight);
          this.draggableFrames.forEach((i) => i.position.set(t, e));
        }
        setColorFromCharacterContainer(t, e) {
          var i;
          null === (i = this.colorPickerFrame) ||
            void 0 === i ||
            i.setColorFromCharacterContainer(t, e),
            this.app.charactersHandler.setCharacterPropertyValue(
              t,
              "lineColor",
              e,
              !1
            );
        }
        switchClassChangeContainer(t, e) {
          var i;
          this.hideAllOtherDraggableFrames(this.changeClassFrame),
            null === (i = this.changeClassFrame) ||
              void 0 === i ||
              i.switchData(t, e);
        }
        switchEquipmentChangeFrame(t, e) {
          var i;
          this.hideAllOtherDraggableFrames(this.changeEquipmentFrame),
            null === (i = this.changeEquipmentFrame) ||
              void 0 === i ||
              i.switchData(t, e);
        }
        switchColorPicker(t) {
          var e;
          this.hideAllOtherDraggableFrames(this.colorPickerFrame),
            null === (e = this.colorPickerFrame) ||
              void 0 === e ||
              e.switchData(t);
        }
        switchCharacterStatsEditor(t) {
          var e;
          this.hideAllOtherDraggableFrames(this.changeCharacterStatsFrame),
            null === (e = this.changeCharacterStatsFrame) ||
              void 0 === e ||
              e.switchData(t);
        }
        switchEnemyTargetEditor(t) {
          var e;
          this.hideAllOtherDraggableFrames(this.targetFrame),
            null === (e = this.targetFrame) || void 0 === e || e.switchData(t);
        }
        updateCharacterTargetData(t) {
          var e, i;
          null === (e = this.changeCharacterStatsFrame) ||
            void 0 === e ||
            e.updateData(t),
            null === (i = this.targetFrame) || void 0 === i || i.updateData(t);
        }
        updateCharacterStats(t) {
          var e;
          null === (e = this.changeCharacterStatsFrame) ||
            void 0 === e ||
            e.updateData(t);
        }
        updateTargetImmunity(t, e, i) {
          var n;
          null === (n = this.targetFrame) ||
            void 0 === n ||
            n.updateStatusEffectToggleSprite(t, e, i, !0);
        }
        updateCharacterStatusEffect(t, e, i, n) {
          var s, r;
          null === (s = this.changeCharacterStatsFrame) ||
            void 0 === s ||
            s.updateStatusEffectToggleSprite(t, e, i, n),
            null === (r = this.targetFrame) ||
              void 0 === r ||
              r.updateStatusEffectToggleSprite(t, e, i);
        }
        updateCharacterProperties(t, e, i) {
          var n;
          null === (n = this.changeCharacterStatsFrame) ||
            void 0 === n ||
            n.updatePropertyValue(t, e, i);
        }
        switchSettingsFrame() {
          var t;
          this.hideAllOtherDraggableFrames(this.settingsFrame),
            null === (t = this.settingsFrame) || void 0 === t || t.switch();
        }
        switchEnchantingFrame(t, e) {
          var i;
          this.hideAllOtherDraggableFrames(this.enchantEquipmentFrame),
            null === (i = this.enchantEquipmentFrame) ||
              void 0 === i ||
              i.switchData(t, e);
        }
        switchChangelogFrame() {
          var t;
          this.hideAllOtherDraggableFrames(this.changelogFrame),
            null === (t = this.changelogFrame) || void 0 === t || t.switch();
        }
        updateLastCheckedVersion() {
          const t = this.app.dataHandler.getLatestUpdate();
          this.app.cacheHandler.setLastCheckedVersion(t.id) ||
            this.changelogIcon.setIcon("changelog_icon");
        }
        onDiscordIconClick(t) {
          window.open("https://www.youtube.com/watch?v=dQw4w9WgXcQ", "_blank");
        }
        onChangelogIconClick(t) {
          this.app.ui.playClickSound(),
            this.updateLastCheckedVersion(),
            this.switchChangelogFrame();
        }
        onSettingsIconClick(t) {
          this.app.ui.playClickSound(), this.switchSettingsFrame();
        }
        changeTitleTextColor() {
          (this.titleColorHue += 2),
            this.titleTextColorMatrixFilter.hue(this.titleColorHue, !1);
        }
        getRandomTip() {
          switch (this.lastTipId++) {
            case 0:
              return "Tip: Hover this area again to read more tips.";
            case 1:
              return "Tip: All your actions are automatically saved.";
            case 2:
              return "Tip: You can export your characters in 'Settings'.";
            case 3:
              return "Tip: All windows can be closed with 'esc' key.";
            case 4:
              return "Tip: Shift-Click any stat input to share it.";
            case 5:
              return "Tip: You can change simulation time in 'Settings'.";
            case 6:
              return "Tip: Hover bottom of a chart to show summary data.";
            case 7:
              return "Tip: You can disable tooltips in 'Settings'.";
            case 8:
              return "Tip: You can press F11 to go fullscreen mode.";
            case 9:
              return "You have read all the tips!";
            default:
              return "Thank You for using the tool!";
          }
        }
        onTitleTextMouseEnter(t) {
          void 0 !== this.versionText &&
            ((this.versionText.text = this.getRandomTip()),
            (this.changeTitleColorIntervalId = window.setInterval(
              this.changeTitleTextColor.bind(this),
              20
            )));
        }
        onTitleTextMouseLeave(t) {
          void 0 !== this.changeTitleColorIntervalId &&
            (window.clearInterval(this.changeTitleColorIntervalId),
            void 0 !== this.versionText &&
              (this.versionText.text = this.updateVersionTextContent));
        }
        clear() {
          this.panelContainer.destroy();
        }
        updatePanelsPosition() {
          this.panelContainer.position.set(
            window.innerWidth - this.panelWidthPixels,
            0
          ),
            this.centerAllDraggableFrames();
        }
        updateBackgroundSize() {
          return Gr(this, void 0, void 0, function* () {
            var t, e;
            const i =
                null !==
                  (e =
                    null === (t = this.app.ui.theme) || void 0 === t
                      ? void 0
                      : t.mainPanel) && void 0 !== e
                  ? e
                  : "gray_main_panel_frame",
              n = {
                x: this.panelWidthPixels,
                y: Math.max(window.innerHeight, 320),
              },
              s = yield this.app.ui.frameTexture({ frameTexture: i, size: n });
            this.backgroundSprite.texture = s;
          });
        }
        onWindowResize(t) {
          return Gr(this, void 0, void 0, function* () {
            this.updatePanelsPosition(), this.updateBackgroundSize();
          });
        }
      }
      var jr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class $r extends Ge {
        constructor(t, e) {
          super(t, e),
            (this.eventMode = "none"),
            (this.interactiveChildren = !1),
            (this.barFrameSize = new Et.b(232, 24)),
            (this.statFrameSize = new Et.b(112, 36)),
            (this.hpBarSprite = new Xt.k()),
            (this.mpBarSprite = new Xt.k()),
            (this.classNameText = t.themedText({
              style: this.ui.outlineTextStyle,
            })),
            (this.yellowHitPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.blueHitPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.yellowMagicPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.blueMagicPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.yellowAttackPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.blueAttackPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.yellowDefensePointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.blueDefensePointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.yellowSpeedPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.blueSpeedPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.yellowDexterityPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.blueDexterityPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.yellowVitalityPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.blueVitalityPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.yellowWisdomPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.blueWisdomPointsText = t.text({
              style: this.ui.outlineTextStyle,
            })),
            (this.leftClickInformationText = t.text({
              text: "Left Click to Change Class",
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fill: ti.orange }
              ),
              anchor: Ve.CENTER_X,
            })),
            (this.rightClickInformationText = t.text({
              text: "Right Click to Edit Stats",
              style: Object.assign(
                Object.assign({}, this.ui.outlineTextStyle),
                { fill: ti.blue }
              ),
              anchor: Ve.CENTER_X,
            }));
        }
        appendData(t) {
          return jr(this, void 0, void 0, function* () {
            var e,
              i,
              n,
              s,
              r,
              o,
              a,
              l,
              u,
              h,
              c,
              d,
              p,
              f,
              m,
              g,
              v,
              y,
              x,
              b,
              S,
              C,
              _;
            (this.characterData = t),
              void 0 !== this.classNameText &&
                (this.classNameText.text = `${Di[t.classData.type]} Class`);
            const T =
              null !== (e = t.stats.getStat(Ee.MAXHP)) && void 0 !== e
                ? e
                : { type: Ee.MAXHP };
            this.updateStatText(
              T,
              this.yellowHitPointsText,
              this.blueHitPointsText,
              0.5 * this.barFrameSize.x,
              t.startingHpPercent
            );
            const w =
              null !== (i = t.stats.getStat(Ee.MAXMP)) && void 0 !== i
                ? i
                : { type: Ee.MAXMP };
            this.updateStatText(
              w,
              this.yellowMagicPointsText,
              this.blueMagicPointsText,
              0.5 * this.barFrameSize.x,
              t.startingMpPercent
            );
            const P =
              null !== (n = t.stats.getStat(Ee.ATT)) && void 0 !== n
                ? n
                : { type: Ee.ATT };
            this.updateStatText(
              P,
              this.yellowAttackPointsText,
              this.blueAttackPointsText,
              0.5 * this.statFrameSize.x
            );
            const A =
              null !== (s = t.stats.getStat(Ee.DEF)) && void 0 !== s
                ? s
                : { type: Ee.DEF };
            this.updateStatText(
              A,
              this.yellowDefensePointsText,
              this.blueDefensePointsText,
              0.5 * this.statFrameSize.x
            );
            const k =
              null !== (r = t.stats.getStat(Ee.SPD)) && void 0 !== r
                ? r
                : { type: Ee.SPD };
            this.updateStatText(
              k,
              this.yellowSpeedPointsText,
              this.blueSpeedPointsText,
              0.5 * this.statFrameSize.x
            );
            const M =
              null !== (o = t.stats.getStat(Ee.DEX)) && void 0 !== o
                ? o
                : { type: Ee.DEX };
            this.updateStatText(
              M,
              this.yellowDexterityPointsText,
              this.blueDexterityPointsText,
              0.5 * this.statFrameSize.x
            );
            const E =
              null !== (a = t.stats.getStat(Ee.VIT)) && void 0 !== a
                ? a
                : { type: Ee.VIT };
            this.updateStatText(
              E,
              this.yellowVitalityPointsText,
              this.blueVitalityPointsText,
              0.5 * this.statFrameSize.x
            );
            const I =
              null !== (l = t.stats.getStat(Ee.WIS)) && void 0 !== l
                ? l
                : { type: Ee.WIS };
            this.updateStatText(
              I,
              this.yellowWisdomPointsText,
              this.blueWisdomPointsText,
              0.5 * this.statFrameSize.x
            );
            const D = Math.max(232 * t.startingHpPercent, 1),
              R = yield this.ui.frameTexture({
                frameTexture: "bar_frame",
                size: new Et.b(D, 24),
              });
            (this.hpBarSprite.texture = R),
              (this.hpBarSprite.visible = t.startingHpPercent > 0);
            const B = Math.max(232 * t.startingMpPercent, 1),
              F = yield this.ui.frameTexture({
                frameTexture: "bar_frame",
                size: new Et.b(B, 24),
              });
            (this.mpBarSprite.texture = F),
              (this.mpBarSprite.visible = t.startingMpPercent > 0);
            const O = t.stats.getStatValue(Ee.XPBONUS);
            null === (u = this.xpBonusValueFrame) ||
              void 0 === u ||
              u.setContentText(`${O}%`);
            const z = t.stats.getStatValue(Ee.MPMULTIPLIER);
            null === (h = this.mpCostValueFrame) ||
              void 0 === h ||
              h.setContentText(Ve.percent(z, 1));
            const L =
                null !== (c = t.playerPermaStatusEffects.get(Ie.PetStasis)) &&
                void 0 !== c &&
                c,
              H =
                null !== (d = t.playerPermaStatusEffects.get(Ie.InCombat)) &&
                void 0 !== d &&
                d,
              [U, N] = this.ui.app.dataHandler.getPetHeal(t.petHealLevel, H),
              G = (0 == N ? 0 : U / N) * +!L,
              V =
                null !== (p = t.playerPermaStatusEffects.get(Ie.Sick)) &&
                void 0 !== p &&
                p,
              j =
                null !== (f = t.playerPermaStatusEffects.get(Ie.Bleeding)) &&
                void 0 !== f &&
                f,
              $ =
                null !== (m = t.playerPermaStatusEffects.get(Ie.Healing)) &&
                void 0 !== m &&
                m,
              q =
                (1 +
                  G +
                  0.24 *
                    (null !==
                      (v =
                        null === (g = t.stats.getStat(Ee.VIT)) || void 0 === g
                          ? void 0
                          : g.totalValue) && void 0 !== v
                      ? v
                      : 0) *
                    +!j *
                    (H ? 0.5 : 1) +
                  20 * +$) *
                  +!V +
                -20 * +j;
            null === (y = this.hpRecoveryValueFrame) ||
              void 0 === y ||
              y.setContentText(`${q.toFixed(1)} HP/s`);
            const [W, X] = this.ui.app.dataHandler.getPetMagicHeal(
                t.petMagicHealLevel,
                H
              ),
              Y = (0 == X ? 0 : W / X) * +!L,
              K =
                null !== (x = t.playerPermaStatusEffects.get(Ie.Quiet)) &&
                void 0 !== x &&
                x,
              Z =
                null !== (b = t.playerPermaStatusEffects.get(Ie.Energized)) &&
                void 0 !== b &&
                b,
              Q =
                (0.5 +
                  Y +
                  0.12 *
                    (null !==
                      (C =
                        null === (S = t.stats.getStat(Ee.WIS)) || void 0 === S
                          ? void 0
                          : S.totalValue) && void 0 !== C
                      ? C
                      : 0) *
                    (H ? 0.5 : 1) +
                  10 * +Z) *
                +!K;
            null === (_ = this.mpRecoveryValueFrame) ||
              void 0 === _ ||
              _.setContentText(`${Q.toFixed(1)} MP/s`);
            const J =
              this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllEnabled;
            (this.leftClickInformationText.visible = J),
              (this.rightClickInformationText.visible = J),
              this.updateBounds();
          });
        }
        updateStatText(t, e, i, n, s) {
          const r = t.type == Ee.MAXHP || t.type == Ee.MAXMP,
            o = Math.ceil(t.totalValue * (null != s ? s : 1));
          (e.text = `${o}${r ? `/${t.totalValue}` : ""}${
            0 != t.totalEquipmentValue
              ? ` (${Ve.signed(t.totalEquipmentValue)})`
              : ""
          }`),
            (e.position.x = Math.floor(n)),
            (i.visible = 0 != t.exaltationValue),
            1 == i.visible &&
              ((i.text = `(${Ve.signed(t.exaltationValue)})`),
              (e.position.x -= Math.floor(0.5 * i.width) + 2),
              (i.position.x = Math.floor(n + 0.5 * e.width) + 2));
        }
        create() {
          return jr(this, void 0, void 0, function* () {
            let t = 16;
            this.classNameText.anchor.set(0.5, 0),
              this.classNameText.position.set(0.5 * this.options.size.x, t),
              yield this.addElement(this.classNameText),
              (t += this.classNameText.height + 8);
            const e = yield this.ui.frameTexture({
              frameTexture: "bar_frame",
              size: new Et.b(232, 24),
            });
            (this.hpBarSprite = new Xt.k(e)),
              (this.hpBarSprite.tint = ti.maxHp);
            const i = yield this.createBaseStatInfoWithBar(
              this.yellowHitPointsText,
              this.blueHitPointsText,
              "HP",
              this.hpBarSprite,
              "bar_frame"
            );
            i.position.set(16, t), this.addElement(i), (t += i.height + 4);
            const n = yield this.ui.frameTexture({
              frameTexture: "bar_frame",
              size: new Et.b(232, 24),
            });
            (this.mpBarSprite = new Xt.k(n)),
              (this.mpBarSprite.tint = ti.maxMp);
            const s = yield this.createBaseStatInfoWithBar(
              this.yellowMagicPointsText,
              this.blueMagicPointsText,
              "MP",
              this.mpBarSprite,
              "bar_frame"
            );
            s.position.set(16, t), this.addElement(s), (t += s.height + 12);
            const r = yield this.createBaseStatInfo(
              this.yellowAttackPointsText,
              this.blueAttackPointsText,
              Ee.ATT
            );
            r.position.set(16, t), this.addElement(r);
            const o = yield this.createBaseStatInfo(
              this.yellowDefensePointsText,
              this.blueDefensePointsText,
              Ee.DEF
            );
            o.position.set(24 + this.statFrameSize.x, t),
              this.addElement(o),
              (t += this.statFrameSize.y + 10);
            const a = yield this.createBaseStatInfo(
              this.yellowSpeedPointsText,
              this.blueSpeedPointsText,
              Ee.SPD
            );
            a.position.set(16, t), this.addElement(a);
            const l = yield this.createBaseStatInfo(
              this.yellowDexterityPointsText,
              this.blueDexterityPointsText,
              Ee.DEX
            );
            l.position.set(24 + this.statFrameSize.x, t),
              this.addElement(l),
              (t += this.statFrameSize.y + 10);
            const u = yield this.createBaseStatInfo(
              this.yellowVitalityPointsText,
              this.blueVitalityPointsText,
              Ee.VIT
            );
            u.position.set(16, t), this.addElement(u);
            const h = yield this.createBaseStatInfo(
              this.yellowWisdomPointsText,
              this.blueWisdomPointsText,
              Ee.WIS
            );
            h.position.set(24 + this.statFrameSize.x, t),
              this.addElement(h),
              (t += this.statFrameSize.y + 10),
              (this.hpRecoveryValueFrame = yield this.ui.thickLabeledFrame({
                size: this.statFrameSize,
                labelText: "HP Regen",
                contentColor: ti.maxHp,
              })),
              this.hpRecoveryValueFrame.position.set(16, t),
              this.addElement(this.hpRecoveryValueFrame),
              (this.mpRecoveryValueFrame = yield this.ui.thickLabeledFrame({
                size: this.statFrameSize,
                labelText: "MP Regen",
                contentColor: ti.maxMp,
              })),
              this.mpRecoveryValueFrame.position.set(
                24 + this.statFrameSize.x,
                t
              ),
              this.addElement(this.mpRecoveryValueFrame),
              (t += this.statFrameSize.y + 10),
              (this.xpBonusValueFrame = yield this.ui.thickLabeledFrame({
                size: this.statFrameSize,
                labelText: "XP Bonus",
              })),
              this.xpBonusValueFrame.position.set(16, t),
              this.addElement(this.xpBonusValueFrame),
              (this.mpCostValueFrame = yield this.ui.thickLabeledFrame({
                size: this.statFrameSize,
                labelText: "MP Cost",
              })),
              this.mpCostValueFrame.position.set(24 + this.statFrameSize.x, t),
              this.addElement(this.mpCostValueFrame),
              (t += this.statFrameSize.y + 4),
              this.leftClickInformationText.position.set(
                0.5 * this.options.size.x,
                t
              ),
              this.addElement(this.leftClickInformationText),
              (t += this.leftClickInformationText.height),
              this.rightClickInformationText.position.set(
                0.5 * this.options.size.x,
                t
              ),
              this.addElement(this.rightClickInformationText),
              this.updateBackground();
          });
        }
        createBaseStatInfoWithBar(t, e, i, n, s) {
          return jr(this, void 0, void 0, function* () {
            const r = new Gt.mc(),
              o = yield this.ui.frameTexture({
                frameTexture: s,
                size: this.barFrameSize,
              }),
              a = new Xt.k(o);
            (a.tint = ti.darkgray), r.addChild(a), r.addChild(n);
            const l = Math.floor(0.2 * this.barFrameSize.y),
              u = yield this.ui.text({
                text: i,
                style: Object.assign({}, this.ui.outlineTextStyle),
              });
            return (
              u.anchor.set(0.5, 0),
              u.position.set(16, l - 1),
              r.addChild(u),
              (t.style.fill = ti.yellow),
              t.anchor.set(0.5, 0),
              t.position.set(0, l - 1),
              r.addChild(t),
              (e.style.fill = 38655),
              e.anchor.set(0.5, 0),
              e.position.set(0, l - 1),
              r.addChild(e),
              Promise.resolve(r)
            );
          });
        }
        createBaseStatInfo(t, e, i) {
          return jr(this, void 0, void 0, function* () {
            const n = yield this.ui.thickLabeledFrame({
                labelText: Ee[i].toUpperCase(),
                labelPaddingX: 16,
                size: this.statFrameSize,
              }),
              s = Math.floor(0.5 * this.statFrameSize.y) - 7;
            return (
              (t.style.fill = ti.yellow),
              t.anchor.set(0.5, 0),
              (t.position.y = s),
              n.addChild(t),
              (e.style.fill = 38655),
              e.anchor.set(0.5, 0),
              (e.position.y = s),
              n.addChild(e),
              n.updateBackground(),
              Promise.resolve(n)
            );
          });
        }
      }
      var qr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Wr extends Ge {
        constructor(t, e) {
          super(t, e),
            (this.eventMode = "none"),
            (this.interactiveChildren = !1),
            (this.equipmentSprite = new js(t)),
            (this.equipmentNameText = this.ui.themedText({})),
            (this.collectionIconSprite = new Xt.k()),
            (this.equipmentTierText = this.ui.text({
              style: { fontSize: 28 },
            })),
            (this.eligibleClassText = this.ui.text({
              style: {
                fill: ti.gray,
                wordWrap: !0,
                wordWrapWidth: this.options.size.x - 32,
              },
            })),
            (this.detailsContainer = new Gt.mc()),
            (this.detailsContainerBackground = new Xt.k(a.g.WHITE)),
            (this.damageLabelText = this.ui.themedText({ text: "Damage" })),
            (this.damageValuesText = this.ui.text({
              style: { fill: ti.lightyellow, fontSize: 40 },
            })),
            (this.damageExaltationBonusText = this.ui.text({
              style: { fill: ti.blue, fontSize: 20 },
            })),
            (this.damageEnchantBonusText = this.ui.text({
              style: { fill: ti.lightyellow, fontSize: 20 },
            })),
            (this.soulboundLabelText = this.ui.themedText({
              text: "Soulbound",
            })),
            (this.descriptionText = this.ui.text({
              style: {
                fill: ti.gray,
                wordWrap: !0,
                wordWrapWidth: this.options.size.x - 32,
              },
            })),
            (this.descriptionSeparatorText = this.ui.text({
              text: "───────────────────",
              style: { fontSize: 24 },
            })),
            (this.tooltipInfoContainer = new Gt.mc()),
            (this.activateOnUseContainer = new Gt.mc()),
            (this.attacksContainer = new Gt.mc()),
            (this.onEquipLabelText = this.ui.themedText({ text: "On Equip:" })),
            (this.onEquipStatsContainer = new Gt.mc()),
            (this.manaCostLabelText = this.ui.themedText({
              text: "MP Cost: ",
            })),
            (this.manaCostValueText = this.ui.text({
              style: { fill: ti.lightyellow },
            })),
            (this.cooldownLabelText = this.ui.themedText({
              text: "Cooldown: ",
            })),
            (this.cooldownValueText = this.ui.text({
              style: { fill: ti.lightyellow },
            })),
            (this.xpBonusLabelText = this.ui.themedText({
              text: "XP Bonus: ",
            })),
            (this.xpBonusValueText = this.ui.text({
              style: { fill: ti.lightyellow },
            })),
            (this.enchantSeparatorText = this.ui.text({
              text: "───────────────────",
              style: { fontSize: 24 },
            })),
            (this.enchantLabelText = this.ui.themedText({
              text: "Enchantments",
              style: { fontSize: 28 },
            })),
            (this.enchantContainer = new Gt.mc()),
            (this.setPieceSeparatorText = this.ui.text({
              text: "───────────────────",
              style: { fontSize: 24, fill: ti.orange },
            })),
            (this.setPieceNameText = this.ui.text({
              style: { fill: ti.orange },
            })),
            (this.setPieceBonusTwoLabelText = this.ui.text({
              text: "2 Pieces",
              style: { fill: ti.orange },
            })),
            (this.setPieceBonusThreeLabelText = this.ui.text({
              text: "3 Pieces",
              style: { fill: ti.orange },
            })),
            (this.setPieceBonusAllLabelText = this.ui.text({
              text: "All Pieces",
              style: { fill: ti.orange },
            })),
            (this.setPieceBonusLabelTexts = new Array(
              this.setPieceBonusTwoLabelText,
              this.setPieceBonusThreeLabelText,
              this.setPieceBonusAllLabelText
            )),
            (this.setPieceOnEquipTwoContainer = new Gt.mc()),
            (this.setPieceOnEquipThreeContainer = new Gt.mc()),
            (this.setPieceOnEquipAllContainer = new Gt.mc()),
            (this.setPieceOnEquipContainers = new Array(
              this.setPieceOnEquipTwoContainer,
              this.setPieceOnEquipThreeContainer,
              this.setPieceOnEquipAllContainer
            )),
            (this.feedPowerText = this.ui.themedText({})),
            (this.bottomPaddingSprite = new Xt.k()),
            (this.bagTypeSprite = new Xt.k()),
            (this.leftClickInformationText = this.ui.text({
              style: { fill: ti.orange },
            })),
            (this.shiftLeftClickInformationText = this.ui.text({
              text: "Shift-Click to Equip S-Tier Item",
              style: { fill: ti.yellow },
            })),
            (this.rightClickInformationText = this.ui.text({
              style: { fill: ti.lightgreen },
            })),
            this.create();
        }
        setName(t, e) {
          const i = e ? `${e} ${t}` : t,
            n = i.length > 16 ? 28 - Math.floor(0.6 * (i.length - 16)) : 28;
          (this.equipmentNameText.text = i),
            (this.equipmentNameText.position.y =
              38 - Math.floor(0.5 * this.equipmentNameText.height)),
            (this.equipmentNameText.style.fontSize = n);
          const [s, r] = Ve.getBoundsReminder(this.equipmentNameText);
          this.equipmentNameText.pivot.set(s, r);
        }
        setTier(t, e) {
          var i, n, s, r, o, a, l, u;
          switch (t) {
            case Oe.Untiered:
              this.options.frameTexture =
                null !==
                  (n =
                    null === (i = this.ui.theme) || void 0 === i
                      ? void 0
                      : i.tooltip.ut) && void 0 !== n
                  ? n
                  : "gray_ut_tooltip_frame";
              break;
            case Oe.Set:
              this.options.frameTexture =
                null !==
                  (r =
                    null === (s = this.ui.theme) || void 0 === s
                      ? void 0
                      : s.tooltip.st) && void 0 !== r
                  ? r
                  : "gray_st_tooltip_frame";
              break;
            default:
              this.options.frameTexture =
                null !==
                  (a =
                    null === (o = this.ui.theme) || void 0 === o
                      ? void 0
                      : o.tooltip.default) && void 0 !== a
                  ? a
                  : "gray_tooltip_frame";
          }
          const [h, c] = Ve.itemTier(t);
          this.equipmentTierText.style.fill =
            t < 100
              ? null !==
                  (u =
                    null === (l = this.ui.theme) || void 0 === l
                      ? void 0
                      : l.windowTextColor) && void 0 !== u
                ? u
                : ti.white
              : c;
          const d = this.options.size.x - (e ? 25 : 32),
            p = e ? 42 : 28;
          this.equipmentTierText.position.set(d, p),
            (this.equipmentTierText.text = h);
        }
        setCollectionIcon(t) {
          return qr(this, void 0, void 0, function* () {
            if (
              ((this.collectionIconSprite.visible = t !== Oi.None),
              0 == this.collectionIconSprite.visible)
            )
              return;
            const e = yield this.ui.getTexture("ui/icons/collection_icon"),
              i = { x: 16 * t, y: 0, width: 16, height: 16 };
            this.collectionIconSprite.texture = new a.g({
              source: e.source,
              frame: i,
            });
          });
        }
        appendData(t, e, i, n) {
          return qr(this, void 0, void 0, function* () {
            var s, r, o, l, u, h, c, d, p, f, m, g;
            const v =
              null !==
                (r =
                  null === (s = this.ui.theme) || void 0 === s
                    ? void 0
                    : s.windowTextColor) && void 0 !== r
                ? r
                : ti.white;
            this.detailsContainerBackground.tint =
              null !==
                (l =
                  null === (o = this.ui.theme) || void 0 === o
                    ? void 0
                    : o.tooltip.detailsBackgroundColor) && void 0 !== l
                ? l
                : 2960685;
            const y = this.ui.app.dataHandler;
            let x = 64;
            yield this.equipmentSprite.createEquipment(t.id, t.slotType, !0),
              this.setName(
                t.name,
                null === (u = e[0]) || void 0 === u ? void 0 : u.prefix
              ),
              this.setTier(t.tier, t.collectionType !== Oi.None),
              this.setCollectionIcon(t.collectionType);
            const b = y.eliglibleClassNamesPerSlotType.get(t.slotType),
              S = void 0 !== b;
            (this.eligibleClassText.visible = S),
              1 == S &&
                ((this.eligibleClassText.text =
                  null !== (h = null == b ? void 0 : b.join(", ")) &&
                  void 0 !== h
                    ? h
                    : ""),
                (x += Ve.setYPosition(this.eligibleClassText, x + 4))),
              (this.detailsContainerBackground.position.y = x + 8),
              (this.detailsContainer.position.y = x + 8);
            let C = 8,
              [_, T, w] = Ve.weaponDamageRange(t.projectiles, e);
            const P = t.projectiles && t.projectiles.size > 0 && 0 != T,
              A = Ve.slotMetaType(t.slotType),
              k =
                null !== (c = null == i ? void 0 : i.damageExaltationLevel) &&
                void 0 !== c
                  ? c
                  : 0;
            if (
              ((this.damageLabelText.visible = P),
              (this.damageValuesText.visible = P),
              (this.damageExaltationBonusText.visible =
                P && A == Re.Weapon && 0 != k),
              (this.damageEnchantBonusText.visible =
                P && A == Re.Weapon && 0 != w),
              1 == P)
            ) {
              A == Re.Weapon &&
                ((_ += Math.floor(_ * k * 0.025)),
                (T += Math.floor(T * k * 0.025))),
                (C += Ve.setYPosition(this.damageLabelText, C)),
                (this.damageValuesText.text =
                  _ === T ? _.toString() : `${_} - ${T}`),
                (this.damageExaltationBonusText.text = `(+${Number(
                  (2.5 * k).toFixed(1)
                )}% Exaltation)`);
              const t = w > 0 ? "+" : "";
              (this.damageEnchantBonusText.text = `(${t}${Number(
                (100 * w).toFixed(1)
              )}% Enchantment)`),
                this.damageExaltationBonusText.position.set(
                  this.damageValuesText.width + 8,
                  C +
                    (this.damageEnchantBonusText.visible
                      ? this.damageExaltationBonusText.visible
                        ? -4
                        : -10
                      : 5)
                ),
                this.damageEnchantBonusText.position.set(
                  this.damageValuesText.width + 8,
                  this.damageExaltationBonusText.position.y + 16
                ),
                (C += Ve.setYPosition(this.damageValuesText, C));
            }
            (this.soulboundLabelText.visible = t.soulbound),
              1 == t.soulbound &&
                (C += Ve.setYPosition(this.soulboundLabelText, C));
            const M = 0 != t.description.length;
            (this.descriptionText.visible = M),
              (this.descriptionSeparatorText.visible = M),
              1 == M &&
                ((this.descriptionText.text = t.description),
                (C += Ve.setYPosition(this.descriptionText, C)),
                (this.descriptionSeparatorText.style.fill = Ve.separatorColor(
                  t.tier
                )),
                (C += Ve.setYPosition(this.descriptionSeparatorText, C)));
            const E = t.abilities.length,
              I = void 0 !== t.abilities && E > 0,
              D = 1 == I && 0 != t.abilities[0].tooltipData.length,
              R = 0 != t.tooltipData.length || D,
              B = Ve.clamp(
                Number(
                  null !== (d = null == i ? void 0 : i.abilityMode) &&
                    void 0 !== d
                    ? d
                    : 0
                ),
                0,
                E - 1
              );
            if (((this.tooltipInfoContainer.visible = R), 1 == R)) {
              const e = (t) => {
                const e = t.name,
                  s = this.textPoll(this.tooltipInfoContainer, n++, e, v);
                Ve.setYPosition(s, i);
                const r = this.textPoll(
                  this.tooltipInfoContainer,
                  n++,
                  t.description.trimStart(),
                  ti.lightyellow
                );
                0 != e.length &&
                  (s.width + r.width <= this.options.size.x - 32
                    ? (r.position.x = s.width + 4)
                    : (i += s.height)),
                  (i += Ve.setYPosition(r, i));
              };
              let i = 0,
                n = 0;
              this.tooltipInfoContainer.children.forEach(
                (t) => (t.visible = !1)
              );
              for (let i = 0; i < t.tooltipData.length; i++)
                e(t.tooltipData[i]);
              if (1 == D) {
                if (E > 1) {
                  const t = `This ability has ${E} modes (${Ve.numeral(
                      B + 1
                    )} is selected)`,
                    e = this.textPoll(
                      this.tooltipInfoContainer,
                      n++,
                      t,
                      ti.lightgreen
                    );
                  i += Ve.setYPosition(e, i);
                }
                const s = t.abilities[B].tooltipData;
                for (let t = 0; t < s.length; t++) e(s[t]);
              }
              C += Ve.setYPosition(this.tooltipInfoContainer, C);
            }
            if (((this.activateOnUseContainer.visible = I), 1 == I)) {
              const e = Ve.clamp(
                  null !== (p = null == i ? void 0 : i.abilityMode) &&
                    void 0 !== p
                    ? p
                    : 0,
                  0,
                  t.abilities.length - 1
                ),
                n = t.abilities[e];
              yield this.createAbility(
                this.activateOnUseContainer,
                n,
                null == i ? void 0 : i.stats
              ),
                (C += Ve.setYPosition(this.activateOnUseContainer, C));
            }
            const F = void 0 !== t.attacks && 0 != t.attacks.length;
            if (((this.attacksContainer.visible = F), 1 == F)) {
              this.attacksContainer.children.forEach((t) => (t.visible = !1));
              let i = 0;
              if (t.uniqueAttacks.length > 1) {
                let n = 1,
                  s = 0;
                for (let r = 0; r < t.uniqueAttacks.length; r++) {
                  let o = t.uniqueAttacks[r].attack;
                  if (0 == o.projectile.maxDamage) continue;
                  const a = Ve.numeral(n),
                    l = Ve.numeral(n + t.uniqueAttacks[r].bulletCount - 1);
                  let u =
                    1 == t.uniqueAttacks[r].bulletCount
                      ? `${a} Bullet`
                      : `${n}-${l} Bullet`;
                  n += t.uniqueAttacks[r].bulletCount;
                  let h = o.projectile.minDamage,
                    c = o.projectile.maxDamage;
                  A == Re.Weapon &&
                    ((h += Math.floor(h * k * 0.025)),
                    (h = Math.ceil(h * (1 + 0.01 * w))),
                    (c += Math.floor(c * k * 0.025)),
                    (c = Math.ceil(c * (1 + 0.01 * w))));
                  u += ` (${h == c ? h.toString() : `${h} - ${c}`}):`;
                  const d = this.textPoll(
                    this.attacksContainer,
                    i++,
                    u,
                    ti.lightyellow
                  );
                  s += Ve.setYPosition(d, s);
                  const p = t.uniqueAttacks[r].attack.projectileCount,
                    [f, m] = yield this.createAttackStats(
                      this.attacksContainer,
                      i,
                      o,
                      p,
                      e,
                      16,
                      s
                    );
                  (i = f), (s = m);
                }
              } else {
                const i = Math.max(
                  t.uniqueAttacks[0].bulletCount,
                  t.uniqueAttacks[0].attack.projectileCount
                );
                yield this.createAttackStats(
                  this.attacksContainer,
                  0,
                  t.attacks[0],
                  i,
                  e,
                  0,
                  0
                );
              }
              C += Ve.setYPosition(this.attacksContainer, C);
            }
            const O = new Array();
            for (const e of t.statsOnEquip)
              O.push({
                type: e.type,
                value: e.value,
                bonus: 0,
                relativeTo: e.relativeTo,
              });
            for (const t of e)
              if (void 0 !== t.statsOnEquip)
                for (const e of t.statsOnEquip) {
                  const t = e.type;
                  let n = e.value;
                  if (e.relativeTo != Ee.None) {
                    const e = null == i ? void 0 : i.stats.getStat(t);
                    if (void 0 === e) continue;
                    n = Math.ceil(e.preRelativeValue * n * 0.01);
                  }
                  let s = !1;
                  for (let e = 0; e < O.length; e++)
                    O[e].type == t &&
                      ((O[e].value += n), (O[e].bonus += n), (s = !0));
                  s ||
                    O.push({
                      type: t,
                      value: n,
                      bonus: n,
                      relativeTo: Ee.None,
                    });
                }
            const z = O.length > 0;
            if (
              ((this.onEquipLabelText.visible = z),
              (this.onEquipStatsContainer.visible = z),
              1 == z)
            ) {
              C += Ve.setYPosition(this.onEquipLabelText, C);
              const e = Ve.slotMetaType(t.slotType);
              yield this.createBaseStats(
                this.onEquipStatsContainer,
                e,
                O,
                null == i ? void 0 : i.stats,
                n
              ),
                (C += Ve.setYPosition(this.onEquipStatsContainer, C));
            }
            const L = t.abilities.length > 0 && 0 != t.abilities[B].mpCost;
            if (
              ((this.manaCostLabelText.visible = L),
              (this.manaCostValueText.visible = L),
              1 == L)
            ) {
              const e = t.abilities[B].mpCost,
                n =
                  null !==
                    (m =
                      null === (f = null == i ? void 0 : i.stats) ||
                      void 0 === f
                        ? void 0
                        : f.getStatValue(Ee.MPMULTIPLIER)) && void 0 !== m
                    ? m
                    : 1,
                s = Math.floor(e * n),
                r = s - e;
              (this.manaCostValueText.text = `${s.toString()}${
                0 != r ? ` (${r})` : ""
              }`),
                Ve.setYPosition(this.manaCostLabelText, C),
                (C += Ve.setYPosition(this.manaCostValueText, C));
            }
            const H = 1 == t.abilities.length && 0 != t.abilities[0].cooldownMs;
            if (
              ((this.cooldownLabelText.visible = H),
              (this.cooldownValueText.visible = H),
              1 == H)
            ) {
              const e = t.abilities[0].cooldownMs;
              (this.cooldownValueText.text = Ve.time(0.001 * e)),
                Ve.setYPosition(this.cooldownLabelText, C),
                (C += Ve.setYPosition(this.cooldownValueText, C));
            }
            const U = 0 != t.xpBonus;
            (this.xpBonusLabelText.visible = U),
              (this.xpBonusValueText.visible = U),
              1 == U &&
                ((this.xpBonusValueText.text = `${t.xpBonus.toString()}%`),
                Ve.setYPosition(this.xpBonusLabelText, C),
                (C += Ve.setYPosition(this.xpBonusValueText, C)));
            const N = t.enchantSlots > 0;
            if (
              ((this.enchantSeparatorText.visible = N),
              (this.enchantLabelText.visible = N),
              (this.enchantContainer.visible = N),
              1 == N)
            ) {
              (this.enchantSeparatorText.style.fill = Ve.separatorColor(
                t.tier
              )),
                (C += Ve.setYPosition(this.enchantSeparatorText, C)),
                (C += Ve.setYPosition(this.enchantLabelText, C) + 2),
                this.enchantContainer.children.forEach((t) => {
                  t.visible = !1;
                });
              for (let t = 0; t < this.enchantContainer.children.length; t++)
                this.enchantContainer.children[t].visible = !1;
              for (
                let i = 0, n = 0;
                i < t.enchantSlots && n < 12;
                i++, n += 3
              ) {
                const t = e[i],
                  s = this.enchantContainer.getChildAt(n);
                (s.visible = !0),
                  (s.style.fill = v),
                  s.position.set(0, C),
                  (s.text = `Slot ${i + 1}:`),
                  this.enchantContainer.addChild(s);
                const r = (null == t ? void 0 : t.id) > 0,
                  [o, a] =
                    1 == r ? [t.name, ti.lightgreen] : ["empty", ti.gray],
                  l = this.enchantContainer.getChildAt(n + 1);
                if (
                  ((l.visible = !0),
                  (l.text = o),
                  (l.style.fill = a),
                  l.position.set(s.width + 6, C),
                  this.enchantContainer.addChild(l),
                  (C += l.height),
                  1 == r)
                ) {
                  const e = this.enchantContainer.getChildAt(n + 2);
                  (e.visible = !0),
                    (e.text = t.description),
                    (e.style.fill = ti.lightyellow),
                    e.position.set(0, C),
                    (e.style.wordWrap = !0),
                    (e.style.wordWrapWidth = this.options.size.x - 32),
                    this.enchantContainer.addChild(l),
                    (C += e.height);
                }
              }
            }
            const G = void 0 !== t.setId && 0 != t.setId;
            if (
              ((this.setPieceSeparatorText.visible = G),
              (this.setPieceNameText.visible = G),
              (this.setPieceBonusTwoLabelText.visible = !1),
              (this.setPieceOnEquipTwoContainer.visible = !1),
              (this.setPieceBonusThreeLabelText.visible = !1),
              (this.setPieceOnEquipThreeContainer.visible = !1),
              (this.setPieceBonusAllLabelText.visible = !1),
              (this.setPieceOnEquipAllContainer.visible = !1),
              1 == G)
            ) {
              C += Ve.setYPosition(this.setPieceSeparatorText, C);
              let e = y.equipmentSetsData.get(t.setId);
              (this.setPieceNameText.text = e.name),
                (C += Ve.setYPosition(this.setPieceNameText, C));
              const s = 110,
                r =
                  null === (g = null == i ? void 0 : i.equipmentSets) ||
                  void 0 === g
                    ? void 0
                    : g.get(t.setId),
                o = void 0 !== r ? r[1] : 0;
              for (let t = 0; t < 3; t++) {
                let r = e.statsOnEquip.get(t + 2);
                if (void 0 === r) break;
                const a = o >= 2 + t ? 1 : 0.5;
                (this.setPieceBonusLabelTexts[t].visible = !0),
                  this.setPieceBonusLabelTexts[t].position.set(s * t, C),
                  (this.setPieceBonusLabelTexts[t].alpha = a),
                  this.createBaseStats(
                    this.setPieceOnEquipContainers[t],
                    Re.None,
                    r,
                    null == i ? void 0 : i.stats,
                    n
                  ),
                  (this.setPieceOnEquipContainers[t].visible = !0),
                  this.setPieceOnEquipContainers[t].position.set(
                    s * t,
                    C + this.setPieceBonusLabelTexts[t].height
                  ),
                  (this.setPieceOnEquipContainers[t].alpha = a);
              }
            }
            (this.detailsContainerBackground.width = this.options.size.x - 10),
              (this.detailsContainerBackground.height =
                this.detailsContainer.height > 0
                  ? this.detailsContainer.height + 16
                  : 0),
              (x += this.detailsContainer.height + 34);
            const V = 0 != t.feedPower;
            (this.feedPowerText.visible = V),
              1 == V &&
                ((this.feedPowerText.text = `Feed Power: ${t.feedPower}`),
                (x += Ve.setYPosition(this.feedPowerText, x))),
              (this.bottomPaddingSprite.visible = 0 == n && 0 == V),
              (this.bottomPaddingSprite.position.y = x);
            const j =
              this.ui.app.settingsHandler.showGuidanceTooltips ==
                ei.AllEnabled && 1 == n;
            (this.leftClickInformationText.visible = j),
              (this.shiftLeftClickInformationText.visible = j);
            const $ = t.enchantSlots > 0 || t.abilities.length > 1;
            if (
              ((this.rightClickInformationText.visible = j && $),
              1 == j &&
                ((this.leftClickInformationText.text = `Left Click to Change ${
                  De[t.slotType || 0]
                } Item`),
                (x += Ve.setYPosition(this.leftClickInformationText, x)),
                (x += Ve.setYPosition(this.shiftLeftClickInformationText, x))),
              1 == $ &&
                ((this.rightClickInformationText.text =
                  "Right Click to " +
                  (t.enchantSlots > 0
                    ? "Enchant Item"
                    : "Change Ability Mode")),
                (x += Ve.setYPosition(this.rightClickInformationText, x))),
              (this.bagTypeSprite.visible = !1),
              this.updateBounds(),
              0 == n && t.bagType > Bi.None)
            ) {
              (this.bagTypeSprite.visible = !0),
                this.bagTypeSprite.position.set(
                  this.options.size.x - 38,
                  this.options.size.y - 22
                );
              const e = (yield this.ui.getTexture("ui/icons/bags")).source,
                i = { x: 8 * t.bagType, y: 0, width: 8, height: 8 };
              this.bagTypeSprite.texture = new a.g({ source: e, frame: i });
            }
            this.show();
          });
        }
        create() {
          return qr(this, void 0, void 0, function* () {
            const t = new Gt.mc();
            (t.position.x = 16),
              this.addElement(t),
              yield this.equipmentSprite.createEquipment(0, 0),
              this.equipmentSprite.anchor.set(0.5, 0.5),
              this.equipmentSprite.position.set(20, 36),
              t.addChild(this.equipmentSprite),
              this.equipmentNameText.position.set(56, 38),
              t.addChild(this.equipmentNameText),
              this.collectionIconSprite.anchor.set(0.5),
              this.collectionIconSprite.scale.set(2),
              this.collectionIconSprite.position.set(
                this.options.size.x - 40,
                24
              ),
              t.addChild(this.collectionIconSprite),
              this.equipmentTierText.anchor.set(1, 0),
              t.addChild(this.equipmentTierText),
              t.addChild(this.eligibleClassText),
              (this.detailsContainerBackground.position.x = -10),
              t.addChild(this.detailsContainerBackground),
              t.addChild(this.detailsContainer),
              this.detailsContainer.addChild(this.damageLabelText),
              this.detailsContainer.addChild(this.damageValuesText),
              this.detailsContainer.addChild(this.damageExaltationBonusText),
              this.detailsContainer.addChild(this.damageEnchantBonusText),
              this.detailsContainer.addChild(this.soulboundLabelText),
              this.detailsContainer.addChild(this.descriptionText),
              this.detailsContainer.addChild(this.descriptionSeparatorText),
              this.detailsContainer.addChild(this.tooltipInfoContainer);
            for (let t = 0; t < 24; t++)
              this.tooltipInfoContainer.addChild(
                this.ui.text({
                  style: {
                    wordWrap: !0,
                    wordWrapWidth: this.options.size.x - 32,
                  },
                })
              );
            this.detailsContainer.addChild(this.activateOnUseContainer);
            for (let t = 0; t < 8; t++)
              this.activateOnUseContainer.addChild(
                this.ui.text({
                  style: {
                    wordWrap: !0,
                    wordWrapWidth: this.options.size.x - 32,
                  },
                })
              );
            this.detailsContainer.addChild(this.attacksContainer);
            for (let t = 0; t < 32; t++)
              this.attacksContainer.addChild(this.ui.text({}));
            this.detailsContainer.addChild(this.onEquipLabelText),
              this.detailsContainer.addChild(this.onEquipStatsContainer);
            for (let t = 0; t < 8; t++)
              this.onEquipStatsContainer.addChild(this.ui.text({}));
            this.detailsContainer.addChild(this.manaCostLabelText),
              (this.manaCostValueText.position.x =
                this.manaCostLabelText.width),
              this.detailsContainer.addChild(this.manaCostValueText),
              this.detailsContainer.addChild(this.cooldownLabelText),
              (this.cooldownValueText.position.x =
                this.cooldownLabelText.width),
              this.detailsContainer.addChild(this.cooldownValueText),
              this.detailsContainer.addChild(this.xpBonusLabelText),
              (this.xpBonusValueText.position.x = this.xpBonusLabelText.width),
              this.detailsContainer.addChild(this.xpBonusValueText),
              this.detailsContainer.addChild(this.enchantSeparatorText),
              this.detailsContainer.addChild(this.enchantLabelText),
              this.detailsContainer.addChild(this.enchantContainer);
            for (let t = 0; t < 12; t++)
              this.enchantContainer.addChild(this.ui.text({}));
            this.detailsContainer.addChild(this.setPieceSeparatorText),
              this.detailsContainer.addChild(this.setPieceNameText),
              this.detailsContainer.addChild(this.setPieceBonusTwoLabelText),
              this.detailsContainer.addChild(this.setPieceOnEquipTwoContainer);
            for (let t = 0; t < 8; t++)
              this.setPieceOnEquipTwoContainer.addChild(this.ui.text({}));
            this.detailsContainer.addChild(this.setPieceBonusThreeLabelText),
              this.detailsContainer.addChild(
                this.setPieceOnEquipThreeContainer
              );
            for (let t = 0; t < 8; t++)
              this.setPieceOnEquipThreeContainer.addChild(this.ui.text({}));
            this.detailsContainer.addChild(this.setPieceBonusAllLabelText),
              this.detailsContainer.addChild(this.setPieceOnEquipAllContainer);
            for (let t = 0; t < 8; t++)
              this.setPieceOnEquipAllContainer.addChild(this.ui.text({}));
            t.addChild(this.feedPowerText),
              (this.bottomPaddingSprite.texture = new a.g(a.g.EMPTY)),
              this.bottomPaddingSprite.setSize({ width: 1, height: 14 }),
              t.addChild(this.bottomPaddingSprite),
              this.bagTypeSprite.scale.set(3, 3),
              this.bagTypeSprite.anchor.set(0.5, 0.5),
              t.addChild(this.bagTypeSprite),
              t.addChild(this.leftClickInformationText),
              t.addChild(this.shiftLeftClickInformationText),
              t.addChild(this.rightClickInformationText);
          });
        }
        createAttackStats(t, e, i, n, s, r, o) {
          return qr(this, void 0, void 0, function* () {
            var a, l;
            const u =
              null !==
                (l =
                  null === (a = this.ui.theme) || void 0 === a
                    ? void 0
                    : a.windowTextColor) && void 0 !== l
                ? l
                : ti.white;
            if (n > 1) {
              const i = this.textPoll(t, e++, "Shots: ", u);
              i.position.set(r, o);
              this.textPoll(t, e++, n.toString(), ti.lightyellow).position.set(
                r + i.width,
                o
              ),
                (o += i.height);
            }
            let h = 0,
              c = 0,
              d = i.projectile.speed,
              p = i.projectile.acceleration,
              f = i.projectile.lifetimeMs;
            for (const t of s)
              if (void 0 !== t.attackMutators)
                for (const e of t.attackMutators)
                  e.projectileId == i.projectileId &&
                    (e.type == Le.MultiplyRateOfFire
                      ? (h = i.rateOfFire * e.value - i.rateOfFire)
                      : e.type == Le.MultiplySpeed
                      ? ((d *= e.value), (p *= e.value * e.value))
                      : e.type == Le.MultiplyLifetimeMs && (f *= e.value));
            if (0 != d || 0 != f) {
              const t = (0, Ue.cloneDeep)(i.projectile);
              (t.speed = d), (t.acceleration = p), (t.lifetimeMs = f);
              c = Ve.calculateRange(t) - i.projectile.precalculatedRange;
            }
            let m = Math.abs(c);
            if (0 != i.projectile.precalculatedRange || m > 0.1) {
              const n = this.textPoll(t, e++, "Range: ", u);
              n.position.set(r, o);
              const s = c < 0 ? "" : "+",
                a =
                  m > 0.1
                    ? `${Number(i.projectile.precalculatedRange + c).toFixed(
                        2
                      )} (${s}${Number(c.toFixed(2))} Enchantment)`
                    : Number(
                        i.projectile.precalculatedRange.toFixed(2)
                      ).toString();
              this.textPoll(t, e++, a, ti.lightyellow).position.set(
                r + n.width,
                o
              ),
                (o += n.height);
            }
            if (1 == i.projectile.pierceTargets) {
              const i = this.textPoll(
                t,
                e++,
                "Shots hit multiple targets",
                ti.lightyellow
              );
              (i.position.x = r), (o += Ve.setYPosition(i, o));
            }
            if (1 == i.projectile.passObstacles) {
              const i = this.textPoll(
                t,
                e++,
                "Shots pass through obstacles",
                ti.lightyellow
              );
              (i.position.x = r), (o += Ve.setYPosition(i, o));
            }
            if (100 == i.projectile.ignoreDefense) {
              const i = this.textPoll(
                t,
                e++,
                "Ignores defense of target",
                ti.lightyellow
              );
              (i.position.x = r), (o += Ve.setYPosition(i, o));
            }
            if (1 != i.rateOfFire || 0 != h) {
              const n = this.textPoll(t, e++, "Rate of Fire: ", u);
              n.position.set(r, o);
              const s = h < 0 ? "" : "+",
                a =
                  0 != h
                    ? `${Ve.percent(i.rateOfFire + h)} (${s}${Ve.percent(
                        h
                      )} Enchantment)`
                    : Ve.percent(i.rateOfFire);
              this.textPoll(t, e++, a, ti.lightyellow).position.set(
                r + n.width,
                o
              ),
                (o += n.height);
            }
            if (0 != i.projectile.statusEffects.length) {
              const n = this.textPoll(t, e++, "Shot Effect: ", u);
              (o += Ve.setYPosition(n, o)), (n.position.x = r);
              for (let n = 0; n < i.projectile.statusEffects.length; n++) {
                const s = i.projectile.statusEffects[n];
                let a = `${Ve.statusEffectToString(s.type)} for ${Ve.time(
                  0.001 * s.durationMs
                )}`;
                s.type == Ie.Bleeding && (a += ` (${s.value} damage/s)`);
                const l = this.textPoll(t, e++, a, ti.lightyellow);
                (o += Ve.setYPosition(l, o)), (l.position.x = r);
              }
            }
            return Promise.resolve([e, o]);
          });
        }
        textPoll(t, e, i, n) {
          const s = t.children[e];
          return (
            s.position.set(0, 0),
            (s.text = i),
            (s.style.fill = n),
            (s.visible = !0),
            s
          );
        }
        createAbility(t, e, i) {
          var n, s, r, o;
          t.children.forEach((t) => (t.visible = !1));
          let a = 0,
            l = 0;
          const u =
              null !==
                (s =
                  null === (n = this.ui.theme) || void 0 === n
                    ? void 0
                    : n.windowTextColor) && void 0 !== s
                ? s
                : ti.white,
            h = new Array(),
            c = new Array(),
            d = new Array();
          for (let n = 0; n < e.onUse.length; n++) {
            const s = e.onUse[n];
            switch (s.type) {
              case Ri.StatBoostSelf: {
                const t = s,
                  e = null == i ? void 0 : i.getStat(Ee.WIS);
                if (void 0 === e) return;
                const n =
                    t.scalingStatThreshold > 0
                      ? Math.max(e.totalValue - t.scalingStatThreshold, 0)
                      : 0,
                  r = Math.floor(0.1 * n),
                  o = t.duration + r,
                  a = `${Ve.signed(t.amount)} ${Ve.baseStatName(
                    t.statType
                  )} for ${Ve.time(o, r)}`;
                h.push(a);
                break;
              }
              case Ri.ConditionEffectSelf: {
                const t = s,
                  e = null == i ? void 0 : i.getStat(Ee.WIS);
                if (void 0 === e) return;
                const n =
                    t.scalingStatThreshold > 0
                      ? Math.max(e.totalValue - t.scalingStatThreshold, 0)
                      : 0,
                  r = Math.floor(0.1 * n) * t.scalingStatDurationBase,
                  o = t.duration + r,
                  a = `${Ie[t.statusEffectType]} for ${Ve.time(o, r)}`;
                h.push(a);
                break;
              }
              case Ri.ClearConditionEffectSelf:
                h.push("Removes Negative Conditions");
                break;
              case Ri.StatBoostAura: {
                const t = s,
                  e = null == i ? void 0 : i.getStat(Ee.WIS);
                if (void 0 === e) return;
                const n =
                    t.scalingStatThreshold > 0
                      ? Math.max(e.totalValue - t.scalingStatThreshold, 0)
                      : 0,
                  r = Math.floor(0.1 * n),
                  o = t.duration + r,
                  a = 0.1 * n,
                  l = t.range + a,
                  u =
                    Math.max(e.totalValue - t.scalingStatThreshold, 0) *
                    t.scalingStatIncrease,
                  h = t.amount + u,
                  d = `${Ve.stat(h, t.statType, u)} for ${Ve.time(
                    o,
                    r
                  )} within ${Ve.range(l, a)}`;
                c.push(d);
                break;
              }
              case Ri.ConditionEffectAura: {
                const t = s,
                  e = null == i ? void 0 : i.getStat(Ee.WIS);
                if (void 0 === e) return;
                const n =
                    t.scalingStatThreshold > 0
                      ? Math.max(e.totalValue - t.scalingStatThreshold, 0)
                      : 0,
                  r = Math.floor(0.1 * n) * t.scalingStatDurationBase,
                  o = t.duration + r,
                  a = 0.1 * n,
                  l = t.range + a,
                  u = `${Ie[t.statusEffectType]} for ${Ve.time(
                    o,
                    r
                  )} within ${Ve.range(l, a)}`;
                c.push(u);
                break;
              }
              case Ri.HealNova: {
                const e = s,
                  n = null == i ? void 0 : i.getStat(e.scalingStatType);
                if (void 0 === n) return;
                if (0 != e.damage) {
                  const i = this.textPoll(t, a++, "Area Damage:", u);
                  l += Ve.setYPosition(i, l);
                  const s =
                      e.scalingStatThreshold > 0
                        ? Math.max(n.totalValue - e.scalingStatThreshold, 0)
                        : 0,
                    r = e.scalingStatBaseDamage * Math.floor(0.1 * s),
                    o = e.damage + r,
                    h = 0.1 * s,
                    c = e.range + h,
                    d = this.textPoll(
                      t,
                      a++,
                      `${Ve.damage(o, r)} within ${Ve.range(c)}`,
                      ti.lightyellow
                    );
                  l += Ve.setYPosition(d, l);
                }
                if (0 != e.amount) {
                  const i = this.textPoll(t, a++, "Party Heal:", u);
                  l += Ve.setYPosition(i, l);
                  const s =
                      e.scalingStatThreshold > 0
                        ? Math.max(n.totalValue - e.scalingStatThreshold, 0)
                        : 0,
                    r = e.scalingStatBaseHeal * Math.floor(0.1 * s),
                    o = e.amount + r,
                    h = Math.floor(0.3 * o),
                    c = 0.025 * o,
                    d = 0.1 * s,
                    p = e.range + d,
                    f = `${Ve.heal(o, r)} within ${Ve.range(
                      p,
                      d
                    )}\nDecreases by ${c.toFixed(
                      1
                    )} HP per Healed Ally\nMinimum ${h} HP at 28 Healed Allies`,
                    m = this.textPoll(t, a++, f, ti.lightyellow);
                  l += Ve.setYPosition(m, l);
                }
                break;
              }
              case Ri.PoisonGrenade: {
                const e = s,
                  n = null == i ? void 0 : i.getStat(e.scalingStatType);
                if (void 0 === n) return;
                const r = this.textPoll(t, a++, "Poison:", u);
                l += Ve.setYPosition(r, l);
                const o =
                    e.scalingStatThreshold > 0
                      ? Math.max(n.totalValue - e.scalingStatThreshold, 0)
                      : 0,
                  h = Math.floor(o * e.scalingStatTotalDamage),
                  c = Math.floor(e.totalDamage + h),
                  d = Math.floor(o * e.scalingStatImpactDamage),
                  p = Math.floor(e.impactDamage + d),
                  f = o * e.scalingStatRadius,
                  m = e.radius + f,
                  g = e.duration,
                  v = o * e.scalingStatDamageBoost,
                  y = e.damageBoost + v;
                let x = `${Ve.damage(c, h)} within ${Ve.range(
                  m,
                  f
                )} over ${Ve.time(g)}`;
                0 != e.impactDamage &&
                  (x += `\n${Ve.damage(p, d)} Dealt Instantly on Impact`),
                  0 != e.damageBoost &&
                    (x += `\n${Ve.signedPercent(y, 1)} Damage Boost`),
                  v >= 0.001 && (x += ` (${Ve.signedPercent(v, 1)})`),
                  (x += `\nValues are determined by ${Ve.baseStatName(
                    e.scalingStatType
                  )}`),
                  e.statusEffect.type != Ie.None &&
                    (x += `\nInflicts ${Ve.statusEffectToString(
                      e.statusEffect.type
                    )} for ${Ve.time(0.001 * e.statusEffect.durationMs)}`);
                const b = this.textPoll(t, a++, x, ti.lightyellow);
                l += Ve.setYPosition(b, l);
                break;
              }
              case Ri.VampireBlast: {
                const e = s,
                  n = null == i ? void 0 : i.getStat(e.scalingStatType);
                if (void 0 === n) return;
                const r = this.textPoll(t, a++, "Skull:", u);
                l += Ve.setYPosition(r, l);
                const o =
                    e.scalingStatThreshold > 0
                      ? Math.max(n.totalValue - e.scalingStatThreshold, 0)
                      : 0,
                  h = Math.floor(0.1 * o) * e.scalingStatIncrease,
                  c = Math.floor(e.damage + h),
                  d = Math.floor(0.1 * o),
                  p = e.healRange + d;
                let f = `${Ve.damage(c, h)} within ${Ve.range(e.radius)}`;
                0 != e.ignoreDefense &&
                  (f += `\nIgnores ${e.ignoreDefense} Defense`),
                  0 != e.heal &&
                    ((f += `\nSteals ${e.heal} HP within ${Ve.range(
                      e.radius
                    )}`),
                    0 != e.heal &&
                      (f += `\nHeals Allies within ${Ve.range(p, d)}`)),
                  e.statusEffect.type != Ie.None &&
                    (f += `\nInflicts ${Ie[e.statusEffect.type]} for ${Ve.time(
                      0.001 * e.statusEffect.durationMs
                    )}`);
                const m = this.textPoll(t, a++, f, ti.lightyellow);
                l += Ve.setYPosition(m, l);
                break;
              }
              case Ri.Trap: {
                const e = s,
                  i = this.textPoll(t, a++, "Trap:", u);
                l += Ve.setYPosition(i, l);
                const n = e.radius * e.sensitivity;
                let r = `${Ve.damage(e.damage)} within ${Ve.range(
                  e.radius
                )}\n${Ve.time(e.throwTime)} to arm for ${Ve.time(
                  e.duration
                )}\nTriggers within ${n.toFixed(2)} sqrs`;
                100 == e.ignoreDefense && (r += "\nIgnores defense of target"),
                  e.statusEffect.type != Ie.None &&
                    (r += `\nInflicts ${Ie[e.statusEffect.type]} for ${Ve.time(
                      0.001 * e.statusEffect.durationMs
                    )}`);
                const o = this.textPoll(t, a++, r, ti.lightyellow);
                l += Ve.setYPosition(o, l);
                break;
              }
              case Ri.Lightning: {
                const e = s,
                  n =
                    null == i ? void 0 : i.getStat(e.lightningScalingStatType),
                  r =
                    null == i ? void 0 : i.getStat(e.shockblastScalingStatType);
                if (void 0 === n || void 0 === r) return;
                const o = this.textPoll(t, a++, "Lightning:", u);
                l += Ve.setYPosition(o, l);
                const h =
                    e.lightningScalingStatThreshold > 0
                      ? Math.max(
                          n.totalValue - e.lightningScalingStatThreshold,
                          0
                        )
                      : 0,
                  c = Math.round(h * e.lightningScalingStatDamage),
                  d = Math.round(e.lightningDamage + c),
                  p = Math.floor(h / e.lightningScalingStatMaxTargets),
                  f = e.lightningMaxTargets + p;
                let m = `${Ve.damage(d, c)} to ${Ve.targets(f, p)}`;
                0 != e.lightningDamagePerTargetChange &&
                  (m += `\n${Ve.signed(
                    e.lightningDamagePerTargetChange
                  )} Damage for each subsequent target`),
                  (m += `\nValues are determined by ${Ve.baseStatName(
                    e.lightningScalingStatType
                  )}`);
                const g = this.textPoll(t, a++, m, ti.lightyellow);
                l += Ve.setYPosition(g, l);
                const v = this.textPoll(t, a++, "Shockblast:", u);
                l += Ve.setYPosition(v, l);
                const y =
                    e.shockblastScalingStatThreshold > 0
                      ? Math.max(
                          r.totalValue - e.shockblastScalingStatThreshold,
                          0
                        )
                      : 0,
                  x = 0,
                  b = e.shockblastTriggerTimes + x,
                  S = Math.floor(e.shockblastScalingStatDamage * y),
                  C = e.shockblastDamage + S,
                  _ = Math.floor(y / e.shockblastScalingStatMaxTargets),
                  T = e.shockblastMaxTargets + _,
                  w = e.shockblastScalingStatRadius * y,
                  P = e.shockblastRadius + w;
                (m = `${Ve.damage(C * b, S * b)} within ${Ve.range(
                  P,
                  w
                )} to ${Ve.targets(T, _)}`),
                  (m += `\nExplodes ${Ve.times(b)} per target`),
                  (m += `\nValues are determined by ${Ve.baseStatName(
                    e.shockblastScalingStatType
                  )}`);
                const A = this.textPoll(t, a++, m, ti.lightyellow);
                l += Ve.setYPosition(A, l);
                break;
              }
              case Ri.EffectBlast: {
                const t = s,
                  e = null == i ? void 0 : i.getStat(t.scalingStatType),
                  n =
                    t.scalingStatThreshold > 0
                      ? Math.max(
                          (null !== (r = null == e ? void 0 : e.totalValue) &&
                          void 0 !== r
                            ? r
                            : 0) - t.scalingStatThreshold,
                          0
                        )
                      : 0,
                  a = Math.floor(0.1 * n),
                  l =
                    0.001 *
                      (null !== (o = t.statusEffect.durationMs) && void 0 !== o
                        ? o
                        : 0) +
                    a,
                  u = 0.1 * n,
                  h = t.radius + u,
                  c = `Inflicts ${Ie[t.statusEffect.type]} for ${Ve.time(
                    l,
                    a
                  )} within ${Ve.range(h, u)}`;
                d.push(c);
                break;
              }
              case Ri.Decoy: {
                const e = s,
                  i = this.textPoll(t, a++, "Decoy:", u);
                l += Ve.setYPosition(i, l);
                const n = `Lasts for ${Ve.time(e.duration)}`,
                  r = this.textPoll(t, a++, n, ti.lightyellow);
                l += Ve.setYPosition(r, l);
                break;
              }
              case Ri.Teleport:
                h.push("Teleport to Target");
            }
          }
          if (0 != d.length) {
            const e = this.textPoll(t, a++, "Effect on Enemy:", u);
            l += Ve.setYPosition(e, l);
            for (let e = 0; e < d.length; e++) {
              const i = this.textPoll(t, a++, d[e], ti.lightyellow);
              l += Ve.setYPosition(i, l);
            }
          }
          if (0 != h.length) {
            const e = this.textPoll(t, a++, "Effect on Self:", u);
            l += Ve.setYPosition(e, l);
            for (let e = 0; e < h.length; e++) {
              const i = this.textPoll(t, a++, h[e], ti.lightyellow);
              l += Ve.setYPosition(i, l);
            }
          }
          if (0 != c.length) {
            const e = this.textPoll(t, a++, "Effect on Party:", u);
            l += Ve.setYPosition(e, l);
            for (let e = 0; e < c.length; e++) {
              const i = this.textPoll(t, a++, c[e], ti.lightyellow);
              l += Ve.setYPosition(i, l);
            }
          }
        }
        createBaseStats(t, e, i, n, s) {
          t.children.forEach((t) => (t.visible = !1));
          let r = 0;
          for (let o = 0; o < i.length; o++) {
            const a = i[o];
            if (a.type == Ee.None || a.type > Ee.WIS) continue;
            const l = t.getChildAt(o);
            if (
              ((l.visible = !0),
              (l.style.fill = a.value > 0 ? ti.lightyellow : ti.red),
              (r += Ve.setYPosition(l, r)),
              a.relativeTo == Ee.None)
            )
              l.text = `${Ve.signed(a.value)} ${Ve.baseStatName(a.type)}${
                a.bonus > 0 ? ` (+${a.bonus} Enchantment)` : ""
              }`;
            else {
              if (void 0 === (null == n ? void 0 : n.getStat(a.type))) return;
              const t = null == n ? void 0 : n.getStat(a.relativeTo);
              if (void 0 === t) return;
              const i =
                  t.preRelativeValue - (0 == s ? t.equipmentValueInSlot[e] : 0),
                r = Math.ceil(i * a.value * 0.01);
              l.text = `${Ve.signed(r)} ${Ve.baseStatName(a.type)} (${Math.abs(
                a.value
              )}% of ${Ve.baseStatName(a.relativeTo)})`;
            }
          }
        }
      }
      var Xr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Yr extends Ge {
        constructor(t, e) {
          super(t, e),
            (this.textContainer = new Gt.mc()),
            this.addElement(this.textContainer);
        }
        create() {
          for (let t = 0; t < 10; t++) {
            const t = this.ui.text({ anchor: Ve.CENTER_X });
            (t.visible = !1), this.textContainer.addChild(t);
          }
        }
        appendData(t, e) {
          return Xr(this, void 0, void 0, function* () {
            var i;
            for (let t = 0; t < this.textContainer.children.length; t++)
              this.textContainer.children[t].visible = !1;
            for (
              let e = 0;
              e < t.length && e < this.textContainer.children.length;
              e++
            ) {
              const n = this.textContainer.children[e];
              (n.text = t[e][0]),
                (n.tint =
                  0 == e
                    ? null === (i = this.ui.theme) || void 0 === i
                      ? void 0
                      : i.windowTextColor
                    : t[e][1]),
                (n.pivot.y = Math.floor(20 * (0.5 * (t.length - 1) - e)) + 9),
                (n.visible = !0);
            }
            this.setBackgroundColor(e),
              yield this.updateBounds(),
              this.centerChildren();
          });
        }
      }
      var Kr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Zr extends Ge {
        constructor(t, e) {
          super(t, e),
            (this.titleText = this.ui.text({})),
            (this.classPortraitSprite = new js(t)),
            (this.weaponContainer = new js(t)),
            (this.abilityContainer = new js(t)),
            (this.armorContainer = new js(t)),
            (this.accessoryContainer = new js(t));
        }
        create() {
          return Kr(this, void 0, void 0, function* () {
            const t = 0.8;
            let e = 8;
            this.titleText.anchor.set(0.5, 0),
              this.titleText.position.set(0.5 * this.options.size.x, e),
              this.addElement(this.titleText),
              (e += this.titleText.height + 24),
              this.classPortraitSprite.setScale(t),
              this.classPortraitSprite.anchor.set(0.5),
              (this.classPortraitSprite.position.y = e),
              this.addElement(this.classPortraitSprite),
              this.weaponContainer.setScale(t),
              this.weaponContainer.anchor.set(0.5),
              (this.weaponContainer.position.y = e),
              this.addElement(this.weaponContainer),
              this.abilityContainer.setScale(t),
              this.abilityContainer.anchor.set(0.5),
              (this.abilityContainer.position.y = e),
              this.addElement(this.abilityContainer),
              this.armorContainer.setScale(t),
              this.armorContainer.anchor.set(0.5),
              (this.armorContainer.position.y = e),
              this.addElement(this.armorContainer),
              this.accessoryContainer.setScale(t),
              this.accessoryContainer.anchor.set(0.5),
              (this.accessoryContainer.position.y = e),
              this.addElement(this.accessoryContainer);
          });
        }
        appendData(t, e, i, n, s) {
          return Kr(this, void 0, void 0, function* () {
            var e, i, n, s, r, o, a, l, u, h, c, d;
            this.classPortraitSprite.createPortrait(t.classData.type);
            const p = [this.classPortraitSprite],
              f =
                null !==
                  (n =
                    null ===
                      (i =
                        null === (e = t.equipment[Re.Weapon]) || void 0 === e
                          ? void 0
                          : e.base) || void 0 === i
                      ? void 0
                      : i.id) && void 0 !== n
                  ? n
                  : 0;
            (this.weaponContainer.visible = f > 0),
              1 == this.weaponContainer.visible &&
                (yield this.weaponContainer.createEquipment(
                  f,
                  t.classData.equipmentSlots[Re.Weapon]
                ),
                p.push(this.weaponContainer));
            const m =
              null !==
                (o =
                  null ===
                    (r =
                      null === (s = t.equipment[Re.Ability]) || void 0 === s
                        ? void 0
                        : s.base) || void 0 === r
                    ? void 0
                    : r.id) && void 0 !== o
                ? o
                : 0;
            (this.abilityContainer.visible = m > 0),
              1 == this.abilityContainer.visible &&
                (yield this.abilityContainer.createEquipment(
                  m,
                  t.classData.equipmentSlots[Re.Ability]
                ),
                p.push(this.abilityContainer));
            const g =
              null !==
                (u =
                  null ===
                    (l =
                      null === (a = t.equipment[Re.Armor]) || void 0 === a
                        ? void 0
                        : a.base) || void 0 === l
                    ? void 0
                    : l.id) && void 0 !== u
                ? u
                : 0;
            (this.armorContainer.visible = g > 0),
              1 == this.armorContainer.visible &&
                (yield this.armorContainer.createEquipment(
                  g,
                  t.classData.equipmentSlots[Re.Armor]
                ),
                p.push(this.armorContainer));
            const v =
              null !==
                (d =
                  null ===
                    (c =
                      null === (h = t.equipment[Re.Accessory]) || void 0 === h
                        ? void 0
                        : h.base) || void 0 === c
                    ? void 0
                    : c.id) && void 0 !== d
                ? d
                : 0;
            (this.accessoryContainer.visible = v > 0),
              1 == this.accessoryContainer.visible &&
                (yield this.accessoryContainer.createEquipment(
                  v,
                  t.classData.equipmentSlots[Re.Accessory]
                ),
                p.push(this.accessoryContainer));
            for (let t = 0; t < p.length; t++) {
              p[t].position.x =
                0.5 * this.options.size.x + 40 * (t - 0.5 * (p.length - 1));
            }
          });
        }
      }
      var Qr = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Jr extends Me {
        constructor(t, e) {
          super(t),
            (this.equipmentSprite = new js(this.ui)),
            this.addChild(this.equipmentSprite),
            (this.separatorGraphics = this.ui.rectangle({
              width: 0.8 * e,
              height: 2,
              fillColor: 12303291,
            })),
            this.addChild(this.separatorGraphics),
            (this.textContainer = new Gt.mc()),
            this.addChild(this.textContainer),
            (this.textId = 0),
            (this.parentWidth = e);
        }
        pollText(t, e, i, n, s = !1) {
          if (this.textId >= this.textContainer.children.length) return 0;
          const r = this.textContainer.children[this.textId++];
          return (
            (r.text = t),
            (r.style.fill = n),
            (r.style.align = 1 == s ? "center" : "left"),
            r.position.set(e, i),
            (r.visible = !0),
            r.height
          );
        }
        create() {
          this.equipmentSprite.scale.set(0.8),
            this.equipmentSprite.anchor.set(0.5, 0.5),
            this.equipmentSprite.position.set(40, 24);
          for (let t = 0; t < 20; t++) {
            const t = this.ui.text({});
            (t.anchor.x = 0.5),
              (t.visible = !1),
              this.textContainer.addChild(t);
          }
        }
        appendText(t, e, i, n, s, r) {
          return 0;
        }
        appendData(t, e, i, n, s, r, o) {
          return Qr(this, void 0, void 0, function* () {
            var a;
            this.textContainer.children.map((t) => (t.visible = !1)),
              (this.textId = 0);
            const l =
              null === (a = t.equipment[e.slotMetaType]) || void 0 === a
                ? void 0
                : a.base;
            void 0 !== l &&
              l.id > 0 &&
              this.equipmentSprite.createEquipment(l.id, l.slotType);
            let u = 8;
            const h = e.name;
            u += this.pollText(h, 0.5 * this.parentWidth, u, ti.white, !0);
            const c = this.ui.app.settingsHandler.showReportDetails;
            (u = this.appendText(e, i, n, s, c, u)),
              (this.separatorGraphics.visible = o),
              1 == o &&
                (this.separatorGraphics.position.set(
                  0.1 * this.parentWidth,
                  u + 8
                ),
                (this.separatorGraphics.tint = r));
          });
        }
      }
      class to extends Jr {
        constructor(t, e) {
          super(t, e);
        }
        appendText(t, e, i, n, s, r) {
          var o;
          if (0 != t.damageDone) {
            const e = t.damageDone / n,
              o = Ve.percent(e / i[0], 2),
              a = `${Ve.separators(e, 1)} DPS (${o} of total)`;
            if (
              ((r += this.pollText(a, 0.5 * this.parentWidth, r, ti.orange)),
              0 != t.baseData.damageDone)
            ) {
              let e = `${Ve.separators(t.baseData.damageDone)} DMG`;
              if (
                0 != t.baseData.hitCount &&
                ((e += ` in ${Ve.separators(t.baseData.hitCount)} hits`),
                1 == s)
              ) {
                e += ` (${Ve.separators(
                  t.baseData.damageDone / t.baseData.hitCount,
                  1
                )} DMG per hit)`;
              }
              r += this.pollText(e, 0.5 * this.parentWidth, r, ti.lightyellow);
            }
          }
          if (0 != t.baseData.castCount) {
            let e = `${Ve.separators(t.baseData.castCount)} casts`;
            if (
              1 == s &&
              (0 != t.baseData.damageDone || 0 != t.baseData.mpSpent)
            ) {
              if (((e += " ("), 0 != t.baseData.damageDone)) {
                (e += `${Ve.separators(
                  t.baseData.damageDone / t.baseData.castCount,
                  1
                )} DMG`),
                  0 != t.baseData.mpSpent && (e += ", ");
              }
              if (0 != t.baseData.mpSpent) {
                e += `${Ve.separators(
                  t.baseData.mpSpent / t.baseData.castCount,
                  1
                )} MP`;
              }
              e += " per cast)";
            }
            r += this.pollText(e, 0.5 * this.parentWidth, r, ti.lightyellow);
          }
          const a = Array.from(t.procsData.entries()).sort((t, e) =>
            t[1].damageDone < e[1].damageDone ? 1 : -1
          );
          if (1 == s)
            for (let e = 0; e < a.length; e++) {
              const [i, s] = a[e];
              if (0 == s.damageDone && 0 == s.castCount && 0 == s.procCount)
                continue;
              const l =
                null !== (o = s.name) && void 0 !== o ? o : "Not Defined Proc";
              if (
                ((r += this.pollText(l, 0.5 * this.parentWidth, r, ti.white)),
                0 != s.damageDone)
              ) {
                const e = s.damageDone / n,
                  i = Ve.percent(e / (t.damageDone / n), 2),
                  o = `${Ve.separators(e, 1)} DPS (${i} of total)`;
                r += this.pollText(
                  o,
                  0.5 * this.parentWidth,
                  r,
                  ti.lightyellow
                );
                let a = `${Ve.separators(s.damageDone)} DMG`;
                if (0 != s.hitCount) {
                  const t = Ve.separators(s.damageDone / s.hitCount, 1);
                  a += ` in ${Ve.separators(
                    s.hitCount
                  )} hits (${t} DMG per hit)`;
                }
                r += this.pollText(
                  a,
                  0.5 * this.parentWidth,
                  r,
                  ti.lightyellow
                );
              }
              if (0 != s.procCount) {
                if (0 != s.value && i.effectType === Fe.Magic) {
                  const t = s.value / s.procCount;
                  let e = `${Math.round(s.value)} MP recovered (${Ve.separators(
                    t,
                    1
                  )} MP per proc)`;
                  r += this.pollText(
                    e,
                    0.5 * this.parentWidth,
                    r,
                    ti.lightyellow
                  );
                }
                let t = `${s.procCount} procs`;
                if (
                  0 == s.uptimeMs ||
                  (i.effectType != Fe.StatBoost &&
                    i.effectType != Fe.StatusEffect)
                ) {
                  if (0 != s.damageDone) {
                    t += ` (${Ve.separators(
                      s.damageDone / s.procCount,
                      1
                    )} DMG per proc)`;
                  }
                } else {
                  const e = (0.001 * s.uptimeMs) / n;
                  t += ` (${Ve.percent(e, 2)} uptime)`;
                }
                if (
                  ((r += this.pollText(
                    t,
                    0.5 * this.parentWidth,
                    r,
                    ti.lightyellow
                  )),
                  0 != s.mpSpent)
                ) {
                  const t = Ve.separators(s.mpSpent / s.procCount, 1);
                  let e = `${Ve.separators(
                    s.mpSpent
                  )} MP drained (${t} MP per proc)`;
                  r += this.pollText(
                    e,
                    0.5 * this.parentWidth,
                    r,
                    ti.lightyellow
                  );
                }
              }
            }
          return r;
        }
      }
      var eo = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class io extends Zr {
        constructor(t, e) {
          super(t, e);
          const i = {
            frameTexture: "white_thin_frame",
            size: new Et.b(120, 32),
          };
          (this.simulationTimeFrame = new $e(
            t,
            Object.assign(Object.assign({}, i), {
              labelText: "Duration",
              contentColor: ti.lightyellow,
              pivotY: 2,
            })
          )),
            (this.totalDPSFrame = new $e(
              t,
              Object.assign(Object.assign({}, i), {
                labelText: "Total DPS",
                contentColor: ti.orange,
                pivotY: 2,
              })
            )),
            (this.targetDefenseFrame = new $e(
              t,
              Object.assign(Object.assign({}, i), {
                labelText: "Defense",
                contentColor: ti.gray,
                pivotY: 2,
              })
            )),
            (this.reportDetailsContainers = new Array());
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return eo(this, void 0, void 0, function* () {
            t.create.call(this), (this.titleText.text = "DPS Report");
            this.simulationTimeFrame.updateBackground(),
              this.simulationTimeFrame.position.set(
                0.5 * this.options.size.x - 188,
                86
              ),
              this.addElement(this.simulationTimeFrame),
              this.totalDPSFrame.updateBackground(),
              this.totalDPSFrame.position.set(
                0.5 * this.options.size.x - 60,
                86
              ),
              this.addElement(this.totalDPSFrame),
              this.targetDefenseFrame.updateBackground(),
              this.targetDefenseFrame.position.set(
                0.5 * this.options.size.x + 68,
                86
              ),
              this.addElement(this.targetDefenseFrame);
            for (let t = 0; t < 4; t++) {
              const t = new to(this.ui, this.options.size.x);
              t.create(),
                this.addChild(t),
                this.reportDetailsContainers.push(t);
            }
            this.updateBounds();
          });
        }
        appendData(t, e, i, n, s) {
          const r = Object.create(null, {
            appendData: { get: () => super.appendData },
          });
          return eo(this, void 0, void 0, function* () {
            if (
              (yield r.appendData.call(this, t, e, i, n, s),
              this.reportDetailsContainers.map((t) => t.hide()),
              void 0 === e)
            )
              return;
            const o = e.steps[i];
            if (void 0 === o) return;
            this.setBackgroundColor(s),
              this.simulationTimeFrame.setBackgroundColor(s),
              this.simulationTimeFrame.setContentText(
                `${Math.round(e.simulationTimeSeconds)} seconds`
              ),
              this.totalDPSFrame.setBackgroundColor(s),
              this.totalDPSFrame.setContentText(Ve.separators(o.values[0], 1)),
              this.targetDefenseFrame.setBackgroundColor(s),
              this.targetDefenseFrame.setContentText(i.toString());
            const a = this.ui.app.settingsHandler.showReportDetails,
              l = o.equipmentDetails.filter(
                (t) =>
                  0 != t.damageDone ||
                  0 != t.castCount ||
                  (0 != t.procCount && 0 != a)
              );
            yield l.sort((t, e) => (t.damageDone < e.damageDone ? 1 : 0));
            const u = [];
            let h = 128;
            for (let r = 0; r < l.length; r++) {
              const o = this.reportDetailsContainers[r],
                a = r < l.length - 1,
                c = o.appendData(t, l[r], i, n, e.simulationTimeSeconds, s, a);
              u.push(c),
                o.position.set(0, h),
                (o.visible = !0),
                (h += o.height + 8);
            }
            yield Promise.all(u), this.updateBounds();
          });
        }
      }
      class no extends Jr {
        constructor(t, e) {
          super(t, e);
        }
        appendText(t, e, i, n, s, r) {
          var o;
          if (0 != t.baseData.castCount) {
            let e = `${Ve.separators(t.baseData.castCount)} casts`;
            if (
              1 == s &&
              (0 != t.baseData.damageDone || 0 != t.baseData.mpSpent) &&
              0 != t.baseData.mpSpent
            ) {
              e += ` (${Ve.separators(
                t.baseData.mpSpent / t.baseData.castCount,
                1
              )} MP per cast)`;
            }
            r += this.pollText(e, 0.5 * this.parentWidth, r, ti.lightyellow);
          }
          const a = Array.from(t.procsData.entries());
          if (1 == s)
            for (let t = 0; t < a.length; t++) {
              const [n, s] = a[t];
              if (0 == s.procCount) continue;
              if (
                n.effectType != Fe.Dash &&
                n.effectType != Fe.Teleport &&
                n.effectType != Fe.StatBoost &&
                n.effectType != Fe.StatusEffect
              )
                continue;
              if (
                n.effectType == Fe.StatBoost &&
                (0 == s.uptimeMs || n.statType != Ee.SPD)
              )
                continue;
              if (n.effectType == Fe.StatusEffect) {
                const t = n;
                if (0 == s.uptimeMs) continue;
                if (
                  t.statusEffectType != Ie.Speedy &&
                  t.statusEffectType != Ie.Slowed &&
                  t.statusEffectType != Ie.Paralyzed
                )
                  continue;
              }
              const l = null !== (o = s.name) && void 0 !== o ? o : "Some Proc";
              if (
                ((r += this.pollText(l, 0.5 * this.parentWidth, r, ti.white)),
                0 != s.value &&
                  (n.effectType == Fe.Teleport || n.effectType == Fe.Dash))
              ) {
                const t = 0 == i[0] ? 1 : s.value / i[0];
                let e = `${s.value} tiles (${Ve.percent(t, 1)} of total)`;
                r += this.pollText(
                  e,
                  0.5 * this.parentWidth,
                  r,
                  ti.lightyellow
                );
              }
              let u = `${s.procCount} procs`;
              if (0 != s.uptimeMs) {
                const t = (0.001 * s.uptimeMs) / e;
                u += ` (${Ve.percent(t, 2)} uptime)`;
              }
              r += this.pollText(u, 0.5 * this.parentWidth, r, ti.lightyellow);
            }
          return r;
        }
      }
      var so = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class ro extends Zr {
        constructor(t, e) {
          super(t, e);
          const i = {
            frameTexture: "white_thin_frame",
            size: new Et.b(120, 32),
          };
          (this.timeSecondsFrame = new $e(
            t,
            Object.assign(Object.assign({}, i), {
              labelText: "Time",
              contentColor: ti.lightyellow,
              pivotY: 2,
            })
          )),
            (this.travelledTilesFrame = new $e(
              t,
              Object.assign(Object.assign({}, i), {
                labelText: "Travelled",
                contentColor: ti.orange,
                pivotY: 2,
              })
            )),
            (this.speedTilesFrame = new $e(
              t,
              Object.assign(Object.assign({}, i), {
                labelText: "Avg. Speed",
                contentColor: ti.lightgreen,
                pivotY: 2,
              })
            )),
            (this.reportDetailsContainers = new Array());
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return so(this, void 0, void 0, function* () {
            t.create.call(this),
              (this.titleText.text = "Travel Distance Report");
            this.timeSecondsFrame.updateBackground(),
              this.timeSecondsFrame.position.set(
                0.5 * this.options.size.x - 188,
                86
              ),
              this.addElement(this.timeSecondsFrame),
              this.travelledTilesFrame.updateBackground(),
              this.travelledTilesFrame.position.set(
                0.5 * this.options.size.x - 60,
                86
              ),
              this.addElement(this.travelledTilesFrame),
              this.speedTilesFrame.updateBackground(),
              this.speedTilesFrame.position.set(
                0.5 * this.options.size.x + 68,
                86
              ),
              this.addElement(this.speedTilesFrame);
            for (let t = 0; t < 4; t++) {
              const t = new no(this.ui, this.options.size.x);
              t.create(),
                this.addChild(t),
                this.reportDetailsContainers.push(t);
            }
            this.updateBounds();
          });
        }
        appendData(t, e, i, n, s) {
          const r = Object.create(null, {
            appendData: { get: () => super.appendData },
          });
          return so(this, void 0, void 0, function* () {
            if (
              (yield r.appendData.call(this, t, e, i, n, s),
              this.reportDetailsContainers.map((t) => t.hide()),
              void 0 === e)
            )
              return;
            const o = e.steps[i];
            if (void 0 === o) return;
            this.setBackgroundColor(s);
            const a = Math.round(i);
            this.timeSecondsFrame.setBackgroundColor(s),
              this.timeSecondsFrame.setContentText(`${a} seconds`),
              this.travelledTilesFrame.setBackgroundColor(s),
              this.travelledTilesFrame.setContentText(
                `${Ve.separators(o.values[0], 1)} tiles`
              );
            const l = 0 == a ? 0 : o.values[0] / a;
            this.speedTilesFrame.setBackgroundColor(s),
              this.speedTilesFrame.setContentText(
                `${Ve.separators(l, 2)} tiles/s`
              );
            const u = o.equipmentDetails.filter((t) => {
              let e = !1;
              for (const i of Array.from(t.procsData.keys()))
                switch (i.effectType) {
                  case Fe.StatusEffect: {
                    if (0 == t.uptimeMs) break;
                    const n = i;
                    (n.statusEffectType != Ie.Paralyzed &&
                      n.statusEffectType != Ie.Slowed &&
                      n.statusEffectType != Ie.Speedy) ||
                      (e = !0);
                    break;
                  }
                  case Fe.StatBoost:
                    if (0 == t.uptimeMs) break;
                    i.statType == Ee.SPD && (e = !0);
                    break;
                  case Fe.Teleport:
                  case Fe.Dash:
                    e = !0;
                }
              return e;
            });
            yield u.sort((t, e) => (t.slotMetaType > e.slotMetaType ? 1 : 0));
            const h = [];
            let c = 128;
            for (let r = 0; r < u.length; r++) {
              const o = this.reportDetailsContainers[r],
                a = r < u.length - 1,
                l = o.appendData(t, u[r], i, n, e.simulationTimeSeconds, s, a);
              h.push(l),
                o.position.set(0, c),
                (o.visible = !0),
                (c += o.height + 8);
            }
            yield Promise.all(h), this.updateBounds();
          });
        }
      }
      class oo extends Me {
        constructor(t) {
          super(t),
            (this.backgroundSprite = new Xt.k(a.g.WHITE)),
            this.backgroundSprite.position.set(0, 0),
            (this.backgroundSprite.alpha = 0.3),
            (this.backgroundSprite.width = 360),
            (this.backgroundSprite.height = 48),
            this.addChild(this.backgroundSprite),
            (this.characterPortaitSprite = new js(t)),
            this.characterPortaitSprite.position.set(4, 4),
            this.characterPortaitSprite.setScale(0.8),
            this.addChild(this.characterPortaitSprite),
            (this.weaponSprite = new js(t)),
            this.weaponSprite.position.set(64, 4),
            this.weaponSprite.setScale(0.8),
            this.addChild(this.weaponSprite),
            (this.abilitySprite = new js(t)),
            this.abilitySprite.position.set(108, 4),
            this.abilitySprite.setScale(0.8),
            this.addChild(this.abilitySprite),
            (this.armorSprite = new js(t)),
            this.armorSprite.position.set(152, 4),
            this.armorSprite.setScale(0.8),
            this.addChild(this.armorSprite),
            (this.accessorySprite = new js(t)),
            this.accessorySprite.position.set(196, 4),
            this.accessorySprite.setScale(0.8),
            this.addChild(this.accessorySprite),
            (this.dpsText = t.text({})),
            this.dpsText.position.set(256, 16),
            this.addChild(this.dpsText);
        }
        onThemeUpdate(t) {
          this.dpsText.style.fill = t.windowTextColor;
        }
        appendData(t, e, i, n) {
          var s, r, o, a, l, u, h, c, d, p, f, m;
          (this.backgroundSprite.tint = i),
            this.characterPortaitSprite.createPortrait(t.classData.type);
          const g =
              null !==
                (o =
                  null ===
                    (r =
                      null === (s = t.equipment[Re.Weapon]) || void 0 === s
                        ? void 0
                        : s.base) || void 0 === r
                    ? void 0
                    : r.id) && void 0 !== o
                ? o
                : 0,
            v = t.classData.equipmentSlots[Re.Weapon];
          (this.weaponSprite.visible = 0 != g),
            this.weaponSprite.createEquipment(g, v);
          const y =
              null !==
                (u =
                  null ===
                    (l =
                      null === (a = t.equipment[Re.Ability]) || void 0 === a
                        ? void 0
                        : a.base) || void 0 === l
                    ? void 0
                    : l.id) && void 0 !== u
                ? u
                : 0,
            x = t.classData.equipmentSlots[Re.Ability];
          (this.abilitySprite.visible = 0 != y),
            this.abilitySprite.createEquipment(y, x);
          const b =
              null !==
                (d =
                  null ===
                    (c =
                      null === (h = t.equipment[Re.Armor]) || void 0 === h
                        ? void 0
                        : h.base) || void 0 === c
                    ? void 0
                    : c.id) && void 0 !== d
                ? d
                : 0,
            S = t.classData.equipmentSlots[Re.Armor];
          (this.armorSprite.visible = 0 != b),
            this.armorSprite.createEquipment(b, S);
          const C =
              null !==
                (m =
                  null ===
                    (f =
                      null === (p = t.equipment[Re.Accessory]) || void 0 === p
                        ? void 0
                        : p.base) || void 0 === f
                    ? void 0
                    : f.id) && void 0 !== m
                ? m
                : 0,
            _ = t.classData.equipmentSlots[Re.Accessory];
          (this.accessorySprite.visible = 0 != C),
            this.accessorySprite.createEquipment(C, _);
          const T = `${Ve.separators(e, 1)} ${n}`;
          this.dpsText.text = T;
        }
      }
      class ao extends Ge {
        constructor(t, e) {
          super(t, e),
            (this.maxCharacterRows = 18),
            (this.characterRows = new Array()),
            (this.characterRowsContainer = new Gt.mc()),
            this.addElement(this.characterRowsContainer);
        }
        create() {
          for (let t = 0; t < this.maxCharacterRows; t++) {
            const t = new oo(this.ui);
            this.characterRows.push(t), this.characterRowsContainer.addChild(t);
          }
          this.updateBounds();
        }
        onThemeUpdate(t) {
          var e;
          const i =
            null !== (e = t.tooltip.default) && void 0 !== e
              ? e
              : "gray_tooltip_frame";
          this.setBackgroundTexture(i);
          for (const e of this.characterRows) e.onThemeUpdate(t);
        }
        appendData(t, e, i) {
          let n = 4;
          this.characterRows.forEach((t) => (t.visible = !1));
          for (let s = 0; s < t.length && s < this.maxCharacterRows; s++)
            (this.characterRows[s].visible = !0),
              this.characterRows[s].appendData(t[s], e[s], t[s].lineColor, i),
              this.characterRows[s].position.set(4, n),
              (n += 48);
          this.updateBounds();
        }
      }
      class lo extends Jr {
        constructor(t, e) {
          super(t, e);
        }
        appendText(t, e, i, n, s, r) {
          var o;
          if (0 != t.baseData.castCount) {
            let e = `${Ve.separators(t.baseData.castCount)} casts`;
            r += this.pollText(e, 0.5 * this.parentWidth, r, ti.lightyellow);
          }
          const a = Array.from(t.procsData.entries());
          if (1 == s)
            for (let t = 0; t < a.length; t++) {
              const [i, n] = a[t];
              if (0 == n.recoveredHp && 0 == n.procCount) continue;
              switch (i.effectType) {
                case Fe.StatusEffect: {
                  if (0 == n.uptimeMs) continue;
                  const t = i;
                  if (
                    t.statusEffectType != Ie.Invulnerable &&
                    t.statusEffectType != Ie.Armored &&
                    t.statusEffectType != Ie.ArmorBroken &&
                    t.statusEffectType != Ie.Exposed &&
                    t.statusEffectType != Ie.Curse &&
                    t.statusEffectType != Ie.Healing &&
                    t.statusEffectType != Ie.Sick &&
                    t.statusEffectType != Ie.Bleeding
                  )
                    continue;
                  break;
                }
                case Fe.StatBoost:
                  if (0 == n.uptimeMs) continue;
                  if (
                    i.statType != Ee.MAXHP &&
                    i.statType != Ee.DEF &&
                    i.statType != Ee.VIT
                  )
                    continue;
              }
              const s = null !== (o = n.name) && void 0 !== o ? o : "Some Proc";
              if (
                ((r += this.pollText(s, 0.5 * this.parentWidth, r, ti.white)),
                n.recoveredHp > 0)
              ) {
                const t = Math.floor(n.recoveredHp),
                  e = t / n.procCount;
                let i = `${Ve.separators(t)} HP recovered (${Ve.separators(
                  e,
                  1
                )} HP per proc)`;
                r += this.pollText(
                  i,
                  0.5 * this.parentWidth,
                  r,
                  ti.lightyellow
                );
              }
              let l = `${n.procCount} procs`;
              if (n.uptimeMs > 0) {
                const t = (0.001 * n.uptimeMs) / e;
                l += ` (${Ve.percent(t, 2)} uptime)`;
              }
              r += this.pollText(l, 0.5 * this.parentWidth, r, ti.lightyellow);
            }
          return r;
        }
      }
      var uo = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class ho extends Zr {
        constructor(t, e) {
          super(t, e);
          const i = {
            frameTexture: "white_thin_frame",
            size: new Et.b(120, 32),
          };
          (this.timeSecondsFrame = new $e(
            t,
            Object.assign(Object.assign({}, i), {
              labelText: "Time",
              contentColor: ti.lightyellow,
              pivotY: 2,
            })
          )),
            (this.hitpointsFrame = new $e(
              t,
              Object.assign(Object.assign({}, i), {
                labelText: "Current HP",
                contentColor: ti.maxHp,
                pivotY: 2,
              })
            )),
            (this.damageTakenFrame = new $e(
              t,
              Object.assign(Object.assign({}, i), {
                labelText: "DMG Taken",
                contentColor: ti.orange,
                pivotY: 2,
              })
            )),
            (this.reportDetailsContainers = new Array());
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return uo(this, void 0, void 0, function* () {
            t.create.call(this), (this.titleText.text = "Resilience Report");
            this.timeSecondsFrame.updateBackground(),
              this.timeSecondsFrame.position.set(
                0.5 * this.options.size.x - 188,
                86
              ),
              this.addElement(this.timeSecondsFrame),
              this.hitpointsFrame.updateBackground(),
              this.hitpointsFrame.position.set(
                0.5 * this.options.size.x - 60,
                86
              ),
              this.addElement(this.hitpointsFrame),
              this.damageTakenFrame.updateBackground(),
              this.damageTakenFrame.position.set(
                0.5 * this.options.size.x + 68,
                86
              ),
              this.addElement(this.damageTakenFrame);
            for (let t = 0; t < 4; t++) {
              const t = new lo(this.ui, this.options.size.x);
              t.create(),
                this.addChild(t),
                this.reportDetailsContainers.push(t);
            }
            this.updateBounds();
          });
        }
        appendData(t, e, i, n, s) {
          const r = Object.create(null, {
            appendData: { get: () => super.appendData },
          });
          return uo(this, void 0, void 0, function* () {
            if (
              (yield r.appendData.call(this, t, e, i, n, s),
              this.reportDetailsContainers.map((t) => t.hide()),
              void 0 === e)
            )
              return;
            const o = e.steps[i];
            if (void 0 === o) return;
            this.setBackgroundColor(s);
            const a = Math.round(i);
            this.timeSecondsFrame.setBackgroundColor(s),
              this.timeSecondsFrame.setContentText(`${a} seconds`),
              this.hitpointsFrame.setBackgroundColor(s),
              this.hitpointsFrame.setContentText(
                `${Ve.separators(o.values[0])} / ${Ve.separators(o.values[1])}`
              ),
              this.damageTakenFrame.setBackgroundColor(s),
              this.damageTakenFrame.setContentText(
                `${Ve.separators(o.values[2])}`
              );
            const l = o.equipmentDetails.filter((t) => {
              let e = !1;
              for (const i of Array.from(t.procsData.keys()))
                switch (i.effectType) {
                  case Fe.StatusEffect: {
                    if (0 == t.uptimeMs) break;
                    const n = i;
                    (n.statusEffectType != Ie.Invulnerable &&
                      n.statusEffectType != Ie.Armored &&
                      n.statusEffectType != Ie.ArmorBroken &&
                      n.statusEffectType != Ie.Exposed &&
                      n.statusEffectType != Ie.Curse &&
                      n.statusEffectType != Ie.Healing &&
                      n.statusEffectType != Ie.Sick &&
                      n.statusEffectType != Ie.Bleeding) ||
                      (e = !0);
                    break;
                  }
                  case Fe.StatBoost:
                    if (0 == t.uptimeMs) break;
                    (i.statType != Ee.MAXHP &&
                      i.statType != Ee.DEF &&
                      i.statType != Ee.VIT) ||
                      (e = !0);
                    break;
                  case Fe.Heal:
                    e = !0;
                    break;
                  case Fe.Minion:
                    i.heal > 0 && (e = !0);
                    break;
                  case Fe.Projectile:
                    i.stealHp > 0 && (e = !0);
                }
              return e;
            });
            yield l.sort((t, e) => (t.slotMetaType > e.slotMetaType ? 1 : 0));
            const u = [];
            let h = 128;
            for (let r = 0; r < l.length; r++) {
              const o = this.reportDetailsContainers[r],
                a = r < l.length - 1,
                c = o.appendData(t, l[r], i, n, e.simulationTimeSeconds, s, a);
              u.push(c),
                o.position.set(0, h),
                (o.visible = !0),
                (h += o.height + 8);
            }
            yield Promise.all(u), this.updateBounds();
          });
        }
      }
      class co extends Jr {
        constructor(t, e) {
          super(t, e);
        }
        appendText(t, e, i, n, s, r) {
          var o;
          const a = i[1];
          if (0 != t.damageDone) {
            const i = t.damageDone / e,
              n = Ve.percent(i / a, 2),
              o = `${Ve.separators(i, 1)} DPS (${n} of total)`;
            if (
              ((r += this.pollText(o, 0.5 * this.parentWidth, r, ti.orange)),
              0 != t.baseData.damageDone)
            ) {
              let e = `${Ve.separators(t.baseData.damageDone)} DMG`;
              if (
                0 != t.baseData.hitCount &&
                ((e += ` in ${Ve.separators(t.baseData.hitCount)} hits`),
                1 == s)
              ) {
                e += ` (${Ve.separators(
                  t.baseData.damageDone / t.baseData.hitCount,
                  1
                )} DMG per hit)`;
              }
              r += this.pollText(e, 0.5 * this.parentWidth, r, ti.lightyellow);
            }
          }
          if (0 != t.baseData.castCount) {
            let e = `${Ve.separators(t.baseData.castCount)} casts`;
            if (
              1 == s &&
              (0 != t.baseData.damageDone || 0 != t.baseData.mpSpent)
            ) {
              if (((e += " ("), 0 != t.baseData.damageDone)) {
                (e += `${Ve.separators(
                  t.baseData.damageDone / t.baseData.castCount,
                  1
                )} DMG`),
                  0 != t.baseData.mpSpent && (e += ", ");
              }
              if (0 != t.baseData.mpSpent) {
                e += `${Ve.separators(
                  t.baseData.mpSpent / t.baseData.castCount,
                  1
                )} MP`;
              }
              e += " per cast)";
            }
            r += this.pollText(e, 0.5 * this.parentWidth, r, ti.lightyellow);
          }
          const l = Array.from(t.procsData.entries()).sort((t, e) =>
            t[1].damageDone < e[1].damageDone ? 1 : -1
          );
          if (1 == s)
            for (let i = 0; i < l.length; i++) {
              const [n, s] = l[i];
              if (0 == s.damageDone && 0 == s.castCount && 0 == s.procCount)
                continue;
              const a =
                null !== (o = s.name) && void 0 !== o ? o : "Not Defined Proc";
              if (
                ((r += this.pollText(a, 0.5 * this.parentWidth, r, ti.white)),
                0 != s.damageDone)
              ) {
                const i = s.damageDone / e,
                  n = Ve.percent(i / t.damageDone, 2),
                  o = `${Ve.separators(i, 1)} DPS (${n} of total)`;
                r += this.pollText(
                  o,
                  0.5 * this.parentWidth,
                  r,
                  ti.lightyellow
                );
                let a = `${Ve.separators(s.damageDone)} DMG`;
                if (0 != s.hitCount) {
                  const t = Ve.separators(s.damageDone / s.hitCount, 1);
                  a += ` in ${Ve.separators(
                    s.hitCount
                  )} hits (${t} DMG per hit)`;
                }
                r += this.pollText(
                  a,
                  0.5 * this.parentWidth,
                  r,
                  ti.lightyellow
                );
              }
              if (0 != s.procCount) {
                if (0 != s.value && n.effectType === Fe.Magic) {
                  const t = s.value / s.procCount;
                  let e = `${Math.round(s.value)} MP recovered (${Ve.separators(
                    t,
                    1
                  )} MP per proc)`;
                  r += this.pollText(
                    e,
                    0.5 * this.parentWidth,
                    r,
                    ti.lightyellow
                  );
                }
                let t = `${s.procCount} procs`;
                if (
                  0 == s.uptimeMs ||
                  (n.effectType != Fe.StatBoost &&
                    n.effectType != Fe.StatusEffect)
                ) {
                  if (0 != s.damageDone) {
                    t += ` (${Ve.separators(
                      s.damageDone / s.procCount,
                      1
                    )} DMG per proc)`;
                  }
                } else {
                  const i = (0.001 * s.uptimeMs) / e;
                  t += ` (${Ve.percent(i, 2)} uptime)`;
                }
                if (
                  ((r += this.pollText(
                    t,
                    0.5 * this.parentWidth,
                    r,
                    ti.lightyellow
                  )),
                  0 != s.mpSpent)
                ) {
                  const t = Ve.separators(s.mpSpent / s.procCount, 1);
                  let e = `${Ve.separators(
                    s.mpSpent
                  )} MP drained (${t} MP per proc)`;
                  r += this.pollText(
                    e,
                    0.5 * this.parentWidth,
                    r,
                    ti.lightyellow
                  );
                }
              }
            }
          return r;
        }
      }
      var po = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class fo extends Zr {
        constructor(t, e) {
          super(t, e);
          const i = {
            frameTexture: "white_thin_frame",
            size: new Et.b(120, 32),
          };
          (this.timeSecondsFrame = new $e(
            t,
            Object.assign(Object.assign({}, i), {
              labelText: "Time",
              contentColor: ti.lightyellow,
              pivotY: 2,
            })
          )),
            (this.targetHPFrame = new $e(
              t,
              Object.assign(Object.assign({}, i), {
                labelText: "Target HP",
                contentColor: ti.maxHp,
                pivotY: 2,
              })
            )),
            (this.totalDPSFrame = new $e(
              t,
              Object.assign(Object.assign({}, i), {
                labelText: "DPS",
                contentColor: ti.orange,
                pivotY: 2,
              })
            )),
            (this.reportDetailsContainers = new Array());
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return po(this, void 0, void 0, function* () {
            t.create.call(this), (this.titleText.text = "Target Burst Report");
            this.timeSecondsFrame.updateBackground(),
              this.timeSecondsFrame.position.set(
                0.5 * this.options.size.x - 188,
                86
              ),
              this.addElement(this.timeSecondsFrame),
              this.targetHPFrame.updateBackground(),
              this.targetHPFrame.position.set(
                0.5 * this.options.size.x - 60,
                86
              ),
              this.addElement(this.targetHPFrame),
              this.totalDPSFrame.updateBackground(),
              this.totalDPSFrame.position.set(
                0.5 * this.options.size.x + 68,
                86
              ),
              this.addElement(this.totalDPSFrame);
            for (let t = 0; t < 4; t++) {
              const t = new co(this.ui, this.options.size.x);
              t.create(),
                this.addChild(t),
                this.reportDetailsContainers.push(t);
            }
            this.updateBounds();
          });
        }
        appendData(t, e, i, n, s) {
          const r = Object.create(null, {
            appendData: { get: () => super.appendData },
          });
          return po(this, void 0, void 0, function* () {
            if (
              (yield r.appendData.call(this, t, e, i, n, s),
              this.reportDetailsContainers.map((t) => t.hide()),
              void 0 === e)
            )
              return;
            const o = e.steps[i];
            if (void 0 === o) return;
            this.setBackgroundColor(s),
              this.timeSecondsFrame.setBackgroundColor(s),
              this.timeSecondsFrame.setContentText(`${Math.round(i)} seconds`),
              this.targetHPFrame.setBackgroundColor(s);
            const a = o.values[0] / e.character.targetData.hitpoints;
            this.targetHPFrame.setContentText(
              `${Ve.separators(o.values[0])} (${Ve.percent(a, 1)})`
            ),
              this.totalDPSFrame.setBackgroundColor(s),
              this.totalDPSFrame.setContentText(Ve.separators(o.values[1], 1));
            const l = this.ui.app.settingsHandler.showReportDetails,
              u = o.equipmentDetails.filter(
                (t) =>
                  0 != t.damageDone ||
                  0 != t.castCount ||
                  (0 != t.procCount && 0 != l)
              );
            yield u.sort((t, e) => (t.damageDone < e.damageDone ? 1 : 0));
            const h = [];
            let c = 128;
            for (let r = 0; r < u.length; r++) {
              const o = this.reportDetailsContainers[r],
                a = r < u.length - 1,
                l = o.appendData(t, u[r], i, n, e.simulationTimeSeconds, s, a);
              h.push(l),
                o.position.set(0, c),
                (o.visible = !0),
                (c += o.height + 8);
            }
            yield Promise.all(h), this.updateBounds();
          });
        }
      }
      var mo = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class go extends Ge {
        constructor(t, e) {
          super(t, e);
          const i = new Gt.mc();
          (i.position.x = 16),
            this.addElement(i),
            (this.sprite = new js(t)),
            this.sprite.position.set(20, 56),
            this.sprite.anchor.set(0.5, 1),
            i.addChild(this.sprite),
            (this.nameText = t.themedText({ style: { fontSize: 28 } })),
            i.addChild(this.nameText),
            (this.detailsContainerBackground = new Xt.k(a.g.WHITE)),
            (this.detailsContainerBackground.position.x = -10),
            i.addChild(this.detailsContainerBackground),
            (this.detailsContainer = new Gt.mc()),
            i.addChild(this.detailsContainer),
            (this.soulboundLabelText = t.themedText({ text: "Soulbound" })),
            this.detailsContainer.addChild(this.soulboundLabelText),
            (this.descriptionText = t.text({
              style: {
                fill: ti.gray,
                wordWrap: !0,
                wordWrapWidth: this.options.size.x - 32,
              },
            })),
            this.detailsContainer.addChild(this.descriptionText),
            (this.playerClassLabelText = t.themedText({
              text: "Player Class:",
            })),
            this.detailsContainer.addChild(this.playerClassLabelText),
            (this.playerClassValueText = t.text({
              style: { fill: ti.lightyellow },
            })),
            (this.playerClassValueText.position.x =
              this.playerClassLabelText.width + 4),
            this.detailsContainer.addChild(this.playerClassValueText),
            (this.petFamilyLabelText = t.themedText({ text: "Pet Family:" })),
            this.detailsContainer.addChild(this.petFamilyLabelText),
            (this.petFamilyValueText = t.text({
              style: { fill: ti.lightyellow },
            })),
            (this.petFamilyValueText.position.x =
              this.petFamilyLabelText.width + 4),
            this.detailsContainer.addChild(this.petFamilyValueText),
            (this.feedPowerText = t.themedText({})),
            i.addChild(this.feedPowerText),
            (this.bagTypeSprite = new Xt.k()),
            this.bagTypeSprite.scale.set(3, 3),
            this.bagTypeSprite.anchor.set(0.5, 0.5),
            i.addChild(this.bagTypeSprite),
            (this.paddingSprite = new Xt.k(a.g.EMPTY)),
            (this.paddingSprite.height = 16),
            i.addChild(this.paddingSprite);
        }
        appendData(t, e) {
          return mo(this, void 0, void 0, function* () {
            var i, n;
            yield e
              ? this.sprite.createPetSkin(t.id, t.type)
              : this.sprite.createPlayerSkin(t.id, t.type),
              this.setName(t.name),
              this.sprite.position.set(20, 12 + this.sprite.height);
            let s = 36 + Math.floor(0.5 * this.sprite.height);
            (this.detailsContainerBackground.tint =
              null !==
                (n =
                  null === (i = this.ui.theme) || void 0 === i
                    ? void 0
                    : i.tooltip.detailsBackgroundColor) && void 0 !== n
                ? n
                : 2960685),
              (this.detailsContainerBackground.position.y = s + 8),
              (this.detailsContainer.position.y = s + 8);
            let r = 8;
            (this.soulboundLabelText.visible = t.soulbound),
              1 == t.soulbound &&
                (r += Ve.setYPosition(this.soulboundLabelText, r));
            const o = 0 != t.description.length;
            (this.descriptionText.visible = o),
              1 == o &&
                ((this.descriptionText.text = t.description),
                (r += Ve.setYPosition(this.descriptionText, r))),
              (this.playerClassLabelText.visible = !e),
              (this.playerClassValueText.visible = !e),
              1 == this.playerClassLabelText.visible &&
                ((this.playerClassValueText.text = Di[t.type]),
                (this.playerClassLabelText.position.y = r),
                (r += Ve.setYPosition(this.playerClassValueText, r))),
              (this.petFamilyLabelText.visible = e),
              (this.petFamilyValueText.visible = e),
              1 == this.petFamilyLabelText.visible &&
                ((this.petFamilyValueText.text = Fi[t.type]),
                (this.petFamilyLabelText.position.y = r),
                (r += Ve.setYPosition(this.petFamilyValueText, r))),
              (this.detailsContainerBackground.width =
                this.options.size.x - 10),
              (this.detailsContainerBackground.height =
                this.detailsContainer.height > 0
                  ? this.detailsContainer.height + 16
                  : 0),
              (s += this.detailsContainer.height + 34);
            const l = 0 != t.feedPower;
            if (
              ((this.feedPowerText.visible = l),
              1 == l &&
                ((this.feedPowerText.text = `Feed Power: ${t.feedPower}`),
                (s += Ve.setYPosition(this.feedPowerText, s))),
              this.paddingSprite.position.set(0, s),
              (this.bagTypeSprite.visible = !1),
              (this.sprite.visible = !1),
              this.updateBounds(),
              (this.sprite.visible = !0),
              t.bagType > Bi.None)
            ) {
              (this.bagTypeSprite.visible = !0),
                this.bagTypeSprite.position.set(
                  this.options.size.x - 38,
                  this.options.size.y - 22
                );
              const e = (yield this.ui.getTexture("ui/icons/bags")).source,
                i = { x: 8 * t.bagType, y: 0, width: 8, height: 8 };
              this.bagTypeSprite.texture = new a.g({ source: e, frame: i });
            }
          });
        }
        setName(t) {
          if (void 0 === this.nameText) return;
          const e = t.length > 18 ? 28 - Math.floor(0.6 * (t.length - 18)) : 28;
          (this.nameText.text = t),
            this.nameText.position.set(
              Math.floor(36 + 0.5 * this.sprite.width),
              14 + Math.floor(0.5 * this.nameText.height)
            ),
            (this.nameText.style.fontSize = e);
          const [i, n] = Ve.getBoundsReminder(this.nameText);
          this.nameText.pivot.set(i, n);
        }
      }
      var vo = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class yo extends ai {
        constructor(t) {
          super(t),
            (this.onMouseMoveBinding = this.onMouseMove.bind(this)),
            (this.onMouseLeaveBinding = this.onMouseLeave.bind(this));
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return vo(this, void 0, void 0, function* () {
            var e, i, n;
            const s =
              null !==
                (n =
                  null ===
                    (i =
                      null === (e = this.app.ui.theme) || void 0 === e
                        ? void 0
                        : e.tooltip) || void 0 === i
                    ? void 0
                    : i.default) && void 0 !== n
                ? n
                : "gray_tooltip_frame";
            (this.informationFrame = new Yr(this.app.ui, {
              frameTexture: s,
              anchor: Ve.TOP_LEFT,
              padding: { x: 36, y: 24 },
              autoWidth: !0,
              autoHeight: !0,
              centerChildren: !0,
            })),
              (this.informationFrame.eventMode = "none"),
              (this.informationFrame.interactiveChildren = !1),
              this.informationFrame.hide(),
              (this.informationFrame.zIndex = 99),
              this.informationFrame.create(),
              this.app.canvas.addChild(this.informationFrame),
              (this.damageReportFrame = new io(this.app.ui, {
                frameTexture: s,
                size: new Et.b(400, 0),
                anchor: Ve.TOP_LEFT,
                padding: new Et.b(24, 24),
                autoHeight: !0,
              })),
              (this.damageReportFrame.eventMode = "none"),
              (this.damageReportFrame.interactiveChildren = !1),
              this.damageReportFrame.hide(),
              (this.damageReportFrame.zIndex = 99),
              this.damageReportFrame.create(),
              this.app.canvas.addChild(this.damageReportFrame),
              (this.burstReportFrame = new fo(this.app.ui, {
                frameTexture: s,
                size: new Et.b(400, 0),
                anchor: Ve.TOP_LEFT,
                padding: new Et.b(24, 24),
                autoHeight: !0,
              })),
              (this.burstReportFrame.eventMode = "none"),
              (this.burstReportFrame.interactiveChildren = !1),
              this.burstReportFrame.hide(),
              (this.burstReportFrame.zIndex = 99),
              this.burstReportFrame.create(),
              this.app.canvas.addChild(this.burstReportFrame),
              (this.survivabilityReportFrame = new ho(this.app.ui, {
                frameTexture: s,
                size: new Et.b(400, 0),
                anchor: Ve.TOP_LEFT,
                padding: new Et.b(24, 24),
                autoHeight: !0,
              })),
              (this.survivabilityReportFrame.eventMode = "none"),
              (this.survivabilityReportFrame.interactiveChildren = !1),
              this.survivabilityReportFrame.hide(),
              (this.survivabilityReportFrame.zIndex = 99),
              this.survivabilityReportFrame.create(),
              this.app.canvas.addChild(this.survivabilityReportFrame),
              (this.travelReportFrame = new ro(this.app.ui, {
                frameTexture: s,
                size: new Et.b(400, 0),
                anchor: Ve.TOP_LEFT,
                padding: new Et.b(24, 24),
                autoHeight: !0,
              })),
              (this.travelReportFrame.eventMode = "none"),
              (this.travelReportFrame.interactiveChildren = !1),
              this.travelReportFrame.hide(),
              (this.travelReportFrame.zIndex = 99),
              this.travelReportFrame.create(),
              this.app.canvas.addChild(this.travelReportFrame),
              (this.reportsSummaryFrame = new ao(this.app.ui, {
                frameTexture: s,
                size: new Et.b(368, 0),
                anchor: Ve.TOP_LEFT,
                padding: new Et.b(24, 8),
                autoHeight: !0,
              })),
              (this.reportsSummaryFrame.eventMode = "none"),
              (this.reportsSummaryFrame.interactiveChildren = !1),
              this.reportsSummaryFrame.hide(),
              (this.reportsSummaryFrame.zIndex = 99),
              this.reportsSummaryFrame.create(),
              this.app.canvas.addChild(this.reportsSummaryFrame),
              (this.equipmentDescriptionFrame = new Wr(this.app.ui, {
                frameTexture: s,
                size: new Et.b(360, 0),
                anchor: Ve.TOP_LEFT,
                padding: new Et.b(24, 24),
                autoHeight: !0,
              })),
              (this.equipmentDescriptionFrame.eventMode = "none"),
              (this.equipmentDescriptionFrame.interactiveChildren = !1),
              this.equipmentDescriptionFrame.hide(),
              (this.equipmentDescriptionFrame.zIndex = 99),
              this.app.canvas.addChild(this.equipmentDescriptionFrame),
              (this.characterDescriptionFrame = new $r(this.app.ui, {
                frameTexture: s,
                anchor: Ve.TOP_LEFT,
                padding: new Et.b(24, 24),
                size: new Et.b(264, 0),
                autoHeight: !0,
              })),
              (this.characterDescriptionFrame.eventMode = "none"),
              (this.characterDescriptionFrame.interactiveChildren = !1),
              this.characterDescriptionFrame.hide(),
              (this.characterDescriptionFrame.zIndex = 99),
              this.characterDescriptionFrame.create(),
              this.app.canvas.addChild(this.characterDescriptionFrame),
              (this.skinDescriptionFrame = new go(this.app.ui, {
                frameTexture: s,
                size: new Et.b(360, 0),
                anchor: Ve.TOP_LEFT,
                padding: new Et.b(24, 24),
                autoHeight: !0,
              })),
              (this.skinDescriptionFrame.eventMode = "none"),
              (this.skinDescriptionFrame.interactiveChildren = !1),
              this.skinDescriptionFrame.hide(),
              (this.skinDescriptionFrame.zIndex = 99),
              this.app.canvas.addChild(this.skinDescriptionFrame),
              t.create.call(this);
          });
        }
        onThemeUpdate(t) {
          var e, i, n, s, r, o, a, l, u;
          null === (e = this.reportsSummaryFrame) ||
            void 0 === e ||
            e.onThemeUpdate(t);
          const h =
            null !== (i = t.tooltip.default) && void 0 !== i
              ? i
              : "gray_tooltip_frame";
          null === (n = this.informationFrame) ||
            void 0 === n ||
            n.setBackgroundTexture(h),
            null === (s = this.damageReportFrame) ||
              void 0 === s ||
              s.setBackgroundTexture(h),
            null === (r = this.burstReportFrame) ||
              void 0 === r ||
              r.setBackgroundTexture(h),
            null === (o = this.survivabilityReportFrame) ||
              void 0 === o ||
              o.setBackgroundTexture(h),
            null === (a = this.travelReportFrame) ||
              void 0 === a ||
              a.setBackgroundTexture(h),
            null === (l = this.characterDescriptionFrame) ||
              void 0 === l ||
              l.setBackgroundTexture(h),
            null === (u = this.skinDescriptionFrame) ||
              void 0 === u ||
              u.setBackgroundTexture(h);
        }
        updateCharacterDescription(t) {
          return vo(this, void 0, void 0, function* () {
            var e;
            void 0 !== t &&
              (null === (e = this.characterDescriptionFrame) || void 0 === e
                ? void 0
                : e.characterData) == t &&
              this.characterDescriptionFrame.appendData(t);
          });
        }
        showCharacterDescription(t) {
          return vo(this, void 0, void 0, function* () {
            void 0 !== this.characterDescriptionFrame &&
              (this.characterDescriptionFrame.appendData(t),
              this.show(this.characterDescriptionFrame));
          });
        }
        showDamageReportInformation(t, e, i, n) {
          return vo(this, void 0, void 0, function* () {
            void 0 !== this.damageReportFrame &&
              (this.damageReportFrame.appendData(t, e, i, e.steps[i].values, n),
              this.show(this.damageReportFrame));
          });
        }
        showBurstReportInformation(t, e, i, n) {
          return vo(this, void 0, void 0, function* () {
            void 0 !== this.burstReportFrame &&
              (this.burstReportFrame.appendData(t, e, i, e.steps[i].values, n),
              this.show(this.burstReportFrame));
          });
        }
        showResilienceReportInformation(t, e, i, n) {
          return vo(this, void 0, void 0, function* () {
            void 0 !== this.survivabilityReportFrame &&
              (this.survivabilityReportFrame.appendData(
                t,
                e,
                i,
                e.steps[i].values,
                n
              ),
              this.show(this.survivabilityReportFrame));
          });
        }
        showTravelReportInformation(t, e, i, n) {
          return vo(this, void 0, void 0, function* () {
            void 0 !== this.travelReportFrame &&
              (this.travelReportFrame.appendData(t, e, i, e.steps[i].values, n),
              this.show(this.travelReportFrame));
          });
        }
        showReportsSummaryInformation(t, e, i, n) {
          return vo(this, void 0, void 0, function* () {
            if (void 0 === this.reportsSummaryFrame) return;
            if (0 == t.length) return;
            t.sort((t, i) => {
              const s = t.data.steps[e].values[0],
                r = i.data.steps[e].values[0];
              return 0 == n ? s - r : r - s;
            });
            const s = t.map((t) => t.data.character),
              r = t.map((t) => t.data.steps[e].values[0]);
            this.reportsSummaryFrame.appendData(s, r, i),
              this.show(this.reportsSummaryFrame);
          });
        }
        showEquipmentDescription(t, e, i, n) {
          return vo(this, void 0, void 0, function* () {
            void 0 !== this.equipmentDescriptionFrame &&
              (this.equipmentDescriptionFrame.appendData(t, e, i, n),
              this.show(this.equipmentDescriptionFrame));
          });
        }
        showInformation(t) {
          return vo(this, arguments, void 0, function* (t, e = 16777215) {
            void 0 !== this.informationFrame &&
              (this.informationFrame.appendData(t, e),
              this.show(this.informationFrame));
          });
        }
        showSkinDescription(t) {
          return vo(this, arguments, void 0, function* (t, e = !1) {
            void 0 !== this.skinDescriptionFrame &&
              (this.skinDescriptionFrame.appendData(t, e),
              this.show(this.skinDescriptionFrame));
          });
        }
        showDyeDescription(t) {
          return vo(this, arguments, void 0, function* (t, e = !1) {
            if (this.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
              return;
            const i = new Array([t.name, ti.white]);
            0 == e &&
              i.push(
                ["Left Click to Use As Large Dye", ti.orange],
                ["Right Click to Use As Small Dye", ti.blue]
              ),
              this.showInformation(i);
          });
        }
        showMissingDataInformation(t) {
          return vo(this, void 0, void 0, function* () {
            const e = t.toLowerCase();
            this.showInformation(
              [
                [`Missing ${t} Data`, ti.red],
                [`Following ${e} data is still missing.`, ti.orange],
                [`If you manage to get this ${e}, please send`, ti.orange],
                [
                  "a message in https://discord.gg/uDK2EhJUtv",
                  ti.orange,
                ],
                ["I will try to add it as soon as possible.", ti.orange],
              ],
              ti.red
            );
          });
        }
        onMouseMove(t) {
          if (void 0 === this.currentlyShownFrame) return;
          (this.currentlyShownFrame.pivot.x =
            t.clientX < 0.5 * window.innerWidth
              ? -this.currentlyShownFrame.width
              : 0),
            (this.currentlyShownFrame.pivot.y =
              t.clientY > 0.5 * window.innerHeight
                ? this.currentlyShownFrame.height
                : 0);
          const e = this.currentlyShownFrame.pivot.x,
            i =
              window.innerWidth -
              this.currentlyShownFrame.width +
              this.currentlyShownFrame.pivot.x,
            n = Ve.clamp(
              t.clientX -
                this.currentlyShownFrame.width +
                (0 == this.currentlyShownFrame.pivot.x ? -8 : 8),
              e,
              i
            ),
            s = this.currentlyShownFrame.pivot.y,
            r =
              window.innerHeight -
              this.currentlyShownFrame.height +
              this.currentlyShownFrame.pivot.y +
              this.currentlyShownFrame.pivot.y,
            o = Ve.clamp(
              t.clientY + (0 == this.currentlyShownFrame.pivot.y ? 8 : -8),
              s,
              r
            );
          this.currentlyShownFrame.position.set(n, o);
        }
        onMouseLeave(t) {
          this.hide();
        }
        show(t) {
          (this.currentlyShownFrame = t),
            this.currentlyShownFrame.show(),
            window.addEventListener("mousemove", this.onMouseMoveBinding);
        }
        hide() {
          var t;
          null === (t = this.currentlyShownFrame) || void 0 === t || t.hide(),
            window.removeEventListener("mousemove", this.onMouseMoveBinding);
        }
      }
      var xo = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class bo extends ai {
        constructor(t) {
          super(t);
        }
        setLastCheckedVersion(t) {
          var e;
          const i =
            null !== (e = localStorage.getItem("lastVersion")) && void 0 !== e
              ? e
              : "";
          return localStorage.setItem("lastVersion", t), i === t;
        }
        checkLastCheckedVersion(t) {
          var e;
          return (
            (null !== (e = localStorage.getItem("lastVersion")) && void 0 !== e
              ? e
              : "") === t
          );
        }
        tryDecode(t) {
          try {
            return JSON.parse(atob(t));
          } catch (t) {
            return;
          }
        }
        importCharacters(t) {
          return xo(this, void 0, void 0, function* () {
            const e = this.tryDecode(t);
            return void 0 === e
              ? "Invalid import code."
              : (yield this.app.charactersHandler.importCharacters(e),
                yield this.saveCharactersToCache(),
                "Characters have been imported successfully.");
          });
        }
        importItemChecklist(t) {
          return xo(this, void 0, void 0, function* () {
            const e = this.tryDecode(t);
            return void 0 === e
              ? Promise.resolve("Invalid import code.")
              : (yield this.app.itemChecklistHandler.appendData(e),
                yield this.saveItemChecklistToCache(),
                Promise.resolve(
                  "Item checklist has been imported successfully."
                ));
          });
        }
        loadFromCache() {
          return xo(this, void 0, void 0, function* () {
            yield this.loadCharactersFromCache(),
              yield this.loadItemChecklistFromCache(),
              yield this.loadSettingsFromCache();
          });
        }
        loadCharactersFromCache() {
          return xo(this, void 0, void 0, function* () {
            const t = localStorage.getItem("characters");
            if (null === t) return Promise.resolve([]);
            const e = yield atob(t),
              i = JSON.parse(e);
            return Promise.resolve(i);
          });
        }
        loadItemChecklistFromCache() {
          return xo(this, void 0, void 0, function* () {
            const t = localStorage.getItem("itemChecklist");
            if (null === t)
              return Promise.resolve({
                selectedItems: [],
                selectedCategories: [zi.Shiny],
                searchbar: "",
              });
            const e = yield atob(t),
              i = JSON.parse(e);
            return Promise.resolve(i);
          });
        }
        loadSettingsFromCache() {
          const t = localStorage.getItem("settings");
          if (null === t) return;
          const e = atob(t);
          return JSON.parse(e);
        }
        saveCharactersToCache() {
          if (!this.app.settingsHandler.saveCharacters) return;
          const t = this.getCharactersCode();
          localStorage.setItem("characters", t);
        }
        saveItemChecklistToCache() {
          const t = this.getItemChecklistCode();
          localStorage.setItem("itemChecklist", t);
        }
        saveSettingsToCache() {
          const t = this.getSettingsCode();
          localStorage.setItem("settings", t);
        }
        getCharactersCode() {
          const t = this.app.charactersHandler.getCharacterInstances(),
            e = this.getCharactersCacheData(t),
            i = JSON.stringify(e);
          return btoa(i);
        }
        getItemChecklistCode() {
          const t = this.app.itemChecklistHandler.getCacheData(),
            e = JSON.stringify(t);
          return btoa(e);
        }
        getSettingsCode() {
          const t = this.app.settingsHandler.getSettingsData(),
            e = JSON.stringify(t);
          return btoa(e);
        }
        getCharactersCacheData(t) {
          const e = new Array();
          for (let i = 0; i < t.length; i++) {
            const n = t[i],
              s = this.characterInstanceToCacheData(n);
            e.push(s);
          }
          return e;
        }
        characterInstanceToCacheData(t) {
          var e, i, n, s, r, o, a, l, u, h;
          const c = t.classData.type,
            d = new Array(),
            p = new Array(),
            f = new Array(),
            m = new Array(),
            g = new Array(),
            v = new Array();
          for (let u = 0; u < 4; u++) {
            (d[u] =
              null !==
                (n =
                  null ===
                    (i =
                      null === (e = t.equipment[u]) || void 0 === e
                        ? void 0
                        : e.base) || void 0 === i
                    ? void 0
                    : i.id) && void 0 !== n
                ? n
                : 0),
              (p[u] = new Array());
            const h =
              null !==
                (r =
                  null === (s = t.equipment[u]) || void 0 === s
                    ? void 0
                    : s.enchants.length) && void 0 !== r
                ? r
                : 0;
            for (let e = 0; e < h; e++)
              p[u][e] =
                null !==
                  (l =
                    null ===
                      (a =
                        null === (o = t.equipment[u]) || void 0 === o
                          ? void 0
                          : o.enchants[e]) || void 0 === a
                      ? void 0
                      : a.id) && void 0 !== l
                  ? l
                  : 0;
          }
          const y = Object.keys(Ie).length / 2;
          for (let e = 0; e < y; e++)
            !0 === t.playerPermaStatusEffects.get(e) && f.push(e),
              !0 === t.targetPermaStatusEffects.get(e) && m.push(e),
              !0 === t.targetImmunities.get(e) && g.push(e);
          for (let e = 0; e < 8; e++) {
            const i =
              null !==
                (h =
                  null === (u = t.stats.getStat(e)) || void 0 === u
                    ? void 0
                    : u.exaltationValue) && void 0 !== h
                ? h
                : 0;
            v[e] = i;
          }
          return {
            classType: c,
            equipment: d,
            enchants: p,
            exaltStats: v,
            damageExaltationLevel: t.damageExaltationLevel,
            inCombatExaltationLevel: t.inCombatExaltationLevel,
            petHeal: t.petHealLevel,
            petMagicHeal: t.petMagicHealLevel,
            hpPercent: t.startingHpPercent,
            mpPercent: t.startingMpPercent,
            weaponAccuracy: t.weaponShotsAccuracy,
            abilityAccuracy: t.abilityShotsAccuracy,
            playerStatusEffects: f,
            targetStatusEffects: m,
            targetImmunities: g,
            abilityUse: Number(t.abilityUse),
            abilityMode: Number(t.abilityMode),
            statusEffectsMode: Number(t.applyStatusEffects),
            onhitProcTrigger: t.onhitProcTrigger,
            hitDamage: t.hitDamage,
            hitIntervalMs: t.hitIntervalMs,
            chartLineColor: t.lineColor,
            targetType: t.targetData.name,
            targetHp: t.targetData.hitpoints,
            targetDefense: t.targetData.defense,
            targetHeal: t.targetData.heal,
          };
        }
      }
      class So extends ai {
        constructor(t) {
          super(t),
            (this.uiThemeDefaultValue = Rr.Default),
            (this.saveCharactersDefaultValue = !0),
            (this.starterEquipmentDefaultValue = Dr.StarterEquipment),
            (this.showGuidanceTooltipsDefaultValue = ei.AllEnabled),
            (this.showReportDetailsDefaultValue = !0),
            (this.playSoundDefaultValue = !0),
            (this.simulationTimeSecondsDefaultValue = 30),
            (this.inGamePingMsDefaultValue = Ti.Ping20Ms),
            (this.skinViewerDisclaimerReadDefaultValue = !1),
            (this.startupToolDefaultValue = He.Calculator),
            (this._uiTheme = this.uiThemeDefaultValue),
            (this._saveCharacters = this.saveCharactersDefaultValue),
            (this._starterEquipment = this.starterEquipmentDefaultValue),
            (this._showGuidanceTooltips =
              this.showGuidanceTooltipsDefaultValue),
            (this._showReportDetails = this.showReportDetailsDefaultValue),
            (this._playSound = this.playSoundDefaultValue),
            (this._simulationTimeSeconds =
              this.simulationTimeSecondsDefaultValue),
            (this._inGamePingMs = this.inGamePingMsDefaultValue),
            (this._skinViewerDisclaimerRead =
              this.skinViewerDisclaimerReadDefaultValue),
            (this._startupTool = this.startupToolDefaultValue);
        }
        loadFromCache() {
          var t, e, i, n, s, r, o, a, l, u;
          const h = this.app.cacheHandler.loadSettingsFromCache();
          (this._uiTheme = Ve.clamp(
            null !== (t = null == h ? void 0 : h.uiTheme) && void 0 !== t
              ? t
              : this.uiThemeDefaultValue,
            Rr.Default,
            Rr.RealmEye
          )),
            (this._saveCharacters =
              null !== (e = null == h ? void 0 : h.saveCharacters) &&
              void 0 !== e
                ? e
                : this.saveCharactersDefaultValue),
            (this._starterEquipment = Ve.clamp(
              null !== (i = null == h ? void 0 : h.starterEquipment) &&
                void 0 !== i
                ? i
                : this.starterEquipmentDefaultValue,
              Dr.NoEquipment,
              Dr.RandomEquipment
            )),
            (this._showGuidanceTooltips = Ve.clamp(
              null !== (n = null == h ? void 0 : h.showGuidanceTooltips) &&
                void 0 !== n
                ? n
                : this.showGuidanceTooltipsDefaultValue,
              ei.AllDisabled,
              ei.CalculationsOnly
            )),
            (this._showReportDetails =
              null !== (s = null == h ? void 0 : h.showReportDetails) &&
              void 0 !== s
                ? s
                : this.showReportDetailsDefaultValue),
            (this._playSound =
              null !== (r = null == h ? void 0 : h.playSound) && void 0 !== r
                ? r
                : this.playSoundDefaultValue),
            (this._simulationTimeSeconds = Ve.clamp(
              null !== (o = null == h ? void 0 : h.simulationTimeSeconds) &&
                void 0 !== o
                ? o
                : this.simulationTimeSecondsDefaultValue,
              5,
              60
            )),
            (this._inGamePingMs = Ve.clamp(
              null !== (a = null == h ? void 0 : h.inGamePingMs) && void 0 !== a
                ? a
                : this.inGamePingMsDefaultValue,
              Ti.Ping20Ms,
              Ti.Ping200Ms
            )),
            (this._skinViewerDisclaimerRead =
              null !== (l = null == h ? void 0 : h.skinViewerDisclaimerRead) &&
              void 0 !== l
                ? l
                : this.skinViewerDisclaimerReadDefaultValue),
            (this._startupTool = Ve.clamp(
              null !== (u = null == h ? void 0 : h.startupTool) && void 0 !== u
                ? u
                : this.startupToolDefaultValue,
              He.Calculator,
              He.ItemChecklist
            )),
            this.app.ui.onThemeUpdate(this._uiTheme);
        }
        resetSettings() {
          (this._uiTheme = this.uiThemeDefaultValue),
            (this._saveCharacters = this.saveCharactersDefaultValue),
            (this._starterEquipment = this.starterEquipmentDefaultValue),
            (this._showGuidanceTooltips =
              this.showGuidanceTooltipsDefaultValue),
            (this._showReportDetails = this.showReportDetailsDefaultValue),
            (this._playSound = this.playSoundDefaultValue),
            (this._simulationTimeSeconds =
              this.simulationTimeSecondsDefaultValue),
            (this._inGamePingMs = this.inGamePingMsDefaultValue),
            (this._startupTool = this.startupToolDefaultValue),
            this.saveSettings(),
            this.app.chartHandler.updateSimulationTimeSeconds(
              this._simulationTimeSeconds
            ),
            this.app.ui.onThemeUpdate(this._uiTheme);
        }
        saveSettings() {
          this.app.cacheHandler.saveSettingsToCache();
        }
        getSettingsData() {
          return {
            uiTheme: this._uiTheme,
            saveCharacters: this._saveCharacters,
            starterEquipment: this._starterEquipment,
            showGuidanceTooltips: this._showGuidanceTooltips,
            showReportDetails: this._showReportDetails,
            playSound: this._playSound,
            simulationTimeSeconds: this._simulationTimeSeconds,
            inGamePingMs: this._inGamePingMs,
            skinViewerDisclaimerRead: this._skinViewerDisclaimerRead,
            startupTool: this._startupTool,
          };
        }
        get uiTheme() {
          return this._uiTheme;
        }
        set uiTheme(t) {
          (this._uiTheme = t),
            this.saveSettings(),
            this.app.ui.onThemeUpdate(t);
        }
        get saveCharacters() {
          return this._saveCharacters;
        }
        set saveCharacters(t) {
          (this._saveCharacters = t),
            this.saveSettings(),
            0 != t && this.app.cacheHandler.saveCharactersToCache();
        }
        get starterEquipment() {
          return this._starterEquipment;
        }
        set starterEquipment(t) {
          (this._starterEquipment = t), this.saveSettings();
        }
        get showGuidanceTooltips() {
          return this._showGuidanceTooltips;
        }
        set showGuidanceTooltips(t) {
          (this._showGuidanceTooltips = t), this.saveSettings();
        }
        get showReportDetails() {
          return this._showReportDetails;
        }
        set showReportDetails(t) {
          (this._showReportDetails = t), this.saveSettings();
        }
        get playSound() {
          return this._playSound;
        }
        set playSound(t) {
          (this._playSound = t), this.saveSettings();
        }
        get simulationTimeSeconds() {
          return this._simulationTimeSeconds;
        }
        set simulationTimeSeconds(t) {
          (this._simulationTimeSeconds = t),
            this.saveSettings(),
            this.app.chartHandler.updateSimulationTimeSeconds(t);
        }
        get inGamePingMs() {
          return this._inGamePingMs;
        }
        set inGamePingMs(t) {
          (this._inGamePingMs = t),
            this.saveSettings(),
            this.app.chartHandler.updateReportEntries();
        }
        get skinViewerDisclaimerRead() {
          return this._skinViewerDisclaimerRead;
        }
        set skinViewerDisclaimerRead(t) {
          (this._skinViewerDisclaimerRead = t), this.saveSettings();
        }
        get startupTool() {
          return this._startupTool;
        }
        set startupTool(t) {
          (this._startupTool = t), this.saveSettings();
        }
      }
      class Co {
        constructor(t) {
          (this.base = t), (this.enchants = new Array());
        }
        clear() {
          (this.base = void 0), (this.enchants = new Array());
        }
        appendData(t, e) {
          (this.base = t), (this.enchants = [...e]);
        }
      }
      var _o = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class To extends Ge {
        constructor(t, e, i, n) {
          super(t, e),
            (this.eventMode = "static"),
            (this.cursor = "pointer"),
            (this.slotType = i),
            (this.characterContainer = n),
            (this.equipmentInstance = new Co()),
            (this.equipmentContainer = new Zs(t)),
            (this.equipmentContainer.eventMode = "none"),
            this.addElement(this.equipmentContainer),
            this.addListener("click", this.onSlotClick.bind(this)),
            this.addListener("rightclick", this.onSlotRightClick.bind(this)),
            this.addListener("mouseenter", this.onSlotMouseEnter.bind(this)),
            this.addListener("mouseleave", this.onSlotMouseLeave.bind(this));
        }
        getEquipmentInstance() {
          return this.equipmentInstance;
        }
        setAbilityMode(t) {
          this.equipmentContainer.setAbilityMode(t);
        }
        appendData(t, e) {
          return _o(this, arguments, void 0, function* (t, e, i = []) {
            this.slotType = t;
            const n = yield this.ui.app.dataHandler.getEquipmentData(e, t);
            return (
              this.updateEquipmentInstance(n, i),
              Promise.resolve(this.equipmentInstance)
            );
          });
        }
        updateEquipmentInstance(t, e = []) {
          var i, n;
          this.equipmentInstance.appendData(t, e),
            this.equipmentContainer.create(
              null !== (i = null == t ? void 0 : t.id) && void 0 !== i ? i : 0,
              null !== (n = null == t ? void 0 : t.slotType) && void 0 !== n
                ? n
                : 0
            );
        }
        onSlotClick(t) {
          this.ui.playClickSound(),
            this.characterContainer.onSlotClick(this.slotType, t.shiftKey);
        }
        onSlotRightClick(t) {
          void 0 !== this.equipmentInstance.base &&
            this.characterContainer.onSlotRightClick(
              this.equipmentInstance,
              this.characterContainer
            );
        }
        onSlotMouseEnter(t) {
          if (
            (this.equipmentContainer.onMouseEnter(t),
            void 0 !== this.equipmentInstance.base)
          )
            return void this.ui.app.tooltipHandler.showEquipmentDescription(
              this.equipmentInstance.base,
              this.equipmentInstance.enchants,
              this.characterContainer.characterInstance,
              !0
            );
          const e = Re[Ve.slotMetaType(this.slotType)].toString(),
            i = new Array([`Empty ${e} Slot`, ti.white]);
          this.ui.app.settingsHandler.showGuidanceTooltips == ei.AllEnabled &&
            i.push(
              [`Left Click to Select ${e} Item`, ti.orange],
              ["Shift-Click to Equip S-Tier Item", ti.yellow]
            ),
            this.ui.app.tooltipHandler.showInformation(i);
        }
        onSlotMouseLeave(t) {
          this.equipmentContainer.onMouseLeave(t),
            this.ui.app.tooltipHandler.hide();
        }
      }
      var wo = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Po extends Me {
        constructor(t, e, i, n) {
          super(t),
            (this.characterInstance = new Ir(e, i)),
            (this.characterInstance.lineColor = n),
            (this.statusEffectTogglesMap = new Map()),
            (this.equipmentSlots = new Array()),
            (this.damageExaltationBar = new dr(t)),
            (this.onMouseLeaveBinding = this.onMouseLeave.bind(this));
        }
        create() {
          return wo(this, arguments, void 0, function* (t = !0) {
            var e, i, n, s;
            const r = 60,
              o = {
                frameTexture: "gray_inventory_frame",
                size: new Et.b(r, r),
                anchor: Ve.CENTER,
              };
            (this.backgroundSprite = new Xt.k(a.g.WHITE)),
              (this.backgroundSprite.alpha = 0.3),
              this.addChild(this.backgroundSprite),
              this.setBackgroundSize(
                this.ui.app.charactersHandler.scrollContainerOptions.itemSize.x,
                this.ui.app.charactersHandler.scrollContainerOptions.itemSize.y
              ),
              (this.classPortraitSprite = new js(this.ui)),
              this.classPortraitSprite.createPortrait(
                this.characterInstance.classData.type
              ),
              (this.classPortraitSprite.eventMode = "static"),
              (this.classPortraitSprite.cursor = "pointer"),
              this.classPortraitSprite.anchor.set(0.5, 0.5),
              this.classPortraitSprite.position.set(34, 34),
              this.classPortraitSprite.addListener(
                "click",
                this.onClassPortraitLeftClick.bind(this)
              ),
              this.classPortraitSprite.addListener(
                "rightclick",
                this.onClassPortraitRightClick.bind(this)
              ),
              this.classPortraitSprite.addListener(
                "mouseenter",
                this.onCharacterPortraitMouseEnter.bind(this)
              ),
              this.classPortraitSprite.addListener(
                "mouseleave",
                this.onMouseLeaveBinding
              ),
              this.addChild(this.classPortraitSprite),
              (this.moveContainerUpIcon = new oi(this.ui, {
                iconTexture: "arrow_up",
                onClick: this.onArrowUpClick.bind(this),
              })),
              this.moveContainerUpIcon.create(),
              this.moveContainerUpIcon.hide(),
              this.addChild(this.moveContainerUpIcon),
              (this.moveContainerDownIcon = new oi(this.ui, {
                iconTexture: "arrow_down",
                onClick: this.onArrowDownClick.bind(this),
              })),
              this.moveContainerDownIcon.create(),
              this.moveContainerDownIcon.hide(),
              this.addChild(this.moveContainerDownIcon),
              (this.eventMode = "static"),
              this.addListener(
                "mouseenter",
                this.onContainerMouseEnter.bind(this)
              ),
              this.addListener(
                "mouseleave",
                this.onContainerMouseLeave.bind(this)
              );
            const l = new Et.b(8, 4),
              u =
                null !==
                  (i =
                    null === (e = this.ui.theme) || void 0 === e
                      ? void 0
                      : e.inventorySlotTint) && void 0 !== i
                  ? i
                  : 16777215;
            for (let t = 0; t < 4; t++) {
              const e = new To(
                this.ui,
                o,
                this.characterInstance.classData.equipmentSlots[t],
                this
              );
              e.position.set(l.x + (t + 1.5) * r, l.y + 30),
                e.setBackgroundColor(u),
                this.addChild(e),
                (this.equipmentSlots[t] = e);
            }
            void 0 === this.characterInstance.damageExaltationLevel &&
              (this.characterInstance.damageExaltationLevel = 4),
              this.damageExaltationBar.position.set(l.x + 330, l.y + 30),
              this.damageExaltationBar.setExaltationStage(
                this.characterInstance.damageExaltationLevel
              ),
              this.addChild(this.damageExaltationBar),
              this.damageExaltationBar.addListener(
                "click",
                this.onDamageExaltationBarLeftClick.bind(this)
              ),
              this.damageExaltationBar.addListener(
                "mouseenter",
                this.onDamageExaltationBarMouseEnter.bind(this)
              ),
              this.damageExaltationBar.addListener(
                "mouseleave",
                this.onMouseLeaveBinding
              ),
              (this.colorPickerIcon = new oi(this.ui, {
                iconTexture: "color_picker",
                anchor: Ve.CENTER,
                guidanceTooltip: new Array(
                  ["Line Color", ti.white],
                  ["Left Click to Change Color", ti.orange],
                  ["Right Click to Randomize", ti.blue]
                ),
                onClick: this.onColorPickerLeftClick.bind(this),
                onRightClick: this.onColorPickerRightClick.bind(this),
              })),
              this.colorPickerIcon.create(),
              this.colorPickerIcon.position.set(20, 84),
              this.addChild(this.colorPickerIcon);
            const h =
              null !==
                (s =
                  null ===
                    (n =
                      this.ui.app.dataHandler.statusEffectDescriptionData.get(
                        Ie.InCombat
                      )) || void 0 === n
                    ? void 0
                    : n.map((t) => [t, ti.lightyellow])) && void 0 !== s
                ? s
                : [];
            (this.inCombatState = new oi(this.ui, {
              iconTexture: "solo_icon",
              anchor: Ve.CENTER,
              guidanceTooltip: new Array(
                ["In-Combat State Toggle", ti.white],
                ...h,
                ["Left Click to Toggle", ti.orange],
                ["Shift-Click to Toggle On All Characters", ti.yellow]
              ),
              onClick: (t) => this.onStatusEffectClick(t, Ie.InCombat, !0),
            })),
              this.inCombatState.create(),
              this.inCombatState.position.set(52, 84),
              this.addChild(this.inCombatState);
            let c = { x: 84, y: 86 },
              d = (yield this.ui.getTexture("ui/icons/status_effects")).source;
            if (
              (yield this.createToggableStatusEffectTypeHelper(
                c,
                Ie.Berserk,
                d
              ),
              yield this.createToggableStatusEffectTypeHelper(
                c,
                Ie.Damaging,
                d
              ),
              yield this.createToggableStatusEffectTypeHelper(
                c,
                Ie.Curse,
                d,
                !1
              ),
              yield this.createToggableStatusEffectTypeHelper(
                c,
                Ie.Exposed,
                d,
                !1
              ),
              yield this.createToggableStatusEffectTypeHelper(
                c,
                Ie.ArmorBroken,
                d,
                !1
              ),
              yield this.createToggableStatusEffectTypeHelper(c, Ie.Healing, d),
              yield this.createToggableStatusEffectTypeHelper(c, Ie.Dazed, d),
              yield this.createToggableStatusEffectTypeHelper(c, Ie.Weak, d),
              yield this.createToggableStatusEffectTypeHelper(
                c,
                Ie.Silenced,
                d
              ),
              yield this.createToggableStatusEffectTypeHelper(
                c,
                Ie.PetStasis,
                d
              ),
              (this.diceIcon = new oi(this.ui, {
                iconTexture: "dice_icon",
                anchor: Ve.CENTER,
                scale: 2,
                scaleOnHover: 2,
                alpha: 0.8,
                alphaOnHover: 1,
                guidanceTooltip: new Array(
                  ["Randomize Items", ti.white],
                  ["Left Click to Randomize", ti.orange]
                ),
                onClick: this.onDiceLeftClick.bind(this),
              })),
              this.diceIcon.create(),
              this.diceIcon.position.set(292, 84),
              this.addChild(this.diceIcon),
              (this.characterDeleteIcon = new oi(this.ui, {
                iconTexture: "delete_icon",
                anchor: Ve.CENTER,
                guidanceTooltip: new Array(
                  ["Delete Character", ti.white],
                  ["Left Click to Delete", ti.orange]
                ),
                onClick: this.onCharacterRemoveLeftClick.bind(this),
              })),
              this.characterDeleteIcon.create(),
              this.characterDeleteIcon.position.set(324, 84),
              this.addChild(this.characterDeleteIcon),
              (this.characterCloneIcon = new oi(this.ui, {
                iconTexture: "clone_icon",
                anchor: Ve.CENTER,
                guidanceTooltip: new Array(
                  ["Clone Character", ti.white],
                  ["Left Click to Clone", ti.orange]
                ),
                onClick: this.onCharacterCloneLeftClick.bind(this),
              })),
              this.characterCloneIcon.create(),
              this.characterCloneIcon.position.set(352, 84),
              this.addChild(this.characterCloneIcon),
              1 == t)
            )
              switch (this.ui.app.settingsHandler.starterEquipment) {
                case Dr.NoEquipment:
                  yield this.equipNothing();
                  break;
                case Dr.STierEquipment:
                  yield this.equipSTierEquipment();
                  break;
                case Dr.RandomEquipment:
                  yield this.equipRandomizedEquipment();
                  break;
                default:
                  yield this.equipStarterEquipment();
              }
            (this.reportEntries =
              yield this.ui.app.chartHandler.createReportEntries(
                this.characterInstance
              )),
              this.setLineColor(this.characterInstance.lineColor);
          });
        }
        onContainerMouseEnter(t) {
          if (
            void 0 === this.moveContainerUpIcon ||
            void 0 === this.moveContainerDownIcon
          )
            return;
          const e =
            this.ui.app.charactersHandler.characterScrollContainer.getElementsCount();
          if (e < 2) return;
          const i =
            this.ui.app.charactersHandler.characterScrollContainer.getElementIndex(
              this
            );
          i > 0 &&
            (this.moveContainerUpIcon.show(),
            this.moveContainerUpIcon.position.set(1, 2)),
            i < e - 1 &&
              (this.moveContainerDownIcon.show(),
              this.moveContainerDownIcon.position.set(
                1,
                2 + 10 * +this.moveContainerUpIcon.visible
              ));
        }
        onContainerMouseLeave(t) {
          var e, i;
          null === (e = this.moveContainerUpIcon) || void 0 === e || e.hide(),
            null === (i = this.moveContainerDownIcon) ||
              void 0 === i ||
              i.hide();
        }
        onArrowUpClick(t) {
          this.ui.playClickSound(), this.onContainerMouseLeave(t);
          this.ui.app.charactersHandler
            .moveCharacter(this, !1)
            .onContainerMouseEnter(t);
        }
        onArrowDownClick(t) {
          this.ui.playClickSound(), this.onContainerMouseLeave(t);
          this.ui.app.charactersHandler
            .moveCharacter(this, !0)
            .onContainerMouseEnter(t);
        }
        createToggableStatusEffectTypeHelper(t, e, i) {
          return wo(this, arguments, void 0, function* (t, e, i, n = !0) {
            const s =
                !!this.characterInstance.playerPermaStatusEffects.has(e) &&
                this.characterInstance.playerPermaStatusEffects.get(e),
              r = { x: 10 * e, y: 0, width: 10, height: 10 },
              o = new a.g({ source: i, frame: r }),
              l = new Gt.mc();
            (l.alpha = 1 == s ? 1 : 0.2), l.position.set(t.x, t.y), (t.x += 20);
            const u = new Xt.k();
            u.anchor.set(0.5, 0.5),
              (u.width = 20),
              (u.height = 20),
              (u.eventMode = "static"),
              (u.cursor = "pointer"),
              u.addListener("mouseenter", () =>
                this.onStatusEffectMouseEnter(e, n)
              ),
              u.addListener("mousedown", (t) =>
                this.onStatusEffectClick(t, e, n)
              ),
              u.addListener("mouseleave", () =>
                this.onStatusEffectMouseLeave(e)
              ),
              l.addChild(u);
            const h = new Xt.k(o);
            return (
              h.anchor.set(0.5, 0.5),
              h.scale.set(2, 2),
              (h.eventMode = "none"),
              l.addChild(h),
              this.statusEffectTogglesMap.set(e, h),
              this.addChild(l),
              Promise.resolve(l)
            );
          });
        }
        onThemeUpdate(t) {
          var e;
          const i =
            null !== (e = null == t ? void 0 : t.inventorySlotTint) &&
            void 0 !== e
              ? e
              : 16777215;
          for (const t of this.equipmentSlots) t.setBackgroundColor(i);
        }
        equipNothing() {
          return wo(this, void 0, void 0, function* () {
            for (let t = 0; t < 4; t++) {
              const e = this.characterInstance.classData.equipmentSlots[t];
              yield this.equip(e, 0, []);
            }
          });
        }
        equipStarterEquipment() {
          return wo(this, void 0, void 0, function* () {
            for (let t = 0; t < 4; t++) {
              const e = this.characterInstance.classData.starterEquipmentIds[t],
                i = this.characterInstance.classData.equipmentSlots[t];
              yield this.equip(i, e, []);
            }
          });
        }
        equipSTierEquipment() {
          return wo(this, void 0, void 0, function* () {
            for (let t = 0; t < 4; t++) {
              const e = this.ui.app.dataHandler.getSTierEquipment(
                  this.characterInstance.classData.type,
                  t
                ),
                i = this.characterInstance.classData.equipmentSlots[t];
              yield this.equip(i, e.id, e.enchants);
            }
          });
        }
        equipRandomizedEquipment() {
          return wo(this, void 0, void 0, function* () {
            var t;
            for (let e = 0; e < 4; e++) {
              const i = Array.from(
                  null ===
                    (t = this.ui.app.dataHandler.equipmentData.get(
                      this.characterInstance.classData.equipmentSlots[e]
                    )) || void 0 === t
                    ? void 0
                    : t.values()
                ),
                n = i[Ve.randomInt(0, i.length - 1)];
              yield this.equip(n.slotType, n.id, []);
            }
          });
        }
        onCharacterCloneLeftClick(t) {
          this.ui.playClickSound(),
            this.ui.app.charactersHandler.cloneCharacter(this);
        }
        onCharacterRemoveLeftClick(t) {
          this.ui.app.mainPanelHandler.removeCharacter(this),
            this.ui.playClickSound();
        }
        onStatusEffectClick(t, e, i) {
          var n;
          const s = !(
            null !==
              (n = (
                1 == i
                  ? this.characterInstance.playerPermaStatusEffects
                  : this.characterInstance.targetPermaStatusEffects
              ).get(e)) &&
            void 0 !== n &&
            n
          );
          t.shiftKey
            ? this.ui.app.charactersHandler.setAllCharactersStatusEffect(
                e,
                s,
                i
              )
            : this.ui.app.charactersHandler.setCharacterStatusEffect(
                this,
                e,
                s,
                i
              ),
            this.ui.playClickSound();
        }
        onStatusEffectMouseEnter(t, e) {
          var i, n;
          const s = this.statusEffectTogglesMap.get(t);
          if (void 0 === s) return;
          s.scale.set(3, 3);
          const r =
            null !==
              (n =
                null ===
                  (i =
                    this.ui.app.dataHandler.statusEffectDescriptionData.get(
                      t
                    )) || void 0 === i
                  ? void 0
                  : i.map((t) => [t, ti.lightyellow])) && void 0 !== n
              ? n
              : [];
          if (this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
            return;
          const o = new Array(
            [
              `Permanent ${Ve.statusEffectToString(t)} Toggle (${
                e ? "Player" : "Enemy"
              })`,
              ti.white,
            ],
            ...r,
            ["Left Click to Toggle", ti.orange],
            [
              "Shift-Click to Toggle On All " + (e ? "Characters" : "Enemies"),
              ti.yellow,
            ]
          );
          this.ui.app.tooltipHandler.showInformation(o);
        }
        onStatusEffectMouseLeave(t) {
          this.ui.app.tooltipHandler.hide();
          const e = this.statusEffectTogglesMap.get(t);
          void 0 !== e && e.scale.set(2, 2);
        }
        onDiceLeftClick(t) {
          return wo(this, void 0, void 0, function* () {
            yield this.equipRandomizedEquipment(),
              this.ui.app.charactersHandler.updateCharacter(this),
              this.ui.playClickSound();
          });
        }
        onColorPickerLeftClick(t) {
          void 0 !== this.colorPickerIcon &&
            (this.ui.app.mainPanelHandler.switchColorPicker(this),
            this.ui.playClickSound());
        }
        onColorPickerRightClick(t) {
          const e = Ve.randomInt(0, 16777215);
          this.ui.app.mainPanelHandler.setColorFromCharacterContainer(this, e),
            this.setLineColor(e),
            this.ui.playClickSound(),
            this.ui.app.cacheHandler.saveCharactersToCache();
        }
        onDamageExaltationBarLeftClick(t) {
          void 0 !== this.damageExaltationBar &&
            (this.ui.app.mainPanelHandler.switchCharacterStatsEditor(this),
            this.ui.playClickSound());
        }
        onDamageExaltationBarMouseEnter(t) {
          if (this.ui.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
            return;
          const e = new Array(
            ["Weapon Damage Exaltation", ti.white],
            ["Left Click to Edit Stats", ti.orange]
          );
          this.ui.app.tooltipHandler.showInformation(e);
        }
        onMouseLeave(t) {
          this.ui.app.tooltipHandler.hide();
        }
        onClassPortraitLeftClick() {
          this.ui.app.mainPanelHandler.switchClassChangeContainer(
            this,
            this.characterInstance.classData.type
          ),
            this.ui.playClickSound();
        }
        onClassPortraitRightClick() {
          this.ui.app.mainPanelHandler.switchCharacterStatsEditor(this),
            this.ui.playClickSound();
        }
        onCharacterPortraitMouseEnter(t) {
          void 0 !== this.classPortraitSprite &&
            (this.classPortraitSprite.onMouseEnter(t),
            this.ui.app.tooltipHandler.showCharacterDescription(
              this.characterInstance
            ));
        }
        updateStatusEffectToggleSprite(t, e, i) {
          if (t == Ie.InCombat) return void this.updateInCombatToggleSprite(e);
          if (
            1 == i &&
            (t == Ie.Curse || t == Ie.ArmorBroken || t == Ie.Exposed)
          )
            return;
          const n = this.statusEffectTogglesMap.get(t);
          void 0 !== n && (n.parent.alpha = e ? 1 : 0.2);
        }
        updateInCombatToggleSprite(t) {
          return wo(this, void 0, void 0, function* () {
            void 0 !== this.inCombatState &&
              this.inCombatState.setIcon(1 == t ? "combat_icon" : "solo_icon");
          });
        }
        setExaltationValue(t, e) {
          this.characterInstance.stats.setExaltationValue(t, e);
        }
        setBackgroundSize(t, e) {
          void 0 !== this.backgroundSprite &&
            ((this.backgroundSprite.width = t),
            (this.backgroundSprite.height = e));
        }
        getReportEntries() {
          return this.reportEntries;
        }
        setLineColor(t) {
          void 0 !== this.backgroundSprite &&
            void 0 !== this.colorPickerIcon &&
            ((this.backgroundSprite.tint = t),
            this.colorPickerIcon.setColor(t),
            void 0 !== this.reportEntries &&
              (this.reportEntries.damageReportEntry.setColor(t),
              this.reportEntries.burstReportEntry.setColor(t),
              this.reportEntries.survivabilityReportEntry.setColor(t),
              this.reportEntries.travelReportEntry.setColor(t)));
        }
        clone() {
          return wo(this, void 0, void 0, function* () {
            var t, e, i, n, s, r;
            const o = new Po(
                this.ui,
                this.characterInstance.classData,
                this.characterInstance.targetData,
                this.characterInstance.lineColor
              ),
              a = o.characterInstance;
            yield o.create(!1);
            for (let e = 0; e < 8; e++) {
              const i = this.characterInstance.stats.getStat(e);
              if (void 0 === i) continue;
              const n =
                null !== (t = i.exaltationValue) && void 0 !== t
                  ? t
                  : e == Ee.MAXHP || e == Ee.MAXMP
                  ? 25
                  : 5;
              a.stats.clearStat(e), a.stats.setExaltationValue(e, n);
            }
            for (let t = 0; t < 4; t++) {
              const l = a.classData.equipmentSlots[t],
                u =
                  null !==
                    (n =
                      null ===
                        (i =
                          null === (e = this.characterInstance.equipment[t]) ||
                          void 0 === e
                            ? void 0
                            : e.base) || void 0 === i
                        ? void 0
                        : i.id) && void 0 !== n
                    ? n
                    : 0,
                h =
                  null !==
                    (r =
                      null === (s = this.characterInstance.equipment[t]) ||
                      void 0 === s
                        ? void 0
                        : s.enchants) && void 0 !== r
                    ? r
                    : [];
              yield o.equip(l, u, h);
            }
            for (let [
              t,
              e,
            ] of this.characterInstance.playerPermaStatusEffects.entries())
              a.playerPermaStatusEffects.set(t, e),
                o.updateStatusEffectToggleSprite(t, e, !0);
            for (let [
              t,
              e,
            ] of this.characterInstance.targetPermaStatusEffects.entries())
              a.targetPermaStatusEffects.set(t, e),
                o.updateStatusEffectToggleSprite(t, e, !1);
            for (let [
              t,
              e,
            ] of this.characterInstance.targetImmunities.entries())
              a.targetImmunities.set(t, e);
            return (
              (a.damageExaltationLevel =
                this.characterInstance.damageExaltationLevel),
              o.updateDamageExaltationSprite(
                this.characterInstance.damageExaltationLevel
              ),
              (a.petMagicHealLevel = this.characterInstance.petMagicHealLevel),
              (a.petHealLevel = this.characterInstance.petHealLevel),
              (a.weaponShotsAccuracy =
                this.characterInstance.weaponShotsAccuracy),
              (a.abilityShotsAccuracy =
                this.characterInstance.abilityShotsAccuracy),
              (a.startingHpPercent = this.characterInstance.startingHpPercent),
              (a.startingMpPercent = this.characterInstance.startingMpPercent),
              (a.abilityMode = this.characterInstance.abilityMode),
              o.updateAbilityMode(Re.Ability),
              (a.abilityUse = this.characterInstance.abilityUse),
              (a.applyStatusEffects =
                this.characterInstance.applyStatusEffects),
              (a.onhitProcTrigger = this.characterInstance.onhitProcTrigger),
              (a.hitIntervalMs = this.characterInstance.hitIntervalMs),
              (a.targetData = Object.assign(
                {},
                this.characterInstance.targetData
              )),
              Promise.resolve(o)
            );
          });
        }
        updateAbilityMode(t) {
          const e = this.characterInstance.equipment[t];
          if (
            t == Re.Ability &&
            void 0 !== e &&
            void 0 !== e.base &&
            e.base.abilities.length > 1
          ) {
            const i = Math.min(
              e.base.abilities.length,
              this.characterInstance.abilityMode + 1
            );
            this.equipmentSlots[t].setAbilityMode(i);
          } else this.equipmentSlots[t].setAbilityMode(0);
        }
        equip(t, e, i) {
          return wo(this, void 0, void 0, function* () {
            const n = Ve.slotMetaType(t),
              s = yield this.equipmentSlots[n].appendData(t, e, i);
            (this.characterInstance.equipment[n] = s),
              this.updateAbilityMode(n);
          });
        }
        getEquipmentSets() {
          return this.characterInstance.equipmentSets;
        }
        getStats() {
          return this.characterInstance.stats;
        }
        getColor() {
          var t, e;
          return null !==
            (e =
              null === (t = this.colorPickerIcon) || void 0 === t
                ? void 0
                : t.getColor()) && void 0 !== e
            ? e
            : ti.white;
        }
        updateDamageExaltationSprite(t) {
          this.damageExaltationBar.setExaltationStage(t);
        }
        changeClass(t) {
          return wo(this, void 0, void 0, function* () {
            var e, i, n, s;
            const r = this.ui.app.dataHandler.classesData.get(t);
            if (void 0 === r) return;
            if (void 0 === this.classPortraitSprite) return;
            const o = yield this.ui.app.dataHandler.getStaticTexture(
              r.portraitTexture
            );
            this.classPortraitSprite.texture = o;
            const a = [];
            for (let t = 0; t < 4; t++) {
              const o =
                null !==
                  (n =
                    null ===
                      (i =
                        null === (e = this.characterInstance.equipment[t]) ||
                        void 0 === e
                          ? void 0
                          : e.base) || void 0 === i
                      ? void 0
                      : i.id) && void 0 !== n
                  ? n
                  : 0;
              if (
                this.characterInstance.classData.equipmentSlots[t] !=
                  r.equipmentSlots[t] ||
                0 == o
              )
                switch (this.ui.app.settingsHandler.starterEquipment) {
                  case Dr.NoEquipment: {
                    const e = this.equip(r.equipmentSlots[t], 0, []);
                    a.push(e);
                    break;
                  }
                  case Dr.STierEquipment: {
                    const e = this.ui.app.dataHandler.getSTierEquipment(
                        r.type,
                        t
                      ),
                      i = this.equip(r.equipmentSlots[t], e.id, e.enchants);
                    a.push(i);
                    break;
                  }
                  case Dr.RandomEquipment: {
                    const e = Array.from(
                        null ===
                          (s = this.ui.app.dataHandler.equipmentData.get(
                            r.equipmentSlots[t]
                          )) || void 0 === s
                          ? void 0
                          : s.values()
                      ),
                      i = e[Ve.randomInt(0, e.length - 1)],
                      n = this.equip(i.slotType, i.id, []);
                    a.push(n);
                    break;
                  }
                  default: {
                    const e = this.equip(
                      r.equipmentSlots[t],
                      r.starterEquipmentIds[t],
                      []
                    );
                    a.push(e);
                    break;
                  }
                }
            }
            yield Promise.all(a),
              (this.characterInstance.classData = Object.assign({}, r)),
              this.ui.app.charactersHandler.updateCharacter(this);
          });
        }
        onSlotClick(t, e) {
          return wo(this, void 0, void 0, function* () {
            if (1 == e) {
              const e = this.ui.app.dataHandler.getSTierEquipment(
                this.characterInstance.classData.type,
                Ve.slotMetaType(t)
              );
              return (
                yield this.equip(t, e.id, e.enchants),
                void this.ui.app.charactersHandler.updateCharacter(this)
              );
            }
            this.ui.app.mainPanelHandler.switchEquipmentChangeFrame(this, t);
          });
        }
        onSlotRightClick(t, e) {
          if (void 0 !== t.base) {
            if (t.base.enchantSlots > 0)
              return (
                this.ui.app.mainPanelHandler.switchEnchantingFrame(t, e),
                void this.ui.playClickSound()
              );
            if (t.base.abilities.length > 1) {
              let e = this.characterInstance.abilityMode + 1;
              return (
                e > t.base.abilities.length - 1 && (e = 0),
                this.ui.app.charactersHandler.setCharacterPropertyValue(
                  this,
                  "abilityMode",
                  e
                ),
                this.ui.app.tooltipHandler.showEquipmentDescription(
                  t.base,
                  t.enchants,
                  this.characterInstance,
                  !0
                ),
                void this.ui.playClickSound()
              );
            }
          }
        }
      }
      var Ao,
        ko,
        Mo,
        Eo,
        Io,
        Do = function (t, e, i, n) {
          return new (i || (i = Promise))(function (s, r) {
            function o(t) {
              try {
                l(n.next(t));
              } catch (t) {
                r(t);
              }
            }
            function a(t) {
              try {
                l(n.throw(t));
              } catch (t) {
                r(t);
              }
            }
            function l(t) {
              t.done
                ? s(t.value)
                : (function (t) {
                    return t instanceof i
                      ? t
                      : new i(function (e) {
                          e(t);
                        });
                  })(t.value).then(o, a);
            }
            l((n = n.apply(t, e || [])).next());
          });
        };
      class Ro extends ai {
        constructor(t) {
          super(t),
            (this.container = new Gt.mc()),
            (this.scrollContainerOptions = {
              size: { x: 400, y: Math.max(window.innerHeight - 160, 104) },
              itemsInRow: 1,
              itemSize: { x: 400, y: 104 },
              itemOffset: { x: 4, y: 0 },
              itemAnchor: { x: 0, y: 0 },
              itemSpacing: { x: 0, y: 0 },
              scrollSpeed: 104,
            }),
            (this.characterScrollContainer = new Js(
              t.ui,
              this.scrollContainerOptions
            )),
            (this.characterContainers = new Array());
        }
        create(t) {
          const e = Object.create(null, {
            create: { get: () => super.create },
          });
          return Do(this, void 0, void 0, function* () {
            (this.createCharacterButton = yield this.app.ui.bigButton({
              text: "Create New Character",
              size: new Et.b(240, 60),
              anchor: Ve.CENTER,
              onClick: () => this.createNewCharacter(!0),
            })),
              this.container.addChild(this.createCharacterButton),
              yield this.characterScrollContainer.create(),
              this.container.addChild(this.characterScrollContainer),
              this.characterScrollContainer.updateHeight(
                window.innerHeight - 132
              ),
              this.updateButton(),
              this.onToolTypeChange(t),
              e.create.call(this);
          });
        }
        onToolTypeChange(t) {
          (this.characterScrollContainer.visible = t == He.Calculator),
            void 0 !== this.createCharacterButton &&
              (this.createCharacterButton.visible = t == He.Calculator);
        }
        onThemeUpdate(t) {
          for (const e of this.characterContainers) e.onThemeUpdate(t);
        }
        onWindowResize(t) {
          const e = t.target.innerHeight;
          this.characterScrollContainer.updateHeight(e - 132, Ys.Stay),
            this.updateButton();
        }
        updateButton() {
          var t;
          const e = this.characterScrollContainer.getElementsCount(),
            i = Math.min(
              e * this.scrollContainerOptions.itemSize.y + 40,
              Math.max(window.innerHeight - 36, 200) - this.container.position.y
            );
          null === (t = this.createCharacterButton) ||
            void 0 === t ||
            t.position.set(0.5 * this.scrollContainerOptions.itemSize.x, i);
        }
        getCharacterInstances() {
          const t = new Array();
          for (let e = 0; e < this.characterContainers.length; e++)
            t.push(this.characterContainers[e].characterInstance);
          return t;
        }
        moveCharacter(t, e) {
          const i = this.characterScrollContainer.getElementIndex(t),
            n = this.characterScrollContainer.getElementsCount();
          if (-1 == i || 1 == n || (0 == i && 0 == e) || (i == n - 1 && 1 == e))
            return t;
          const s = i + (1 == e ? 1 : -1);
          this.characterScrollContainer.swapElements(i, s);
          const r = this.characterContainers[i];
          return (
            (this.characterContainers[i] = this.characterContainers[s]),
            (this.characterContainers[s] = r),
            this.saveCharacters(),
            this.characterContainers[i]
          );
        }
        saveCharacters() {
          this.app.cacheHandler.saveCharactersToCache();
        }
        updateAllCharacters() {
          return Do(this, void 0, void 0, function* () {
            const t = [],
              e = [];
            for (let i = 0; i < this.characterContainers.length; i++) {
              const n = this.characterContainers[i],
                s = n.characterInstance.recalculateStats(this.app.dataHandler);
              t.push(s);
              const r = n.getReportEntries();
              void 0 !== r && e.push(r);
            }
            yield Promise.all(t),
              this.app.chartHandler.updateReportEntries(e, !1),
              this.saveCharacters();
          });
        }
        updateCharacter(t) {
          return Do(this, arguments, void 0, function* (t, e = !0) {
            if (void 0 === t) return;
            const i = t.characterInstance;
            yield i.recalculateStats(this.app.dataHandler);
            const n = t.getReportEntries();
            void 0 !== n &&
              (this.app.chartHandler.updateReportEntries([n], e),
              this.saveCharacters());
          });
        }
        setCharacterTargetHelper(t, e, i) {
          return Do(this, void 0, void 0, function* () {
            var n;
            if (
              (void 0 !== e.name && (t.targetData.name = e.name),
              void 0 !== e.portraitTexture &&
                (t.targetData.portraitTexture = e.portraitTexture),
              void 0 !== e.hitpoints && (t.targetData.hitpoints = e.hitpoints),
              void 0 !== e.defense && (t.targetData.defense = e.defense),
              void 0 !== e.heal && (t.targetData.heal = e.heal),
              void 0 !== e.defense && (t.targetData.defense = e.defense),
              void 0 !== e.mirrorable &&
                (t.targetData.mirrorable = e.mirrorable),
              0 == i.size)
            )
              return;
            const s = [Ie.Curse, Ie.Exposed, Ie.ArmorBroken];
            for (const e of s) {
              const s = null !== (n = i.get(e)) && void 0 !== n && n;
              t.targetImmunities.set(e, s);
            }
          });
        }
        setCharacterTargetData(t, e) {
          return Do(this, arguments, void 0, function* (t, e, i = xr.Keep) {
            const n = t.characterInstance,
              s = (() => {
                switch (i) {
                  case xr.Keep:
                    return new Map();
                  case xr.Propagate:
                    return t.characterInstance.targetImmunities;
                  case xr.Change: {
                    const t = [Ie.Curse, Ie.Exposed, Ie.ArmorBroken],
                      i = new Map();
                    for (const n of t)
                      i.set(n, e.statusEffectImmunities.includes(n));
                    return i;
                  }
                }
              })();
            this.setCharacterTargetHelper(n, e, s),
              this.app.mainPanelHandler.updateCharacterTargetData(t),
              this.saveCharacters();
            const r = t.getReportEntries();
            void 0 !== r && this.app.chartHandler.updateReportEntries([r], !0);
          });
        }
        setAllCharacterTargetData(t, e) {
          return Do(this, arguments, void 0, function* (t, e, i = xr.Keep) {
            const n = (() => {
                switch (i) {
                  case xr.Keep:
                    return new Map();
                  case xr.Propagate:
                    return t.characterInstance.targetImmunities;
                  case xr.Change: {
                    const t = [Ie.Curse, Ie.Exposed, Ie.ArmorBroken],
                      i = new Map();
                    for (const n of t)
                      i.set(n, e.statusEffectImmunities.includes(n));
                    return i;
                  }
                }
              })(),
              s = [],
              r = [];
            for (let t = 0; t < this.characterContainers.length; t++) {
              const i = this.setCharacterTargetHelper(
                this.characterContainers[t].characterInstance,
                e,
                n
              );
              s.push(i);
              const o = this.characterContainers[t].getReportEntries();
              void 0 !== o && r.push(o);
            }
            yield Promise.all(s),
              this.saveCharacters(),
              this.app.chartHandler.updateReportEntries(r, !0);
          });
        }
        setCharacterExaltationStatValueHelper(t, e, i) {
          return Do(this, void 0, void 0, function* () {
            const n = t.characterInstance;
            n.stats.setExaltationValue(e, i),
              yield n.recalculateStats(this.app.dataHandler),
              this.app.mainPanelHandler.updateCharacterStats(t);
          });
        }
        setCharacterExaltationStatValue(t, e, i) {
          return Do(this, void 0, void 0, function* () {
            yield this.setCharacterExaltationStatValueHelper(t, e, i),
              this.saveCharacters();
            const n = t.getReportEntries();
            void 0 !== n && this.app.chartHandler.updateReportEntries([n], !0);
          });
        }
        setAllCharactersExaltationStatValue(t, e) {
          return Do(this, void 0, void 0, function* () {
            const i = [],
              n = [];
            for (let s = 0; s < this.characterContainers.length; s++) {
              const r = this.setCharacterExaltationStatValueHelper(
                this.characterContainers[s],
                t,
                e
              );
              i.push(r);
              const o = this.characterContainers[s].getReportEntries();
              void 0 !== o && n.push(o);
            }
            yield Promise.all(i),
              this.saveCharacters(),
              this.app.chartHandler.updateReportEntries(n, !0);
          });
        }
        setCharacterStatusEffectHelper(t, e, i, n) {
          return Do(this, void 0, void 0, function* () {
            const s = t.characterInstance;
            (1 == n
              ? s.playerPermaStatusEffects
              : s.targetPermaStatusEffects
            ).set(e, i),
              yield s.recalculateStats(this.app.dataHandler),
              t.updateStatusEffectToggleSprite(e, i, n),
              this.app.mainPanelHandler.updateCharacterStatusEffect(t, e, i, n);
          });
        }
        setCharacterStatusEffect(t, e, i, n) {
          return Do(this, void 0, void 0, function* () {
            yield this.setCharacterStatusEffectHelper(t, e, i, n),
              this.saveCharacters();
            const s = t.getReportEntries();
            void 0 !== s && this.app.chartHandler.updateReportEntries([s], !0);
          });
        }
        setAllCharactersStatusEffect(t, e, i) {
          return Do(this, void 0, void 0, function* () {
            const n = [],
              s = [];
            for (let r = 0; r < this.characterContainers.length; r++) {
              const o = this.setCharacterStatusEffectHelper(
                this.characterContainers[r],
                t,
                e,
                i
              );
              n.push(o);
              const a = this.characterContainers[r].getReportEntries();
              void 0 !== a && s.push(a);
            }
            yield Promise.all(n),
              this.saveCharacters(),
              this.app.chartHandler.updateReportEntries(s, !0);
          });
        }
        setTargetImmunityHelper(t, e, i) {
          return Do(this, void 0, void 0, function* () {
            const n = t.characterInstance;
            n.targetImmunities.set(e, i),
              yield n.recalculateStats(this.app.dataHandler),
              this.app.mainPanelHandler.updateTargetImmunity(t, e, i);
          });
        }
        setTargetImmunity(t, e, i) {
          return Do(this, void 0, void 0, function* () {
            yield this.setTargetImmunityHelper(t, e, i), this.saveCharacters();
            const n = t.getReportEntries();
            void 0 !== n && this.app.chartHandler.updateReportEntries([n], !0);
          });
        }
        setAllTargetsImmunity(t, e) {
          return Do(this, void 0, void 0, function* () {
            const i = [],
              n = [];
            for (let s = 0; s < this.characterContainers.length; s++) {
              const r = this.setTargetImmunityHelper(
                this.characterContainers[s],
                t,
                e
              );
              i.push(r);
              const o = this.characterContainers[s].getReportEntries();
              void 0 !== o && n.push(o);
            }
            yield Promise.all(i),
              this.saveCharacters(),
              this.app.chartHandler.updateReportEntries(n, !0);
          });
        }
        setCharacterPropertyValueHelper(t, e, i) {
          return Do(this, arguments, void 0, function* (t, e, i, n = !0) {
            const s = t.characterInstance;
            switch (
              ((s[e] = i), yield s.recalculateStats(this.app.dataHandler), e)
            ) {
              case "damageExaltationLevel":
                t.updateDamageExaltationSprite(i);
                break;
              case "abilityMode":
                t.updateAbilityMode(Re.Ability);
                break;
              case "lineColor":
                t.setLineColor(i);
            }
            0 != n &&
              this.app.mainPanelHandler.updateCharacterProperties(t, e, i);
          });
        }
        setCharacterPropertyValue(t, e, i) {
          return Do(this, arguments, void 0, function* (t, e, i, n = !0) {
            if (
              (yield this.setCharacterPropertyValueHelper(t, e, i, n),
              this.saveCharacters(),
              0 == n)
            )
              return;
            const s = t.getReportEntries();
            void 0 !== s && this.app.chartHandler.updateReportEntries([s], !0);
          });
        }
        setAllCharactersPropertyValue(t, e) {
          return Do(this, void 0, void 0, function* () {
            const i = [],
              n = [];
            for (let s = 0; s < this.characterContainers.length; s++) {
              const r = this.setCharacterPropertyValueHelper(
                this.characterContainers[s],
                t,
                e
              );
              i.push(r);
              const o = this.characterContainers[s].getReportEntries();
              void 0 !== o && n.push(o);
            }
            yield Promise.all(i),
              this.saveCharacters(),
              this.app.chartHandler.updateReportEntries(n, !0);
          });
        }
        createCharacter(t, e, i) {
          return Do(this, void 0, void 0, function* () {
            const n = this.app.dataHandler.classesData.get(e);
            if (void 0 === n) return Promise.reject();
            const s = yield this.app.dataHandler.getEnemyData("Training Dummy"),
              r = new Po(
                this.app.ui,
                Object.assign({}, n),
                Object.assign({}, s),
                i
              );
            return (
              yield r.create(t),
              this.characterContainers.push(r),
              yield this.characterScrollContainer.addElement(r),
              Promise.resolve(r)
            );
          });
        }
        createNewCharacter(t) {
          return Do(this, void 0, void 0, function* () {
            const e = Ve.randomInt(0, 17),
              i = Ve.randomInt(11184810, 16777215),
              n = yield this.createCharacter(!0, e, i);
            this.characterScrollContainer.updateHeight(
              window.innerHeight - 132,
              Ys.Bottom
            ),
              this.updateCharacter(n, t),
              this.updateButton(),
              this.updateButton();
          });
        }
        cloneCharacter(t) {
          return Do(this, void 0, void 0, function* () {
            const e = this.characterContainers.indexOf(t);
            if (e < 0) return;
            const i = yield t.clone();
            this.characterContainers.splice(e + 1, 0, i),
              yield this.characterScrollContainer.addElement(i, e + 1),
              this.characterScrollContainer.updateHeight(
                window.innerHeight - 132,
                Ys.AddElement
              ),
              this.updateCharacter(i),
              this.updateButton();
          });
        }
        importCharacters(t) {
          return Do(this, arguments, void 0, function* (t, e = !0) {
            var i,
              n,
              s,
              r,
              o,
              a,
              l,
              u,
              h,
              c,
              d,
              p,
              f,
              m,
              g,
              v,
              y,
              x,
              b,
              S,
              C,
              _;
            yield this.removeAllCharacters();
            const T = new Array();
            for (let e = 0; e < t.length; e++) {
              const w = t[e],
                P = this.app.dataHandler.getClass(w.classType);
              if (void 0 === P) continue;
              const A =
                  null !== (i = w.chartLineColor) && void 0 !== i
                    ? i
                    : Ve.randomInt(11184810, 16777215),
                k = yield this.createCharacter(!1, w.classType, A),
                M = k.characterInstance;
              M.stats.setExaltationValues(w.exaltStats);
              const E = [];
              for (let t = 0; t < 4; t++) {
                const e = new Array();
                for (let i = 0; i < w.enchants[t].length; i++) {
                  const n = w.enchants[t][i],
                    s = this.app.dataHandler.enchantmentsData.get(n);
                  if (void 0 === s) break;
                  e.push(s);
                }
                const i = k.equip(P.equipmentSlots[t], w.equipment[t], e);
                E.push(i);
              }
              const I =
                null !== (n = w.playerStatusEffects) && void 0 !== n
                  ? n
                  : new Array();
              for (let t = 0; t < I.length; t++) {
                const e = w.playerStatusEffects[t];
                M.playerPermaStatusEffects.set(e, !0),
                  k.updateStatusEffectToggleSprite(e, !0, !0);
              }
              const D =
                null !== (s = w.targetStatusEffects) && void 0 !== s
                  ? s
                  : new Array();
              for (const t of D)
                M.targetPermaStatusEffects.set(t, !0),
                  k.updateStatusEffectToggleSprite(t, !0, !1);
              const R =
                null !== (r = w.targetImmunities) && void 0 !== r
                  ? r
                  : new Array();
              for (const t of R) M.targetImmunities.set(t, !0);
              (M.damageExaltationLevel =
                null !== (o = w.damageExaltationLevel) && void 0 !== o ? o : 4),
                k.updateDamageExaltationSprite(M.damageExaltationLevel),
                (M.inCombatExaltationLevel =
                  null !== (a = w.inCombatExaltationLevel) && void 0 !== a
                    ? a
                    : 5),
                (M.petHealLevel =
                  null !== (l = w.petHeal) && void 0 !== l ? l : 100),
                (M.petMagicHealLevel =
                  null !== (u = w.petMagicHeal) && void 0 !== u ? u : 100),
                (M.startingHpPercent =
                  null !== (h = w.hpPercent) && void 0 !== h ? h : 1),
                (M.startingMpPercent =
                  null !== (c = w.mpPercent) && void 0 !== c ? c : 1),
                (M.weaponShotsAccuracy =
                  null !== (d = w.weaponAccuracy) && void 0 !== d ? d : 1),
                (M.abilityShotsAccuracy =
                  null !== (p = w.abilityAccuracy) && void 0 !== p ? p : 1),
                (M.abilityUse =
                  null !== (f = w.abilityUse) && void 0 !== f
                    ? f
                    : bi.OffCooldownAndHold),
                (M.abilityMode =
                  null !== (m = w.abilityMode) && void 0 !== m ? m : hr.Mode1),
                (M.applyStatusEffects =
                  null !== (g = w.statusEffectsMode) && void 0 !== g
                    ? g
                    : _i.AllIncluded),
                (M.onhitProcTrigger =
                  null !== (v = w.onhitProcTrigger) && void 0 !== v
                    ? v
                    : Pi.RespectValue),
                (M.hitDamage =
                  null !== (y = w.hitDamage) && void 0 !== y ? y : 100),
                (M.hitIntervalMs =
                  null !== (x = w.hitIntervalMs) && void 0 !== x ? x : 3e3);
              const B = yield this.app.dataHandler.getEnemyData(
                  null !== (b = w.targetType) && void 0 !== b
                    ? b
                    : "Training Dummy"
                ),
                F = null !== (S = w.targetHp) && void 0 !== S ? S : B.hitpoints,
                O =
                  null !== (C = w.targetDefense) && void 0 !== C
                    ? C
                    : B.defense,
                z = null !== (_ = w.targetHeal) && void 0 !== _ ? _ : B.heal;
              (M.targetData = Object.assign(Object.assign({}, B), {
                hitpoints: F,
                defense: O,
                heal: z,
              })),
                yield Promise.all(E),
                yield k.characterInstance.recalculateStats(
                  this.app.dataHandler
                );
              const L = k.getReportEntries();
              void 0 !== L && T.push(L);
            }
            this.characterScrollContainer.updateHeight(
              window.innerHeight - 132
            ),
              1 == e && this.saveCharacters(),
              this.app.chartHandler.updateReportEntries(T, !1),
              this.updateButton();
          });
        }
        removeCharacter(t) {
          return Do(this, void 0, void 0, function* () {
            const e = this.characterContainers.indexOf(t);
            if (e < 0) return;
            const i = this.characterContainers[e];
            this.characterContainers.splice(e, 1);
            const n = i.getReportEntries();
            void 0 !== n && this.app.chartHandler.removeReportEntries([n]),
              yield this.characterScrollContainer.removeElement(i),
              yield this.characterScrollContainer.updateHeight(
                window.innerHeight - 132,
                Ys.RemoveElement
              ),
              yield i.destroy(),
              this.app.tooltipHandler.hide(),
              this.saveCharacters(),
              this.app.chartHandler.updateBackgroundIfNeeded(),
              this.updateButton();
          });
        }
        removeAllCharacters() {
          return Do(this, void 0, void 0, function* () {
            const t = new Array();
            for (let e = 0; e < this.characterContainers.length; e++) {
              const i = this.characterContainers[e],
                n = i.getReportEntries();
              void 0 !== n && (t.push(n), i.destroy());
            }
            this.app.chartHandler.removeReportEntries(t),
              (this.characterContainers = new Array()),
              this.characterScrollContainer.removeElements(),
              this.updateButton();
          });
        }
      }
      class Bo extends ai {
        constructor(t) {
          super(t),
            (this.container = new Me(t.ui)),
            (this.descriptionText = t.ui.text({ text: "Item Sandbox Tool" })),
            (this.comingSoonText = t.ui.text({ text: "Coming Soon™" }));
        }
        create() {
          this.app.canvas.addChild(this.container);
          const t = Math.floor(0.5 * (window.innerWidth - 400)),
            e = Math.floor(0.5 * window.innerHeight),
            [i, n] = Ve.getBoundsReminder(this.descriptionText);
          this.descriptionText.position.set(t, e - 12),
            this.descriptionText.anchor.set(0.5, 1),
            this.descriptionText.pivot.set(i, n),
            this.container.addChild(this.descriptionText);
          const [s, r] = Ve.getBoundsReminder(this.comingSoonText);
          this.comingSoonText.position.set(t, e + 12),
            this.comingSoonText.anchor.set(0.5, 1),
            this.comingSoonText.pivot.set(s, r),
            this.container.addChild(this.comingSoonText),
            super.create();
        }
        onThemeUpdate(t) {
          (this.descriptionText.style.fill = t.chartTitleTextColor),
            (this.comingSoonText.style.fill = t.chartTitleTextColor);
        }
        show() {
          this.container.show(), this.onWindowResize(undefined);
        }
        hide() {
          this.container.hide();
        }
        onWindowResize(t) {
          if (0 == this.container.visible) return;
          const e = Math.floor(0.5 * (window.innerWidth - 400)),
            i = Math.floor(0.5 * window.innerHeight);
          this.comingSoonText.position.set(e, i + 12),
            this.descriptionText.position.set(e, i - 12);
        }
      }
      !(function (t) {
        (t[(t.Idle = 0)] = "Idle"),
          (t[(t.Walk = 1)] = "Walk"),
          (t[(t.Attack = 2)] = "Attack"),
          (t[(t.Ability = 4)] = "Ability");
      })(Ao || (Ao = {})),
        (function (t) {
          (t[(t.Up = 0)] = "Up"),
            (t[(t.Down = 1)] = "Down"),
            (t[(t.Left = 2)] = "Left"),
            (t[(t.Right = 3)] = "Right");
        })(ko || (ko = {})),
        (function (t) {
          (t[(t.Sideways = 0)] = "Sideways"),
            (t[(t.Back = 2)] = "Back"),
            (t[(t.Front = 3)] = "Front");
        })(Mo || (Mo = {})),
        (function (t) {
          (t[(t.Minor = 0)] = "Minor"), (t[(t.Major = 1)] = "Major");
        })(Eo || (Eo = {})),
        (function (t) {
          (t[(t.None = 0)] = "None"),
            (t[(t.ScrollX = 1)] = "ScrollX"),
            (t[(t.ScrollY = 2)] = "ScrollY"),
            (t[(t.Rotate = 3)] = "Rotate");
        })(Io || (Io = {}));
      var Fo = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Oo extends Wt {
        constructor(t, e) {
          super(e),
            (this.ui = t),
            (this.animationData = this.clearAnimationData());
        }
        animateScrollX() {
          this.tilePosition.x =
            5 * -this.animationData.speed * Ve.elapsedSeconds();
        }
        animateScrollY() {
          this.tilePosition.y =
            5 * this.animationData.speed * Ve.elapsedSeconds();
        }
        animateRotate() {
          this.tileRotation =
            0.1 * -this.animationData.speed * Ve.elapsedSeconds();
        }
        clearAnimationData() {
          return { type: Io.None, speed: 0, pivotX: 0, pivotY: 0 };
        }
        removeDye() {
          this.texture = a.g.EMPTY;
        }
        setColor(t) {
          return Fo(this, void 0, void 0, function* () {
            void 0 !== t && ((this.texture = a.g.WHITE), (this.tint = t));
          });
        }
        setTexture(t, e) {
          return Fo(this, void 0, void 0, function* () {
            if (void 0 === t || void 0 === e) return;
            this.tint = 16777215;
            const i = { fileName: t, index: e, offsetX: 0, offsetY: 0 },
              n = yield this.ui.app.dataHandler.getStaticTexture(i);
            this.texture = n;
          });
        }
        updateAnimationData() {
          this.setAnimation(this.animationData);
        }
        setAnimation(t) {
          return Fo(this, void 0, void 0, function* () {
            var e, i;
            if (void 0 === t || t.type == Io.None)
              return (
                (this.animationData = this.clearAnimationData()),
                this.tileTransform.pivot.set(0, 0),
                this.tilePosition.set(0, 0),
                (this.tileRotation = 0),
                void (this.updateAnimation = void 0)
              );
            this.animationData = Object.assign({}, t);
            const n = this.texture.width;
            switch (t.type) {
              case Io.ScrollX:
                (this.tileRotation = 0),
                  (this.tilePosition.y =
                    null !== (e = Oo.ScrollXPivotYMap.get(n)) && void 0 !== e
                      ? e
                      : 0),
                  this.tileTransform.pivot.set(0, 0),
                  (this.updateAnimation = this.animateScrollX);
                break;
              case Io.ScrollY:
                (this.tileRotation = 0),
                  (this.tilePosition.x =
                    null !== (i = Oo.ScrollYPivotXMap.get(n)) && void 0 !== i
                      ? i
                      : 0),
                  this.tileTransform.pivot.set(0, 0),
                  (this.updateAnimation = this.animateScrollY);
                break;
              case Io.Rotate: {
                const t = { x: -4, y: 8 },
                  e = { x: 2, y: 2 },
                  i = 0.5 * -n + e.x,
                  s = 0.5 * -n + e.y,
                  r = 0.5 * this.height + t.x,
                  o = this.height - 20 + t.y;
                this.tileTransform.pivot.set(i, s),
                  this.tilePosition.set(r, o),
                  (this.updateAnimation = this.animateRotate);
                break;
              }
            }
          });
        }
      }
      (Oo.ScrollYPivotXMap = new Map([
        [16, 6],
        [18, -1],
        [24, 2],
        [32, -9],
      ])),
        (Oo.ScrollXPivotYMap = new Map([
          [14, -6],
          [16, 2],
        ]));
      var zo,
        Lo,
        Ho = function (t, e, i, n) {
          return new (i || (i = Promise))(function (s, r) {
            function o(t) {
              try {
                l(n.next(t));
              } catch (t) {
                r(t);
              }
            }
            function a(t) {
              try {
                l(n.throw(t));
              } catch (t) {
                r(t);
              }
            }
            function l(t) {
              t.done
                ? s(t.value)
                : (function (t) {
                    return t instanceof i
                      ? t
                      : new i(function (e) {
                          e(t);
                        });
                  })(t.value).then(o, a);
            }
            l((n = n.apply(t, e || [])).next());
          });
        };
      class Uo extends Me {
        constructor(t, e) {
          var i, n, s;
          super(t),
            (this.shadowSprite = new Xt.k()),
            this.shadowSprite.anchor.set(0.5, 0.5),
            this.addChild(this.shadowSprite),
            (this.spriteContainer = new Gt.mc()),
            (this.spriteContainer.eventMode = "none"),
            this.addChild(this.spriteContainer),
            (this.spriteScale = e.scale),
            (this.walkableAreaSize = { x: 0, y: 0 }),
            (this.floatPosition = { x: 0, y: 0 }),
            (this.blackSprite = new Xt.k()),
            this.blackSprite.anchor.set(0, 1),
            (this.blackSprite.tint = 0),
            (this.blackSprite.roundPixels = !0),
            this.spriteContainer.addChild(this.blackSprite),
            (this.blurFilter = new wt({ strength: 5 })),
            (this.blurFilter.padding = 10),
            (this.blackSprite.filters = [this.blurFilter]),
            (this.sprite = new Xt.k()),
            this.sprite.anchor.set(0, 1),
            (this.sprite.roundPixels = !0),
            this.spriteContainer.addChild(this.sprite),
            (this.outlineFilter = new ys({ color: 0, thickness: 1 })),
            (this.sprite.filters = [this.outlineFilter]),
            (this.minorDyedSprite = new Oo(this.ui)),
            this.minorDyedSprite.anchor.set(0, 1),
            (this.minorDyedSprite.roundPixels = !0),
            this.spriteContainer.addChild(this.minorDyedSprite),
            (this.majorDyedSprite = new Oo(this.ui)),
            this.majorDyedSprite.anchor.set(0, 1),
            (this.majorDyedSprite.roundPixels = !0),
            this.spriteContainer.addChild(this.majorDyedSprite),
            (this.redMaskFilter = new ct.d({})),
            (this.redMaskUniformGroup = new ht.k({})),
            (this.greenMaskFilter = new ct.d({})),
            (this.greenMaskUniformGroup = new ht.k({})),
            (this.currentDirection = ko.Down),
            (this.currentSpriteDirection = Mo.Front),
            (this.currentAction = Ao.Idle),
            (this.currentFrame = 0),
            (this.currentFrameId = 0),
            (this.maxFrameId = 0),
            (this.centerFrameIndividually = !1),
            (this.isPet = null === (i = e.isPet) || void 0 === i || i),
            (this.hasOnlySidewaysFrames = !1),
            (this.hasAttackFrames = !1),
            (this.isWalking = !1),
            (this.movementSpeed =
              null !== (n = e.movementSpeed) && void 0 !== n ? n : 140),
            (this.lookAngle = 0.5 * Math.PI),
            (this.moveAngle = 1 / 0),
            (this.isHoldingMouseButton = !1),
            (this.isHoldingAbilityButton = !1),
            (this.isUsingAbility = !1),
            (this.isAttacking = !1),
            (this.attackAngle = 0),
            (this.attacksPerSecond =
              null !== (s = e.attackSpeed) && void 0 !== s ? s : 1.5),
            (this.skinData = {}),
            (this.classType = Di.Wizard),
            (this.idleFrames = new Map()),
            (this.walkFrames = new Map()),
            (this.attackFrames = new Map()),
            (this.abilityFrames = new Map()),
            (this.framesMap = new Map()),
            this.framesMap.set(Ao.Idle, this.idleFrames),
            this.framesMap.set(Ao.Walk, this.walkFrames),
            this.framesMap.set(Ao.Attack, this.attackFrames),
            this.framesMap.set(Ao.Ability, this.abilityFrames);
        }
        setScale(t) {
          (this.spriteScale = t), this.setSkin(this.skinData, !0);
        }
        setWalkableAreaSize(t, e) {
          (this.walkableAreaSize.x = t), (this.walkableAreaSize.y = e);
        }
        startFollowing(t) {
          this.followTarget = t;
        }
        stopFollowing() {
          this.followTarget = void 0;
        }
        updateFollowing() {
          if (void 0 === this.followTarget) return;
          const t = this.followTarget.position.x - this.position.x,
            e = this.followTarget.position.y - this.position.y;
          let i = Math.atan2(e, t);
          i < 0 && (i += 2 * Math.PI);
          const n = t * t + e * e;
          (this.isWalking = n > 1600),
            0 == this.isWalking && this.stopFollowing(),
            (this.moveAngle = i),
            (this.lookAngle = i),
            (this.attackAngle = i);
        }
        updatePosition() {
          const t = Math.floor(this.floatPosition.x),
            e = Math.floor(this.floatPosition.y);
          this.position.set(t, e), (this.zIndex = e);
        }
        setPosition(t, e, i = !0) {
          1 == i && (this.lookAngle = 0.5 * Math.PI);
          const n = Math.max(
              0.5 * this.sprite.width - this.parent.position.x,
              0
            ),
            s = Math.max(this.sprite.height - this.parent.position.y, 0),
            r = this.walkableAreaSize.x,
            o = this.walkableAreaSize.y;
          (this.floatPosition.x = Ve.clamp(t, n, r)),
            (this.floatPosition.y = Ve.clamp(e, s, o)),
            this.updatePosition();
        }
        updateMoveAngle(t) {
          (this.moveAngle = t),
            t != 1 / 0
              ? ((this.isWalking = !0),
                0 == this.isAttacking && (this.lookAngle = t))
              : (this.isWalking = !1);
        }
        updateMovement(t) {
          if (0 == this.isWalking) return;
          if (this.moveAngle == 1 / 0) return;
          const e = Math.cos(this.moveAngle) * t * this.movementSpeed,
            i = Math.sin(this.moveAngle) * t * this.movementSpeed,
            n = Math.max(0.5 * this.sprite.width - this.parent.position.x, 0),
            s = Math.max(this.sprite.height - this.parent.position.y, 0),
            r = this.walkableAreaSize.x,
            o = this.walkableAreaSize.y;
          (this.floatPosition.x = Ve.clamp(this.floatPosition.x + e, n, r)),
            (this.floatPosition.y = Ve.clamp(this.floatPosition.y + i, s, o)),
            this.updatePosition();
        }
        create() {
          return Ho(this, void 0, void 0, function* () {
            this.redMaskUniformGroup = new ht.k({
              uScaleX: { type: "f32", value: 1 },
              uDimensions: { type: "vec2<f32>", value: [8, 8] },
              uFrameSize: { type: "vec2<f32>", value: [8, 8] },
            });
            const t = yield this.ui.getShaderSource("vert", "default"),
              e = yield this.ui.getShaderSource("frag", "red_mask"),
              i = {
                glProgram: lt.M.from({ vertex: t, fragment: e }),
                resources: {
                  uMaskTexture: a.g.EMPTY.source,
                  uniforms: this.redMaskUniformGroup,
                },
              };
            (this.redMaskFilter = new ct.d(i)),
              (this.majorDyedSprite.filters = [this.redMaskFilter]),
              (this.greenMaskUniformGroup = new ht.k({
                uScaleX: { type: "f32", value: 1 },
                uDimensions: { type: "vec2<f32>", value: [8, 8] },
                uFrameSize: { type: "vec2<f32>", value: [8, 8] },
              }));
            const n = yield this.ui.getShaderSource("frag", "green_mask"),
              s = {
                glProgram: lt.M.from({ vertex: t, fragment: n }),
                resources: {
                  uMaskTexture: a.g.EMPTY.source,
                  uniforms: this.greenMaskUniformGroup,
                },
              };
            (this.greenMaskFilter = new ct.d(s)),
              (this.minorDyedSprite.filters = [this.greenMaskFilter]),
              1 == this.isPet
                ? this.setDefaultPetSkin()
                : this.setDefaultPlayerSkin();
            const r = yield this.ui.getTexture("rotmg/shadow");
            this.shadowSprite.texture = r;
          });
        }
        updateAction(t, e) {
          (this.currentAction == t && this.currentDirection == e) ||
            (this.currentAction != t &&
              ((this.currentFrame = 0), (this.currentFrameId = 0)),
            (this.currentAction = t),
            (this.currentDirection = e),
            this.updateSkin());
        }
        updateAnimation(t) {
          var e, i, n, s;
          const r = (() =>
            1 == this.isUsingAbility
              ? 4 * this.getAbilityAnimationLength()
              : 1 == this.isAttacking
              ? this.attacksPerSecond * this.getAttackAnimationLength()
              : 1 == this.isWalking
              ? (1.5 + 0.005 * this.movementSpeed) *
                this.getWalkAnimationLength()
              : 10)();
          let o = !1;
          this.currentFrame += t * r;
          let a = Math.floor(this.currentFrame);
          a !== this.currentFrameId &&
            (a > this.maxFrameId &&
              ((this.currentFrame = 0), (a = 0), (o = !0)),
            (this.currentFrameId = a),
            this.updateSkin()),
            1 == o &&
              (1 == this.isUsingAbility &&
                (0 == this.isHoldingAbilityButton
                  ? (this.isUsingAbility = !1)
                  : this.attack()),
              1 == this.isAttacking &&
                (0 == this.isHoldingMouseButton
                  ? (this.isAttacking = !1)
                  : 0 == this.isUsingAbility && this.attack())),
            1 == this.isUsingAbility
              ? this.updateAction(
                  Ao.Ability,
                  this.mapAttackAngle(this.attackAngle)
                )
              : 1 == this.isAttacking && 1 == this.hasAttackFrames
              ? (this.updateAction(
                  Ao.Attack,
                  this.mapAttackAngle(this.attackAngle)
                ),
                this.setPosition(
                  this.floatPosition.x,
                  this.floatPosition.y,
                  !1
                ))
              : 1 == this.isWalking
              ? this.updateAction(
                  Ao.Walk,
                  this.mapMovementAngle(this.lookAngle)
                )
              : this.updateAction(
                  Ao.Idle,
                  this.mapMovementAngle(this.lookAngle)
                ),
            null === (i = (e = this.majorDyedSprite).updateAnimation) ||
              void 0 === i ||
              i.call(e),
            null === (s = (n = this.minorDyedSprite).updateAnimation) ||
              void 0 === s ||
              s.call(n);
        }
        startAttacking() {
          0 == this.isUsingAbility && 0 == this.isAttacking && this.attack(),
            (this.isHoldingMouseButton = !0),
            (this.isAttacking = !0);
        }
        stopAttackingRequest() {
          this.isHoldingMouseButton = !1;
        }
        startUsingAbility() {
          0 == this.isUsingAbility && this.attack(),
            (this.isHoldingAbilityButton = !0),
            (this.isUsingAbility = !0);
        }
        stopUsingAbility() {
          this.isHoldingAbilityButton = !1;
        }
        attack() {
          if (1 == this.isPet) return;
          const t = this.ui.app.mousePosition,
            e = this.getGlobalPosition(),
            i = t.x - e.x,
            n = t.y - e.y;
          let s = Math.atan2(n, i);
          s < 0 && (s += 2 * Math.PI),
            (this.attackAngle = s),
            (this.lookAngle = s + 0.25 * Math.PI),
            this.lookAngle < 0
              ? (this.lookAngle += 2 * Math.PI)
              : this.lookAngle > 2 * Math.PI && (this.lookAngle -= 2 * Math.PI),
            this.ui.playShootSound();
        }
        mapMovementAngle(t) {
          return t < 0.5 * Math.PI
            ? ko.Right
            : t < 1 * Math.PI
            ? ko.Down
            : t < 1.5 * Math.PI
            ? ko.Left
            : ko.Up;
        }
        mapAttackAngle(t) {
          return t < 0.25 * Math.PI || t > 1.75 * Math.PI
            ? ko.Right
            : t < 0.75 * Math.PI
            ? ko.Down
            : t < 1.25 * Math.PI
            ? ko.Left
            : ko.Up;
        }
        setDefaultPlayerSkin() {
          const t = this.ui.app.dataHandler.classesData.get(this.classType);
          if (void 0 === t) return;
          const e = {
            fileName: t.portraitTexture.fileName,
            index: t.portraitTexture.index,
          };
          this.setSkin(e);
        }
        setDefaultPetSkin() {
          const t = this.ui.app.dataHandler.petFamiliesData.get(Fi.Woodland);
          if (void 0 === t) return;
          const e = t.skins.get(32878);
          void 0 !== e && this.setSkin(e);
        }
        setDye(t, e) {
          return Ho(this, void 0, void 0, function* () {
            const i =
              t == Eo.Major ? this.majorDyedSprite : this.minorDyedSprite;
            void 0 !== e.fileName && void 0 !== e.index
              ? (yield i.setTexture(e.fileName, e.index),
                yield i.setAnimation(e.animationData))
              : void 0 !== e.color
              ? yield i.setColor(e.color)
              : i.removeDye(),
              this.ui.playClickSound();
          });
        }
        setSkin(t) {
          return Ho(this, arguments, void 0, function* (t, e = !1) {
            var i, n, s, r, o, l;
            const u = t.fileName,
              h = t.index;
            if (this.skinData.fileName == u && this.skinData.index == h && !e)
              return;
            (this.skinData = t),
              (this.centerFrameIndividually =
                void 0 !==
                (null ===
                  (i =
                    this.ui.app.dataHandler.alwaysCenteredSkinsData.get(u)) ||
                void 0 === i
                  ? void 0
                  : i.get(h)));
            const c = (yield this.ui.getTexture("rotmg/charactersTextureAtlas"))
                .source,
              d = this.ui.app.dataHandler.getAnimatedTextureData(u, h);
            this.isPet ||
              (this.spriteScale =
                null !== (n = t.scale) && void 0 !== n ? n : 5),
              this.blackSprite.scale.set(this.spriteScale),
              this.sprite.scale.set(this.spriteScale),
              this.shadowSprite.scale.set(0.2 * this.spriteScale),
              this.idleFrames.clear(),
              this.walkFrames.clear(),
              this.attackFrames.clear(),
              this.abilityFrames.clear();
            for (const t of d) {
              const e = this.framesMap.get(t.action);
              if (void 0 === e) continue;
              const i =
                  null !== (s = e.get(t.direction)) && void 0 !== s
                    ? s
                    : new Array(),
                n = new a.g({ source: c, frame: t.coords }),
                r = {
                  x: t.coords.x,
                  y: t.coords.y + t.coords.height,
                  width: t.coords.width,
                  height: t.coords.height,
                },
                o = new Gt.mc(),
                l = new a.g({ source: c, frame: r }),
                u = new Xt.k(l);
              u.scale.set(this.spriteScale), o.addChild(u);
              const h = Ve.nearestPowerOf2(u.width),
                d = Ve.nearestPowerOf2(u.height),
                p = Ht.Y.create({ width: h, height: d, scaleMode: "nearest" });
              this.ui.app.canvas.renderer.render({ target: p, container: o });
              const f = new Array(n, p);
              i.unshift(f), e.set(t.direction, i);
            }
            if (
              ((this.hasOnlySidewaysFrames = 1 == this.idleFrames.size),
              1 == this.idleFrames.size)
            ) {
              const t =
                null !== (r = this.idleFrames.get(Mo.Sideways)) && void 0 !== r
                  ? r
                  : new Array();
              this.idleFrames.set(Mo.Back, t), this.idleFrames.set(Mo.Front, t);
            }
            if (1 == this.walkFrames.size) {
              const t =
                null !== (o = this.walkFrames.get(Mo.Sideways)) && void 0 !== o
                  ? o
                  : new Array();
              this.walkFrames.set(Mo.Back, t), this.walkFrames.set(Mo.Front, t);
            }
            if (
              ((this.hasAttackFrames = 0 != this.attackFrames.size),
              1 == this.attackFrames.size)
            ) {
              const t =
                null !== (l = this.attackFrames.get(Mo.Sideways)) &&
                void 0 !== l
                  ? l
                  : new Array();
              this.attackFrames.set(Mo.Back, t),
                this.attackFrames.set(Mo.Front, t);
            }
            if (0 == this.abilityFrames.size)
              for (const t of this.attackFrames.keys()) {
                const e = this.attackFrames.get(t);
                void 0 !== e && this.abilityFrames.set(t, e);
              }
            this.updateSkin(),
              this.majorDyedSprite.updateAnimationData(),
              this.minorDyedSprite.updateAnimationData(),
              this.setPosition(this.floatPosition.x, this.floatPosition.y);
          });
        }
        getAbilityAnimationLength() {
          var t, e;
          return null !==
            (e =
              null ===
                (t = this.abilityFrames.get(this.currentSpriteDirection)) ||
              void 0 === t
                ? void 0
                : t.length) && void 0 !== e
            ? e
            : 1;
        }
        getAttackAnimationLength() {
          var t, e;
          return null !==
            (e =
              null ===
                (t = this.attackFrames.get(this.currentSpriteDirection)) ||
              void 0 === t
                ? void 0
                : t.length) && void 0 !== e
            ? e
            : 1;
        }
        getWalkAnimationLength() {
          var t, e;
          return null !==
            (e =
              null === (t = this.walkFrames.get(this.currentSpriteDirection)) ||
              void 0 === t
                ? void 0
                : t.length) && void 0 !== e
            ? e
            : 1;
        }
        updateSkin() {
          var t, e, i;
          const [n, s] = this.hasOnlySidewaysFrames
            ? [
                Mo.Sideways,
                this.lookAngle > 0.5 * Math.PI && this.lookAngle < 1.5 * Math.PI
                  ? -1
                  : 1,
              ]
            : null !== (t = Uo.directionMap.get(this.currentDirection)) &&
              void 0 !== t
            ? t
            : [Mo.Sideways, 1];
          this.currentSpriteDirection = n;
          const r =
            null === (e = this.framesMap.get(this.currentAction)) ||
            void 0 === e
              ? void 0
              : e.get(n);
          if (void 0 === r) return;
          (this.maxFrameId = r.length - 1),
            this.currentFrameId > this.maxFrameId && (this.currentFrameId = 0);
          const o =
            null === (i = this.framesMap.get(Ao.Idle)) || void 0 === i
              ? void 0
              : i.get(Mo.Sideways);
          if (void 0 === o) return;
          const a = r[this.currentFrameId],
            l =
              0.5 *
              (this.centerFrameIndividually ? a[0].width : o[0][0].width) *
              this.spriteScale;
          (this.spriteContainer.pivot.x = l),
            (this.spriteContainer.scale.x = s),
            (this.blackSprite.texture = a[0]),
            (this.sprite.texture = a[0]),
            (this.minorDyedSprite.width = this.sprite.width),
            (this.minorDyedSprite.height = this.sprite.height),
            (this.majorDyedSprite.width = this.sprite.width),
            (this.majorDyedSprite.height = this.sprite.height),
            (this.redMaskFilter.resources.uMaskTexture = a[1].source),
            (this.redMaskUniformGroup.uniforms.uScaleX = s),
            (this.redMaskUniformGroup.uniforms.uDimensions = [
              this.sprite.width,
              this.sprite.height,
            ]),
            (this.redMaskUniformGroup.uniforms.uFrameSize = [
              a[1].source.pixelWidth,
              a[1].source.pixelHeight,
            ]),
            this.redMaskUniformGroup.update(),
            (this.greenMaskFilter.resources.uMaskTexture = a[1].source),
            (this.greenMaskUniformGroup.uniforms.uScaleX = s),
            (this.greenMaskUniformGroup.uniforms.uDimensions = [
              this.sprite.width,
              this.sprite.height,
            ]),
            (this.greenMaskUniformGroup.uniforms.uFrameSize = [
              a[1].source.pixelWidth,
              a[1].source.pixelHeight,
            ]),
            this.greenMaskUniformGroup.update();
        }
      }
      (Uo.directionMap = new Map([
        [ko.Up, [Mo.Back, 1]],
        [ko.Down, [Mo.Front, 1]],
        [ko.Left, [Mo.Sideways, -1]],
        [ko.Right, [Mo.Sideways, 1]],
      ])),
        (function (t) {
          (t[(t.MoveUp = 0)] = "MoveUp"),
            (t[(t.MoveDown = 1)] = "MoveDown"),
            (t[(t.MoveLeft = 2)] = "MoveLeft"),
            (t[(t.MoveRight = 3)] = "MoveRight"),
            (t[(t.UseAbility = 4)] = "UseAbility");
        })(zo || (zo = {}));
      class No extends Me {
        constructor(t) {
          super(t),
            (this.playerSprite = new Uo(t, {
              isPet: !1,
              attackSpeed: 8,
              movementSpeed: 140,
              scale: 5,
            })),
            (this.petSprite = new Uo(t, {
              isPet: !0,
              attackSpeed: 4,
              movementSpeed: 140,
              scale: 4,
            })),
            (this.controlledSprite = this.playerSprite),
            (this.followingSprite = this.petSprite),
            (this.inputArray = new Array()),
            (this.onKeyDownBinding = this.onKeyDown.bind(this)),
            (this.onKeyUpBinding = this.onKeyUp.bind(this));
        }
        create() {
          this.playerSprite.create(),
            this.petSprite.create(),
            this.resetPosition();
        }
        setPetScale(t) {
          this.petSprite.setScale(t);
        }
        bindKeyboardEvents() {
          window.addEventListener("keydown", this.onKeyDownBinding),
            window.addEventListener("keyup", this.onKeyUpBinding);
        }
        unbindKeyboardEvents() {
          window.removeEventListener("keydown", this.onKeyDownBinding),
            window.removeEventListener("keyup", this.onKeyUpBinding);
        }
        startAttacking() {
          this.playerSprite.startAttacking(), this.petSprite.startAttacking();
        }
        stopAttacking() {
          this.playerSprite.stopAttackingRequest(),
            this.petSprite.stopAttackingRequest();
        }
        setWalkableAreaSize(t, e) {
          this.playerSprite.setWalkableAreaSize(t, e),
            this.petSprite.setWalkableAreaSize(t, e);
        }
        update(t) {
          this.handleInput(),
            this.handlePetPosition(),
            this.controlledSprite.updateMovement(t),
            this.controlledSprite.updateAnimation(t),
            this.followingSprite.updateFollowing(),
            this.followingSprite.updateMovement(t),
            this.followingSprite.updateAnimation(t);
        }
        clearInput() {
          for (let t = 0; t < this.inputArray.length; t++)
            this.inputArray[t] = !1;
        }
        getPlayerSprite() {
          return this.playerSprite;
        }
        getPetSprite() {
          return this.petSprite;
        }
        resetPosition() {
          this.playerSprite.setPosition(240, 120),
            this.petSprite.setPosition(160, 120);
        }
        setSkin(t) {
          this.playerSprite.setSkin(t);
        }
        setPetSkin(t) {
          this.petSprite.setSkin(t);
        }
        swapControl() {
          (this.petSprite.isPet = !this.petSprite.isPet),
            (this.playerSprite.isPet = !this.playerSprite.isPet),
            1 == this.playerSprite.isPet
              ? ((this.controlledSprite = this.petSprite),
                (this.followingSprite = this.playerSprite))
              : ((this.controlledSprite = this.playerSprite),
                (this.followingSprite = this.petSprite));
        }
        togglePetVisibility() {
          return (
            (this.followingSprite.renderable =
              !this.followingSprite.renderable),
            this.followingSprite.renderable
          );
        }
        togglePlayerVisibility() {
          return (
            (this.controlledSprite.renderable =
              !this.controlledSprite.renderable),
            this.controlledSprite.renderable
          );
        }
        onKeyDown(t) {
          if (!this.ui.hasFocus())
            switch (t.key) {
              case "w":
                this.inputArray[zo.MoveUp] = !0;
                break;
              case "s":
                this.inputArray[zo.MoveDown] = !0;
                break;
              case "a":
                this.inputArray[zo.MoveLeft] = !0;
                break;
              case "d":
                this.inputArray[zo.MoveRight] = !0;
                break;
              case " ":
                (this.inputArray[zo.UseAbility] = !0), this.startUsingAbility();
            }
        }
        onKeyUp(t) {
          switch (t.key) {
            case "w":
              this.inputArray[zo.MoveUp] = !1;
              break;
            case "s":
              this.inputArray[zo.MoveDown] = !1;
              break;
            case "a":
              this.inputArray[zo.MoveLeft] = !1;
              break;
            case "d":
              this.inputArray[zo.MoveRight] = !1;
              break;
            case " ":
              (this.inputArray[zo.UseAbility] = !1), this.stopUsingAbility();
          }
        }
        startUsingAbility() {
          this.controlledSprite.startUsingAbility();
        }
        stopUsingAbility() {
          this.controlledSprite.stopUsingAbility();
        }
        handleInput() {
          let t = 1 / 0;
          (this.inputArray[zo.MoveUp] && this.inputArray[zo.MoveDown]) ||
          (this.inputArray[zo.MoveLeft] && this.inputArray[zo.MoveRight])
            ? (t = 1 / 0)
            : this.inputArray[zo.MoveUp] && this.inputArray[zo.MoveLeft]
            ? (t = 1.25 * Math.PI)
            : this.inputArray[zo.MoveUp] && this.inputArray[zo.MoveRight]
            ? (t = 1.75 * Math.PI)
            : this.inputArray[zo.MoveDown] && this.inputArray[zo.MoveLeft]
            ? (t = 0.75 * Math.PI)
            : this.inputArray[zo.MoveDown] && this.inputArray[zo.MoveRight]
            ? (t = 0.25 * Math.PI)
            : this.inputArray[zo.MoveUp]
            ? (t = 1.5 * Math.PI)
            : this.inputArray[zo.MoveDown]
            ? (t = 0.5 * Math.PI)
            : this.inputArray[zo.MoveLeft]
            ? (t = Math.PI)
            : this.inputArray[zo.MoveRight] && (t = 0),
            this.controlledSprite.updateMoveAngle(t);
        }
        handlePetPosition() {
          const t =
              this.controlledSprite.position.x -
              this.followingSprite.position.x,
            e =
              this.controlledSprite.position.y -
              this.followingSprite.position.y;
          t * t + e * e > 1e4 &&
            this.followingSprite.startFollowing(this.controlledSprite);
        }
      }
      !(function (t) {
        (t[(t.None = -1)] = "None"),
          (t[(t.PlayerColorDye = 0)] = "PlayerColorDye"),
          (t[(t.PlayerTextileDye = 1)] = "PlayerTextileDye"),
          (t[(t.PlayerFlipbook = 2)] = "PlayerFlipbook"),
          (t[(t.PlayerArcaneStyle = 3)] = "PlayerArcaneStyle"),
          (t[(t.PetFlipbook = 4)] = "PetFlipbook"),
          (t[(t.PetArcaneStyle = 5)] = "PetArcaneStyle");
      })(Lo || (Lo = {}));
      var Go = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Vo extends Me {
        constructor(t) {
          super(t),
            (this.labels = ""),
            (this.searchResult = !0),
            (this.eventMode = "static"),
            (this.cursor = "pointer"),
            (this.paddingBackgroundSprite = new Xt.k(a.g.EMPTY)),
            (this.paddingBackgroundSprite.width = 42),
            (this.paddingBackgroundSprite.height = 42),
            this.paddingBackgroundSprite.anchor.set(0.5),
            this.addChild(this.paddingBackgroundSprite),
            (this.borderSprite = new Xt.k()),
            this.borderSprite.anchor.set(0.5),
            (this.borderSprite.eventMode = "none"),
            this.addChild(this.borderSprite),
            (this.dyedTilingSprite = new Oo(t, { width: 38, height: 38 })),
            this.dyedTilingSprite.anchor.set(0.5),
            (this.dyedTilingSprite.eventMode = "none"),
            this.addChild(this.dyedTilingSprite);
        }
        create(t, e) {
          return Go(this, void 0, void 0, function* () {
            this.labels = t.name.toLowerCase();
            const i =
              null != e
                ? e
                : yield this.ui.frameTexture({
                    frameTexture: "pure_white_frame",
                    size: { x: 40, y: 40 },
                  });
            this.borderSprite.texture = i;
          });
        }
        removeDye() {
          this.dyedTilingSprite.removeDye();
        }
        updateAnimation() {
          return Go(this, void 0, void 0, function* () {
            var t, e;
            null === (e = (t = this.dyedTilingSprite).updateAnimation) ||
              void 0 === e ||
              e.call(t);
          });
        }
        setBorderColor(t) {
          this.borderSprite.tint = t;
        }
        setColor(t) {
          return Go(this, void 0, void 0, function* () {
            this.dyedTilingSprite.setColor(t), yield this.setMask();
          });
        }
        setTexture(t, e) {
          return Go(this, void 0, void 0, function* () {
            yield this.dyedTilingSprite.setTexture(t, e), yield this.setMask();
          });
        }
        setAnimation(t) {
          return Go(this, void 0, void 0, function* () {
            this.dyedTilingSprite.setAnimation(t);
          });
        }
        setMask() {
          return Go(this, void 0, void 0, function* () {
            void 0 === this.maskSprite &&
              ((this.maskSprite = new Xt.k()),
              (this.maskSprite.texture = yield this.ui.getTexture(
                "masks/textile_mask"
              )),
              this.maskSprite.anchor.set(0.5),
              this.addChild(this.maskSprite),
              (this.dyedTilingSprite.mask = this.maskSprite));
          });
        }
      }
      var jo = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class $o extends Me {
        constructor(t) {
          super(t),
            (this.labels = ""),
            (this.searchResult = !0),
            (this.backgroundSprite = new Xt.k()),
            this.addChild(this.backgroundSprite),
            (this.skinSprite = new js(this.ui)),
            this.addChild(this.skinSprite);
        }
        create(t, e, i) {
          return jo(this, arguments, void 0, function* (t, e, i, n = !1) {
            const s = yield n
              ? this.skinSprite.createPortrait(e, !1)
              : i
              ? this.skinSprite.createPetSkin(t, e)
              : this.skinSprite.createPlayerSkin(t, e);
            return (
              void 0 === s
                ? this.skinSprite.scale.set(0.8)
                : (this.labels = s.name.toLowerCase()),
              (this.backgroundSprite.texture = new a.g(a.g.EMPTY)),
              this.backgroundSprite.anchor.set(0.5),
              (this.backgroundSprite.width = 42),
              (this.backgroundSprite.height = 42),
              (this.backgroundSprite.eventMode = "static"),
              (this.backgroundSprite.cursor = "pointer"),
              this.skinSprite.anchor.set(0.5, 1),
              this.skinSprite.position.set(
                0,
                0.5 * this.backgroundSprite.height
              ),
              (this.skinSprite.eventMode = "none"),
              this.show(),
              Promise.resolve(s)
            );
          });
        }
      }
      var qo = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Wo extends Me {
        constructor(t) {
          super(t),
            (this.backgroundSprite = new Xt.k()),
            this.addChild(this.backgroundSprite),
            (this.eggSprite = new js(this.ui)),
            this.addChild(this.eggSprite);
        }
        create(t) {
          return qo(this, void 0, void 0, function* () {
            (this.backgroundSprite.texture = new a.g(a.g.EMPTY)),
              this.backgroundSprite.anchor.set(0.5),
              (this.backgroundSprite.width = 42),
              (this.backgroundSprite.height = 42),
              (this.backgroundSprite.eventMode = "static"),
              (this.backgroundSprite.cursor = "pointer"),
              yield this.eggSprite.createEgg(t),
              this.eggSprite.anchor.set(0.5, 0.5),
              this.eggSprite.scale.set(0.8),
              (this.eggSprite.eventMode = "none"),
              this.show();
          });
        }
      }
      var Xo,
        Yo = function (t, e, i, n) {
          return new (i || (i = Promise))(function (s, r) {
            function o(t) {
              try {
                l(n.next(t));
              } catch (t) {
                r(t);
              }
            }
            function a(t) {
              try {
                l(n.throw(t));
              } catch (t) {
                r(t);
              }
            }
            function l(t) {
              t.done
                ? s(t.value)
                : (function (t) {
                    return t instanceof i
                      ? t
                      : new i(function (e) {
                          e(t);
                        });
                  })(t.value).then(o, a);
            }
            l((n = n.apply(t, e || [])).next());
          });
        };
      class Ko extends Me {
        constructor(t) {
          super(t),
            (this.backgroundSprite = new Xt.k()),
            this.addChild(this.backgroundSprite),
            (this.sprite = new js(this.ui)),
            this.addChild(this.sprite);
        }
        create(t) {
          return Yo(this, void 0, void 0, function* () {
            (this.backgroundSprite.texture = new a.g(a.g.EMPTY)),
              this.backgroundSprite.anchor.set(0.5),
              (this.backgroundSprite.width = 42),
              (this.backgroundSprite.height = 42);
            const e = yield this.ui.getTexture(t);
            (this.sprite.texture = e),
              this.sprite.anchor.set(0.5, 0.5),
              this.sprite.scale.set(0.8),
              (this.sprite.eventMode = "none"),
              this.show();
          });
        }
        setInteractive(t) {
          (this.backgroundSprite.eventMode = 1 == t ? "static" : "none"),
            (this.backgroundSprite.cursor = 1 == t ? "pointer" : "default");
        }
      }
      !(function (t) {
        (t[(t.Left = 0)] = "Left"),
          (t[(t.Middle = 1)] = "Middle"),
          (t[(t.Right = 2)] = "Right");
      })(Xo || (Xo = {}));
      var Zo = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class Qo extends ai {
        constructor(t) {
          var e, i, n, s;
          super(t),
            (this.container = new Me(t.ui)),
            (this.container.visible = !1),
            (this.interactiveContainer = new Gt.mc()),
            this.interactiveContainer.position.set(0, 32),
            (this.interactiveContainer.eventMode = "static"),
            this.interactiveContainer.addListener(
              "mousedown",
              this.onInteractiveBackgroundMouseDown.bind(this)
            ),
            this.interactiveContainer.addListener(
              "rightdown",
              this.onInteractiveBackgroundRightDown.bind(this)
            ),
            window.addEventListener(
              "mouseup",
              this.onInteractiveBackgroundMouseUp.bind(this)
            ),
            this.container.addChild(this.interactiveContainer),
            (this.interactiveSprite = new Xt.k()),
            this.interactiveContainer.addChild(this.interactiveSprite),
            (this.toolTitleText = t.ui.text({
              text: "Skin Viewer",
              anchor: Ve.CENTER_X,
            })),
            this.container.addChild(this.toolTitleText),
            (this.toolNoteText = t.ui.text({
              text: "Note: WSAD to Move; Left Click to Attack; Right Click to Use Ability",
              anchor: Ve.CENTER_X,
              style: { fill: ti.gray },
            })),
            this.container.addChild(this.toolNoteText),
            (this.togglesContainer = new Gt.mc()),
            this.container.addChild(this.togglesContainer),
            (this.petToggleIcon = new oi(this.app.ui, {
              iconTexture: "pet_icon",
              anchor: Ve.CENTER,
              guidanceTooltip: [
                ["Pet Visibility Toggle", ti.white],
                ["Left Click to Toggle", ti.orange],
                ["Right Click to Change Scale", ti.blue],
              ],
              onClick: this.onShowPetIconClick.bind(this),
              onRightClick: this.onShowPetRightClick.bind(this),
            })),
            (this.petScale = 4),
            (this.petScaleText = this.app.ui.text({
              text: `x${this.petScale}`,
              style: Object.assign(
                Object.assign({}, this.app.ui.outlineTextStyle),
                {
                  fill:
                    null !==
                      (i =
                        null === (e = this.app.ui.theme) || void 0 === e
                          ? void 0
                          : e.specialCaseTextColor) && void 0 !== i
                      ? i
                      : ti.lightyellow,
                }
              ),
            })),
            this.petToggleIcon.addChild(this.petScaleText),
            this.petScaleText.position.set(12, 6),
            this.togglesContainer.addChild(this.petToggleIcon),
            (this.petSwapIcon = new oi(this.app.ui, {
              iconTexture: "swap_icon",
              anchor: Ve.CENTER,
              guidanceTooltip: [
                ["Control Swap Toggle", ti.white],
                ["Left Click to Swap Control", ti.orange],
                ["Between Player And Pet", ti.orange],
              ],
              onClick: this.onPetSwapClick.bind(this),
            })),
            (this.petSwapIcon.alpha =
              0.3 *
              (null !==
                (s =
                  null === (n = this.app.ui.theme) || void 0 === n
                    ? void 0
                    : n.semitransparencyMultiplier) && void 0 !== s
                ? s
                : 1)),
            this.togglesContainer.addChild(this.petSwapIcon),
            (this.selectedElementsPreviewContainer = new Gt.mc()),
            this.container.addChild(this.selectedElementsPreviewContainer),
            (this.selectedElementsPreviewLabelText = this.app.ui.text({
              text: "Selected Skins",
              anchor: Ve.CENTER_X,
            })),
            this.selectedElementsPreviewContainer.addChild(
              this.selectedElementsPreviewLabelText
            ),
            (this.selectedPlayerSkinPreview = new $o(this.app.ui)),
            this.selectedPlayerSkinPreview.addListener(
              "mouseenter",
              this.showSelectedPlayerSkinInfo.bind(this)
            ),
            this.selectedPlayerSkinPreview.addListener(
              "mouseleave",
              this.app.tooltipHandler.onMouseLeaveBinding
            ),
            this.selectedElementsPreviewContainer.addChild(
              this.selectedPlayerSkinPreview
            ),
            (this.selectedPlayerLargeDyeLabelText = this.app.ui.text({
              text: "Large Dye",
              anchor: Ve.CENTER_X,
            })),
            this.selectedElementsPreviewContainer.addChild(
              this.selectedPlayerLargeDyeLabelText
            ),
            (this.selectedPlayerLargeDyePreview = new Vo(this.app.ui)),
            this.selectedPlayerLargeDyePreview.addListener(
              "mouseenter",
              this.showSelectedLargeDyeInfo.bind(this)
            ),
            this.selectedPlayerLargeDyePreview.addListener(
              "mouseleave",
              this.app.tooltipHandler.onMouseLeaveBinding
            ),
            this.selectedElementsPreviewContainer.addChild(
              this.selectedPlayerLargeDyePreview
            ),
            (this.selectedPlayerSmallDyeLabelText = this.app.ui.text({
              text: "Small Dye",
              anchor: Ve.CENTER_X,
            })),
            this.selectedElementsPreviewContainer.addChild(
              this.selectedPlayerSmallDyeLabelText
            ),
            (this.selectedPlayerSmallDyePreview = new Vo(this.app.ui)),
            this.selectedPlayerSmallDyePreview.addListener(
              "mouseenter",
              this.showSelectedSmallDyeInfo.bind(this)
            ),
            this.selectedPlayerSmallDyePreview.addListener(
              "mouseleave",
              this.app.tooltipHandler.onMouseLeaveBinding
            ),
            this.selectedElementsPreviewContainer.addChild(
              this.selectedPlayerSmallDyePreview
            ),
            (this.selectedPetSkinPreview = new $o(this.app.ui)),
            this.selectedPetSkinPreview.addListener(
              "mouseenter",
              this.showSelectedPetSkinInfo.bind(this)
            ),
            this.selectedPetSkinPreview.addListener(
              "mouseleave",
              this.app.tooltipHandler.onMouseLeaveBinding
            ),
            this.selectedElementsPreviewContainer.addChild(
              this.selectedPetSkinPreview
            ),
            (this.walkableAreaContainer = new Gt.mc()),
            (this.walkableAreaContainer.eventMode = "none"),
            this.container.addChild(this.walkableAreaContainer),
            (this.walkableAreaBackgroundSprite = new Xt.k()),
            this.walkableAreaBackgroundSprite.scale.set(5),
            this.walkableAreaContainer.addChild(
              this.walkableAreaBackgroundSprite
            ),
            (this.playerHandler = new No(t.ui)),
            this.walkableAreaContainer.addChild(
              this.playerHandler.getPlayerSprite()
            ),
            this.walkableAreaContainer.addChild(
              this.playerHandler.getPetSprite()
            ),
            (this.playerCustomizationContainer = new Gt.mc()),
            this.container.addChild(this.playerCustomizationContainer),
            (this.playerClassTypeSelectionLabelText = this.app.ui.text({
              text: "Player Class Filter",
            })),
            this.playerCustomizationContainer.addChild(
              this.playerClassTypeSelectionLabelText
            ),
            (this.playerClassTypeSelectionContainer = new Gt.mc()),
            this.playerCustomizationContainer.addChild(
              this.playerClassTypeSelectionContainer
            ),
            (this.playerClassTypeSelectionArray = new Array()),
            (this.playerSkinContentLabelText = this.app.ui.text({
              text: "Player Skin Selection",
            })),
            this.playerCustomizationContainer.addChild(
              this.playerSkinContentLabelText
            ),
            (this.playerSkinContentContainer = new Gt.mc()),
            this.playerCustomizationContainer.addChild(
              this.playerSkinContentContainer
            ),
            (this.playerClassSkinsArray = new Array()),
            (this.selectedPlayerClassType = Di.None),
            (this.skinCustomizationContainer = new Gt.mc()),
            this.container.addChild(this.skinCustomizationContainer),
            (this.skinCustomizationTypeSelectionLabelText = this.app.ui.text({
              text: "Customization Filter",
            })),
            this.skinCustomizationContainer.addChild(
              this.skinCustomizationTypeSelectionLabelText
            ),
            (this.skinCustomizationTypeSelectionContainer = new Gt.mc()),
            this.skinCustomizationContainer.addChild(
              this.skinCustomizationTypeSelectionContainer
            ),
            (this.skinCustomizationTypeSelectionArray = new Array()),
            (this.skinCustomizationContentLabelText = this.app.ui.text({
              text: "Customization Selection",
            })),
            this.skinCustomizationContainer.addChild(
              this.skinCustomizationContentLabelText
            ),
            (this.skinCustomizationContentContainer = new Gt.mc()),
            this.skinCustomizationContainer.addChild(
              this.skinCustomizationContentContainer
            ),
            (this.skinCustomizationArray = new Array()),
            (this.selectedSkinCustomizationType = Lo.None),
            (this.playerDyeCustomizationSprite =
              this.createskinCustomizationTypeIcon(Lo.PlayerColorDye)),
            (this.playerTextileCustomizationSprite =
              this.createskinCustomizationTypeIcon(Lo.PlayerTextileDye)),
            (this.playerFlipbookCustomizationSprite =
              this.createskinCustomizationTypeIcon(Lo.PlayerFlipbook)),
            (this.playerArcaneStyleCustomizationSprite =
              this.createskinCustomizationTypeIcon(Lo.PlayerArcaneStyle)),
            (this.petFlipbookCustomizationSprite =
              this.createskinCustomizationTypeIcon(Lo.PetFlipbook)),
            (this.petArcaneStyleCustomizationSprite =
              this.createskinCustomizationTypeIcon(Lo.PetArcaneStyle)),
            (this.petCustomizationContainer = new Gt.mc()),
            this.container.addChild(this.petCustomizationContainer),
            (this.petFamilyTypeSelectionLabelText = this.app.ui.text({
              text: "Pet Family Filter",
            })),
            this.petCustomizationContainer.addChild(
              this.petFamilyTypeSelectionLabelText
            ),
            (this.petFamilyTypeSelectionContainer = new Gt.mc()),
            this.petCustomizationContainer.addChild(
              this.petFamilyTypeSelectionContainer
            ),
            (this.petFamilyTypeSelectionArray = new Array()),
            (this.petSkinContentLabelText = this.app.ui.text({
              text: "Pet Skin Selection",
            })),
            this.petCustomizationContainer.addChild(
              this.petSkinContentLabelText
            ),
            (this.petSkinContentContainer = new Gt.mc()),
            this.petCustomizationContainer.addChild(
              this.petSkinContentContainer
            ),
            (this.petFamilySkinsArray = new Array()),
            (this.selectedPetFamilyType = Fi.None),
            (this.updateBinding = this.update.bind(this));
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return Zo(this, void 0, void 0, function* () {
            var e, i, n, s, r, o, a, l, u;
            const h = yield this.app.ui.getTexture(
              `rotmg/tilesets/${
                null !==
                  (i =
                    null === (e = this.app.ui.theme) || void 0 === e
                      ? void 0
                      : e.walkableAreaTileset) && void 0 !== i
                  ? i
                  : "realm_tileset"
              }`
            );
            (this.walkableAreaBackgroundSprite.texture = h),
              this.app.canvas.addChild(this.container),
              this.playerHandler.create(),
              this.playerHandler.setWalkableAreaSize(
                this.walkableAreaBackgroundSprite.width,
                this.walkableAreaBackgroundSprite.height
              ),
              this.petToggleIcon.position.set(20, 0),
              this.petToggleIcon.create(),
              this.petSwapIcon.position.set(20, 36),
              this.petSwapIcon.create(),
              yield this.playerDyeCustomizationSprite.create(
                "ui/icons/dye_icon"
              ),
              yield this.playerTextileCustomizationSprite.create(
                "ui/icons/cloth_icon"
              ),
              yield this.playerFlipbookCustomizationSprite.create(
                "ui/icons/player_flipbook_icon"
              ),
              yield this.playerArcaneStyleCustomizationSprite.create(
                "ui/icons/player_arcane_icon"
              ),
              yield this.petFlipbookCustomizationSprite.create(
                "ui/icons/pet_flipbook_icon"
              ),
              yield this.petArcaneStyleCustomizationSprite.create(
                "ui/icons/pet_arcane_icon"
              );
            const c = {
              placeholder: "Search",
              clearOnClick: !0,
              size: { x: 100, y: 24 },
            };
            (this.playerSkinContentSearchBar = yield this.app.ui.searchbar(
              Object.assign({}, c)
            )),
              this.playerSkinContentSearchBar.on(
                "change",
                this.onPlayerSkinSearchBarInput.bind(this)
              ),
              this.playerCustomizationContainer.addChild(
                this.playerSkinContentSearchBar
              ),
              (this.skinCustomizationContentSearchBar =
                yield this.app.ui.searchbar(Object.assign({}, c))),
              this.skinCustomizationContentSearchBar.on(
                "change",
                this.onSkinCustomizationSearchBarInput.bind(this)
              ),
              this.skinCustomizationContainer.addChild(
                this.skinCustomizationContentSearchBar
              ),
              (this.petSkinContentSearchBar = yield this.app.ui.searchbar(
                Object.assign({}, c)
              )),
              this.petSkinContentSearchBar.on(
                "change",
                this.onPetSkinSearchBarInput.bind(this)
              ),
              this.petCustomizationContainer.addChild(
                this.petSkinContentSearchBar
              ),
              (this.playerSkinContentScrollContainer = new Js(this.app.ui, {
                size: { x: 0, y: 0 },
                itemSize: { x: 42, y: 42 },
                itemAnchor: Ve.CENTER,
                itemOffset: { x: 0, y: 0 },
                itemsInRow: 10,
                itemSpacing: { x: 0, y: 0 },
                scrollSpeed: 42,
              })),
              this.playerSkinContentContainer.addChild(
                this.playerSkinContentScrollContainer
              );
            const d =
                null !==
                  (s =
                    null === (n = this.app.ui.theme) || void 0 === n
                      ? void 0
                      : n.semitransparencyMultiplier) && void 0 !== s
                  ? s
                  : 1,
              p = Array.from(this.app.dataHandler.classesData.values());
            for (let t = 0; t < p.length; t++) {
              const e = p[t],
                i = new $o(this.app.ui);
              this.playerClassTypeSelectionContainer.addChild(i),
                yield i.create(0, e.type, !1, !0),
                (i.alpha = 0.3 * d),
                (i.eventMode = "static"),
                (i.cursor = "pointer"),
                i.addListener("mousedown", (t) =>
                  this.onPlayerClassIconClick(e.type)
                ),
                i.addListener("mouseenter", (t) =>
                  this.onPlayerClassIconHover(e.type)
                ),
                i.addListener("mouseleave", (t) =>
                  this.onPlayerClassIconMouseLeave(e.type, t)
                ),
                (this.playerClassTypeSelectionArray[e.type] = i);
              const n =
                null === (r = this.app.dataHandler.skinsData.get(e.type)) ||
                void 0 === r
                  ? void 0
                  : r.keys();
              if (void 0 !== n)
                for (const t of n) {
                  const i = new $o(this.app.ui),
                    n = yield i.create(t, e.type, !1);
                  if (void 0 === n) continue;
                  i.addListener("mouseenter", () =>
                    this.app.tooltipHandler.showSkinDescription(n)
                  ),
                    i.addListener(
                      "mouseleave",
                      this.app.tooltipHandler.onMouseLeaveBinding
                    ),
                    i.addListener("mousedown", () =>
                      this.onPlayerSkinIconClick(n)
                    ),
                    this.playerSkinContentScrollContainer.addElement(i);
                  const s =
                    null !== (o = this.playerClassSkinsArray[e.type]) &&
                    void 0 !== o
                      ? o
                      : new Array();
                  s.push(i), (this.playerClassSkinsArray[e.type] = s);
                }
            }
            yield this.playerSkinContentScrollContainer.create(),
              (this.petSkinContentScrollContainer = new Js(this.app.ui, {
                size: { x: 0, y: 0 },
                itemSize: { x: 42, y: 42 },
                itemAnchor: Ve.CENTER,
                itemOffset: { x: 0, y: 0 },
                itemsInRow: 10,
                itemSpacing: { x: 0, y: 0 },
                scrollSpeed: 42,
              })),
              this.petSkinContentContainer.addChild(
                this.petSkinContentScrollContainer
              );
            const f = Array.from(this.app.dataHandler.petFamiliesData.values());
            for (let t = 0; t < f.length; t++) {
              const e = f[t],
                i = new Wo(this.app.ui);
              this.petFamilyTypeSelectionContainer.addChild(i),
                yield i.create(e.type),
                (i.alpha = 0.3 * d),
                (i.eventMode = "static"),
                (i.cursor = "pointer"),
                i.addListener("mousedown", () =>
                  this.onPetEggIconClick(e.type)
                ),
                i.addListener("mouseenter", () =>
                  this.onPetEggIconHover(e.type)
                ),
                i.addListener("mouseleave", (t) =>
                  this.onPetEggIconMouseLeave(e.type, t)
                ),
                (this.petFamilyTypeSelectionArray[e.type] = i);
              const n = e.skins.keys();
              if (void 0 !== n)
                for (const t of n) {
                  const i = new $o(this.app.ui),
                    n = yield i.create(t, e.type, !0);
                  if (void 0 === n) continue;
                  i.addListener("mouseenter", () =>
                    this.app.tooltipHandler.showSkinDescription(n, !0)
                  ),
                    i.addListener(
                      "mouseleave",
                      this.app.tooltipHandler.onMouseLeaveBinding
                    ),
                    i.addListener("mousedown", () => this.onPetSkinClick(n)),
                    this.petSkinContentScrollContainer.addElement(i);
                  const s =
                    null !== (a = this.petFamilySkinsArray[e.type]) &&
                    void 0 !== a
                      ? a
                      : new Array();
                  s.push(i), (this.petFamilySkinsArray[e.type] = s);
                }
            }
            yield this.petSkinContentScrollContainer.create(),
              yield this.createPlayerDyes(),
              this.showPlayerSkins(),
              this.showPetSkins(),
              this.showSkinCustomization(),
              this.selectedElementsPreviewLabelText.position.set(0, 0),
              (this.selectedPetSkinData =
                yield this.selectedPetSkinPreview.create(
                  32878,
                  Fi.Woodland,
                  !0
                )),
              this.selectedPetSkinPreview.position.set(-25, 46);
            const m = this.app.dataHandler.skinsData.get(Di.Wizard),
              g = this.app.dataHandler.classesData.get(Di.Wizard);
            let v = 0;
            if (void 0 !== m)
              for (let t of m.values())
                t.fileName ==
                  (null == g ? void 0 : g.portraitTexture.fileName) &&
                  t.index == (null == g ? void 0 : g.portraitTexture.index) &&
                  (v = t.id);
            const y =
              null !==
                (u =
                  null === (l = this.app.ui.theme) || void 0 === l
                    ? void 0
                    : l.chartBorderColor) && void 0 !== u
                ? u
                : 0;
            (this.selectedPlayerSkinData =
              yield this.selectedPlayerSkinPreview.create(v, Di.Wizard, !1)),
              this.selectedPlayerSkinPreview.position.set(24, 46),
              this.selectedPlayerLargeDyeLabelText.position.set(2, 76),
              (this.selectedPlayerLargeDyeData = {
                id: 0,
                name: "Empty Large Dye",
              }),
              this.selectedPlayerLargeDyePreview.create(
                this.selectedPlayerLargeDyeData
              ),
              this.selectedPlayerLargeDyePreview.setBorderColor(y),
              this.selectedPlayerLargeDyePreview.position.set(0, 116),
              this.selectedPlayerSmallDyeLabelText.position.set(2, 140),
              (this.selectedPlayerSmallDyeData = {
                id: 0,
                name: "Empty Small Dye",
              }),
              this.selectedPlayerSmallDyePreview.create(
                this.selectedPlayerSmallDyeData
              ),
              this.selectedPlayerSmallDyePreview.setBorderColor(y),
              this.selectedPlayerSmallDyePreview.position.set(0, 180),
              t.create.call(this);
          });
        }
        showSelectedPlayerSkinInfo() {
          void 0 !== this.selectedPlayerSkinData &&
            this.app.tooltipHandler.showSkinDescription(
              this.selectedPlayerSkinData
            );
        }
        showSelectedPetSkinInfo() {
          void 0 !== this.selectedPetSkinData &&
            this.app.tooltipHandler.showSkinDescription(
              this.selectedPetSkinData,
              !0
            );
        }
        showSelectedLargeDyeInfo() {
          void 0 !== this.selectedPlayerLargeDyeData &&
            this.app.tooltipHandler.showDyeDescription(
              this.selectedPlayerLargeDyeData,
              !0
            );
        }
        showSelectedSmallDyeInfo() {
          void 0 !== this.selectedPlayerSmallDyeData &&
            this.app.tooltipHandler.showDyeDescription(
              this.selectedPlayerSmallDyeData,
              !0
            );
        }
        onPlayerSkinSearchBarInput(t) {
          (t = t.toLowerCase()), this.showPlayerSkins(t);
        }
        onSkinCustomizationSearchBarInput(t) {
          (t = t.toLowerCase()), this.showSkinCustomization(t);
        }
        onPetSkinSearchBarInput(t) {
          (t = t.toLowerCase()), this.showPetSkins(t);
        }
        createskinCustomizationTypeIcon(t) {
          var e, i;
          const n = new Ko(this.app.ui);
          return (
            (n.alpha =
              0.3 *
              (null !==
                (i =
                  null === (e = this.app.ui.theme) || void 0 === e
                    ? void 0
                    : e.semitransparencyMultiplier) && void 0 !== i
                ? i
                : 1)),
            t < Lo.PlayerFlipbook &&
              (n.setInteractive(!0),
              n.addListener("mousedown", () =>
                this.onSkinCustomizationTypeIconClick(t)
              )),
            n.addListener("mouseenter", () =>
              this.onSkinCustomizationIconHover(t)
            ),
            n.addListener("mouseleave", (e) =>
              this.onSkinCustomizationIconMouseLeave(t, e)
            ),
            this.skinCustomizationTypeSelectionContainer.addChild(n),
            (this.skinCustomizationTypeSelectionArray[t] = n),
            n
          );
        }
        updatePlayerTextileDyes() {
          const t = this.skinCustomizationArray[Lo.PlayerTextileDye];
          for (let e = 0; e < t.length; e++) t[e].updateAnimation();
          this.selectedPlayerSmallDyePreview.updateAnimation(),
            this.selectedPlayerLargeDyePreview.updateAnimation();
        }
        createPlayerDyes() {
          return Zo(this, void 0, void 0, function* () {
            var t, e, i, n, s;
            (this.skinCustomizationContentScrollContainer = new Js(
              this.app.ui,
              {
                size: { x: 0, y: 0 },
                itemSize: { x: 42, y: 42 },
                itemAnchor: Ve.CENTER,
                itemOffset: { x: 0, y: 0 },
                itemsInRow: 10,
                itemSpacing: { x: 0, y: 0 },
                scrollSpeed: 42,
              }
            )),
              this.skinCustomizationContentContainer.addChild(
                this.skinCustomizationContentScrollContainer
              );
            const r = yield this.app.ui.getTexture("ui/icons/dye_remover_icon"),
              o = {
                name: "Dye Remover",
                color: void 0,
                fileName: void 0,
                index: void 0,
              },
              a = new Vo(this.app.ui);
            a.scale.set(0.8),
              (a.cursor = "pointer"),
              (a.eventMode = "static"),
              a.addListener("mousedown", () => this.onPlayerDyeClick(o)),
              a.addListener("rightdown", () => this.onPlayerDyeRightClick(o)),
              a.addListener("mouseenter", () =>
                this.app.tooltipHandler.showDyeDescription(o)
              ),
              a.addListener(
                "mouseleave",
                this.app.tooltipHandler.onMouseLeaveBinding
              ),
              a.create(o, r),
              null === (t = this.skinCustomizationContentScrollContainer) ||
                void 0 === t ||
                t.addElement(a);
            const l = (0, Ue.sortBy)(
                Array.from(this.app.dataHandler.dyesData.values()).reverse(),
                (t) => {
                  var e;
                  const i = new at.Q(
                      null !== (e = t.color) && void 0 !== e ? e : 0
                    ),
                    n = Ve.rgb2hsv(i.red, i.green, i.blue);
                  return 3600 * n[0] + 100 * (1 - n[1]) * n[2];
                }
              ),
              u =
                null !==
                  (i =
                    null === (e = this.app.ui.theme) || void 0 === e
                      ? void 0
                      : e.chartBorderColor) && void 0 !== i
                  ? i
                  : 0;
            for (let t of l) {
              const e = new Vo(this.app.ui);
              if (
                (yield e.create(t),
                e.setBorderColor(u),
                e.addListener("mousedown", () => this.onPlayerDyeClick(t)),
                e.addListener("rightdown", () => this.onPlayerDyeRightClick(t)),
                e.addListener("mouseenter", () =>
                  this.app.tooltipHandler.showDyeDescription(t)
                ),
                e.addListener(
                  "mouseleave",
                  this.app.tooltipHandler.onMouseLeaveBinding
                ),
                void 0 !== t.fileName && void 0 !== t.index)
              ) {
                yield e.setTexture(t.fileName, t.index),
                  yield e.setAnimation(t.animationData),
                  this.skinCustomizationContentScrollContainer.addElement(e);
                const i =
                  null !==
                    (n = this.skinCustomizationArray[Lo.PlayerTextileDye]) &&
                  void 0 !== n
                    ? n
                    : new Array();
                i.push(e),
                  (this.skinCustomizationArray[Lo.PlayerTextileDye] = i);
              } else if (void 0 !== t.color) {
                yield e.setColor(t.color),
                  this.skinCustomizationContentScrollContainer.addElement(e);
                const i =
                  null !==
                    (s = this.skinCustomizationArray[Lo.PlayerColorDye]) &&
                  void 0 !== s
                    ? s
                    : new Array();
                i.push(e), (this.skinCustomizationArray[Lo.PlayerColorDye] = i);
              }
            }
            yield this.skinCustomizationContentScrollContainer.create();
          });
        }
        setPlayerDye(t, e, i) {
          return Zo(this, void 0, void 0, function* () {
            e = Object.assign({}, e);
            switch (
              (this.playerHandler.getPlayerSprite().setDye(t, e),
              void 0 !== e.fileName && void 0 !== e.index
                ? (yield i.setTexture(e.fileName, e.index),
                  yield i.setAnimation(e.animationData))
                : void 0 !== e.color
                ? yield i.setColor(e.color)
                : ((e.name = `Empty ${t == Eo.Major ? "Large" : "Small"} Dye`),
                  i.removeDye()),
              t)
            ) {
              case Eo.Major:
                this.selectedPlayerLargeDyeData = e;
                break;
              case Eo.Minor:
                this.selectedPlayerSmallDyeData = e;
            }
          });
        }
        onPlayerDyeClick(t) {
          return Zo(this, void 0, void 0, function* () {
            this.setPlayerDye(Eo.Major, t, this.selectedPlayerLargeDyePreview),
              this.app.ui.playClickSound();
          });
        }
        onPlayerDyeRightClick(t) {
          this.setPlayerDye(Eo.Minor, t, this.selectedPlayerSmallDyePreview),
            this.app.ui.playClickSound();
        }
        showSkinCustomization(t = "") {
          var e, i;
          const n =
            null !==
              (i =
                null === (e = this.app.ui.theme) || void 0 === e
                  ? void 0
                  : e.semitransparencyMultiplier) && void 0 !== i
              ? i
              : 1;
          for (let e = 0; e < this.skinCustomizationArray.length; e++) {
            this.skinCustomizationTypeSelectionArray[e].alpha =
              this.selectedSkinCustomizationType == e ? 1 : 0.3 * n;
            for (let i = 0; i < this.skinCustomizationArray[e].length; i++) {
              const n = this.skinCustomizationArray[e][i],
                s =
                  (this.selectedSkinCustomizationType == Lo.None ||
                    this.selectedSkinCustomizationType == e) &&
                  n.labels.includes(t);
              n.searchResult = s;
            }
          }
          this.updateSkinCustomization();
        }
        updateSkinCustomization() {
          var t;
          for (let t = 0; t < this.skinCustomizationArray.length; t++)
            for (let e = 0; e < this.skinCustomizationArray[t].length; e++)
              this.skinCustomizationArray[t][e].visible =
                this.skinCustomizationArray[t][e].searchResult;
          null === (t = this.skinCustomizationContentScrollContainer) ||
            void 0 === t ||
            t.setScrollDistance(0);
        }
        onSkinCustomizationTypeIconClick(t) {
          var e;
          (this.selectedSkinCustomizationType =
            this.selectedSkinCustomizationType == t ? Lo.None : t),
            this.showSkinCustomization(
              null === (e = this.skinCustomizationContentSearchBar) ||
                void 0 === e
                ? void 0
                : e.value
            ),
            this.app.ui.playClickSound();
        }
        onSkinCustomizationIconHover(t) {
          if (
            ((this.skinCustomizationTypeSelectionArray[t].alpha = 1),
            this.app.settingsHandler.showGuidanceTooltips != ei.AllEnabled)
          )
            return;
          let e = new Array();
          switch (t) {
            case Lo.PlayerColorDye:
              e.push(
                ["Player Dyes Filter", ti.white],
                ["Left Click To Toggle", ti.orange]
              );
              break;
            case Lo.PlayerTextileDye:
              e.push(
                ["Player Textiles Filter", ti.white],
                ["Left Click To Toggle", ti.orange]
              );
              break;
            case Lo.PlayerFlipbook:
              e.push(
                ["Player Flipbooks Filter", ti.white],
                ["Coming Soon™", ti.lightyellow]
              );
              break;
            case Lo.PlayerArcaneStyle:
              e.push(
                ["Player Arcane Styles Filter", ti.white],
                ["Coming Soon™", ti.lightyellow]
              );
              break;
            case Lo.PetFlipbook:
              e.push(
                ["Pet Flipbooks Filter", ti.white],
                ["Coming Soon™", ti.lightyellow]
              );
              break;
            case Lo.PetArcaneStyle:
              e.push(
                ["Pet Arcane Styles Filter", ti.white],
                ["Coming Soon™", ti.lightyellow]
              );
          }
          this.app.tooltipHandler.showInformation(e);
        }
        onSkinCustomizationIconMouseLeave(t, e) {
          (this.skinCustomizationTypeSelectionArray[t].alpha =
            this.selectedSkinCustomizationType == t ? 1 : 0.3),
            this.app.tooltipHandler.onMouseLeaveBinding(e);
        }
        onShowPetIconClick(t) {
          const e = this.playerHandler.togglePetVisibility();
          (this.petToggleIcon.alpha = e ? 1 : 0.2),
            this.app.ui.playClickSound();
        }
        onShowPetRightClick(t) {
          2 == this.petScale ? (this.petScale = 4) : this.petScale--,
            (this.petScaleText.text = `x${this.petScale}`),
            this.playerHandler.setPetScale(this.petScale),
            this.app.ui.playClickSound();
        }
        onPetSwapClick(t) {
          this.playerHandler.swapControl(),
            (this.petSwapIcon.alpha = this.playerHandler.getPlayerSprite().isPet
              ? 1
              : 0.2);
          const e = this.playerHandler.getPetSprite().renderable,
            i = this.playerHandler.getPlayerSprite().renderable;
          (0 != e && 0 != i) ||
            (this.playerHandler.togglePetVisibility(),
            this.playerHandler.togglePlayerVisibility()),
            this.app.ui.playClickSound();
        }
        showPlayerSkins(t = "") {
          var e, i;
          const n =
            null !==
              (i =
                null === (e = this.app.ui.theme) || void 0 === e
                  ? void 0
                  : e.semitransparencyMultiplier) && void 0 !== i
              ? i
              : 1;
          for (let e = 0; e < this.playerClassSkinsArray.length; e++) {
            this.playerClassTypeSelectionArray[e].alpha =
              this.selectedPlayerClassType == e ? 1 : 0.3 * n;
            for (let i = 0; i < this.playerClassSkinsArray[e].length; i++) {
              const n = this.playerClassSkinsArray[e][i],
                s =
                  (this.selectedPlayerClassType == Di.None ||
                    this.selectedPlayerClassType == e) &&
                  n.labels.includes(t);
              n.searchResult = s;
            }
          }
          this.updatePlayerSkins();
        }
        updatePlayerSkins() {
          var t;
          for (let t = 0; t < this.playerClassSkinsArray.length; t++)
            for (let e = 0; e < this.playerClassSkinsArray[t].length; e++)
              this.playerClassSkinsArray[t][e].visible =
                this.playerClassSkinsArray[t][e].searchResult;
          null === (t = this.playerSkinContentScrollContainer) ||
            void 0 === t ||
            t.setScrollDistance(0);
        }
        showPetSkins(t = "") {
          var e, i;
          const n =
            null !==
              (i =
                null === (e = this.app.ui.theme) || void 0 === e
                  ? void 0
                  : e.semitransparencyMultiplier) && void 0 !== i
              ? i
              : 1;
          for (let e = 0; e < this.petFamilySkinsArray.length; e++) {
            this.petFamilyTypeSelectionArray[e].alpha =
              this.selectedPetFamilyType == e ? 1 : 0.3 * n;
            for (let i = 0; i < this.petFamilySkinsArray[e].length; i++) {
              const n = this.petFamilySkinsArray[e][i],
                s =
                  (this.selectedPetFamilyType == Fi.None ||
                    this.selectedPetFamilyType == e) &&
                  n.labels.includes(t);
              n.searchResult = s;
            }
          }
          this.updatePetSkins();
        }
        updatePetSkins() {
          var t;
          for (let t = 0; t < this.petFamilySkinsArray.length; t++)
            for (let e = 0; e < this.petFamilySkinsArray[t].length; e++)
              this.petFamilySkinsArray[t][e].visible =
                this.petFamilySkinsArray[t][e].searchResult;
          null === (t = this.petSkinContentScrollContainer) ||
            void 0 === t ||
            t.setScrollDistance(0);
        }
        onThemeUpdate(t) {
          return Zo(this, void 0, void 0, function* () {
            const e = t.chartTitleTextColor,
              i = t.chartBorderColor,
              n = t.specialCaseTextColor;
            (this.toolTitleText.style.fill = e),
              (this.playerClassTypeSelectionLabelText.style.fill = e),
              (this.playerSkinContentLabelText.style.fill = e),
              (this.skinCustomizationTypeSelectionLabelText.style.fill = e),
              (this.skinCustomizationContentLabelText.style.fill = e),
              (this.petFamilyTypeSelectionLabelText.style.fill = e),
              (this.petSkinContentLabelText.style.fill = e),
              (this.selectedPlayerSmallDyeLabelText.style.fill = e),
              (this.selectedElementsPreviewLabelText.style.fill = e),
              (this.selectedPlayerLargeDyeLabelText.style.fill = e),
              (this.petScaleText.style.fill = n);
            const s = yield this.app.ui.getTexture(
              `rotmg/tilesets/${t.walkableAreaTileset}`
            );
            (this.walkableAreaBackgroundSprite.texture = s),
              this.selectedPlayerSmallDyePreview.setBorderColor(i),
              this.selectedPlayerLargeDyePreview.setBorderColor(i);
            for (const t of this.skinCustomizationArray)
              for (const e of t) e.setBorderColor(i);
          });
        }
        update(t) {
          const e = 0.001 * t.deltaMS;
          this.playerHandler.update(e),
            this.updatePlayerTextileDyes(),
            this.updateTextAlpha(e);
        }
        updateTextAlpha(t) {
          const e = this.playerHandler.getPlayerSprite(),
            i = this.playerHandler.getPetSprite(),
            n = (e.position.y - e.height) * +e.visible,
            s = (i.position.y - i.height) * +i.visible,
            r = Math.min(n, s);
          let o = this.toolTitleText.alpha;
          (o = r < -20 ? Math.max(o - 2.4 * t, 0) : Math.min(o + 2.4 * t, 1)),
            (this.toolTitleText.alpha = o),
            (this.toolNoteText.alpha = o);
        }
        show() {
          return Zo(this, void 0, void 0, function* () {
            this.container.show(),
              yield this.onWindowResize(undefined),
              this.playerHandler.bindKeyboardEvents(),
              te.R.shared.add(this.updateBinding);
          });
        }
        hide() {
          te.R.shared.remove(this.updateBinding),
            this.app.canvas.ticker.remove(this.updateBinding),
            this.playerHandler.unbindKeyboardEvents(),
            this.playerHandler.clearInput(),
            this.container.hide();
        }
        onWindowResize(t) {
          var e, i, n;
          if (0 == this.container.visible) return;
          const s = Math.max(Math.floor(0.5 * (window.innerWidth - 400)), 420),
            r = window.innerWidth - 400,
            o = window.innerHeight - 32;
          (this.interactiveSprite.width = r),
            (this.interactiveSprite.height = o),
            this.toolTitleText.position.set(s, 18),
            this.toolNoteText.position.set(s, 38);
          const a = s - 0.5 * this.walkableAreaBackgroundSprite.width;
          this.walkableAreaContainer.position.set(a, 80);
          const l = a + this.walkableAreaBackgroundSprite.width + 4;
          this.togglesContainer.position.set(l, 96),
            this.playerHandler.resetPosition(),
            this.playerHandler.clearInput();
          const u = 300,
            h = Math.max(Math.floor(0.33 * (r - 60)), 280),
            c = 42,
            d = Math.floor((h - 20) / c),
            p = d * c - 100;
          this.playerCustomizationContainer.position.set(24, u),
            this.skinCustomizationContainer.position.set(24 + h + 10, u),
            this.petCustomizationContainer.position.set(24 + 2 * h + 20, u);
          let f = 24;
          this.playerClassTypeSelectionContainer.position.set(15, f + 20);
          for (
            let t = 0;
            t < this.playerClassTypeSelectionContainer.children.length;
            t++
          ) {
            const e = this.playerClassTypeSelectionContainer.children[t],
              i = (t % d) * c,
              n = Math.floor(t / d) * c;
            e.position.set(i, n);
          }
          (f += this.playerClassTypeSelectionContainer.height + 8),
            this.playerSkinContentLabelText.position.set(0, f);
          const m = f - 2;
          (f += 28), this.playerSkinContentContainer.position.set(-6, f);
          const g = Math.max(100, window.innerHeight - u - f - 20);
          if (void 0 !== this.playerSkinContentScrollContainer) {
            (this.playerSkinContentScrollContainer.options.itemsInRow = d),
              this.playerSkinContentScrollContainer.setMaskSize({
                x: h + 20,
                y: g,
              });
            const t = p + 20;
            null === (e = this.playerSkinContentSearchBar) ||
              void 0 === e ||
              e.position.set(t, m);
          }
          (f = 24),
            this.skinCustomizationTypeSelectionContainer.position.set(
              15,
              f + 20
            );
          for (
            let t = 0;
            t < this.skinCustomizationTypeSelectionContainer.children.length;
            t++
          ) {
            const e = this.skinCustomizationTypeSelectionContainer.children[t],
              i = (t % d) * c,
              n = Math.floor(t / d) * c;
            e.position.set(i, n);
          }
          (f += this.skinCustomizationTypeSelectionContainer.height + 8),
            this.skinCustomizationContentLabelText.position.set(0, f);
          const v = f - 2;
          (f += 28), this.skinCustomizationContentContainer.position.set(-6, f);
          const y = Math.max(100, window.innerHeight - u - f - 20);
          if (void 0 !== this.skinCustomizationContentScrollContainer) {
            (this.skinCustomizationContentScrollContainer.options.itemsInRow =
              d),
              this.skinCustomizationContentScrollContainer.setMaskSize({
                x: h + 20,
                y,
              });
            const t = p + 20;
            null === (i = this.skinCustomizationContentSearchBar) ||
              void 0 === i ||
              i.position.set(t, v);
          }
          (f = 24),
            this.petFamilyTypeSelectionContainer.position.set(15, f + 20);
          for (
            let t = 0;
            t < this.petFamilyTypeSelectionContainer.children.length;
            t++
          ) {
            const e = this.petFamilyTypeSelectionContainer.children[t],
              i = (t % d) * c,
              n = Math.floor(t / d) * c;
            e.position.set(i, n);
          }
          (f += this.petFamilyTypeSelectionContainer.height + 8),
            this.petSkinContentLabelText.position.set(0, f);
          const x = f - 2;
          (f += 28), this.petSkinContentContainer.position.set(-6, f);
          const b = Math.max(100, window.innerHeight - u - f - 20);
          if (void 0 !== this.petSkinContentScrollContainer) {
            (this.petSkinContentScrollContainer.options.itemsInRow = d),
              this.petSkinContentScrollContainer.setMaskSize({
                x: h + 20,
                y: b,
              });
            const t = p + 20;
            null === (n = this.petSkinContentSearchBar) ||
              void 0 === n ||
              n.position.set(t, x);
          }
          const S = Math.floor(
            s -
              0.5 * this.walkableAreaBackgroundSprite.width -
              0.5 * this.selectedElementsPreviewContainer.width -
              8
          );
          this.selectedElementsPreviewContainer.position.set(S, 80);
        }
        onPlayerClassIconClick(t) {
          var e;
          (this.selectedPlayerClassType =
            this.selectedPlayerClassType == t ? Di.None : t),
            this.showPlayerSkins(
              null === (e = this.playerSkinContentSearchBar) || void 0 === e
                ? void 0
                : e.value
            ),
            this.app.ui.playClickSound();
        }
        onPlayerClassIconHover(t) {
          (this.playerClassTypeSelectionArray[t].alpha = 1),
            this.app.settingsHandler.showGuidanceTooltips == ei.AllEnabled &&
              this.app.tooltipHandler.showInformation([
                [`${Di[t]} Skins Filter`, ti.white],
                ["Left Click To Toggle", ti.orange],
              ]);
        }
        onPlayerClassIconMouseLeave(t, e) {
          (this.playerClassTypeSelectionArray[t].alpha =
            this.selectedPlayerClassType == t ? 1 : 0.3),
            this.app.tooltipHandler.onMouseLeaveBinding(e);
        }
        onPetEggIconClick(t) {
          var e;
          (this.selectedPetFamilyType =
            this.selectedPetFamilyType == t ? Fi.None : t),
            this.showPetSkins(
              null === (e = this.petSkinContentSearchBar) || void 0 === e
                ? void 0
                : e.value
            ),
            this.app.ui.playClickSound();
        }
        onPetEggIconHover(t) {
          (this.petFamilyTypeSelectionArray[t].alpha = 1),
            this.app.settingsHandler.showGuidanceTooltips == ei.AllEnabled &&
              this.app.tooltipHandler.showInformation([
                [`${Fi[t]} Pet Skins Filter`, ti.white],
                ["Left Click To Toggle", ti.orange],
              ]);
        }
        onPetEggIconMouseLeave(t, e) {
          (this.petFamilyTypeSelectionArray[t].alpha =
            this.selectedPetFamilyType == t ? 1 : 0.3),
            this.app.tooltipHandler.onMouseLeaveBinding(e);
        }
        onPlayerSkinIconClick(t) {
          return Zo(this, void 0, void 0, function* () {
            this.playerHandler.setSkin(t),
              (this.selectedPlayerSkinData =
                yield this.selectedPlayerSkinPreview.create(t.id, t.type, !1)),
              this.app.ui.playClickSound();
          });
        }
        onPetSkinClick(t) {
          return Zo(this, void 0, void 0, function* () {
            this.playerHandler.setPetSkin(t),
              (this.selectedPetSkinData =
                yield this.selectedPetSkinPreview.create(t.id, t.type, !0)),
              this.app.ui.playClickSound();
          });
        }
        onInteractiveBackgroundMouseDown(t) {
          this.playerHandler.startAttacking();
        }
        onInteractiveBackgroundRightDown(t) {
          this.playerHandler.startUsingAbility();
        }
        onInteractiveBackgroundMouseUp(t) {
          switch (t.button) {
            case Xo.Left:
              this.playerHandler.stopAttacking();
              break;
            case Xo.Right:
              this.playerHandler.stopUsingAbility();
          }
        }
      }
      class Jo extends ai {
        constructor(t) {
          super(t),
            (this.container = new Me(t.ui)),
            (this.descriptionText = t.ui.text({ text: "Item Editor Tool" })),
            (this.comingSoonText = t.ui.text({ text: "Coming Soon™" }));
        }
        create() {
          this.app.canvas.addChild(this.container);
          const t = Math.floor(0.5 * (window.innerWidth - 400)),
            e = Math.floor(0.5 * window.innerHeight),
            [i, n] = Ve.getBoundsReminder(this.descriptionText);
          this.descriptionText.position.set(t, e - 12),
            this.descriptionText.anchor.set(0.5, 1),
            this.descriptionText.pivot.set(i, n),
            this.container.addChild(this.descriptionText);
          const [s, r] = Ve.getBoundsReminder(this.comingSoonText);
          this.comingSoonText.position.set(t, e + 12),
            this.comingSoonText.anchor.set(0.5, 1),
            this.comingSoonText.pivot.set(s, r),
            this.container.addChild(this.comingSoonText),
            super.create();
        }
        onThemeUpdate(t) {
          (this.descriptionText.style.fill = t.chartTitleTextColor),
            (this.comingSoonText.style.fill = t.chartTitleTextColor);
        }
        show() {
          this.container.show(), this.onWindowResize(undefined);
        }
        hide() {
          this.container.hide();
        }
        onWindowResize(t) {
          if (0 == this.container.visible) return;
          const e = Math.floor(0.5 * (window.innerWidth - 400)),
            i = Math.floor(0.5 * window.innerHeight);
          this.comingSoonText.position.set(e, i + 12),
            this.descriptionText.position.set(e, i - 12);
        }
      }
      var ta = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class ea extends ai {
        constructor(t) {
          super(t),
            (this.container = new Me(t.ui)),
            (this.toolTitleText = t.ui.text({ text: "Item Checklist" })),
            this.toolTitleText.anchor.set(0.5, 0),
            this.container.addChild(this.toolTitleText),
            (this.obtainedText = t.ui.text({})),
            this.obtainedText.anchor.set(0.5, 0),
            this.container.addChild(this.obtainedText),
            (this.lootMap = new Map()),
            (this.selectedIdMap = new Map()),
            (this.equipmentScrollContainer = new Js(t.ui, {
              size: { x: 1e3, y: 600 },
              itemSize: { x: 60, y: 60 },
              itemAnchor: Ve.CENTER,
              itemOffset: { x: 0, y: 0 },
              itemSpacing: { x: 0, y: 0 },
              itemsInRow: 20,
              scrollSpeed: 60,
            })),
            this.container.addChild(this.equipmentScrollContainer),
            (this.filteredLength = 0),
            (this.filteredTotalLength = 0);
          const e = {
            size: { x: 380, y: 600 },
            itemSize: { x: 368, y: 32 },
            itemAnchor: Ve.TOP_LEFT,
            itemOffset: { x: 0, y: 0 },
            itemSpacing: { x: 0, y: 0 },
            itemsInRow: 1,
            scrollSpeed: 32,
          };
          (this.overlayContainer = new Gt.mc()),
            (this.overlayContainer.zIndex = 2),
            this.app.canvas.addChild(this.overlayContainer),
            (this.dataMenuContainer = new Gt.mc()),
            this.overlayContainer.addChild(this.dataMenuContainer),
            (this.checkboxesScrollContainer = new Js(this.app.ui, e)),
            this.overlayContainer.addChild(this.checkboxesScrollContainer),
            (this.selectedCategoryMap = new Map([[zi.Shiny, null]])),
            (this.checkboxMap = new Map()),
            (this.exportCallbackText = this.app.ui.text({
              style: { fill: ti.lightyellow },
              anchor: Ve.CENTER_X,
            })),
            this.overlayContainer.addChild(this.exportCallbackText);
        }
        onExportClick() {
          this.exportCallbackText.text = "Copied export code to clipboard.";
          const t = this.app.cacheHandler.getItemChecklistCode();
          navigator.clipboard.writeText(t);
        }
        onImportClick() {
          return ta(this, void 0, void 0, function* () {
            if (void 0 === this.importDataInput) return;
            const t = this.importDataInput.value,
              e = yield this.app.cacheHandler.importItemChecklist(t);
            (this.exportCallbackText.text = e),
              (this.importDataInput.value = ""),
              this.updateCheckboxes(),
              this.filterItems();
          });
        }
        onClearDataClick(t) {
          0 != t.shiftKey &&
            ((this.selectedIdMap = new Map()),
            (this.selectedCategoryMap = new Map([[zi.Shiny, null]])),
            void 0 !== this.searchbar && (this.searchbar.value = ""),
            this.updateCheckboxes(),
            this.filterItems(),
            this.saveItemChecklist());
        }
        create() {
          const t = Object.create(null, {
            create: { get: () => super.create },
          });
          return ta(this, void 0, void 0, function* () {
            var e, i, n;
            this.app.canvas.addChild(this.container);
            const s = { x: 160, y: 24 };
            (this.searchbar = yield this.app.ui.searchbar({
              placeholder: "Filter Items",
              size: s,
            })),
              this.searchbar.on("change", this.onSearchBarInput.bind(this)),
              this.searchbar.pivot.set(0.5 * s.x, 0),
              this.container.addChild(this.searchbar);
            const r = [];
            for (const t of this.app.dataHandler.equipmentData.values())
              for (const i of t.values()) {
                if (i.slotType == De.Consumable) continue;
                if (
                  null ===
                    (e = this.app.dataHandler.itemChecklistTags.get(
                      zi.Debug
                    )) || void 0 === e
                    ? void 0
                    : e.has(i.id)
                )
                  continue;
                const t = new Gt.mc();
                (t.eventMode = "static"),
                  (t.cursor = "pointer"),
                  (t.alpha = this.selectedIdMap.has(i.id) ? 1 : 0.2),
                  this.equipmentScrollContainer.addElement(t);
                const n = new Xt.k();
                n.anchor.set(0.5, 0.5),
                  (n.width = 60),
                  (n.height = 60),
                  t.addChild(n);
                const s = new Zs(this.app.ui);
                s.eventMode = "none";
                const o = s.create(i.id, i.slotType);
                r.push(o),
                  t.addListener("mousedown", (t) => this.onItemClick(i.id)),
                  t.addListener("mouseenter", () =>
                    this.app.tooltipHandler.showEquipmentDescription(
                      i,
                      [],
                      void 0,
                      !1
                    )
                  ),
                  t.addListener(
                    "mouseleave",
                    this.app.tooltipHandler.onMouseLeaveBinding
                  ),
                  t.addChild(s),
                  this.lootMap.set(i.id, s);
              }
            yield Promise.all(r),
              yield this.equipmentScrollContainer.create(),
              this.filterItems();
            const o =
              null !==
                (n =
                  null === (i = this.app.ui.theme) || void 0 === i
                    ? void 0
                    : i.checkbox.default) && void 0 !== n
                ? n
                : "green_checkbox";
            (this.legacyItemsCheckbox = yield this.app.ui.checkbox({
              text: "Include Legacy Items",
              texture: o,
              guidanceTooltip: [
                ["Legacy Items", ti.white],
                [
                  "All limited items that are no longer obtainable,",
                  ti.lightyellow,
                ],
                [
                  "even during seasonal events within RotMG year",
                  ti.lightyellow,
                ],
              ],
              onChange: (t) => this.onItemCategoryTick(zi.Legacy, t),
            })),
              this.checkboxesScrollContainer.addElement(
                this.legacyItemsCheckbox
              ),
              this.checkboxMap.set(zi.Legacy, this.legacyItemsCheckbox),
              (this.vanityItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Vanity Items",
                texture: o,
                guidanceTooltip: [["Vanity Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.Vanity, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.vanityItemsCheckbox
              ),
              this.checkboxMap.set(zi.Vanity, this.vanityItemsCheckbox),
              (this.shinyItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Shiny Items",
                texture: o,
                guidanceTooltip: [["Shiny Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.Shiny, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.shinyItemsCheckbox
              ),
              this.checkboxMap.set(zi.Shiny, this.shinyItemsCheckbox),
              (this.lowTierItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Low Tier Items",
                texture: o,
                guidanceTooltip: [
                  ["Low Tier Items", ti.white],
                  [
                    "Tiered items from lower difficulty dungeons, up to:",
                    ti.lightyellow,
                  ],
                  [
                    "T12 weapons, T5 abilities, T13 armors, T5 rings",
                    ti.lightyellow,
                  ],
                ],
                onChange: (t) => this.onItemCategoryTick(zi.LowTier, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.lowTierItemsCheckbox
              ),
              this.checkboxMap.set(zi.LowTier, this.lowTierItemsCheckbox),
              (this.highTierItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include High Tier Items",
                texture: o,
                guidanceTooltip: [
                  ["High Tier Items", ti.white],
                  [
                    "Tiered items from high difficulty dungeons, which are:",
                    ti.lightyellow,
                  ],
                  ["T13 weapons, T6 abilities, T14 armors", ti.lightyellow],
                ],
                onChange: (t) => this.onItemCategoryTick(zi.HighTier, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.highTierItemsCheckbox
              ),
              this.checkboxMap.set(zi.HighTier, this.highTierItemsCheckbox),
              (this.topTierItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Top Tier Items",
                texture: o,
                guidanceTooltip: [
                  ["Top Tier Items", ti.white],
                  [
                    "Tiered items from highest difficulty dungeons, which are:",
                    ti.lightyellow,
                  ],
                  [
                    "T14 weapons, T7 abilities, T15 armors, T6 rings",
                    ti.lightyellow,
                  ],
                ],
                onChange: (t) => this.onItemCategoryTick(zi.TopTier, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.topTierItemsCheckbox
              ),
              this.checkboxMap.set(zi.TopTier, this.topTierItemsCheckbox),
              (this.setTierItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Set Tier Items",
                texture: o,
                guidanceTooltip: [
                  ["Set Tier Items", ti.white],
                  [
                    "Non-legacy set items that are currently obtainable",
                    ti.lightyellow,
                  ],
                ],
                onChange: (t) => this.onItemCategoryTick(zi.SetTier, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.setTierItemsCheckbox
              ),
              this.checkboxMap.set(zi.SetTier, this.setTierItemsCheckbox),
              (this.halloweenItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Halloween Themed Items",
                texture: o,
                guidanceTooltip: [
                  ["Halloween Items", ti.white],
                  [
                    "Includes all unique items and reskins, which are",
                    ti.lightyellow,
                  ],
                  ["mostly available during Halloween period.", ti.lightyellow],
                ],
                onChange: (t) => this.onItemCategoryTick(zi.Halloween, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.halloweenItemsCheckbox
              ),
              this.checkboxMap.set(zi.Halloween, this.halloweenItemsCheckbox),
              (this.oryxmasItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Oryxmas Themed Items",
                texture: o,
                guidanceTooltip: [["Oryxmas Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.Oryxmas, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.oryxmasItemsCheckbox
              ),
              this.checkboxMap.set(zi.Oryxmas, this.oryxmasItemsCheckbox),
              (this.valentinesDayItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Valentine's Day Themed Items",
                texture: o,
                guidanceTooltip: [["Valentine's Day Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.ValentinesDay, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.valentinesDayItemsCheckbox
              ),
              this.checkboxMap.set(
                zi.ValentinesDay,
                this.valentinesDayItemsCheckbox
              ),
              (this.stPatricksDayItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include St Patrick's Day Themed Items",
                texture: o,
                guidanceTooltip: [["St Patrick's Day Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.StPatricksDay, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.stPatricksDayItemsCheckbox
              ),
              this.checkboxMap.set(
                zi.StPatricksDay,
                this.stPatricksDayItemsCheckbox
              ),
              (this.easterItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Easter Themed Items",
                texture: o,
                guidanceTooltip: [["Easter Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.Easter, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.easterItemsCheckbox
              ),
              this.checkboxMap.set(zi.Easter, this.easterItemsCheckbox),
              (this.alienItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Alien Items",
                texture: o,
                guidanceTooltip: [["Alien Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.Alien, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.alienItemsCheckbox
              ),
              this.checkboxMap.set(zi.Alien, this.alienItemsCheckbox),
              (this.agentsOfOryxCheckbox = yield this.app.ui.checkbox({
                text: "Include Agents Of Oryx Items",
                texture: o,
                guidanceTooltip: [["Agents Of Oryx Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.AgentsOfOryx, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.agentsOfOryxCheckbox
              ),
              this.checkboxMap.set(zi.AgentsOfOryx, this.agentsOfOryxCheckbox),
              (this.aspirantItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Aspirant Items",
                texture: o,
                guidanceTooltip: [["Aspirant Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.Aspirant, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.aspirantItemsCheckbox
              ),
              this.checkboxMap.set(zi.Aspirant, this.aspirantItemsCheckbox),
              (this.syndicateItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Syndicate Items",
                texture: o,
                guidanceTooltip: [["Syndicate Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.Syndicate, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.syndicateItemsCheckbox
              ),
              this.checkboxMap.set(zi.Syndicate, this.syndicateItemsCheckbox),
              (this.antimonyItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Antimony Items",
                texture: o,
                guidanceTooltip: [["Antimony Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.Antinomy, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.antimonyItemsCheckbox
              ),
              this.checkboxMap.set(zi.Antinomy, this.antimonyItemsCheckbox),
              (this.rehearsalItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Rehearsal Items",
                texture: o,
                guidanceTooltip: [["Rehearsal Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.Rehearsal, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.rehearsalItemsCheckbox
              ),
              this.checkboxMap.set(zi.Rehearsal, this.rehearsalItemsCheckbox),
              (this.constructionItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include Construction Items",
                texture: o,
                guidanceTooltip: [["Construction Items", ti.white]],
                onChange: (t) => this.onItemCategoryTick(zi.Construction, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.constructionItemsCheckbox
              ),
              this.checkboxMap.set(
                zi.Construction,
                this.constructionItemsCheckbox
              ),
              (this.allOtherUntieredItemsCheckbox = yield this.app.ui.checkbox({
                text: "Include All Other Items",
                texture: o,
                guidanceTooltip: [
                  ["All Other Items", ti.white],
                  [
                    "All items that do not match above categories.",
                    ti.lightyellow,
                  ],
                ],
                onChange: (t) => this.onItemCategoryTick(zi.AllOther, t),
              })),
              this.checkboxesScrollContainer.addElement(
                this.allOtherUntieredItemsCheckbox
              ),
              this.checkboxMap.set(
                zi.AllOther,
                this.allOtherUntieredItemsCheckbox
              );
            const a = { x: 190, y: 40 };
            (this.clearDataButton = yield this.app.ui.smallButton({
              text: "Wipe Everything",
              size: a,
              anchor: Ve.CENTER,
              onClick: this.onClearDataClick.bind(this),
            })),
              this.clearDataButton.addListener(
                "mouseenter",
                this.onClearDataMouseEnter.bind(this)
              ),
              this.clearDataButton.addListener(
                "mouseleave",
                this.app.tooltipHandler.onMouseLeaveBinding
              ),
              this.clearDataButton.position.set(0.5 * a.x, 0.5 * a.y),
              this.dataMenuContainer.addChild(this.clearDataButton);
            const l = yield this.app.ui.thickLabeledFrame({
              labelText: "Import Data",
              size: a,
            });
            (this.importDataInput = new Ke(this.app.ui, {
              placeholder: "Paste Here",
              background: l,
              clearOnClick: !0,
              anchor: Ve.CENTER,
              textStyle: { fill: ti.lightyellow },
            })),
              this.importDataInput.create(),
              this.importDataInput.position.set(1 * a.x + 8, 0),
              this.dataMenuContainer.addChild(this.importDataInput),
              (this.exportButton = yield this.app.ui.smallButton({
                text: "Export",
                size: a,
                anchor: Ve.CENTER,
                onClick: this.onExportClick.bind(this),
              })),
              this.exportButton.position.set(0.5 * a.x, 1.5 * a.y + 4),
              this.dataMenuContainer.addChild(this.exportButton),
              (this.importButton = yield this.app.ui.smallButton({
                text: "Import",
                size: a,
                anchor: Ve.CENTER,
                onClick: this.onImportClick.bind(this),
              })),
              this.importButton.position.set(1.5 * a.x + 8, 1.5 * a.y + 4),
              this.dataMenuContainer.addChild(this.importButton),
              yield this.checkboxesScrollContainer.create(),
              this.checkboxesScrollContainer.setScrollDistance(0),
              this.updateCheckboxes(),
              t.create.call(this);
          });
        }
        appendData(t) {
          (this.selectedIdMap = new Map()),
            (this.selectedCategoryMap = new Map());
          for (const e of t.selectedItems) this.selectedIdMap.set(e, null);
          for (const e of t.selectedCategories)
            this.selectedCategoryMap.set(e, null);
          void 0 !== this.searchbar && (this.searchbar.value = t.searchbar),
            this.updateCheckboxes(),
            this.filterItems();
        }
        updateCheckboxes() {
          for (const [t, e] of this.checkboxMap.entries()) {
            const i = this.selectedCategoryMap.has(t);
            e.setValue(i);
          }
        }
        loadFromCache() {
          return ta(this, void 0, void 0, function* () {
            const t = yield this.app.cacheHandler.loadItemChecklistFromCache();
            this.appendData(t);
          });
        }
        onClearDataMouseEnter() {
          this.app.tooltipHandler.showInformation([
            ["Wipe Everything", ti.white],
            ["It will remove all items you have ever selected", ti.red],
            ["Shift + Left Click To Wipe Everything", ti.red],
          ]);
        }
        selectFilterMap(t, e = !1) {
          0 == e
            ? this.selectedCategoryMap.delete(t)
            : this.selectedCategoryMap.set(t, null),
            this.filterItems();
        }
        onItemCategoryTick(t, e) {
          this.selectFilterMap(t, e), this.saveItemChecklist();
        }
        saveItemChecklist() {
          this.app.cacheHandler.saveItemChecklistToCache();
        }
        onSearchBarInput(t) {
          this.saveItemChecklist(), this.filterItems(t);
        }
        filterItems(t, e) {
          var i, n, s, r, o;
          void 0 === t &&
            (t =
              null !==
                (n =
                  null === (i = this.searchbar) || void 0 === i
                    ? void 0
                    : i.value) && void 0 !== n
                ? n
                : ""),
            void 0 === e && (e = !0);
          const a =
            null !==
              (r =
                null === (s = this.app.ui.theme) || void 0 === s
                  ? void 0
                  : s.semitransparencyMultiplier) && void 0 !== r
              ? r
              : 1;
          let l = 0,
            u = 0;
          for (const [e, i] of this.lootMap.entries())
            if (i.equipmentLabels.includes(t)) {
              const t = this.selectedIdMap.has(e);
              let n = !1;
              for (const t of this.selectedCategoryMap.keys())
                (null === (o = this.app.dataHandler.itemChecklistTags.get(t)) ||
                void 0 === o
                  ? void 0
                  : o.has(e)) && (n = !0);
              n
                ? (u++,
                  (i.parent.visible = !0),
                  t ? ((i.parent.alpha = 1), l++) : (i.parent.alpha = 0.2 * a))
                : (i.parent.visible = !1);
            } else i.parent.visible = !1;
          (this.filteredLength = l),
            (this.filteredTotalLength = u),
            this.equipmentScrollContainer.setScrollDistance(e ? 0 : void 0),
            this.updateObtainedText();
        }
        onThemeUpdate(t) {
          (this.toolTitleText.style.fill = t.chartTitleTextColor),
            (this.obtainedText.style.fill = t.specialCaseTextColor);
        }
        show() {
          this.container.show(),
            (this.overlayContainer.visible = !0),
            this.onWindowResize(undefined);
        }
        hide() {
          this.container.hide(), (this.overlayContainer.visible = !1);
        }
        getCacheData() {
          var t, e;
          return {
            selectedItems: Array.from(this.selectedIdMap.keys()),
            selectedCategories: Array.from(this.selectedCategoryMap.keys()),
            searchbar:
              null !==
                (e =
                  null === (t = this.searchbar) || void 0 === t
                    ? void 0
                    : t.value) && void 0 !== e
                ? e
                : "",
          };
        }
        onWindowResize(t) {
          if (0 == this.container.visible) return;
          const e = this.equipmentScrollContainer.options.itemSize.x,
            i = Math.max(Math.floor(0.5 * (window.innerWidth - 400)), 300);
          this.toolTitleText.position.set(i, 18),
            this.obtainedText.position.set(i, 40),
            this.equipmentScrollContainer.position.set(20, 68);
          const n = Math.max(window.innerWidth - 460, 600),
            s = Math.max(window.innerHeight - 88, 100),
            r = Math.floor(n / e);
          if (
            (this.equipmentScrollContainer.setItemsInRow(r),
            this.equipmentScrollContainer.setMaskSize({ x: n + 30, y: s }),
            void 0 !== this.searchbar)
          ) {
            const t = 46 + r * e - 0.5 * this.searchbar.width;
            this.searchbar.position.set(t, 38);
          }
          const o = window.innerWidth - 392,
            a = Math.max(window.innerHeight - 128, 200);
          this.dataMenuContainer.position.set(o, a);
          const l = Math.max(window.innerHeight - 208, 128);
          this.checkboxesScrollContainer.position.set(o, 70),
            this.checkboxesScrollContainer.setMaskSize({ x: 392, y: l }),
            this.exportCallbackText.position.set(
              window.innerWidth - 200,
              Math.max(window.innerHeight - 30, 292)
            );
        }
        onItemClick(t) {
          var e;
          const i = this.lootMap.get(t);
          if (void 0 === i) return;
          1 == (1 == i.parent.alpha)
            ? this.selectedIdMap.delete(t)
            : (this.selectedIdMap.set(t, null), i.playAnimation()),
            this.app.ui.playClickSound(),
            this.saveItemChecklist(),
            this.filterItems(
              null === (e = this.searchbar) || void 0 === e ? void 0 : e.value,
              !1
            );
        }
        updateObtainedText() {
          const t =
            0 == this.filteredTotalLength
              ? 0
              : this.filteredLength / this.filteredTotalLength;
          this.obtainedText.text = `Obtained ${this.filteredLength} / ${
            this.filteredTotalLength
          } items (${Ve.percent(t, 2)})`;
        }
      }
      var ia = function (t, e, i, n) {
        return new (i || (i = Promise))(function (s, r) {
          function o(t) {
            try {
              l(n.next(t));
            } catch (t) {
              r(t);
            }
          }
          function a(t) {
            try {
              l(n.throw(t));
            } catch (t) {
              r(t);
            }
          }
          function l(t) {
            t.done
              ? s(t.value)
              : (function (t) {
                  return t instanceof i
                    ? t
                    : new i(function (e) {
                        e(t);
                      });
                })(t.value).then(o, a);
          }
          l((n = n.apply(t, e || [])).next());
        });
      };
      class na {
        constructor() {
          (this.version = "202404132"),
            (this.isMobile = ee.F.any),
            (this.easterEggMessages = this.getEasterEggMessages()),
            (this.canvas = new ni(this)),
            (this.ui = new ti(this)),
            (this.dataHandler = new Ni(this)),
            (this.cacheHandler = new bo(this)),
            (this.settingsHandler = new So(this)),
            (this.simulationHandler = new Ii(this, this.dataHandler)),
            (this.tooltipHandler = new yo(this)),
            (this.chartHandler = new ki(this)),
            (this.skinViewerHandler = new Qo(this)),
            (this.itemSandboxHandler = new Bo(this)),
            (this.itemCreatorHandler = new Jo(this)),
            (this.itemChecklistHandler = new ea(this)),
            (this.charactersHandler = new Ro(this)),
            (this.mainPanelHandler = new Vr(this)),
            (this.mousePosition = { x: 0, y: 0 }),
            this.createHTMLElements(),
            this.loadEverything(),
            window.addEventListener("resize", this.onWindowResize.bind(this)),
            window.addEventListener("mousemove", this.onMouseMove.bind(this));
        }
        getEasterEggMessages() {
          const t = [
            "Popping Runes...",
            "Popping WC...",
            "Popping keys in USEast...",
            "Fixing RotMG Servers...",
            "Spawning Oryx in The Nexus...",
            "Banning Bots in The Nexus...",
          ];
          switch (Ve.getSeasonalEvent()) {
            case ze.AprilFools:
              t.push("Logging to your account..."),
                t.push("Crashing servers..."),
                t.push("Duping items...");
              break;
            case ze.Halloween:
              t.push("Don't look behind you.");
              break;
            case ze.Christmas:
              t.push("Merry Christmas!");
          }
          return t;
        }
        createHTMLElements() {
          (this.loadingContainer = document.createElement("div")),
            (this.loadingContainer.id = "loading-container"),
            document.body.append(this.loadingContainer);
          const t = document.createElement("div");
          if (Ve.isWebGLSupported())
            switch (Ve.randomInt(0, 4)) {
              case 0:
                t.id = "king";
                break;
              case 1:
                t.id = "penguin";
                break;
              case 2:
                t.id = "cube";
                break;
              case 3:
                t.id = "dancer";
                break;
              case 4:
                t.id = "knight";
            }
          else t.id = "king";
          this.loadingContainer.append(t),
            (this.loadingProgressText = document.createElement("div")),
            (this.loadingProgressText.id = "loading-container-text"),
            this.loadingContainer.append(this.loadingProgressText);
        }
        loadEverything() {
          return ia(this, void 0, void 0, function* () {
            0 != Ve.isWebGLSupported()
              ? yield this.canvas.loadAssets(this.onLoadProgress.bind(this))
              : this.setLoadingMessage("Enable WebGL in your browser.", !1);
          });
        }
        setLoadingMessage(t) {
          return ia(this, arguments, void 0, function* (t, e = !0) {
            if (void 0 === this.loadingProgressText) return;
            const i =
              e && Math.random() < 0.24
                ? this.easterEggMessages[
                    Ve.randomInt(0, this.easterEggMessages.length - 1)
                  ]
                : t;
            this.loadingProgressText.innerText = i;
          });
        }
        onLoadProgress(t) {
          return ia(this, void 0, void 0, function* () {
            var e;
            if (
              (this.setLoadingMessage(
                `Loading Textures (${Ve.percent(t)})`,
                !1
              ),
              t < 1)
            )
              return;
            this.setLoadingMessage("Initializing Canvas..."),
              yield this.canvas.init(),
              this.setLoadingMessage("Loading Themes..."),
              yield this.dataHandler.loadThemeData(),
              this.setLoadingMessage("Loading Changelog Data..."),
              yield this.dataHandler.loadChangelogData(),
              this.setLoadingMessage("Loading Texture Atlas Data..."),
              yield this.dataHandler.getStaticTextureCoordsData(),
              yield this.dataHandler.getAnimatedTextureCoordsData(),
              this.setLoadingMessage("Loading RotMG Data..."),
              yield this.dataHandler.loadCollectionType(),
              yield this.dataHandler.loadItemChecklistTagsData(),
              yield this.dataHandler.loadDyesData(),
              yield this.dataHandler.loadClassType(),
              yield this.dataHandler.loadAdjustmentsData(),
              yield this.dataHandler.loadAlwaysCenteredSkinsData(),
              yield this.dataHandler.loadClassEventReskinsData(),
              yield this.dataHandler.loadPetsXMLData(),
              yield this.dataHandler.loadObjectData(),
              yield this.dataHandler.loadAttacksData(),
              yield this.dataHandler.loadEnchantmentXMLData(),
              yield this.dataHandler.loadEnchantmentsTierData(),
              yield this.dataHandler.loadPetHealData(),
              yield this.dataHandler.loadEquipmentSetXMLData(),
              yield this.dataHandler.loadEquipmentXMLData(),
              yield this.dataHandler.loadSTierEquipmentData(),
              yield this.dataHandler.loadClassXMLData(),
              yield this.dataHandler.loadEnemiesData(),
              yield this.dataHandler.loadBaseStatDescriptionData(),
              yield this.dataHandler.loadStatusEffectDescriptionData(),
              yield this.dataHandler.loadSkinsXMLData(),
              this.setLoadingMessage("Loading Settings..."),
              yield this.settingsHandler.loadFromCache();
            const i =
                null !==
                  (e = new URLSearchParams(window.location.search).get(
                    "tool"
                  )) && void 0 !== e
                  ? e
                  : "",
              n =
                0 != i.length
                  ? Ve.stringToToolType(i)
                  : this.settingsHandler.startupTool;
            this.setLoadingMessage("Loading UI..."),
              yield this.tooltipHandler.create(),
              yield this.chartHandler.create(),
              yield this.skinViewerHandler.create(),
              yield this.itemSandboxHandler.create(),
              yield this.itemCreatorHandler.create(),
              yield this.itemChecklistHandler.create(),
              yield this.itemChecklistHandler.loadFromCache(),
              yield this.mainPanelHandler.create(n),
              this.setLoadingMessage("Ready!", !1),
              yield this.canvas.onReady(),
              yield setTimeout(() => {
                var t;
                return null === (t = this.loadingContainer) || void 0 === t
                  ? void 0
                  : t.remove();
              }, 1e3);
          });
        }
        onWindowResize(t) {
          document.body.style.scale = 100 / window.devicePixelRatio + "%";
        }
        onMouseMove(t) {
          (this.mousePosition.x = t.clientX),
            (this.mousePosition.y = t.clientY);
        }
        changeWindowTitle(t) {
          document.title = `${t} - RotMG Toolset`;
        }
      }
      document.addEventListener("DOMContentLoaded", () =>
        ia(void 0, void 0, void 0, function* () {
          yield (function (t, e) {
            return ia(this, void 0, void 0, function* () {
              const i = new FontFace(t, `url(${e})`),
                n = yield i.load();
              document.fonts.add(n);
            });
          })("ChronoType", "./assets/fonts/ChronoType.ttf");
          new na();
        })
      ),
        window.addEventListener("contextmenu", (t) => {
          t.preventDefault(), t.stopPropagation();
        });
    })();
})();
